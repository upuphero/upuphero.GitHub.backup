[{"title":"1833. Maximum Ice Cream Bars(medium)","path":"2023/01/06/1833/","text":"1833. Maximum Ice Cream Bars(medium)It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. Return the maximum number of ice cream bars the boy can buy with coins coins. Note: The boy can buy the ice cream bars in any order. è¿™é“é¢˜å…¶å®å¾ˆç®€å•ï¼Œä¸€ä¸ªç”·å­©æ‰‹ä¸Šæœ‰coinsä¸ªç¡¬å¸ï¼Œç„¶åæ±‚æœ€å¤šèƒ½æœ€å¤šä¹°å¤šå°‘å†°æ·‡æ·‹ï¼Œè€Œä¸”è¿˜æ²¡æœ‰å…¶ä»–è¦æ±‚.é‚£ä¹ˆå…ˆå¯¹æ•°ç»„æ’åºï¼Œç„¶åcoinsä¸æ–­æŠŠæ•°ç»„é‡Œçš„æ•°å­—å‡å»ï¼Œç›´åˆ°å°äº0ä¹Ÿå°±æ˜¯æ²¡é’±ä¹°ä¸‹ä¸€ä¸ªå†°æ·‡æ·‹ï¼ŒåŒæ—¶è®°ä¸ªæ•°å°±è¡Œ 12345678910111213class Solution: def maxIceCream(self, costs: List[int], coins: int) -&gt; int: costs.sort() res=0 for i in range(len(costs)): if costs[i]&lt;=coins: res+=1 coins-=costs[i] else: break return res"},{"title":"1339.Maximum Product of Splitted Binary Tree(medium)","path":"2022/12/10/1339/","text":"1339.Maximum Product of Splitted Binary Tree(medium)Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7. Note that you need to maximize the answer before taking the mod and not after taking it. Leetcodeå®˜æ–¹é¢˜è§£123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def maxProduct(self, root: TreeNode) -&gt; int: all_sums = [] def tree_sum(subroot): if subroot is None: return 0 left_sum = tree_sum(subroot.left) right_sum = tree_sum(subroot.right) total_sum = left_sum + right_sum + subroot.val all_sums.append(total_sum) return total_sum total = tree_sum(root) best = 0 for s in all_sums: best = max(best, s * (total - s)) return best % (10 ** 9 + 7)"},{"title":"938. Range Sum of BST(easy)","path":"2022/12/07/938/","text":"938. Range Sum of BST(easy)Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. leetcodeå®˜æ–¹é¢˜è§£æˆ‘ä»¬ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢éå†æ ‘ã€‚å¦‚æœè¶…å‡ºèŒƒå›´ï¼Œï¼ˆä¾‹å¦‚ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬çŸ¥é“åªæœ‰æ­£ç¡®çš„åˆ†æ”¯æ‰èƒ½æœ‰å†…éƒ¨æœ‰å€¼çš„èŠ‚ç‚¹ For the recursive and iterative implementations, we are performing a DFS (Depth-First Search) traversal. The recursive solution requries additional space to maintain the function call stack while the iterative solution requires additional space to maintain the stack. In both implementations, the worst-case scenario occurs when the tree is is of chain shape, and we will reach all the way down to the leaf node. In this case, the space required for the stack is O(N)O(N)O(N). 12345678910111213141516class Solution: def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -&gt; int: def dfs(node): nonlocal ans if node: if low &lt;= node.val &lt;= high: ans += node.val if low &lt; node.val: dfs(node.left) if node.val &lt; high: dfs(node.right) ans = 0 dfs(root) return ans"},{"title":"1154. Day of the Year(easy)","path":"2022/12/06/1154/","text":"1154. Day of the Year(easy)Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year. è®¡ç®—æ—¥æœŸæœˆä»½ 123456789101112from calendar import monthrangeclass Solution: def dayOfYear(self, date): def numberDaysInMonth(Y, M): return monthrange(Y, M)[1] year, month, day = map(int, date.split(&quot;-&quot;)) res = 0 for i in range(1, month): res += numberDaysInMonth(year, i) return res + day"},{"title":"2303. Calculate Amount Paid in Taxes(easy)","path":"2022/12/06/2303/","text":"2303. Calculate Amount Paid in Taxes(easy)You are given a 0-indexed 2D integer array brackets where brackets[i] = [upperi, percenti] means that the ith tax bracket has an upper bound of upperi and is taxed at a rate of percenti. The brackets are sorted by upper bound (i.e. upperi-1 &lt; upperi for 0 &lt; i &lt; brackets.length). Tax is calculated as follows: The first upper0 dollars earned are taxed at a rate of percent0.The next upper1 - upper0 dollars earned are taxed at a rate of percent1.The next upper2 - upper1 dollars earned are taxed at a rate of percent2.And so on.You are given an integer income representing the amount of money you earned. Return the amount of money that you have to pay in taxes. Answers within 10-5 of the actual answer will be accepted. 12345678910111213class Solution: def calculateTax(self, brackets: List[List[int]], income: int) -&gt; float: brackets.sort(key=lambda x: x[0]) res = 0 # Total Tax prev = 0 # Prev Bracket Upperbound for u, p in brackets: if income &gt;= u: # res += ((u-prev) * p) / 100 prev = u else: res += ((income-prev) * p) / 100 break # As total income has been taxed at this point. return res"},{"title":"530. Minimum Absolute Difference in BST(easy)","path":"2022/12/06/530/","text":"530. Minimum Absolute Difference in BST(easy)Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. 12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int: res = [] self.inorder(root, res) slow = 0 fast = 1 min_diff = float(&quot;inf&quot;) while fast &lt; len(res): min_diff = min(min_diff, res[fast]-res[slow]) slow += 1 fast += 1 return min_diff def inorder(self, root, res): if not root: return self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res)"},{"title":"561. Array Partition(easy)","path":"2022/12/06/561/","text":"Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), â€¦, (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. ä¸€é“æ‰¾è§„å¾‹çš„é¢˜ï¼Œæ‰¾ä¸¤ä¸¤åˆ†ç»„ä»¥åçš„æœ€å°å€¼çš„æœ€å¤§å’Œï¼Œé‚£ä¹ˆç›´æ¥å…ˆå¯¹æ•°ç»„æ’åºï¼Œæœ€å°çš„å€¼æ’åœ¨ä¸€èµ·ï¼Œå¤§çš„æ’åœ¨ä¸€èµ·ï¼Œæœ€åæ±‚å’Œçš„æ—¶å€™åªå–ç¬¬0ä¸ªç¬¬2ä¸ªç¬¬4ä¸ªâ€¦â€¦æœ€åè¾“å‡ºæœ€å¤§å’Œ 1234567class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: nums.sort() count=0 for i in range(0,len(nums),2): count+=nums[i] return count"},{"title":"551. Student Attendance Record I(easy)","path":"2022/12/06/551/","text":"551. Student Attendance Record I(easy)You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: â€˜Aâ€™: Absent.â€˜Lâ€™: Late.â€˜Pâ€™: Present.The student is eligible for an attendance award if they meet both of the following criteria: The student was absent (â€˜Aâ€™) for strictly fewer than 2 days total.The student was never late (â€˜Lâ€™) for 3 or more consecutive days.Return true if the student is eligible for an attendance award, or false otherwise. å°±æ˜¯å¾ªç¯ä»¥ååŠ åˆ¤æ–­ï¼Œè¿ç»­ä¸‰å¤©è¿Ÿåˆ°å°±æ˜¯å¦‚æœä¸‹ä¸€ä¸ªä¸æ˜¯è¿Ÿåˆ°ï¼Œå°†è®¡æ•°å™¨æ¸…é›¶ 1234567891011121314151617181920class Solution: def checkRecord(self, s: str) -&gt; bool: countA=0 countL=0 countP=0 left=0 right=left+1 for i in range(len(s)): if s[i]==&#x27;A&#x27;: countA+=1 if countA&gt;1: return False if s[i]==&#x27;L&#x27;: countL+=1 if countL&gt;=3: return False else: countL=0 return True"},{"title":"46. Permutations(medium)","path":"2022/12/05/46/","text":"46. Permutations(medium)Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.å…¨æ’åˆ—ï¼Œåˆ©ç”¨äº†å›æº¯çš„æ–¹æ³• 12345678910111213141516171819202122class Solution: def permute(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; def backtrack(first = 0): # æ‰€æœ‰æ•°éƒ½å¡«å®Œäº† if first == n: res.append(nums[:]) for i in range(first, n): # åŠ¨æ€ç»´æŠ¤æ•°ç»„ nums[first], nums[i] = nums[i], nums[first] # ç»§ç»­é€’å½’å¡«ä¸‹ä¸€ä¸ªæ•° backtrack(first + 1) # æ’¤é”€æ“ä½œ nums[first], nums[i] = nums[i], nums[first] n = len(nums) res = [] backtrack() return res"},{"title":"256. Paint House(medium)","path":"2022/12/05/256/","text":"256. Paint House(medium)There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so onâ€¦Return the minimum cost to paint all houses.å‡å¦‚æœ‰ä¸€æ’æˆ¿å­ï¼Œå…± n ä¸ªï¼Œæ¯ä¸ªæˆ¿å­å¯ä»¥è¢«ç²‰åˆ·æˆçº¢è‰²ã€è“è‰²æˆ–è€…ç»¿è‰²è¿™ä¸‰ç§é¢œè‰²ä¸­çš„ä¸€ç§ï¼Œä½ éœ€è¦ç²‰åˆ·æ‰€æœ‰çš„æˆ¿å­å¹¶ä¸”ä½¿å…¶ç›¸é‚»çš„ä¸¤ä¸ªæˆ¿å­é¢œè‰²ä¸èƒ½ç›¸åŒã€‚å½“ç„¶ï¼Œå› ä¸ºå¸‚åœºä¸Šä¸åŒé¢œè‰²æ²¹æ¼†çš„ä»·æ ¼ä¸åŒï¼Œæ‰€ä»¥æˆ¿å­ç²‰åˆ·æˆä¸åŒé¢œè‰²çš„èŠ±è´¹æˆæœ¬ä¹Ÿæ˜¯ä¸åŒçš„ã€‚æ¯ä¸ªæˆ¿å­ç²‰åˆ·æˆä¸åŒé¢œè‰²çš„èŠ±è´¹æ˜¯ä»¥ä¸€ä¸ª n x 3 çš„æ­£æ•´æ•°çŸ©é˜µ costs æ¥è¡¨ç¤ºçš„ã€‚ä¾‹å¦‚ï¼Œcosts[0][0] è¡¨ç¤ºç¬¬ 0 å·æˆ¿å­ç²‰åˆ·æˆçº¢è‰²çš„æˆæœ¬èŠ±è´¹ï¼›costs[1][2] è¡¨ç¤ºç¬¬ 1 å·æˆ¿å­ç²‰åˆ·æˆç»¿è‰²çš„èŠ±è´¹ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¯·è®¡ç®—å‡ºç²‰åˆ·å®Œæ‰€æœ‰æˆ¿å­æœ€å°‘çš„èŠ±è´¹æˆæœ¬ã€‚ åå­çš„æœºè€ƒé¢˜ï¼Œæ”¹äº†ä¸€ä¸‹æ•°å­—ï¼Œå˜æˆå››ç§é¢œè‰²äº†ï¼Œä½†è¿‡ç¨‹æ˜¯ä¸€æ ·çš„ ç¾åŒºçš„å®˜æ–¹é¢˜è§£å°±åœ¨costsè¿™ä¸ªçŸ©é˜µä¸Šå¤„ç†ï¼Œä»ä¸‹å¾€ä¸Šï¼Œä¹Ÿå°±æ˜¯ä»æœ€åä¸€è¡Œå¼€å§‹å¤„ç†ï¼Œä¸Šä¸€è¡ŒåŠ ä¸Šä¸‹ä¸€è¡Œçš„costsï¼Œå°±æ˜¯æ‰¾æ¯è¡Œæœ€å°çš„æˆæœ¬ç„¶åä¸æ–­çš„åŠ åˆ°ç¬¬ä¸€è¡Œï¼Œè¾“å‡ºç¬¬ä¸€è¡Œé‡Œæœ€å°çš„ç»“æœ 12345678910class Solution: def minCost(self, costs: List[List[int]]) -&gt; int: n=len(costs) for i in reversed(range(n-1)): costs[i][0]+=min(costs[i+1][1],costs[i+1][2]) costs[i][1]+=min(costs[i+1][0],costs[i+1][2]) costs[i][2]+=min(costs[i+1][1],costs[i+1][0]) if len(costs)==0: return 0 return min(costs[0])"},{"title":"523. Continuous Subarray Sum(medium)","path":"2022/12/04/523/","text":"523. Continuous Subarray Sum(medium)Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.A good subarray is a subarray where:its length is at least two, andthe sum of the elements of the subarray is a multiple of k.Note that: A subarray is a contiguous part of the array.An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.è¿™é“é¢˜æœ€é‡è¦çš„å°±æ˜¯åŒä½™å®šç†ï¼Œä¸¤ä¸ªæ•´æ•°aã€bï¼Œè‹¥å®ƒä»¬é™¤ä»¥æ•´æ•°mæ‰€å¾—çš„ä½™æ•°ç›¸ç­‰ï¼Œåˆ™ç§°aä¸bå¯¹äºæ¨¡måŒä½™æˆ–aåŒä½™äºbæ¨¡mã€‚ä¸¾ä¸ªä¾‹å­å°±æ˜¯ï¼Œa%c=k,b%c=k æ‰€ä»¥(a-b)%c=0 æ‰€ä»¥å°±æ˜¯å°†ä¸æ–­æ±‚å’Œçš„æ•°ç»„å¯¹Kæ±‚ä½™ï¼Œå¾—åˆ°çš„å€¼çœ‹hashmapé‡Œæœ‰æ²¡æœ‰ï¼Œæ²¡æœ‰å°±åŠ è¿›å»ï¼Œæœ‰çš„è¯å°±è¾“å‡ºå‡ºæ¥è¿™é‡Œå­æ•°ç»„çš„æœ€å°é•¿åº¦æ˜¯2ï¼Œæ‰€ä»¥æ˜¯ä¸èƒ½ç›´æ¥è¿™æ ·ä»hashmapé‡Œåªæ¯”è¾ƒkeyï¼Œè¿˜éœ€è¦åˆ©ç”¨iæ¥è®¾ç½®valueçš„å€¼è¿›è¡Œæ¯”è¾ƒ 12345678910111213141516class Solution: def checkSubarraySum(self, nums: List[int], k: int) -&gt; bool: hashmap=collections.defaultdict(int) sum1=0 count=0 if len(nums)&lt;2: return False hashmap[0]=0 remainder = 0 for i in range(len(nums)): sum1+=nums[i] if sum1%k not in hashmap: hashmap[sum1 % k] = i + 1 elif hashmap[sum1%k]&lt;i: return True return False"},{"title":"84. Largest Rectangle in Histogram(hard)","path":"2022/12/03/84/","text":"84. Largest Rectangle in Histogram(hard)Given an array of integers heights representing the histogramâ€™s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.leetcodeé¢˜è§£123456789101112131415161718192021class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n = len(heights) left, right = [0] * n, [0] * n mono_stack = list() for i in range(n): while mono_stack and heights[mono_stack[-1]] &gt;= heights[i]: mono_stack.pop() left[i] = mono_stack[-1] if mono_stack else -1 mono_stack.append(i) mono_stack = list() for i in range(n - 1, -1, -1): while mono_stack and heights[mono_stack[-1]] &gt;= heights[i]: mono_stack.pop() right[i] = mono_stack[-1] if mono_stack else n mono_stack.append(i) ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n &gt; 0 else 0 return ans"},{"title":"400. Nth Digit(medium)","path":"2022/12/03/400/","text":"400. Nth Digit(medium)Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, â€¦].123456789101112class Solution: def findNthDigit(self, n: int) -&gt; int: d,count=1,9 while n&gt;d*count: n-=d*count d+=1 count*=10 index=n-1 start=10**(d-1) num=start+index//d digitIndex=index%d return num//10**(d-digitIndex-1)%10"},{"title":"554. Brick Wall(medium)","path":"2022/12/03/554/","text":"554. Brick Wall(medium)There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.12è¾“å…¥ï¼šwall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]è¾“å‡ºï¼š2 leetcodeé¢˜è§£ å…¶å®ä¸»è¦æ€è·¯å°±æ˜¯ä»æ•°ç»„ä¸­æ€ä¹ˆå¾—åˆ°ç¼éš™çš„ä½ç½®ã€‚å¦‚æœç¼éš™çš„ä½ç½®æ˜¯æ ¹æ®ç¼éš™ç¦»æœ€å·¦è¾¹å¤šè¿œæ¥å†³å®šï¼Œé‚£ä¹ˆç¼éš™çš„ä½ç½®å¯ç”±æ•°ç»„ç´¯åŠ å¾—åˆ°ã€‚æœ‰äº†ç¼éš™çš„ä½ç½®å¾ˆè‡ªç„¶çš„ä¼šæƒ³åˆ°ï¼Œå¯ä»¥ç»Ÿè®¡æ¯ä¸ªä½ç½®æœ‰å¤šå°‘ç¼éš™ã€‚å› ä¸ºè¿”å›æœ€å°‘çš„ç –å¤´æ•°é‡ = å¢™é«˜ - æœ€å¤šç¼éš™ 123456789101112class Solution: def leastBricks(self, wall: List[List[int]]) -&gt; int: m=len(wall) count=collections.defaultdict(int) for wallline in wall: dis=0 for i in range(len(wallline)-1): dis+=wallline[i] count[dis]+=1 if len(count.values())==0: return len(wall) return len(wall)-max(count.values())"},{"title":"994. Rotting Oranges(medium)","path":"2022/12/02/994/","text":"994. Rotting Oranges(medium)You are given an m x n grid where each cell can have one of three values:0 representing an empty cell,1 representing a fresh orange, or2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. leetcodeé¢˜è§£æœ‰äº†è®¡ç®—æœ€çŸ­è·¯å¾„çš„å±‚åº BFS ä»£ç æ¡†æ¶ï¼Œå†™è¿™é“é¢˜å°±å¾ˆç®€å•äº†ã€‚è¿™é“é¢˜çš„ä¸»è¦æ€è·¯æ˜¯ï¼šä¸€å¼€å§‹ï¼Œæˆ‘ä»¬æ‰¾å‡ºæ‰€æœ‰è…çƒ‚çš„æ©˜å­ï¼Œå°†å®ƒä»¬æ”¾å…¥é˜Ÿåˆ—ï¼Œä½œä¸ºç¬¬ 0 å±‚çš„ç»“ç‚¹ã€‚ç„¶åè¿›è¡Œ BFS éå†ï¼Œæ¯ä¸ªç»“ç‚¹çš„ç›¸é‚»ç»“ç‚¹å¯èƒ½æ˜¯ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘çš„ç»“ç‚¹ï¼Œæ³¨æ„åˆ¤æ–­ç»“ç‚¹ä½äºç½‘æ ¼è¾¹ç•Œçš„ç‰¹æ®Šæƒ…å†µã€‚ç”±äºå¯èƒ½å­˜åœ¨æ— æ³•è¢«æ±¡æŸ“çš„æ©˜å­ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•æ–°é²œæ©˜å­çš„æ•°é‡ã€‚åœ¨ BFS ä¸­ï¼Œæ¯éå†åˆ°ä¸€ä¸ªæ©˜å­ï¼ˆæ±¡æŸ“äº†ä¸€ä¸ªæ©˜å­ï¼‰ï¼Œå°±å°†æ–°é²œæ©˜å­çš„æ•°é‡å‡ä¸€ã€‚å¦‚æœ BFS ç»“æŸåè¿™ä¸ªæ•°é‡ä»æœªå‡ä¸ºé›¶ï¼Œè¯´æ˜å­˜åœ¨æ— æ³•è¢«æ±¡æŸ“çš„æ©˜å­ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def orangesRotting(self, grid: List[List[int]])-&gt; int: M = len(grid) N = len(grid[0]) queue = [] count = 0 # count è¡¨ç¤ºæ–°é²œæ©˜å­çš„æ•°é‡ for r in range(M): for c in range(N): if grid[r][c] == 1: count += 1 #è®¡æ•°å¥½æ©˜å­ elif grid[r][c] == 2: queue.append((r, c)) round = 0 # round è¡¨ç¤ºè…çƒ‚çš„è½®æ•°ï¼Œæˆ–è€…åˆ†é’Ÿæ•° while count &gt; 0 and len(queue) &gt; 0: # è¿˜æœ‰å¥½æ©˜å­ä¸”é˜Ÿåˆ—è¿˜æœ‰åæ©˜å­ round += 1 # å±‚æ•°+1 n = len(queue) # è®°å½•è¿™ä¸€å±‚çš„åæ©˜å­æ•° for i in range(n): # éå†å®Œè¿™ä¸€å±‚çš„åæ©˜å­ r, c = queue.pop(0) # å–å‡ºé˜Ÿåˆ—å¼€å¤´çš„åæ©˜å­åæ ‡ if r-1 &gt;= 0 and grid[r-1][c] == 1: # ä¸Šé‚»æœ‰å¥½æ©˜å­ grid[r-1][c] = 2 # å¥½æ©˜å­å˜å count -= 1 # å¥½æ©˜å­æ•°-1 queue.append((r-1, c)) # æ–°å˜åçš„è¿™åªæ©˜å­è¿›å…¥åæ©˜å­é˜Ÿåˆ— if r+1 &lt; M and grid[r+1][c] == 1: # ä¸‹é‚»æœ‰å¥½æ©˜å­ grid[r+1][c] = 2 count -= 1 queue.append((r+1, c)) if c-1 &gt;= 0 and grid[r][c-1] == 1: # å·¦é‚»æœ‰å¥½æ©˜å­ grid[r][c-1] = 2 count -= 1 queue.append((r, c-1)) if c+1 &lt; N and grid[r][c+1] == 1: # å³é‚»æœ‰å¥½æ©˜å­ grid[r][c+1] = 2 count -= 1 queue.append((r, c+1)) if count &gt; 0: # è¿˜æœ‰å¥½æ©˜å­ return -1 else: # æ²¡æœ‰å¥½æ©˜å­äº† return round"},{"title":"921","path":"2022/11/30/921/","text":""},{"title":"1704. Determine if String Halves Are Alike(easy)","path":"2022/11/30/1704/","text":"1704. Determine if String Halves Are Alike(easy)You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels (â€˜aâ€™, â€˜eâ€™, â€˜iâ€™, â€˜oâ€™, â€˜uâ€™, â€˜Aâ€™, â€˜Eâ€™, â€˜Iâ€™, â€˜Oâ€™, â€˜Uâ€™). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false. è¿™é“é¢˜æ˜¯æŠŠä¸€ä¸ªå­—ç¬¦ä¸²åŠˆæˆä¸¤åŠï¼Œå·¦è¾¹ä¸ºaå³è¾¹ä¸ºbï¼Œç„¶ååˆ¤æ–­aå’Œbé‡Œé¢çš„å…ƒéŸ³æ•°æ˜¯å¦ç›¸åŒã€‚è¿™é‡Œé¢æœ‰ä¸€ç‚¹ç®€ä¾¿è®¡ç®—çš„æ˜¯ï¼Œä»–ä¸æ˜¯è€ƒè™‘å…ƒéŸ³å„è‡ªçš„ä¸ªæ•°ï¼Œæ‰€ä»¥åªè¦è®¾ä¸€ä¸ªå¸¸é‡å¾€ä¸ŠåŠ å°±å¯ä»¥äº†å¦‚æœè€ƒè™‘å…ƒéŸ³å„è‡ªçš„ä¸ªæ•°ï¼Œé‚£å°±å¦å¤–è®¾ä¸¤ä¸ªhashmapï¼Œæœ€åæ¯”è¾ƒä¸¤ä¸ªhashmapæ˜¯å¦ç›¸åŒ 123456789101112131415class Solution: def halvesAreAlike(self, s: str) -&gt; bool: n=len(s) a=s[:n//2] b=s[n//2:] count_a=0 count_b=0 vowels=&#123;&#x27;a&#x27;:1, &#x27;e&#x27;:1, &#x27;i&#x27;:1, &#x27;o&#x27;:1, &#x27;u&#x27;:1, &#x27;A&#x27;:1, &#x27;E&#x27;:1, &#x27;I&#x27;:1, &#x27;O&#x27;:1, &#x27;U&#x27;:1&#125; for c in a: if c in vowels: count_a+=1 for c in b: if c in vowels: count_b+=1 return count_a==count_b"},{"title":"43","path":"2022/11/30/43/","text":""},{"title":"1277. Count Square Submatrices with All Ones(medium)","path":"2022/11/29/1277/","text":"1277. Count Square Submatrices with All Ones(medium)Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.è¿™é“é¢˜å’Œ221. Maximal Square(medium)åŒå±ä¸€ç±»é¢˜ å’Œ221 ç”¨åŒæ ·çš„æ–¹æ³•ï¼Œæœ€åçš„è¾“å‡ºç»“æœæ˜¯dpçŸ©é˜µæ¯ä¸ªæ•°çš„å’Œ 1234567891011121314151617class Solution: def countSquares(self, matrix: List[List[int]]) -&gt; int: m=len(matrix) n=len(matrix[0]) if m==0 or n==0: return 0 dp=[[0 for i in range(n)]for _ in range(m)] count=0 for i in range(m): for j in range(n): if matrix[i][j]==1: if i==0 or j==0: dp[i][j]=1 else: dp[i][j]=min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j])+1 count+=dp[i][j] return count"},{"title":"221. Maximal Square(medium)","path":"2022/11/29/221/","text":"221. Maximal Square(medium)Given an m x n binary matrix filled with 0â€™s and 1â€™s, find the largest square containing only 1â€™s and return its area.è¿™é“é¢˜å’Œ1277. Count Square Submatrices with All Ones(medium)åŒå±ä¸€ç±»é¢˜ å®˜æ–¹é¢˜è§£å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’é™ä½æ—¶é—´å¤æ‚åº¦ã€‚æˆ‘ä»¬ç”¨ dp(i,j) è¡¨ç¤ºä»¥ (i,j) ä¸ºå³ä¸‹è§’ï¼Œä¸”åªåŒ…å« 1 çš„æ­£æ–¹å½¢çš„è¾¹é•¿æœ€å¤§å€¼ã€‚å¦‚æœæˆ‘ä»¬èƒ½è®¡ç®—å‡ºæ‰€æœ‰ dp(i,j) çš„å€¼ï¼Œé‚£ä¹ˆå…¶ä¸­çš„æœ€å¤§å€¼å³ä¸ºçŸ©é˜µä¸­åªåŒ…å« 1 çš„æ­£æ–¹å½¢çš„è¾¹é•¿æœ€å¤§å€¼ï¼Œå…¶å¹³æ–¹å³ä¸ºæœ€å¤§æ­£æ–¹å½¢çš„é¢ç§¯ã€‚ æ³¨ï¼šdp(i,j) è¡¨ç¤ºä»¥ (i,j) ä¸ºå³ä¸‹è§’ï¼Œä¸”åªåŒ…å« 1 çš„æ­£æ–¹å½¢çš„è¾¹é•¿æœ€å¤§å€¼ã€‚é‚£ä¹ˆå¦‚ä½•è®¡ç®— dp ä¸­çš„æ¯ä¸ªå…ƒç´ å€¼å‘¢ï¼Ÿå¯¹äºæ¯ä¸ªä½ç½® (i,j)ï¼Œæ£€æŸ¥åœ¨çŸ©é˜µä¸­è¯¥ä½ç½®çš„å€¼ï¼š å¦‚æœè¯¥ä½ç½®çš„å€¼æ˜¯ 0ï¼Œåˆ™ dp(i,j)=0ï¼Œå› ä¸ºå½“å‰ä½ç½®ä¸å¯èƒ½åœ¨ç”± 1 ç»„æˆçš„æ­£æ–¹å½¢ä¸­ï¼› å¦‚æœè¯¥ä½ç½®çš„å€¼æ˜¯ 1ï¼Œåˆ™ dp(i,j) çš„å€¼ç”±å…¶ä¸Šæ–¹ã€å·¦æ–¹å’Œå·¦ä¸Šæ–¹çš„ä¸‰ä¸ªç›¸é‚»ä½ç½®çš„ dp å€¼å†³å®šã€‚å…·ä½“è€Œè¨€ï¼Œå½“å‰ä½ç½®çš„å…ƒç´ å€¼ç­‰äºä¸‰ä¸ªç›¸é‚»ä½ç½®çš„å…ƒç´ ä¸­çš„æœ€å°å€¼åŠ  1ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š dp(i, j)=min(dp(iâˆ’1, j), dp(iâˆ’1, jâˆ’1), dp(i, jâˆ’1))+1 æ­¤å¤–ï¼Œè¿˜éœ€è¦è€ƒè™‘è¾¹ç•Œæ¡ä»¶ã€‚å¦‚æœ i å’Œ j ä¸­è‡³å°‘æœ‰ä¸€ä¸ªä¸º 0ï¼ˆå°±æ˜¯æœ€è¾¹ä¸Šé‚£åŠè¾¹ï¼‰ï¼Œåˆ™ä»¥ä½ç½® (i, j) ä¸ºå³ä¸‹è§’çš„æœ€å¤§æ­£æ–¹å½¢çš„è¾¹é•¿åªèƒ½æ˜¯ 1ï¼Œå› æ­¤ dp(i,j)=1ã€‚ 1234567891011121314151617class Solution: def maximalSquare(self, matrix: List[List[str]]) -&gt; int: m=len(matrix) n=len(matrix[0]) if m==0 or n==0: return 0 dp=[[0 for i in range(n)]for _ in range(m)] maxside=0 for i in range(m): for j in range(n): if matrix[i][j]==&#x27;1&#x27;: if i==0 or j==0: dp[i][j]=1 else: dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1 maxside=max(maxside,dp[i][j]) return maxside*maxside"},{"title":"55. Jump Game(medium)","path":"2022/11/29/55/","text":"55. Jump Game(medium)You are given an integer array nums. You are initially positioned at the arrayâ€™s first index, and each element in the array represents your maximum jump length at that position.Return true if you can reach the last index, or false otherwise.123Input: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. leetcodeé¢˜è§£æ€è·¯ï¼šå°½å¯èƒ½åˆ°è¾¾æœ€è¿œä½ç½®ï¼ˆè´ªå¿ƒï¼‰ã€‚å¦‚æœèƒ½åˆ°è¾¾æŸä¸ªä½ç½®ï¼Œé‚£ä¸€å®šèƒ½åˆ°è¾¾å®ƒå‰é¢çš„æ‰€æœ‰ä½ç½®ã€‚ æ–¹æ³•ï¼šåˆå§‹åŒ–æœ€è¿œä½ç½®ä¸º 0ï¼Œç„¶åéå†æ•°ç»„ï¼Œå¦‚æœå½“å‰ä½ç½®èƒ½åˆ°è¾¾ï¼Œå¹¶ä¸”å½“å‰ä½ç½®+è·³æ•°&gt;æœ€è¿œä½ç½®ï¼Œå°±æ›´æ–°æœ€è¿œä½ç½®ã€‚æœ€åæ¯”è¾ƒæœ€è¿œä½ç½®å’Œæ•°ç»„é•¿åº¦ã€‚ å¤æ‚åº¦ï¼šæ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚ 123456789class Solution: def canJump(self, nums: List[int]) -&gt; bool: n=len(nums) farthest=0 for i in range(n-1): farthest=max(farthest,i+nums[i]) if farthest&lt;=i: return False return farthest&gt;=n-1"},{"title":"23. Merge k Sorted Lists(hard)","path":"2022/11/27/23/","text":"23. Merge k Sorted Lists(hard)You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.Merge all the linked-lists into one sorted linked-list and return it.12345678910Input: lists = [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]merging them into one sorted list:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 è¿™é“é¢˜æ˜¯21. Merge Two Sorted Lists(easy) çš„å‡çº§ç‰ˆåšæ³•æ˜¯ç”¨ä¼˜å…ˆé˜Ÿåˆ—æˆ–è€…å †æ’åºï¼Œç¡®å®šåˆ—å…¥é“¾è¡¨çš„é¡ºåº ç”šè‡³å¯ä»¥ç¬¬ä¸€ééå†å°†æ‰€æœ‰nodeçš„valueå­˜å…¥ä¸€ä¸ªæ•°ç»„ï¼Œç„¶åç›´æ¥æ’åºï¼Œå†æŠŠæ•°ç»„è½¬æ¢æˆé“¾è¡¨è¾“å‡ºå°±å¯ä»¥çŒªçŒªä¾ çš„æ£’æ£’ç³–çš„è¯„è®ºä¸å¾—ä¸è¯´è¿™ä¸ªæ–¹æ³•æœ€å¥½ç†è§£ï¼Œè€Œä¸”æ—¶é—´å¤æ‚åº¦ä¹Ÿæ²¡æœ‰å˜é«˜ 12345678910111213141516171819# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]: temp = [] for i in range(len(lists)): while lists[i]: temp.append(lists[i].val) lists[i] = lists[i].next temp.sort() head = current = ListNode() for i in range(len(temp)): Node = ListNode(temp[i]) current.next = Node current = current.next return head.next"},{"title":"2487. Remove Nodes From Linked List(medium)","path":"2022/11/27/2487/","text":"2487. Remove Nodes From Linked List(medium)You are given the head of a linked list.Remove every node which has a node with a strictly greater value anywhere to the right side of it.Return the head of the modified linked list.123456Input: head = [5,2,13,3,8]Output: [13,8]Explanation: The nodes that should be removed are 5, 2 and 3.- Node 13 is to the right of node 5.- Node 13 is to the right of node 2.- Node 8 is to the right of node 3. Leetcodeé¢˜è§£ å…ˆåè½¬é“¾è¡¨ï¼Œç„¶ååˆ¤æ–­å¤§å°ï¼Œæœ€åå†æŠŠé“¾è¡¨åè½¬å›æ¥ 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def removeNodes(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: def reverse(n: ListNode) -&gt; ListNode: tail = None while n: nxt = n.next n.next = tail tail = n n = nxt return tail cur = tail = reverse(head) mx = cur.val while cur.next: if cur.next.val &lt; mx: cur.next = cur.next.next else: cur = cur.next mx = cur.val return reverse(tail)"},{"title":"2486. Append Characters to String to Make Subsequence(medium)","path":"2022/11/27/2486/","text":"2486. Append Characters to String to Make Subsequence(medium)You are given two strings s and t consisting of only lowercase English letters.Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.12345678910111213class Solution: def appendCharacters(self, s: str, t: str) -&gt; int: count=0 i=j=0 while i&lt;len(s) and j&lt;len(t): if s[i]==t[j]: j+=1 else: j+=0 i+=1 return len(t)-j"},{"title":"2485. Find the Pivot Integer(easy)","path":"2022/11/27/2485/","text":"2485. Find the Pivot Integer(easy)Given a positive integer n, find the pivot integer x such that:sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.è¿™å°±æ˜¯ä¸ªæ•°å­¦é¢˜ 12345678class Solution: def pivotInteger(self, n: int) -&gt; int: num=(pow(n,2)+n)/2 num1=sqrt(num) if num1%1==0: return int(num1) else: return -1"},{"title":"781. Rabbits in Forest(medium)","path":"2022/11/25/781/","text":"781. Rabbits in Forest(medium)There is a forest with an unknown number of rabbits. We asked n rabbits â€œHow many rabbits have the same color as you?â€ and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit.Given the array answers, return the minimum number of rabbits that could be in the forest.123456789class Solution: def numRabbits(self, answers: List[int]) -&gt; int: hashmap=Counter(answers) res=0 for x in hashmap: res +=(x + hashmap[x]) // (x + 1) * (x + 1) return res"},{"title":"200. Number of Islands(medium)","path":"2022/11/25/200/","text":"200. Number of Islands(medium)Given an m x n 2D binary grid grid which represents a map of â€˜1â€™s (land) and â€˜0â€™s (water), return the number of islands.An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.1234567Input: grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]Output: 1 å²›å±¿ç³»åˆ— Number of Enclaves 1020. é£åœ°çš„æ•°é‡ Number of Closed Islands 1254. ç»Ÿè®¡å°é—­å²›å±¿çš„æ•°ç›® Count Sub Islands 1905. ç»Ÿè®¡å­å²›å±¿ Number of Islands 200. å²›å±¿æ•°é‡ Number of Distinct IslandsğŸ”’ 694. ä¸åŒå²›å±¿çš„æ•°é‡ğŸ”’ Max Area of Island 695. å²›å±¿çš„æœ€å¤§é¢ç§¯ å²›å±¿ç³»åˆ—é¢˜ç›®çš„æ ¸å¿ƒè€ƒç‚¹å°±æ˜¯ç”¨ DFS/BFS ç®—æ³•éå†äºŒç»´æ•°ç»„ã€‚ é‚£ä¹ˆå¦‚ä½•åœ¨äºŒç»´çŸ©é˜µä¸­ä½¿ç”¨ DFS æœç´¢å‘¢ï¼Ÿå¦‚æœæŠŠäºŒç»´çŸ©é˜µä¸­çš„æ¯ä¸€ä¸ªä½ç½®çœ‹åšä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸ªèŠ‚ç‚¹çš„ä¸Šä¸‹å·¦å³å››ä¸ªä½ç½®å°±æ˜¯ç›¸é‚»èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ•´ä¸ªçŸ©é˜µå°±å¯ä»¥æŠ½è±¡æˆä¸€å¹…ç½‘çŠ¶çš„ã€Œå›¾ã€ç»“æ„ã€‚ æ ¹æ® å­¦ä¹ æ•°æ®ç»“æ„å’Œç®—æ³•çš„æ¡†æ¶æ€ç»´ï¼Œå®Œå…¨å¯ä»¥æ ¹æ®äºŒå‰æ ‘çš„éå†æ¡†æ¶æ”¹å†™å‡ºäºŒç»´çŸ©é˜µçš„ DFS ä»£ç æ¡†æ¶ï¼šJava ç‰ˆæœ¬ 123456789101112131415161718192021222324// äºŒå‰æ ‘éå†æ¡†æ¶void traverse(TreeNode root) &#123; traverse(root.left); traverse(root.right);&#125;// äºŒç»´çŸ©é˜µéå†æ¡†æ¶void dfs(int[][] grid, int i, int j, boolean[][] visited) &#123; int m = grid.length, n = grid[0].length; if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n) &#123; // è¶…å‡ºç´¢å¼•è¾¹ç•Œ return; &#125; if (visited[i][j]) &#123; // å·²éå†è¿‡ (i, j) return; &#125; // è¿›å…¥èŠ‚ç‚¹ (i, j) visited[i][j] = true; dfs(grid, i - 1, j, visited); // ä¸Š dfs(grid, i + 1, j, visited); // ä¸‹ dfs(grid, i, j - 1, visited); // å·¦ dfs(grid, i, j + 1, visited); // å³&#125; python ç‰ˆæœ¬ 123456789101112def dfs(grid,i,j): m=len(grid) n=len(grid[0]) if i&lt;0 or j&lt;0 or i&gt;=m or j&gt;=n: return if grid[i][j]==&#x27;0&#x27;: return grid[i][j]=&#x27;0&#x27; dfs(grid,i+1,j) dfs(grid,i,j+1) dfs(grid,i-1,j) dfs(grid,i,j-1) ä»£ç  1234567891011121314151617181920212223242526272829303132class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: # ä» (i, j) å¼€å§‹ï¼Œå°†ä¸ä¹‹ç›¸é‚»çš„é™†åœ°éƒ½å˜æˆæµ·æ°´ def dfs(grid,i,j): m=len(grid) n=len(grid[0]) if i&lt;0 or j&lt;0 or i&gt;=m or j&gt;=n: # è¶…å‡ºç´¢å¼•è¾¹ç•Œ return if grid[i][j]==&#x27;0&#x27;: # å·²ç»æ˜¯æµ·æ°´äº† return # å°† (i, j) å˜æˆæµ·æ°´,è¿™é‡Œçš„ä¸Šä¸‹å·¦å³é¡ºåºä¸å½±å“ç»“æœ grid[i][j]=&#x27;0&#x27; dfs(grid,i+1,j) dfs(grid,i,j+1) dfs(grid,i-1,j) dfs(grid,i,j-1) res=0 m=len(grid) n=len(grid[0]) # éå† grid for i in range(m): for j in range(n): if grid[i][j]==&#x27;1&#x27;: # æ¯å‘ç°ä¸€ä¸ªå²›å±¿ï¼Œå²›å±¿æ•°é‡åŠ ä¸€ res+=1 # ç„¶åä½¿ç”¨ DFS å°†å²›å±¿æ·¹äº† dfs(grid,i,j) return res"},{"title":"1190. Reverse Substrings Between Each Pair of Parentheses(medium)","path":"2022/11/25/1190/","text":"1190. Reverse Substrings Between Each Pair of Parentheses(medium)You are given a string s that consists of lower case English letters and brackets.Reverse the strings in each pair of matching parentheses, starting from the innermost one.Your result should not contain any brackets.ä¸€é“å¤æ‚ç‰ˆçš„æ ˆé¢˜ç›®ï¼Œåœ¨é‡åˆ°å¤šæ‹¬å·çš„æƒ…å†µä¸‹ï¼Œéœ€è¦å¦å¤–è®¾ç½®ä¸€ä¸ªå­—ç¬¦ä¸²reså»å­˜å‚¨å½“å‰æ‹¬å·åè½¬åçš„å­—ç¬¦ä¸²ï¼Œå†å­˜å›stackç„¶åå†ä»stack popå‡ºä¸‹ä¸€ä¸ªæ‹¬å·çš„åè½¬å­—ç¬¦ä¸²ï¼Œå­˜å‚¨ä»¥åå†èµ‹ç»™stackï¼Œæœ€åï¼Œè¿”å›stack 1234567891011121314151617class Solution: def reverseParentheses(self, s: str) -&gt; str: stack=[] n=len(s) for char in s: if char !=&quot;)&quot;: stack.append(char) else: result=&quot;&quot; current=stack.pop() while current!=&quot;(&quot;: result+=current current=stack.pop() for char in result: stack.append(char) return &quot;&quot;.join(stack)"},{"title":"1010. Pairs of Songs With Total Durations Divisible by 60(medium)","path":"2022/11/23/1010/","text":"You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 == 0. 123456Input: time = [30,20,150,100,40]Output: 3Explanation: Three pairs have a total duration divisible by 60:(time[0] = 30, time[2] = 150): total duration 180(time[1] = 20, time[3] = 100): total duration 120(time[1] = 20, time[4] = 40): total duration 60 å…¶å®å°±æ˜¯2sumçš„å‡çº§ç‰ˆï¼Œè¦æ±‚åœ¨ä¸€ç»„æ•°ä¸­æ‰¾åˆ°å’Œæ˜¯60çš„å€æ•°çš„ä¸¤ä¸ªæ•°ä¸€å¼€å§‹ç”¨çš„2sumåŠ hashmapçš„æ€è·¯ï¼Œä½†å‘ç°éå¸¸éº»çƒ¦åæ¥çœ‹åˆ°é¢˜è§£å‘ç°äº†æ•°å­¦æ–¹æ³•ï¼š IntuitionCalculate the time % 60 then it will be exactly same as two sum problem. Explanationt % 60 gets the remainder from 0 to 59.We count the occurrence of each remainders in a array/hashmap c. we want to know that, for each t,how many x satisfy (t + x) % 60 = 0. The straight forward idea is to take x % 60 = 60 - t % 60,which is valid for the most cases.But if t % 60 = 0, x % 60 = 0 instead of 60. One solution is to use x % 60 = (60 - t % 60) % 60,the other idea is to use x % 60 = (600 - t) % 60.Not sure which one is more straight forward. è¿™ä¸ªé—®é¢˜çš„å…³é”®å…¬å¼ï¼šå‡è®¾ä¸¤ä¸ªæ•°xå’Œyçš„å’Œæ˜¯60çš„å€æ•°åˆ™æœ‰ (x+y)%60==0æ‰€ä»¥ x%60+y%60==60æˆ–è€…x%60+y%60==0ä¸å¾—ä¸è¯´æˆ‘ä»æ¥æ²¡æœ‰æƒ³è¿‡æ±‚ä½™çš„å…¬å¼çš„å±•å¼€å¯ä»¥è½¬æ¢æˆ x % 60 = (60 - t % 60) % 60 12345678class Solution: def numPairsDivisibleBy60(self, time): c = [0] * 60 res = 0 for t in time: res += c[-t % 60] c[t % 60] += 1 return res"},{"title":"45. Jump Game II(medium)","path":"2022/11/22/45/","text":"45. Jump Game II(medium)You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:120 &lt;= j &lt;= nums[i] andi + j &lt; n Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].ç”¨è´ªå¿ƒçš„æ€æƒ³æ¥åšè¿™é“é¢˜ä¼šæ›´èŠ‚çœæ—¶é—´[3,1,4,2â€¦â€¦]æ¯”å¦‚è¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬ç«™åœ¨ç´¢å¼• 0 çš„ä½ç½®ï¼Œå¯ä»¥å‘å‰è·³ 1ï¼Œ2 æˆ– 3 æ­¥ æœ€ä½³çš„é€‰æ‹©æ˜¾ç„¶åº”è¯¥è·³ 2 æ­¥è°ƒåˆ°ç´¢å¼• 2ï¼Œå› ä¸º nums[2] çš„å¯è·³è·ƒåŒºåŸŸæ¶µç›–äº†ç´¢å¼•åŒºé—´ [3..6]ï¼Œæ¯”å…¶ä»–çš„éƒ½å¤§ã€‚ è¿™å°±æ˜¯æ€è·¯ï¼Œæˆ‘ä»¬ç”¨ i å’Œ end æ ‡è®°äº†å¯ä»¥é€‰æ‹©çš„è·³è·ƒæ­¥æ•°ï¼Œfarthest æ ‡è®°äº†æ‰€æœ‰é€‰æ‹© [i..end] ä¸­èƒ½å¤Ÿè·³åˆ°çš„æœ€è¿œè·ç¦»ï¼Œjumps è®°å½•è·³è·ƒæ¬¡æ•°ã€‚ 12345678910111213class Solution: def jump(self, nums: List[int]) -&gt; int: n=len(nums) jumps=0 farthest=0 end=0 for i in range(n-1): farthest=max(nums[i]+i,farthest) if end==i: jumps+=1 end=farthest return jumps"},{"title":"22. Generate Parentheses(medium)","path":"2022/11/22/22/","text":"1234567891011121314151617class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: ans=[] def backtrack(S,left,right): if len(S)==2*n: ans.append(&#x27;&#x27;.join(S)) return if left&lt;n: S.append(&#x27;(&#x27;) backtrack(S,left+1,right) S.pop() if right&lt;left: S.append(&#x27;)&#x27;) backtrack(S,left,right+1) S.pop() backtrack([],0,0) return ans"},{"title":"279. Perfect Squares(medium)","path":"2022/11/22/279/","text":"279. Perfect Squares(medium)Given an integer n, return the least number of perfect square numbers that sum to n.A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.123Input: n = 12Output: 3Explanation: 12 = 4 + 4 + 4. leetcodeé¢˜è§£åŠ¨æ€è§„åˆ’12345678class Solution: def numSquares(self, n: int) -&gt; int: dp=[i for i in range(n+1)] for i in range(2,n+1): for j in range(1,int(i**(0.5))+1): dp[i]=min(dp[i],dp[i-j*j]+1) return dp[-1] BFSæ–¹æ³•12345678910111213141516171819202122232425class node: def __init__(self,value,step=0): self.value = value self.step = step def __str__(self): return &#x27;&lt;value:&#123;&#125;, step:&#123;&#125;&gt;&#x27;.format(self.value,self.step)class Solution: def numSquares(self, n: int) -&gt; int: queue = [node(n)] visited = set([node(n).value]) while queue: vertex = queue.pop(0) residuals = [vertex.value - n*n for n in range(1,int(vertex.value**.5)+1)] for i in residuals: new_vertex = node(i, vertex.step+1) if i==0: return new_vertex.step elif i not in visited: queue.append(new_vertex) visited.add(i) return -1"},{"title":"541. Reverse String II(easy)","path":"2022/11/21/541/","text":"541. Reverse String II(easy)Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; å®˜æ–¹é¢˜è§£å®˜æ–¹é¢˜è§£å¤ªç®€å•äº†ï¼Œæ€è·¯éå¸¸ç®€å•ï¼Œå°±æ˜¯iåˆ°i+kçš„å­—æ¯ç¿»è½¬å°±å¯ä»¥ 1234567class Solution: def reverseStr(self, s: str, k: int) -&gt; str: t = list(s) for i in range(0, len(t), 2 * k): t[i: i + k] = reversed(t[i: i + k]) return &quot;&quot;.join(t)"},{"title":"557. Reverse Words in a String III(easy)","path":"2022/11/21/557/","text":"557. Reverse Words in a String III(easy)Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.12Input: s = &quot;Let&#x27;s take LeetCode contest&quot;Output: &quot;s&#x27;teL ekat edoCteeL tsetnoc&quot; é¢˜ç›®æœ¬èº«å€’ä¸éš¾ï¼Œå°±æ˜¯è¾“å‡ºçš„å­—ç¬¦ä¸²å½¢å¼ç›¸å¯¹éº»çƒ¦ 12345678910111213141516class Solution: def reverseWords(self, s: str) -&gt; str: s=list(s.split()) res=[] ans=[] stack=[] for c in s: for i in c: stack.append(i) for _ in c: res.append(stack.pop()) ans.append(&quot;&quot;.join(res)) stack=[] res=[] return &quot; &quot;.join(ans)"},{"title":"696. Count Binary Substrings(easy)","path":"2022/11/21/696/","text":"696. Count Binary Substrings(easy)Given a binary string s, return the number of non-empty substrings that have the same number of 0â€™s and 1â€™s, and all the 0â€™s and all the 1â€™s in these substrings are grouped consecutively.Substrings that occur multiple times are counted the number of times they occur.å®˜æ–¹é¢˜è§£çœ‹åˆ°è¯¥é¢˜çš„ç¬¬ä¸€ååº”æ˜¯ä½è¿ç®—ï¼Œä½†æ˜¯æ²¡æœ‰æƒ³å¥½è¯¥æ€ä¹ˆè§£ã€‚ä½†å…¶å®æ ¹æœ¬æ²¡æœ‰é‚£ä¹ˆå¤æ‚ï¼šæˆ‘ä»¬å¯ä»¥å°†å­—ç¬¦ä¸² s æŒ‰ç…§ 0 å’Œ 1 çš„è¿ç»­æ®µåˆ†ç»„ï¼Œå­˜åœ¨ counts æ•°ç»„ä¸­ï¼Œä¾‹å¦‚ s = 00111011ï¼Œå¯ä»¥å¾—åˆ°è¿™æ ·çš„ counts æ•°ç»„ï¼šcounts={2,3,1,2}ã€‚ è¿™é‡Œ counts æ•°ç»„ä¸­ä¸¤ä¸ªç›¸é‚»çš„æ•°ä¸€å®šä»£è¡¨çš„æ˜¯ä¸¤ç§ä¸åŒçš„å­—ç¬¦ã€‚å‡è®¾ counts æ•°ç»„ä¸­ä¸¤ä¸ªç›¸é‚»çš„æ•°å­—ä¸º u æˆ–è€… vï¼Œå®ƒä»¬å¯¹åº”ç€ u ä¸ª 0 å’Œ v ä¸ª 1ï¼Œæˆ–è€… u ä¸ª 1 å’Œ v ä¸ª 0ã€‚å®ƒä»¬èƒ½ç»„æˆçš„æ»¡è¶³æ¡ä»¶çš„å­ä¸²æ•°ç›®ä¸º min{u,v}ï¼Œå³ä¸€å¯¹ç›¸é‚»çš„æ•°å­—å¯¹ç­”æ¡ˆçš„è´¡çŒ®ã€‚ æˆ‘ä»¬åªè¦éå†æ‰€æœ‰ç›¸é‚»çš„æ•°å¯¹ï¼Œæ±‚å®ƒä»¬çš„è´¡çŒ®æ€»å’Œï¼Œå³å¯å¾—åˆ°ç­”æ¡ˆã€‚ 12345678910111213141516class Solution: def countBinarySubstrings(self, s: str) -&gt; int: n=len(s) last=0 ans=0 i=0 while i &lt;n: c=s[i] count=0 while i&lt;n and s[i]==c: i+=1 count+=1 ans +=min(count,last) last=count return ans"},{"title":"599. Minimum Index Sum of Two Lists(easy)","path":"2022/11/21/599/","text":"599. Minimum Index Sum of Two Lists(easy)Given two arrays of strings list1 and list2, find the common strings with the least index sum.A common string is a string that appeared in both list1 and list2.A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.Return all the common strings with the least index sum. Return the answer in any order.å…ˆæ‰¾å‡ºä¸¤ä¸ªlistç›¸åŒçš„å­—ç¬¦ï¼Œå†è®°å½•ä¸‹æœ€å°çš„æ•°å€¼ï¼Œç„¶åç”¨hashmapæ‰¾åˆ°å¯¹åº”çš„å­—ç¬¦ class Solution: def findRestaurant(self, list1: List[str], list2: List[str]) -&gt; List[str]: ans=[] d=&#123;&#125; for i in range(len(list1)): if list1[i] in list2: d[list1[i]]=i+list2.index(list1[i]) min_index=min(d.values()) res=[] for i in d: if d[i]==min_index: res.append(i) return res"},{"title":"917. Reverse Only Letters(easy)","path":"2022/11/21/917/","text":"917. Reverse Only Letters(easy)Given a string s, reverse the string according to the following rules:All the characters that are not English letters remain in the same position.All the English letters (lowercase or uppercase) should be reversed.Return s after reversing it.12Input: s = &quot;ab-cd&quot;Output: &quot;dc-ba&quot; stackç”¨åœ¨è¿™é‡Œæ­£å¥½ï¼Œå­—æ¯å­˜è¿›æ ˆï¼Œç­‰è¯†åˆ«åˆ°ç¬¦å·å°±æ”¾ç¬¦å·ï¼Œä¸æ˜¯ç¬¦å·å°±pop 12345678910class Solution: def reverseOnlyLetters(self, s: str) -&gt; str: letters=[c for c in s if c.isalpha()] ans=[] for c in s: if c.isalpha(): ans.append(letters.pop()) else: ans.append(c) return &quot;&quot;.join(ans)"},{"title":"598. Range Addition II(easy)","path":"2022/11/21/598/","text":"You are given an m x n matrix M initialized with all 0â€™s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi. Count and return the number of maximum integers in the matrix after performing all the operations. class Solution: def maxCount(self, m: int, n: int, ops: List[List[int]]) -&gt; int: mina, minb = m, n for a, b in ops: mina = min(mina, a) minb = min(minb, b) return mina * minb"},{"title":"709. To Lower Case(easy)","path":"2022/11/21/709/","text":"709. To Lower Case(easy)Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.123class Solution: def toLowerCase(self, s: str) -&gt; str: return s.lower()"},{"title":"222. Count Complete Tree Nodes(medium)","path":"2022/11/16/222/","text":"222. Count Complete Tree Nodes(medium)Given the root of a complete binary tree, return the number of the nodes in the tree.According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.Design an algorithm that runs in less than O(n) time complexity.Solution:wiki:å®Œå…¨äºŒå‰æ ‘ (Complete Binary Tree)ï¼šA Complete Binary Tree ï¼ˆCBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. å¯¹äºä¸€é¢—äºŒå‰æ ‘ï¼Œå‡è®¾å…¶æ·±åº¦ä¸ºdï¼ˆd&gt;1ï¼‰ã€‚é™¤äº†ç¬¬då±‚å¤–ï¼Œå…¶å®ƒå„å±‚çš„èŠ‚ç‚¹æ•°ç›®å‡å·²è¾¾æœ€å¤§å€¼ï¼Œä¸”ç¬¬då±‚æ‰€æœ‰èŠ‚ç‚¹ä»å·¦å‘å³è¿ç»­åœ°ç´§å¯†æ’åˆ—ï¼Œè¿™æ ·çš„äºŒå‰æ ‘è¢«ç§°ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼› æ¢å¥è¯è¯´ï¼Œå®Œå…¨äºŒå‰æ ‘ä»æ ¹ç»“ç‚¹åˆ°å€’æ•°ç¬¬äºŒå±‚æ»¡è¶³å®Œç¾äºŒå‰æ ‘ï¼Œæœ€åä¸€å±‚å¯ä»¥ä¸å®Œå…¨å¡«å……ï¼Œå…¶å¶å­ç»“ç‚¹éƒ½é å·¦å¯¹é½ã€‚ å®Œç¾äºŒå‰æ ‘ (Perfect Binary Tree)ï¼šA Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2. äºŒå‰æ ‘çš„ç¬¬iå±‚è‡³å¤šæ‹¥æœ‰ 2^{i-1} ä¸ªèŠ‚ç‚¹æ•°ï¼›æ·±åº¦ä¸ºkçš„äºŒå‰æ ‘è‡³å¤šæ€»å…±æœ‰ {\\displaystyle 2^{\\begin{aligned}k+1\\end{aligned}}-1} ä¸ªèŠ‚ç‚¹æ•°ï¼Œè€Œæ€»è®¡æ‹¥æœ‰èŠ‚ç‚¹æ•°åŒ¹é…çš„ï¼Œç§°ä¸ºâ€œæ»¡äºŒå‰æ ‘â€ï¼› å®Œæ»¡äºŒå‰æ ‘ (Full Binary Tree):A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. æ¢å¥è¯è¯´ï¼Œæ‰€æœ‰éå¶å­ç»“ç‚¹çš„åº¦éƒ½æ˜¯2ã€‚ï¼ˆåªè¦ä½ æœ‰å­©å­ï¼Œä½ å°±å¿…ç„¶æ˜¯æœ‰ä¸¤ä¸ªå­©å­ã€‚ï¼‰ æ€è·¯æˆ‘ä»¬è¿˜æ˜¯è¦æ¥åˆ©ç”¨ä¸€ä¸‹å®Œå…¨äºŒå‰æ ‘è¿™ä¸ªæ¡ä»¶ï¼Œä¸ç„¶æ„Ÿè§‰å¯¹å‡ºé¢˜è€…ä¸å¤ªå°Šé‡ã€‚é€šè¿‡ä¸Šé¢å¯¹å®Œå…¨äºŒå‰æ ‘è·Ÿå®Œç¾äºŒå‰æ ‘çš„å®šä¹‰æ¯”è¾ƒï¼Œå¯ä»¥çœ‹å‡ºäºŒè€…çš„å…³ç³»æ˜¯ï¼Œå®Œç¾äºŒå‰æ ‘ä¸€å®šæ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œè€Œå®Œå…¨äºŒå‰æ ‘ä¸ä¸€å®šæ˜¯å®Œç¾äºŒå‰æ ‘ã€‚é‚£ä¹ˆè¿™é“é¢˜ç»™çš„å®Œå…¨äºŒå‰æ ‘å°±æœ‰å¯èƒ½æ˜¯å®Œç¾äºŒå‰æ ‘ï¼Œè‹¥æ˜¯å®Œç¾äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹ä¸ªæ•°å¾ˆå¥½æ±‚ï¼Œä¸º2çš„hæ¬¡æ–¹å‡1ï¼Œhä¸ºè¯¥å®Œç¾äºŒå‰æ ‘çš„é«˜åº¦ã€‚è‹¥ä¸æ˜¯çš„è¯ï¼Œåªèƒ½è€è€å®å®çš„ä¸€ä¸ªä¸€ä¸ªæ•°ç»“ç‚¹äº†ã€‚æ€è·¯æ˜¯ç”± root æ ¹ç»“ç‚¹å¾€ä¸‹ï¼Œåˆ†åˆ«æ‰¾æœ€é å·¦è¾¹å’Œæœ€é å³è¾¹çš„è·¯å¾„é•¿åº¦ï¼Œå¦‚æœé•¿åº¦ç›¸ç­‰ï¼Œåˆ™è¯æ˜äºŒå‰æ ‘æœ€åä¸€å±‚èŠ‚ç‚¹æ˜¯æ»¡çš„ï¼Œæ˜¯æ»¡äºŒå‰æ ‘ï¼Œç›´æ¥è¿”å›èŠ‚ç‚¹ä¸ªæ•°ï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™èŠ‚ç‚¹ä¸ªæ•°ä¸ºå·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°åŠ ä¸Šå³å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°å†åŠ 1(æ ¹èŠ‚ç‚¹)ï¼Œå…¶ä¸­å·¦å³å­æ ‘èŠ‚ç‚¹ä¸ªæ•°çš„è®¡ç®—å¯ä»¥ä½¿ç”¨é€’å½’æ¥è®¡ç®—ï¼Œå‚è§ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def countNodes(self, root: Optional[TreeNode]) -&gt; int: hLeft=0 hRight=0 pLeft=root pRight=root while pLeft: hLeft+=1 pLeft=pLeft.left while pRight: hRight+=1 pRight=pRight.right if hLeft==hRight: return pow(2,hLeft)-1 return self.countNodes(root.left)+self.countNodes(root.right)+1"},{"title":"354. Russian Doll Envelopes(hard)","path":"2022/11/16/354/","text":"354. Russian Doll Envelopes(hard)You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelopeâ€™s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope. è¿™é“é¢˜å’Œ300. Longest Increasing Subsequence(medium)å±äºç±»ä¼¼é—®é¢˜ï¼Œåªä¸è¿‡è¯¥é—®é¢˜æŠŠç»´åº¦å‡åˆ°äºŒç»´äº†ï¼Œå…ˆå¯¹å®½åº¦ w è¿›è¡Œå‡åºæ’åºï¼Œå¦‚æœé‡åˆ° w ç›¸åŒçš„æƒ…å†µï¼Œåˆ™æŒ‰ç…§é«˜åº¦ h é™åºæ’åºï¼›ä¹‹åæŠŠæ‰€æœ‰çš„ h ä½œä¸ºä¸€ä¸ªæ•°ç»„ï¼Œåœ¨è¿™ä¸ªæ•°ç»„ä¸Šè®¡ç®— LIS çš„é•¿åº¦å°±æ˜¯ç­”æ¡ˆã€‚ 12345678910111213141516171819202122class Solution: def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int: if not envelopes: return 0 n = len(envelopes) envelopes.sort(key=lambda x: (x[0], -x[1]))#wå‡åºæ’åˆ—ï¼Œhé™åºæ’åˆ— arr=[envelopes[0][1]] for i in range(n): if envelopes[i][1]&gt;arr[-1]: arr.append(envelopes[i][1]) elif envelopes[i][1]&lt;arr[-1]: left,right=0,n-1 while left&lt;right: mid=left+(right-left)//2 #è¿™é‡Œç”¨mid=(left+right)//2 ä¼šè¶…èŒƒå›´ if arr[mid]&gt;=envelopes[i][1]: right=mid else: left=mid+1 arr[left]=envelopes[i][1] return len(arr)"},{"title":"521. Longest Uncommon Subsequence I(easy)","path":"2022/11/16/521/","text":"521. Longest Uncommon Subsequence I(easy)Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.An uncommon subsequence between two strings is a string that is a subsequence of one but not the other.A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.For example, â€œabcâ€ is a subsequence of â€œaebdcâ€ because you can delete the underlined characters in â€œaebdcâ€ to get â€œabcâ€. Other subsequences of â€œaebdcâ€ include â€œaebdcâ€, â€œaebâ€, and â€œâ€ (empty string).è¿™é“é¢˜å¾ˆå”¬äººå•Šï¼Œæˆ‘ä¸€å¼€å§‹ä»¥ä¸ºæ˜¯åŒæŒ‡é’ˆä¸¤ä¸ªå­—ç¬¦ä¸²ä¸æ–­æ¯”è¾ƒï¼Œåæ¥å‘ç°ï¼Œåªéœ€è¦åˆ¤æ–­ä¸€ç‚¹å³å¯ï¼Œå¦‚æœå­—ç¬¦ä¸²aå’Œbç›¸åŒï¼Œé‚£ä¹ˆè¿”å›-1å¦‚æœä¸ç›¸åŒï¼Œæœ€å¤§çš„ä¸åŒå­å­—ç¬¦ä¸²å°±æ˜¯æœ€é•¿çš„é‚£ä¸ªå­—ç¬¦ä¸² 123456class Solution: def findLUSlength(self, a: str, b: str) -&gt; int: if a==b: return -1 else: return max(len(a),len(b))"},{"title":"520. Detect Capital(easy)","path":"2022/11/16/520/","text":"520. Detect Capital(easy)We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like â€œUSAâ€.All letters in this word are not capitals, like â€œleetcodeâ€.Only the first letter in this word is capital, like â€œGoogleâ€.Given a string word, return true if the usage of capitals in it is right. åˆ†å‡ ç§æƒ…å†µè®¨è®ºï¼Œç„¶åç”¨åˆ°äº†isupper()å’Œislower()ä¸¤ä¸ªå‡½æ•° 1234567891011121314151617class Solution: def detectCapitalUse(self, word: str) -&gt; bool: n=len(word) if n==1: return True elif word.isupper(): return True elif word.islower(): return True elif word[0].isupper(): if word[1:].islower(): return True else: return False else: return False"},{"title":"300. Longest Increasing Subsequence(medium)","path":"2022/11/15/300/","text":"300. Longest Increasing Subsequence(medium)Given an integer array nums, return the length of the longest strictly increasing subsequence.æ±‚æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚ å®˜æ–¹é¢˜è§£æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’è¿™ä¸ªæ–¹æ³•ä¼šè¶…æ—¶ 123456789101112class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) æ–¹æ³•äºŒï¼šè´ªå¿ƒ + äºŒåˆ†æŸ¥æ‰¾è¿™é“é¢˜çš„æ–¹æ³•äºŒï¼ŒåŸé¢˜è§£å†™çš„ä¸å¤ªå®¹æ˜“ç†è§£ï¼Œè¯•ç€åœ¨è¿™é‡Œå†è§£é‡Šä¸€éï¼š æ— åºåˆ—è¡¨æœ€å…³é”®çš„ä¸€å¥åœ¨äºï¼š æ•°ç»„ d[i]è¡¨ç¤ºé•¿åº¦ä¸º i çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„æœ«å°¾å…ƒç´ çš„æœ€å°å€¼ï¼Œå³åœ¨æ•°ç»„ 1,2,3,4,5,6ä¸­é•¿åº¦ä¸º3çš„ä¸Šå‡å­åºåˆ—å¯ä»¥ä¸º 1,2,3ä¹Ÿå¯ä»¥ä¸º 2,3,4ç­‰ç­‰ä½†æ˜¯d[3]=3ï¼Œå³å­åºåˆ—æœ«å°¾å…ƒç´ æœ€å°ä¸º3ã€‚ æ— åºåˆ—è¡¨è§£é‡Šæ¸…äº†æ•°ç»„dçš„å«ä¹‰ä¹‹åï¼Œæˆ‘ä»¬æ¥ç€éœ€è¦è¯æ˜æ•°ç»„då…·æœ‰å•è°ƒæ€§ï¼Œå³è¯æ˜i&lt;jæ—¶ï¼Œd[i]&lt;d[j]ï¼Œä½¿ç”¨åè¯æ³•ï¼Œå‡è®¾å­˜åœ¨k&lt;jæ—¶ï¼Œd[k]&gt;d[j]ï¼Œä½†åœ¨é•¿åº¦ä¸ºjï¼Œæœ«å°¾å…ƒç´ ä¸ºd[j]çš„å­åºåˆ—Aä¸­ï¼Œå°†åj-iä¸ªå…ƒç´ å‡æ‰ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸ºiçš„å­åºåˆ—Bï¼Œå…¶æœ«å°¾å…ƒç´ t1å¿…ç„¶å°äºd[j]ï¼ˆå› ä¸ºåœ¨å­åºåˆ—Aä¸­ï¼Œt1çš„ä½ç½®ä¸Šåœ¨d[j]çš„åé¢ï¼‰ï¼Œè€Œæˆ‘ä»¬å‡è®¾æ•°ç»„då¿…é¡»ç¬¦åˆè¡¨ç¤ºé•¿åº¦ä¸º i çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„æœ«å°¾å…ƒç´ çš„æœ€å°å€¼ï¼Œæ­¤æ—¶é•¿åº¦ä¸ºiçš„å­åºåˆ—çš„æœ«å°¾å…ƒç´ t1&lt;d[j]&lt;d[k]ï¼Œå³t1&lt;d[k]ï¼Œæ‰€ä»¥d[k]ä¸æ˜¯æœ€å°çš„ï¼Œä¸é¢˜è®¾ç›¸çŸ›ç›¾ï¼Œå› æ­¤å¯ä»¥è¯æ˜å…¶å•è°ƒæ€§ æ— åºåˆ—è¡¨è¯æ˜å•è°ƒæ€§æœ‰ä¸¤ä¸ªå¥½å¤„ï¼š1.å¯ä»¥ä½¿ç”¨äºŒåˆ†æ³•ï¼›2.æ•°ç»„dçš„é•¿åº¦å³ä¸ºæœ€é•¿å­åºåˆ—çš„é•¿åº¦ï¼›"},{"title":"501. Find Mode in Binary Search Tree(easy)","path":"2022/11/15/501/","text":"501. Find Mode in Binary Search Tree(easy)Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.If the tree has more than one mode, return them in any order.Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the nodeâ€™s key.The right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.Both the left and right subtrees must also be binary search trees. 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findMode(self, root: Optional[TreeNode]) -&gt; List[int]: counter= defaultdict(int) def dfs(root): if not root: return counter[root.val]+=1 dfs(root.left) dfs(root.right) dfs(root) max_val=max(counter.values()) return [i for i in counter if counter[i]==max_val]"},{"title":"506. Relative Ranks(easy)","path":"2022/11/15/506/","text":"506. Relative Ranks(easy)You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:The 1st place athleteâ€™s rank is â€œGold Medalâ€.The 2nd place athleteâ€™s rank is â€œSilver Medalâ€.The 3rd place athleteâ€™s rank is â€œBronze Medalâ€.For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athleteâ€™s rank is â€œxâ€).Return an array answer of size n where answer[i] is the rank of the ith athlete. 123456789101112131415class Solution: def findRelativeRanks(self, score: List[int]) -&gt; List[str]: nums=sorted(score) res=[] for i in range(len(score)): if nums.index(score[i])==len(score)-1: res.append(&#x27;Gold Medal&#x27;) elif nums.index(score[i])==len(score)-2: res.append(&#x27;Silver Medal&#x27;) elif nums.index(score[i])==len(score)-3: res.append(&#x27;Bronze Medal&#x27;) else: res.append(str(len(nums)-nums.index(score[i]))) return res"},{"title":"507. Perfect Number(easy)","path":"2022/11/15/507/","text":"A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly. Given an integer n, return true if n is a perfect number, otherwise return false. æ‰€æœ‰çš„ä½™æ•°ä¹‹å’Œç­‰äºnumæœ¬èº« 123456789101112class Solution: def checkPerfectNumber(self, num: int) -&gt; bool: res=[] x=sqrt(num) if num==1: return False for i in range(1,int(x)+1): if num%i==0: res.append(i) if i!=1: res.append(num//i) return sum(res)==num"},{"title":"504. Base 7(easy)","path":"2022/11/15/504/","text":"504. Base 7(easy)Given an integer num, return a string of its base 7 representation.12345678910111213141516class Solution: def convertToBase7(self, num: int) -&gt; str: res=list() x=num num=abs(num) if num==0: return &quot;0&quot; while num!=0: carry=num%7 num=(num-carry)//7 res.append(carry) res=res[::-1] if x&gt;0: return &quot;&quot;.join(map(str,res)) elif x&lt;0: return &quot;-&quot;+&quot;&quot;.join(map(str,res))"},{"title":"500. Keyboard Row(easy)","path":"2022/11/15/500/","text":"500. Keyboard Row(easy)Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below. In the American keyboard: the first row consists of the characters â€œqwertyuiopâ€,the second row consists of the characters â€œasdfghjklâ€, andthe third row consists of the characters â€œzxcvbnmâ€. 123456789101112131415class Solution: def findWords(self, words: List[str]) -&gt; List[str]: s1 = &quot;qwertyuiop&quot; s2 = &quot;asdfghjkl&quot; s3 = &quot;zxcvbnm&quot; res = [] for word in words: cnt1 = cnt2 = cnt3 = 0 for c in list(word.lower()): if c in s1: cnt1 += 1 if c in s2: cnt2 += 1 if c in s3: cnt3 += 1 if (len(word) == cnt1) or (len(word) == cnt2) or (len(word) == cnt3): res.append(word) return res"},{"title":"482. License Key Formatting(easy)","path":"2022/11/15/482/","text":"482. License Key Formatting(easy)You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.Return the reformatted license key.1234Input: s = &quot;5F3Z-2e-9-w&quot;, k = 4Output: &quot;5F3Z-2E9W&quot;Explanation: The string s has been split into two parts, each part has 4 characters.Note that the two extra dashes are not needed and can be removed. 1234567891011121314151617class Solution: def licenseKeyFormatting(self, s: str, k: int) -&gt; str: ans = list() cnt = 0 for i in range(len(s) - 1, -1, -1): if s[i] != &quot;-&quot;: ans.append(s[i].upper()) cnt += 1 if cnt % k == 0: ans.append(&quot;-&quot;) if ans and ans[-1] == &quot;-&quot;: ans.pop() return &quot;&quot;.join(ans[::-1])"},{"title":"495. Teemo Attacking(easy)","path":"2022/11/15/495/","text":"495. Teemo Attacking(easy)Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.Return the total number of seconds that Ashe is poisoned.123456class Solution: def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&gt; int: ans=duration*len(timeSeries) for i in range(1,len(timeSeries)): ans-=max(0,duration-(timeSeries[i]-timeSeries[i-1])) return ans"},{"title":"492. Construct the Rectangle(easy)","path":"2022/11/15/492/","text":"492. Construct the Rectangle(easy)A web developer needs to know how to design a web pageâ€™s size. So, given a specific rectangular web pageâ€™s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:The area of the rectangular web page you designed must equal to the given target area.The width W should not be larger than the length L, which means L &gt;= W.The difference between length L and width W should be as small as possible.Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.1234Input: area = 4Output: [2,2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. 12345class Solution: def constructRectangle(self, area: int) -&gt; List[int]: for i in range(int(area**0.5),0,-1): if area%i==0: return [area//i,i]"},{"title":"476. Number Complement(easy)","path":"2022/11/15/476/","text":"476. Number Complement(easy)The complement of an integer is the integer you get when you flip all the 0â€™s to 1â€™s and all the 1â€™s to 0â€™s in its binary representation.For example, The integer 5 is â€œ101â€ in binary and its complement is â€œ010â€ which is the integer 2.Given an integer num, return its complement.ä»Šå¤©è¿™é“é¢˜ä¹çœ‹ä¹‹ä¸‹å¾ˆç®€å•ï¼Œç›´æ¥è·ŸäºŒè¿›åˆ¶å…¨ 1 çš„æ•°å¼‚æˆ–å³å¯ï¼š æ¯”å¦‚ï¼šç»™å®šæ•°å­—ä¸º 5 ï¼ˆ101ï¼‰ï¼Œè·Ÿ 111 è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œç»“æœä¸º 010ã€‚ å®åˆ™ä¸ç„¶ï¼Œå› ä¸ºè®¡ç®—æœºåœ¨å­˜å‚¨ 5 è¿™ä¸ªæ•°å­—çš„æ—¶å€™æ˜¯æŒ‰ç…§ 32 ä½æ¥è¿›è¡Œå­˜å‚¨çš„ï¼Œåº”è¯¥ä¸º 00000000000000000000000000000101ï¼ˆä¸‹ç®€å†™ä¸º00..00101ï¼‰ï¼Œæ‰€ä»¥ï¼Œè·Ÿ 32 ä½å…¨æ˜¯ 1 çš„æ•°å­—å¼‚æˆ–ä¹‹åï¼Œé«˜ä½çš„é‚£äº› 0 ä¹Ÿä¼šå…¨éƒ¨å˜æˆ 1ï¼Œæœ€ç»ˆçš„ç»“æœä¸º 11111111111111111111111111111010ï¼Œä¸é¢˜ç›®ç»™å®šçš„ç»“æœå°†ä¸ä¸€è‡´ã€‚ æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦æ¢ä¸€ç§æ€è·¯ã€‚ å…¶å®ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°æœ€é«˜ä½çš„ 1ï¼Œå°†æœ€é«˜ä½çš„ 1 æ‰€åœ¨çš„ä½ç½®åŠæ¯”å®ƒä½çš„ä½ç½®å…¨å˜æˆ 1ï¼Œå†å¼‚æˆ–å³å¯ã€‚ æ¯”å¦‚ï¼Œç»™å®šæ•°å­—ä¸º 5ï¼ˆ00..00101ï¼‰ï¼Œæœ€é«˜ä½çš„ 1 æ˜¯ç¬¬ä¸‰ä½ï¼Œæˆ‘ä»¬å°†ç¬¬ä¸‰ä½åŠæ¯”å®ƒä½çš„ä½ç½®å…¨å˜æˆ 1ï¼Œå³ 00..00111ï¼Œå†è¿›è¡Œå¼‚æˆ–å°±å¾—åˆ°äº† 010 è¿™ä¸ªç»“æœã€‚ é‚£ä¹ˆï¼Œå¦‚ä½•æ‰¾åˆ°æœ€é«˜ä½çš„ 1ï¼Œåˆå¦‚ä½•å°†å…¶åŠæ¯”å®ƒä½çš„ä½ç½®å…¨å˜æˆ 1 å‘¢ï¼Ÿ å…³äºç¬¬ä¸€ä¸ªé—®é¢˜ï¼šæˆ‘ä»¬è¿™é‡Œä»‹ç»ä¸€ç§éå¸¸ç®€å•é«˜æ•ˆçš„æ–¹å¼ï¼Œæ¯æ¬¡æ‰¾åˆ°æœ€ä½ä½ï¼ˆæœ€å³è¾¹ï¼‰çš„ 1 å¹¶æŠŠå®ƒæ‰“æ‰ï¼ˆå˜æˆ 0ï¼‰ï¼Œæœ€ç»ˆæ‰¾åˆ°æœ€é«˜ä½çš„ 1ã€‚ å…³äºç¬¬äºŒä¸ªé—®é¢˜ï¼šæˆ‘ä»¬åªéœ€è¦å°†æœ€é«˜ä½çš„ 1 å·¦ç§»ä¸€ä½ï¼Œå†å‡ 1ï¼Œå°±å¯ä»¥å¾—åˆ°æœ€é«˜ä½ä¸º 1 çš„ä½ç½®åŠæ¯”å®ƒä½çš„ä½ç½®å…¨æ˜¯ 1 çš„æ•°å­—äº†ã€‚ æ¯”å¦‚ï¼Œç»™å®šæ•°å­—ä¸º 5ï¼ˆ00..00101ï¼‰ï¼Œæˆ‘ä»¬ç¬¬ä¸€æ¬¡æ‰¾åˆ°çš„ 1 æ˜¯ 00.00001ï¼ŒæŠŠå®ƒæ‰“æ‰åæ•°å­—å˜ä¸º 00..00100ï¼Œç„¶åï¼Œæ‰¾åˆ°çš„ç¬¬äºŒä¸ª 1 æ˜¯ 00..00100ï¼ŒæŠŠè¿™ä¸ª 1 å†æ‰“æ‰åæ•°å­—å˜ä¸º 00..00000ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬è¦æ‰¾çš„æœ€é«˜ä½çš„ 1 å°±æ˜¯ 00..00100 è¿™ä¸ªæ•°å­—ï¼ŒæŠŠè¿™ä¸ªæ•°å­—å·¦ç§»ä¸€ä½å˜æˆ00..01000ï¼Œå†å‡ 1 å¾—åˆ° 00..00111ï¼Œæœ€åï¼Œå†ä¸åŸæ•°å­—å¼‚æˆ–ï¼Œå¾—åˆ° 00..00010ï¼Œå®Œäº‹å„¿ã€‚ å…³äºæº¢å‡ºï¼šé¢˜ç›®çº¦å®šäº†ç»™å®šçš„æ•°å­—ä¸ºå¤§äºæˆ–ç­‰äº 1 çš„ 32 ä½æ•°å­—ï¼Œæ‰€ä»¥ï¼Œ32 ä½çš„æœ€é«˜ä½ä¸ä¼šä¸º 1ï¼Œå› æ­¤ï¼Œä¸ä¼šæº¢å‡º ã€‚ ä½œè€…ï¼štong-zhué“¾æ¥ï¼šhttps://leetcode.cn/problems/number-complement/solution/tong-ge-lai-shua-ti-la-jian-dan-gao-xiao-k0p9/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 12345678class Solution: def findComplement(self, num: int) -&gt; int: highbit=1 x=num while x!=0: highbit=x&amp;(-x) x=x&amp;(x-1) return num^((highbit&lt;&lt;1)-1)"},{"title":"796. Rotate String(easy)","path":"2022/11/14/796/","text":"Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.A shift on s consists of moving the leftmost character of s to the rightmost position.For example, if s = â€œabcdeâ€, then it will be â€œbcdeaâ€ after one shift.å¯ä»¥ç”¨å­å­—ç¬¦ä¸²çš„æ–¹å¼ï¼Œåˆ¤æ–­goalåœ¨ä¸åœ¨ä¸¤ä¸ªsè¿åœ¨ä¸€èµ·çš„å­—ç¬¦ä¸²é‡Œ class Solution: def rotateString(self, s: str, goal: str) -&gt; bool: if len(s)!=len(goal): return False else: if goal in s+s: return True else: return False"},{"title":"128. Longest Consecutive Sequence(medium)","path":"2022/11/14/128/","text":"128. Longest Consecutive Sequence(medium)Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.You must write an algorithm that runs in O(n) time.123Input: nums = [100,4,200,1,3,2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. å…ˆå¯¹numså–setåæ’åº(å¦‚æœæœ‰ç›¸åŒçš„æ•°å­—ï¼Œæ˜¯å¯ä»¥ç›´æ¥è·³è¿‡ï¼Œè€Œä¸”è®¡æ•°ä¹Ÿä¸ä¼šåœçš„)ï¼Œç„¶åä¸æ–­è®¡æ•°è¿ç»­çš„æ•°å­— 1234567891011121314151617class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: nums=list(set(nums)) nums.sort() if len(nums)==0: return 0 elif len(nums)==1: return 1 res=0 count=1 for i in range(1,len(nums)): if nums[i]-nums[i-1]==1: count+=1 else: count=1 res=max(res,count) return res"},{"title":"238. Product of Array Except Self(medium)","path":"2022/11/14/238/","text":"238. Product of Array Except Self(medium)Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation.å› ä¸ºé¢˜ç›®é™åˆ¶äº†é™¤æ³•ï¼Œæ‰€ä»¥ä¸ºäº†ç¼©å‡æ—¶é—´å¤æ‚åº¦ï¼Œæ¨¡ä»¿å‰ç¼€å’Œæ•°ç»„ï¼Œå»ºç«‹ä¸¤ä¸ªæ•°ç»„ï¼Œä¸€ä¸ªä»å·¦è¾¹ä¹˜å¾—åˆ°çš„æ•°ç»„ï¼Œä¸€ä¸ªä»å³è¾¹ä¹˜å¾—åˆ°çš„æ•°ç»„ï¼Œæœ€åçš„ç»“æœå°±ç­‰äºä¸¤ä¸ªæ•°ç»„åœ¨ç›¸åŒä½ç½®çš„ä¹˜ç§¯ 12345678910111213class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: n=len(nums) L,R,res=[0]*n,[0]*n,[0]*n L[0]=1 R[n-1]=1 for i in range(1,n): L[i]=nums[i-1]*L[i-1] for i in reversed(range(n-1)): R[i]=nums[i+1]*R[i+1] for i in range(n): res[i]=L[i]*R[i] return res"},{"title":"49. Group Anagrams(medium)","path":"2022/11/14/49/","text":"49. Group Anagrams(medium)Given an array of strings strs, group the anagrams together. You can return the answer in any order.An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.leetcode å®˜æ–¹é¢˜è§£ç”±äºäº’ä¸ºå­—æ¯å¼‚ä½è¯çš„ä¸¤ä¸ªå­—ç¬¦ä¸²åŒ…å«çš„å­—æ¯ç›¸åŒï¼Œå› æ­¤å¯¹ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ†åˆ«è¿›è¡Œæ’åºä¹‹åå¾—åˆ°çš„å­—ç¬¦ä¸²ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œæ•…å¯ä»¥å°†æ’åºä¹‹åçš„å­—ç¬¦ä¸²ä½œä¸ºå“ˆå¸Œè¡¨çš„é”®ã€‚è¿™é“é¢˜ä¸»è¦æ˜¯æŠŠå­—ç¬¦ä¸²æœ¬èº«å½“ä½œé”®ï¼Œå­—æ¯ç›¸åŒçš„å­—ç¬¦ä½œä¸ºé”®æ˜¯åŒä¸€ä¸ª 12345678class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: n=len(strs) mp=collections.defaultdict(list) for st in strs: key=&quot;&quot;.join(sorted(st)) mp[key].append(st) return list(mp.values())"},{"title":"217. Contains Duplicate(easy)","path":"2022/11/14/217/","text":"217. Contains Duplicate(easy)Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.12Input: nums = [1,2,3,1]Output: true åˆ©ç”¨ï½“ï½…ï½”çš„å»é‡å±æ€§ 123class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: return len(set(nums))!=len(nums)"},{"title":"2131. Longest Palindrome by Concatenating Two Letter Words(medium)","path":"2022/11/12/2131/","text":"2131. Longest Palindrome by Concatenating Two Letter Words(medium)You are given an array of strings words. Each element of words consists of two lowercase English letters.Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.A palindrome is a string that reads the same forward and backward.åŠ›æ‰£å®˜æ–¹é¢˜è§£ æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ + å“ˆå¸Œè¡¨æ€è·¯ä¸ç®—æ³• æ ¹æ®å›æ–‡ä¸²çš„å®šä¹‰ï¼Œå›æ–‡ä¸²å¯ä»¥ç”±å¥‡æ•°æˆ–è€…å¶æ•°ä¸ª words ä¸­çš„å•è¯æ‹¼æ¥è€Œæˆï¼Œä½†å¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š å¦‚æœæ•°é‡ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆä½äºæ­£ä¸­é—´çš„å•è¯å¿…é¡»æ˜¯å›æ–‡å­—ç¬¦ä¸²ï¼ˆå³ä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰ï¼‰ï¼› æ¯ä¸ªå•è¯å’Œåè½¬åå¯¹åº”ä½ç½®çš„å•è¯å¿…é¡»äº’ä¸ºåè½¬å­—ç¬¦ä¸²ã€‚ æ ¹æ®ä¸Šé¢çš„ä¸¤ä¸ªæ¡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºæ„é€ æœ€é•¿å›æ–‡ä¸²çš„è§„åˆ™ï¼š å¯¹äºä¸¤ä¸ªå­—ç¬¦ä¸åŒçš„å•è¯ï¼Œéœ€è¦å°½å¯èƒ½å¤šçš„æˆå¯¹é€‰æ‹©å®ƒå’Œå®ƒçš„åè½¬å­—ç¬¦ä¸²ï¼ˆå¦‚æœ‰ï¼‰ï¼› å¯¹äºä¸¤ä¸ªå­—ç¬¦ç›¸åŒçš„å•è¯ï¼Œéœ€è¦å°½å¯èƒ½å¤šçš„æˆå¯¹é€‰æ‹©è¯¥å•è¯ï¼› å¦‚æœæŒ‰ç…§ä¸Šè¿°æ¡ä»¶æŒ‘é€‰åï¼Œä»ç„¶å­˜åœ¨æœªè¢«é€‰æ‹©çš„ä¸¤ä¸ªå­—ç¬¦ç›¸åŒçš„å•è¯ï¼ˆæ­¤æ—¶è¯¥å­—ç¬¦ä¸²åªå¯èƒ½æœ‰ä¸€ä¸ªæœªè¢«é€‰æ‹©ï¼Œä¸”è¯¥å­—ç¬¦ä¸²ä¸€å®šåœ¨ words ä¸­å‡ºç°å¥‡æ•°æ¬¡ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„é€‰æ‹©ä¸€ä¸ªã€‚ å› æ­¤ï¼Œæˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡ words ä¸­æ¯ä¸ªå•è¯çš„å‡ºç°æ¬¡æ•°ã€‚éšåï¼Œæˆ‘ä»¬éå†å“ˆå¸Œè¡¨çš„æ‰€æœ‰å…ƒç´ ï¼Œå¹¶ç”¨ res ç»´æŠ¤å¯èƒ½æ„æˆå›æ–‡å­—ç¬¦ä¸²çš„æœ€é•¿é•¿åº¦ï¼ŒåŒæ—¶ç”¨åˆå€¼ä¸º false çš„å¸ƒå°”å˜é‡ mid åˆ¤æ–­æ˜¯å¦å­˜åœ¨å¯ä»¥ä½œä¸ºä¸­å¿ƒå•è¯çš„ã€å‡ºç°å¥‡æ•°æ¬¡çš„å›æ–‡å•è¯ã€‚åœ¨éå†åˆ°å­—ç¬¦ä¸² word æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆæ±‚å‡ºå®ƒåè½¬åçš„å­—ç¬¦ä¸² revï¼Œæ­¤æ—¶æ ¹æ® word ä¸ rev çš„å…³ç³»ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š word=Ì¸revï¼Œæ­¤æ—¶æˆ‘ä»¬éœ€è¦ç»Ÿè®¡ä¸¤è€…åœ¨ words å‡ºç°æ¬¡æ•°çš„æœ€å°å€¼ï¼Œå³ä¸ºæˆå¯¹é€‰æ‹©çš„æœ€å¤šæ•°ç›®ã€‚å‡è®¾æ­¤æ—¶å¯¹æ•°ä¸º nï¼Œåˆ™å…¶å¯¹æœ€é•¿å›æ–‡å­—ç¬¦ä¸²è´¡çŒ®çš„å­—ç¬¦é•¿åº¦ä¸º 4nï¼Œæˆ‘ä»¬å°† res åŠ ä¸Šå¯¹åº”å€¼ï¼› word=revï¼Œæ­¤æ—¶å¯ä»¥æ„æˆçš„å¯¹æ•°ä¸º âŒŠm/2âŒ‹ï¼Œå³å¯¹æœ€é•¿å›æ–‡å­—ç¬¦ä¸²è´¡çŒ®çš„å­—ç¬¦é•¿åº¦ä¸º 4âŒŠm/2âŒ‹ï¼Œæˆ‘ä»¬åŒæ ·å°† res åŠ ä¸Šå¯¹åº”å€¼ã€‚é™¤æ­¤ä»¥å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åˆ¤æ–­ word çš„å‡ºç°æ¬¡æ•° m æ˜¯å¦ä¸ºå¥‡æ•°ï¼š å¦‚æœ m ä¸ºå¥‡æ•°ï¼Œåˆ™å­˜åœ¨å¯ä»¥ä½œä¸ºä¸­å¿ƒå•è¯çš„å‰©ä½™å›æ–‡å•è¯ï¼Œæˆ‘ä»¬å°† mid ç½®ä¸º trueï¼› å¦‚æœ m ä¸ºå¶æ•°ï¼Œåˆ™ä¸å­˜åœ¨å¯ä»¥ä½œä¸ºä¸­å¿ƒå•è¯çš„å‰©ä½™å›æ–‡å•è¯ï¼Œæˆ‘ä»¬ä¸æ”¹å˜ mid çš„å–å€¼ã€‚ æœ€åï¼Œæˆ‘ä»¬æ ¹æ® mid çš„å–å€¼ï¼Œåˆ¤æ–­æœ€é•¿å›æ–‡ä¸²æ˜¯å¦å«æœ‰ä¸­å¿ƒå•è¯ã€‚å¦‚æœ mid ä¸º trueï¼Œåˆ™ä»£è¡¨å«æœ‰ï¼Œæˆ‘ä»¬å°† res åŠ ä¸Š 2ï¼›åä¹‹åˆ™æ²¡æœ‰ï¼Œæˆ‘ä»¬ä¸è¿›è¡Œä»»ä½•æ“ä½œã€‚ æœ€åï¼Œæˆ‘ä»¬è¿”å› res ä½œä¸ºæœ€é•¿å›æ–‡ä¸²çš„é•¿åº¦ã€‚ ç»†èŠ‚ åœ¨éå†å“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸ªå•è¯æ—¶ï¼Œä¸ºäº†é¿å…é‡å¤è®¡ç®—æˆå¯¹é€‰æ‹©çš„å•è¯ï¼Œæˆ‘ä»¬åªåœ¨ word çš„å­—å…¸åºå¤§äºç­‰äº rev æ—¶æ›´æ–° resã€‚ 12345678910111213141516171819class Solution: def longestPalindrome(self, words: List[str]) -&gt; int: freq = Counter(words) # å•è¯å‡ºç°æ¬¡æ•° res = 0 # æœ€é•¿å›æ–‡ä¸²é•¿åº¦ mid = False # æ˜¯å¦å«æœ‰ä¸­å¿ƒå•è¯ for word, cnt in freq.items(): # éå†å‡ºç°çš„å•è¯ï¼Œå¹¶æ›´æ–°é•¿åº¦ rev = word[1] + word[0] # åè½¬åçš„å•è¯ if word == rev: if cnt % 2 == 1: mid = True res += 2 * (cnt // 2 * 2) elif word &gt; rev: # é¿å…é‡å¤éå† res += 4 * min(freq[word], freq[rev]) if mid: # å«æœ‰ä¸­å¿ƒå•è¯ï¼Œæ›´æ–°é•¿åº¦ res += 2 return res"},{"title":"1641. Count Sorted Vowel Strings(medium)","path":"2022/11/12/1641/","text":"1641. Count Sorted Vowel Strings(medium)Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.å®˜æ–¹è§£æ³•æ•°å­¦è§£æ³•çœ‹åˆ°é¢˜ç›®çš„ç¬¬ä¸€çœ¼å°±æ„Ÿè§‰è¿™æ˜¯æ’åˆ—ç»„åˆï¼Œä½†æ²¡æƒ³å¥½æ€ä¹ˆå†™å‡ºæ’åˆ—çš„å…¬å¼ï¼Œè¿™ä½å¤§ä½¬çš„æ€è·¯å¤ªç‰›äº†ï¼š è¿™ä¸ªé—®é¢˜çš„æ•°å­¦è§£æ³•ï¼Œå¯ä»¥æŠŠé—®é¢˜è½¬æ¢æˆå°† n ä¸ªå°çƒæ”¾åˆ° 5 ä¸ªç›’å­é‡Œï¼Œç›’å­å¯ä»¥ä¸ºç©ºã€‚æˆ‘ä»¬å¯ä»¥æƒ³è±¡æˆæŠŠ n ä¸ªå­—ç¬¦åˆ†é…ç»™äº”ä¸ªå…ƒéŸ³æ‰€ä»£è¡¨çš„ç›’å­ä¸­ã€‚ä¸€æ—¦æ¯ä¸ªç›’å­ä¸­çš„å­—ç¬¦ä¸ªæ•°å®šäº†ï¼Œé‚£ä¹ˆè¿™ä¸ªå­—ç¬¦ä¸²ä¹Ÿå›ºå®šä¸‹æ¥äº†ã€‚å› ä¸ºé¢˜ç›®è¦æ±‚å¿…é¡»æ˜¯å­—å…¸åºï¼Œæ‰€ä»¥ä¸€å®š a å­—ç¬¦åœ¨æœ€å‰ï¼›å…¶æ¬¡æ˜¯ e å­—ç¬¦ï¼›å…¶æ¬¡æ˜¯ i å­—ç¬¦ï¼›å…¶æ¬¡æ˜¯ o å­—ç¬¦ï¼›å…¶æ¬¡æ˜¯ u å­—ç¬¦ã€‚ ä¸‹é¢é—®é¢˜çš„å…³é”®å°±æ˜¯ï¼Œn ä¸ªå°çƒæ”¾åˆ° 5 ä¸ªç›’å­é‡Œï¼Œç›’å­å¯ä»¥ä¸ºç©ºï¼Œä¸€å…±æœ‰å¤šå°‘ç§æ–¹æ³•ï¼Ÿ è¿™æ˜¯ç»å…¸çš„ä¸­å­¦æ•°å­¦é—®é¢˜ã€‚æ›´ä¸€èˆ¬çš„ï¼Œæˆ‘ä»¬æ¥æ¢è®¨ï¼Œå°† n ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œæœ‰å¤šå°‘ç§æ–¹æ³•ï¼Ÿ é¦–å…ˆï¼Œæˆ‘ä»¬è€ƒè™‘é—®é¢˜çš„ç®€å•ç‰ˆæœ¬ï¼Œå³ç›’å­ä¸èƒ½ä¸ºç©ºçš„æƒ…å†µã€‚ æ­¤æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ n ä¸ªå°çƒæ’æˆä¸€æ’ï¼Œä¸­é—´æ”¾ m - 1 ä¸ªéš”æ¿ï¼Œæ”¾å¥½ä»¥åï¼Œç›¸å½“äºæŠŠ n ä¸ªå°çƒåˆ†æˆäº† m ä»½ã€‚æ¯ä¸€ä»½å¯¹åº”ä¸€ä¸ªç›’å­é‡Œçš„å°çƒæ•°é‡ã€‚ å› ä¸ºç›’å­ä¸èƒ½ä¸ºç©ºï¼Œæ‰€ä»¥ä¸¤ä¸ªå°çƒä¹‹é—´ä¸å¯èƒ½æ”¾å¤šä¸ªéš”æ¿ï¼Œå·¦å³ä¸¤ç«¯ä¹Ÿä¸å¯èƒ½æ”¾éš”æ¿ã€‚å› æ­¤ï¼Œæ”¾éš”æ¿çš„ä½ç½®æœ‰ n - 1 ä¸ªï¼Œæˆ‘ä»¬è¦æ”¾ m - 1 ä¸ªéš”æ¿ã€‚ç­”æ¡ˆä¸º C(n - 1, m - 1)ã€‚ æœ‰äº†è¿™ä¸ªç»“è®ºï¼Œå†æ¥è®¨è®ºé—®é¢˜çš„å¤æ‚ç‰ˆæœ¬ï¼Œå°±ç®€å•äº†ï¼Œå³ç›’å­å¯ä»¥ä¸ºç©ºçš„æƒ…å†µã€‚ æ­¤æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦å…ˆæ‹¿ m ä¸ªæ–°çš„å°çƒï¼Œåœ¨ m ä¸ªç›’å­é‡Œï¼Œæ¯ä¸ªç›’å­ä¸­æ‰”è¿›å»ä¸€ä¸ªå°çƒã€‚ä¹‹åï¼Œå†åˆ†é…åŸæ¥çš„è¿™ n ä¸ªå°çƒï¼Œå¾—åˆ°çš„åˆ†é…ç»“æœï¼Œè‚¯å®š m ä¸ªç›’å­é‡Œéƒ½ä¸ä¸ºç©ºã€‚ä½†æ­¤æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† n + m ä¸ªå°çƒã€‚ æ¢å¥è¯è¯´ï¼ŒæŠŠ n ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­å¯ä»¥ä¸ºç©ºï¼Œç­‰ä»·äºï¼šæŠŠ n + m ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­ä¸èƒ½ä¸ºç©ºã€‚ å¤§å®¶ä¹Ÿå¯ä»¥æƒ³æˆæ˜¯ï¼šæˆ‘ä»¬å…ˆæŠŠ n + m ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­ä¸èƒ½ä¸ºç©ºï¼Œç„¶åå†åœ¨æ¯ä¸ªç›’å­é‡Œæ‹¿èµ° 1 ä¸ªå°çƒï¼Œæ€»å…±æ‹¿èµ°äº† m ä¸ªå°çƒï¼Œå¾—åˆ°çš„ç»“æœï¼Œå°±æ˜¯æŠŠ n ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­å¯ä»¥ä¸ºç©ºçš„è§£ã€‚ æŠŠ n + m ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­ä¸èƒ½ä¸ºç©ºçš„åˆ†æ³•ï¼Œå¸¦å…¥ä¸Šé¢çš„å…¬å¼ï¼Œå°±æ˜¯ C(n + m - 1, m - 1) æ‰€ä»¥ï¼ŒæŠŠ n ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­å¯ä»¥ä¸ºç©ºï¼Œç­”æ¡ˆä¸º C(n + m - 1, m - 1)ã€‚ æ€»ç»“ï¼šå°† n ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­ä¸ä¸ºç©ºï¼šC(n - 1, m - 1)ï¼› å°† n ä¸ªå°çƒæ”¾åˆ° m ä¸ªç›’å­é‡Œï¼Œç›’å­å¯ä»¥ç©ºï¼šC(n + m - 1, m - 1)ï¼› å¯¹äºè¿™ä¸ªé—®é¢˜ï¼Œm = 5ï¼Œç›’å­å¯ä»¥ä¸ºç©ºï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ C(n + 5 - 1, 5 - 1) = C(n + 4, 4) æé†’ï¼šåˆ†æˆäº”ä¸ªç›’å­ï¼Œé¦–å…ˆä¸è®ºç©ºä¸ä¸ç©ºï¼Œæˆ‘ä»¬çš„äº”ä¸ªç›’å­æœ€ç»ˆç»„æˆæˆ‘ä»¬ç­”æ¡ˆçš„å½¢å¼æ˜¯ç”Ÿæˆä¸æ¯ä¸ªç›’å­æ•°é‡ç›¸ç­‰çš„å¯¹åº”å­—ç¬¦ä¸²ï¼Œç„¶åæŠŠäº”ä¸ªå­—ç¬¦ä¸²ç©¿èµ·æ¥ï¼Œå¦‚aa+e+i+o+uè¿™ç§ï¼Œç›’å­é‡Œçƒçš„æ•°é‡æ˜¯æŸä¸€ä¸ªå…ƒéŸ³å­—æ¯è¿ç»­å‡ºç°çš„æ•°é‡ï¼Œæ‰€ä»¥å¯ä»¥ç©º"},{"title":"1646. Get Maximum in Generated Array(easy)","path":"2022/11/10/1646/","text":"1646. Get Maximum in Generated Array(easy)You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:nums[0] = 0nums[1] = 1nums[2 * i] = nums[i] when 2 &lt;= 2 * i &lt;= nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &lt;= 2 * i + 1 &lt;= nReturn the maximum integer in the array numsâ€‹â€‹â€‹. 123456789101112Input: n = 7Output: 3Explanation: According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. å®˜æ–¹é¢˜è§£æˆ‘ä»¬å¯ä»¥ç›´æ¥æ ¹æ®é¢˜ç›®ä¸­æè¿°çš„è§„åˆ™æ¥è®¡ç®—å‡º nums æ•°ç»„ï¼Œå¹¶è¿”å›å…¶æœ€å¤§å…ƒç´ ã€‚ ä¸ºäº†ç®€åŒ–ä»£ç é€»è¾‘ï¼Œæˆ‘ä»¬å¯ä»¥åŒ–ç®€é¢˜ç›®ä¸­çš„é€’æ¨å¼ã€‚å½“ iâ‰¥2 æ—¶ï¼š å½“iä¸ºå¶æ•°ï¼Œnums[i]=nums[i//2]å½“iä¸ºå¥‡æ•°ï¼Œnums[i]=nums[i//2]+nums[i//2+1] æ‰€ä»¥æ€»ç»“åœ¨ä¸€èµ·æ˜¯ï¼Œnums[i]=nums[i//2]+i%2*nums[i//2+1] 12345678910class Solution: def getMaximumGenerated(self, n: int) -&gt; int: if n==0: return 0 dp=[0]*(n+1) dp[1]=1 for i in range(2,n+1): dp[i]=dp[i//2]+i%2*dp[i//2+1] return max(dp)"},{"title":"1025. Divisor Game(easy)","path":"2022/11/10/1025/","text":"1025. Divisor Game(easy)Alice and Bob take turns playing a game, with Alice starting first.Initially, there is a number n on the chalkboard. On each playerâ€™s turn, that player makes a move consisting of:Choosing any x with 0 &lt; x &lt; n and n % x == 0.Replacing the number n on the chalkboard with n - x.Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally.åŸºæœ¬æ€è·¯ï¼š æœ€ç»ˆç»“æœåº”è¯¥æ˜¯å åˆ° 2 çš„èµ¢ï¼Œå åˆ° 1 çš„è¾“ï¼› è‹¥å½“å‰ä¸ºå¥‡æ•°ï¼Œå¥‡æ•°çš„çº¦æ•°åªèƒ½æ˜¯å¥‡æ•°æˆ–è€… 1ï¼Œå› æ­¤ä¸‹ä¸€ä¸ªä¸€å®šæ˜¯å¶æ•°ï¼› è‹¥å½“å‰ä¸ºå¶æ•°ï¼Œ å¶æ•°çš„çº¦æ•°å¯ä»¥æ˜¯å¥‡æ•°å¯ä»¥æ˜¯å¶æ•°ä¹Ÿå¯ä»¥æ˜¯ 1ï¼Œå› æ­¤ç›´æ¥å‡ 1ï¼Œåˆ™ä¸‹ä¸€ä¸ªæ˜¯å¥‡æ•°ï¼› å› æ­¤ï¼Œå¥‡åˆ™è¾“ï¼Œå¶åˆ™èµ¢ã€‚ç›´æ¥: 123class Solution: def divisorGame(self, n: int) -&gt; bool: return n%2==0"},{"title":"1047. Remove All Adjacent Duplicates In String(easy)","path":"2022/11/10/1047/","text":"1047. Remove All Adjacent Duplicates In String(easy)You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.We repeatedly make duplicate removals on s until we no longer can.Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.è¿™é“é¢˜ç”¨æ ˆå°±å¯ä»¥è§£å†³ï¼Œè¾“å…¥è¿›æ¥åˆ¤æ–­å’Œstacké˜Ÿé¦–æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰å°±å¼¹å‡ºï¼Œä¸ç›¸ç­‰å°±å­˜è¿›å» class Solution: def removeDuplicates(self, s: str) -&gt; str: stack=[] for letter in s: if stack and letter==stack[-1]: stack.pop() else: stack.append(letter) return &quot;&quot;.join(stack)"},{"title":"905. Sort Array By Parity(easy)","path":"2022/11/09/905/","text":"905. Sort Array By Parity(easy)Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.Return any array that satisfies this condition.å¶æ•°æ”¾å‰é¢ï¼Œå¥‡æ•°æ”¾åé¢ ç¬¬ä¸€ç§æ–¹æ³•å¯¹%2çš„å€¼æ’åº 1234class Solution: def sortArrayByParity(self, nums: List[int]) -&gt; List[int]: nums.sort(key = lambda x: x % 2) return nums ç¬¬äºŒç§æ–¹æ³•é€šè¿‡äº¤æ¢é˜Ÿé¦–å’Œé˜Ÿå°¾çš„å€¼ 1234567891011class Solution(object): def sortArrayByParity(self, nums): i, j = 0, len(nums) - 1 while i &lt; j: if nums[i] % 2 &gt; nums[j] % 2: nums[i], nums[j] = nums[j], nums[i] if nums[i] % 2 == 0: i += 1 if nums[j] % 2 == 1: j -= 1 return nums"},{"title":"904. Fruit Into Baskets(medium)","path":"2022/11/09/904/","text":"904. Fruit Into Baskets(medium)You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.Once you reach a tree with fruit that cannot fit in your baskets, you must stop.Given the integer array fruits, return the maximum number of fruits you can pick. è¿™é“é¢˜çš„æœ¬è´¨æ˜¯æ±‚è¿ç»­å­åºåˆ— åŠ›æ‰£å®˜æ–¹é¢˜è§£1234567891011121314class Solution: def totalFruit(self, fruits: List[int]) -&gt; int: cnt = Counter() left = ans = 0 for right, x in enumerate(fruits): cnt[x] += 1 while len(cnt) &gt; 2: cnt[fruits[left]] -= 1 if cnt[fruits[left]] == 0: cnt.pop(fruits[left]) left += 1 ans = max(ans, right - left + 1) return ans"},{"title":"901. Online Stock Span(medium)","path":"2022/11/09/901/","text":"901. Online Stock Span(medium)Design an algorithm that collects daily price quotes for some stock and returns the span of that stockâ€™s price for the current day.The span of the stockâ€™s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to todayâ€™s price.For example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6].Implement the StockSpanner class:StockSpanner() Initializes the object of the class.int next(int price) Returns the span of the stockâ€™s price given that todayâ€™s price is price. å®˜æ–¹é¢˜è§£ä¸€å¼€å§‹æˆ‘å…ˆè¯•äº†ç›´æ¥ç”¨æ•°ç»„è®°å½•æ•°æ®ï¼Œç„¶åæ¯æ¬¡å¾€å‰éå†ä¸€éè®°å½•æœ‰å¤šå°‘å°äºå½“å‰priceçš„å€¼ï¼Œä½†æ˜¯åœ¨åé¢çš„testcaseä¸­é‡åˆ°äº†è¶…æ—¶çš„é—®é¢˜ã€‚å®˜æ–¹è§£ç­”æ˜¯ç”¨äº†stackæ¥è§£å†³è¿™ä¸ªé—®é¢˜ è°ƒç”¨ next æ—¶ï¼Œè¾“å…¥æ˜¯æ–°çš„ä¸€å¤©çš„è‚¡ç¥¨ä»·æ ¼ï¼Œéœ€è¦è¿”å›åŒ…å«æ­¤æ—¥åœ¨å†…çš„ï¼Œå¾€å‰æ•°æœ€å¤šæœ‰è¿ç»­å¤šå°‘æ—¥çš„è‚¡ç¥¨ä»·æ ¼æ˜¯å°äºç­‰äºä»Šæ—¥è‚¡ç¥¨ä»·æ ¼çš„ã€‚å¦‚æœæŠŠæ¯æ—¥çš„ price å½“æˆæ•°ç»„ä¸åŒä¸‹æ ‡çš„å€¼ï¼Œå³éœ€è¦æ±‚å‡ºæ¯ä¸ªå€¼ä¸ä¸Šä¸€ä¸ªæ›´å¤§å…ƒç´ ä¹‹é—´çš„ä¸‹æ ‡ä¹‹å·®ã€‚è¿™ç§é¢˜ç›®å¯ä»¥ç”¨å•è°ƒæ ˆæ±‚è§£ï¼Œå…·ä½“åŸç†å¯ä»¥å‚è€ƒã€Œ496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I çš„å®˜æ–¹é¢˜è§£çš„æ–¹æ³•äºŒã€ã€‚æ­¤é¢˜çš„å…·ä½“è§£æ³•ä¸Šï¼Œæ ˆçš„å…ƒç´ å¯ä»¥æ˜¯è‚¡ç¥¨ä»·æ ¼çš„ä¸‹æ ‡ï¼ˆå³å¤©æ•°ï¼‰å’Œè‚¡ç¥¨ä»·æ ¼çš„äºŒå…ƒæ•°å¯¹ï¼Œå¹¶ä¸”åœ¨æ ˆä¸­å…ˆæ’å…¥ä¸€ä¸ªæœ€å¤§å€¼ä½œä¸ºå¤©æ•°ä¸º âˆ’1 å¤©çš„ä»·æ ¼ï¼Œæ¥ä¿è¯æ ˆä¸ä¼šä¸ºç©ºã€‚è°ƒç”¨ next æ—¶ï¼Œå…ˆå°†æ ˆä¸­ä»·æ ¼å°äºç­‰äºæ­¤æ—¶ price çš„å…ƒç´ éƒ½å¼¹å‡ºï¼Œç›´åˆ°é‡åˆ°ä¸€ä¸ªå¤§äº price çš„å€¼ï¼Œå¹¶å°† price å…¥æ ˆï¼Œè®¡ç®—ä¸‹æ ‡å·®è¿”å›ã€‚ 1234567891011class StockSpanner: def __init__(self): self.stack = [(-1, inf)] self.idx = -1 def next(self, price: int) -&gt; int: self.idx += 1 while price &gt;= self.stack[-1][1]: self.stack.pop() self.stack.append((self.idx, price)) return self.idx - self.stack[-2][0] ä½œè€…ï¼šåŠ›æ‰£å®˜æ–¹é¢˜è§£é“¾æ¥ï¼šhttps://leetcode.cn/problems/online-stock-span/solutions/1906765/gu-piao-jie-ge-kua-du-by-leetcode-soluti-5cm7/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"2244. Minimum Rounds to Complete All Tasks(medium)","path":"2022/11/09/2244/","text":"2244. Minimum Rounds to Complete All Tasks(medium)You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.12345678Input: tasks = [2,2,3,3,2,4,4,4,4,4]Output: 4Explanation: To complete all the tasks, a possible plan is:- In the first round, you complete 3 tasks of difficulty level 2. - In the second round, you complete 2 tasks of difficulty level 3. - In the third round, you complete 3 tasks of difficulty level 4. - In the fourth round, you complete 2 tasks of difficulty level 4. It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4. Solution:é€šè¿‡Counterè®°å½•ç›¸åŒtaskï¼Œç„¶åéå†æ¯ä¸ªvalueçš„ä¸ªæ•°countåˆ†æƒ…å†µè®¨è®ºï¼Œé‡åˆ°åªæœ‰ä¸€ä¸ªçš„ç›´æ¥è¿”å›-1ï¼Œå¯¹3èƒ½æ•´é™¤çš„ansåŠ ä¸Šcounté™¤3å‰©ä¸‹çš„éƒ½æ˜¯é™¤ä¸‰å‘ä¸‹å–æ•´åŠ 1 12345678910111213141516#from collections import Counterclass Solution: def minimumRounds(self, tasks: List[int]) -&gt; int: ans=0 if len(tasks)==1: return -1 hashmap=Counter(tasks) ans=0 for count in hashmap.values(): if count==1: return -1 elif count%3==0: ans+=count/3 else: ans+=count//3+1 return int(ans)"},{"title":"746. Min Cost Climbing Stairs(easy)","path":"2022/11/08/746/","text":"746. Min Cost Climbing Stairs(easy)You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.You can either start from the step with index 0, or the step with index 1.Return the minimum cost to reach the top of the floor.å®˜æ–¹é¢˜è§£åˆ›å»ºé•¿åº¦ä¸º n+1çš„æ•°ç»„ dpï¼Œå…¶ä¸­ dp[i] è¡¨ç¤ºè¾¾åˆ°ä¸‹æ ‡ i çš„æœ€å°èŠ±è´¹ã€‚ ç”±äºå¯ä»¥é€‰æ‹©ä¸‹æ ‡ 0 æˆ– 1 ä½œä¸ºåˆå§‹é˜¶æ¢¯ï¼Œå› æ­¤æœ‰ dp[0]=dp[1]=0 çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š dp[i]=min(dp[iâˆ’1]+cost[iâˆ’1],dp[iâˆ’2]+cost[iâˆ’2]) æœ‰äº†è¿™ä¸ªæ–¹ç¨‹ï¼Œè¿™é“é¢˜å°±å¥½ä¸‹æ‰‹äº† 12345678class Solution: def minCostClimbingStairs(self, cost: List[int]) -&gt; int: n=len(cost) dp=[0]*(n+1) dp[0]=dp[1]=0 for i in range(2,n+1): dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]) return dp[n] ä¼˜åŒ–ï¼šåˆ©ç”¨æ»šåŠ¨æ•°ç»„ æ³¨æ„åˆ°å½“ iâ‰¥2æ—¶ï¼Œdp[i] åªå’Œ dp[iâˆ’1] ä¸ dp[iâˆ’2] æœ‰å…³ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„çš„æ€æƒ³ï¼Œå°†ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–åˆ° O(1)ã€‚ç±»ä¼¼äºä¸ç»´æŠ¤ä¸€ä¸ªå®Œæ•´æ•°ç»„ï¼Œåªè®¡ç®—åˆ°æœ€åä¸€ä¸ªæ•°å­— 12345678class Solution: def minCostClimbingStairs(self, cost: List[int]) -&gt; int: n = len(cost) prev = curr = 0 for i in range(2, n + 1): nxt = min(curr + cost[i - 1], prev + cost[i - 2]) prev, curr = curr, nxt return curr"},{"title":"6. Zigzag Conversion(medium)","path":"2022/11/07/6/","text":"6. Zigzag Conversion(medium)The string â€œPAYPALISHIRINGâ€ is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)123P A H NA P L S I I GY I R And then read line by line: â€œPAHNAPLSIIGYIRâ€ Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); é¢˜è§£è¿™é“é¢˜æ²¡æœ‰ç”¨åˆ°ä»€ä¹ˆç‹¬ç‰¹çš„æ•°æ®ç»“æ„æˆ–è€…ç®—æ³•ï¼Œä½†æ˜¯è¿™é‡Œç”¨ä¸€ä¸ªflagè®°å½•æ˜¯å¦è¦åæ–¹å‘è®°å½• è§£é¢˜æ€è·¯ï¼šé¢˜ç›®ç†è§£ï¼šå­—ç¬¦ä¸² s æ˜¯ä»¥ Z å­—å½¢ä¸ºé¡ºåºå­˜å‚¨çš„å­—ç¬¦ä¸²ï¼Œç›®æ ‡æ˜¯æŒ‰è¡Œæ‰“å°ã€‚è®¾ numRows è¡Œå­—ç¬¦ä¸²åˆ†åˆ«ä¸º s1, s2s_2s2,â€¦, snï¼Œåˆ™å®¹æ˜“å‘ç°ï¼šæŒ‰é¡ºåºéå†å­—ç¬¦ä¸² s æ—¶ï¼Œæ¯ä¸ªå­—ç¬¦ c åœ¨ Z å­—å½¢ä¸­å¯¹åº”çš„è¡Œç´¢å¼•å…ˆä» s1å¢å¤§è‡³ snï¼Œå†ä» snå‡å°è‡³ s1â€¦â€¦ å¦‚æ­¤åå¤ã€‚å› æ­¤ï¼Œè§£å†³æ–¹æ¡ˆä¸ºï¼šæ¨¡æ‹Ÿè¿™ä¸ªè¡Œç´¢å¼•çš„å˜åŒ–ï¼Œåœ¨éå† s ä¸­æŠŠæ¯ä¸ªå­—ç¬¦å¡«åˆ°æ­£ç¡®çš„è¡Œ res[i] ã€‚ç®—æ³•æµç¨‹ï¼š æŒ‰é¡ºåºéå†å­—ç¬¦ä¸² sï¼›res[i] += cï¼š æŠŠæ¯ä¸ªå­—ç¬¦ c å¡«å…¥å¯¹åº”è¡Œ siï¼›i += flagï¼š æ›´æ–°å½“å‰å­—ç¬¦ c å¯¹åº”çš„è¡Œç´¢å¼•ï¼›flag = - flagï¼š åœ¨è¾¾åˆ° ZZZ å­—å½¢è½¬æŠ˜ç‚¹æ—¶ï¼Œæ‰§è¡Œåå‘ã€‚å¤æ‚åº¦åˆ†æï¼šæ—¶é—´å¤æ‚åº¦ O(N) ï¼šéå†ä¸€éå­—ç¬¦ä¸² sï¼›ç©ºé—´å¤æ‚åº¦ O(N) ï¼šå„è¡Œå­—ç¬¦ä¸²å…±å ç”¨ O(N)é¢å¤–ç©ºé—´ã€‚ 12345678910class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows &lt; 2: return s res = [&quot;&quot; for _ in range(numRows)] i, flag = 0, -1 for c in s: res[i] += c if i == 0 or i == numRows - 1: flag = -flag i += flag return &quot;&quot;.join(res) ç¡®å®æ˜¯éå¸¸å·§å¦™çš„æ–¹æ³•"},{"title":"1684. Count the Number of Consistent Strings(easy)","path":"2022/11/07/1684/","text":"1684. Count the Number of Consistent Strings(easy)You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.Return the number of consistent strings in the array words.123Input: allowed = &quot;ab&quot;, words = [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;]Output: 2Explanation: Strings &quot;aaab&quot; and &quot;baa&quot; are consistent since they only contain characters &#x27;a&#x27; and &#x27;b&#x27;. è¿™é“é¢˜åŸæœ¬æ˜¯æƒ³å¯¹wordsè¿›è¡Œsetæ“ä½œçš„ï¼Œåé¢å‘ç°å¯¹listé‡Œçš„æ¯ä¸€ä¸ªæ•°éƒ½æ“ä½œå¤ªéº»çƒ¦ï¼Œæ‰€ä»¥æ¢ä¸€ä¸ªæ€è·¯ï¼Œé€‰æ‹©ä»åæ–¹å‘å…¥æ‰‹ã€‚é¢˜ç›®æ˜¯è¦æˆ‘ä»¬æ‰¾wordsé‡Œçš„å­—æ¯åªå«æœ‰allowedé‡Œçš„å­—æ¯ï¼Œæ‰€ä»¥å°†allowedå»é‡åï¼Œå¦‚æœwordsçš„å•è¯é‡Œçš„å­—æ¯å¦‚æœä¸åœ¨allowedé‡Œï¼Œå°±è®°å½•ä¸‹æ¥cntæœ€åè¾“å‡ºçš„æ˜¯æœ‰ç›¸åŒå­—æ¯çš„ï¼Œé‚£ä¹ˆå°±ç”¨wordsçš„æ€»ä¸ªæ•°å‡å»cntå³å¯ 12345678910class Solution: def countConsistentStrings(self, allowed: str, words: List[str]) -&gt; int: allowed=set(allowed) cnt=0 for cha in words: for letter in cha: if letter not in allowed: cnt+=1 break return len(words)-cnt"},{"title":"1137. N-th Tribonacci Number(easy)","path":"2022/11/07/1137/","text":"1137. N-th Tribonacci Number(easy)The Tribonacci sequence Tn is defined as follows:T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn. ä¸‰ä¸ªæ•°è¿ç»­ç›¸åŠ çš„æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œè¿˜æ˜¯åŠ¨æ€è§„åˆ’çš„æ€è·¯ 123456789101112class Solution: def tribonacci(self, n: int) -&gt; int: if n&lt;2: return n elif n==2: return 1 dp=[0]*(n+1) dp[1]=1 dp[2]=1 for i in range(3,n+1): dp[i]=dp[i-1]+dp[i-2]+dp[i-3] return dp[n]"},{"title":"509. Fibonacci Number(easy)","path":"2022/11/07/509/","text":"509. Fibonacci Number(easy)The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,12F(0) = 0, F(1) = 1F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n). æ–æ³¢é‚£å¥‘æ•°åˆ—F(0)=0,F(1)=1 123456789class Solution: def fib(self, n: int) -&gt; int: if n&lt;1: return n dp=[0]*(n+1) dp[1]=1 for i in range(2,n+1): dp[i]=dp[i-1]+dp[i-2] return dp[n]"},{"title":"1323. Maximum 69 Number(easy)","path":"2022/11/06/1323/","text":"1323. Maximum 69 Number(easy)You are given a positive integer num consisting only of digits 6 and 9.Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).å°†numè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åå†è½¬æ¢æˆliståˆ¤æ–­listæœ‰æ²¡æœ‰6ï¼Œå¦‚æœæ²¡æœ‰ç›´æ¥è¾“å‡ºnumindex(x)è¿”å›æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªxæœ€åjoinæŠŠå­—ç¬¦ä¸²è¿åœ¨ä¸€èµ· class Solution: def maximum69Number (self, num: int) -&gt; int: s=list(str(num)) if &#39;6&#39; not in s: return num s[s.index(&#39;6&#39;)]=&#39;9&#39; return &#39;&#39;.join(s)"},{"title":"408. Valid Word Abbreviation(easy)","path":"2022/11/06/408/","text":"408. Valid Word Abbreviation(easy)A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.For example, a string such as â€œsubstitutionâ€ could be abbreviated as (but not limited to): â€œs10nâ€ (â€œs ubstitutio nâ€)â€œsub4u4â€ (â€œsub stit u tionâ€)â€œ12â€ (â€œsubstitutionâ€)â€œsu3i1u2onâ€ (â€œsu bst i t u ti onâ€)â€œsubstitutionâ€ (no substrings replaced)The following are not valid abbreviations: â€œs55nâ€ (â€œs ubsti tutio nâ€, the replaced substrings are adjacent)â€œs010nâ€ (has leading zeros)â€œs0ubstitutionâ€ (replaces an empty substring)Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation. A substring is a contiguous non-empty sequence of characters within a string. è¿™é“é¢˜å°±æ˜¯ç›´æ¥æ¨¡æ‹Ÿè®¡ç®—é¢˜è§£ 12345678910111213141516171819class Solution: def validWordAbbreviation(self, word, abbr): i = j = 0 m, n = len(word), len(abbr) while i &lt; m and j &lt; n: if word[i] == abbr[j]: i += 1 j += 1 elif abbr[j] == &quot;0&quot;: return False elif abbr[j].isnumeric(): k = j while k &lt; n and abbr[k].isnumeric(): k += 1 i += int(abbr[j:k]) j = k else: return False return i == m and j == n"},{"title":"459. Repeated Substring Pattern(easy)","path":"2022/11/06/459/","text":"459. Repeated Substring Pattern(easy)Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.é¢˜è§£è¿™é“é¢˜çš„é¢˜è§£éå¸¸æœ‰æŠ€å·§ï¼š First char of input string is first char of repeated substring Last char of input string is last char of repeated substring Let S1 = S + S (where S in input string) Remove 1 and last char of S1. Let this be S2 If S exists in S2 then return true else false Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1] è¿™é‡Œæœ€åŸºç¡€çš„ä¸€ç‚¹æ˜¯ï¼Œæ–°å­—ç¬¦ä¸²s2=s+sï¼Œsæ˜¯ä¸€å¼€å§‹çš„å­—ç¬¦ä¸²ã€‚å¦‚æœsæ˜¯é‡å¤çš„ï¼Œé‚£ä¹ˆs2ä»ç¬¬äºŒä¸ªå­—ç¬¦åˆ°å€’æ•°ç¬¬äºŒä¸ªå­—ç¬¦é‡Œä¸€å®šåŒ…å«äº†s class Solution: def repeatedSubstringPattern(self, s: str) -&gt; bool: if not s: return False s2=(s+s)[1:-1] return s2.find(s)!=-1"},{"title":"422. Valid Word Square(easy)","path":"2022/11/06/422/","text":"422. Valid Word Square(easy)Given an array of strings words, return true if it forms a valid word square.A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).12345678Input: words = [&quot;abcd&quot;,&quot;bnrt&quot;,&quot;crmy&quot;,&quot;dtye&quot;]Output: trueExplanation:The 1st row and 1st column both read &quot;abcd&quot;.The 2nd row and 2nd column both read &quot;bnrt&quot;.The 3rd row and 3rd column both read &quot;crmy&quot;.The 4th row and 4th column both read &quot;dtye&quot;.Therefore, it is a valid word square. æ‰¾çŸ©é˜µæ˜¯å¦å¯¹ç§° 12345678910class Solution: def validWordSquare(self, words: List[str]) -&gt; bool: if words==None or len(words)==0: return True row=len(words) for i in range(row): for j in range(len(words[i])): if j&gt;=len(words) or i &gt;=len(words[j]) or words[i][j]!=words[j][i]: return False return True"},{"title":"463. Island Perimeter(easy)","path":"2022/11/06/463/","text":"463. Island Perimeter(easy)You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).The island doesnâ€™t have â€œlakesâ€, meaning the water inside isnâ€™t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height donâ€™t exceed 100. Determine the perimeter of the island.ç›´æ¥æ¨¡æ‹Ÿï¼Œçœ‹å½“å‰ä¸º1çš„æ ¼å­å››è¾¹æœ‰æ²¡æœ‰å…¶ä»–ä¸º1çš„æ ¼å­ 123456789101112131415161718class Solution: def islandPerimeter(self, grid: List[List[int]]) -&gt; int: row=len(grid) col=len(grid[0]) ans=0 for i in range(row): for j in range(col): if grid[i][j]==1: ans+=4 if i+1&lt;row and grid[i+1][j]==1: ans-=1 if i-1&gt;=0 and grid[i-1][j]==1: ans-=1 if j+1&lt;col and grid[i][j+1]==1: ans-=1 if j-1&gt;=0 and grid[i][j-1]==1: ans-=1 return ans"},{"title":"461. Hamming Distance(easy)","path":"2022/11/06/461/","text":"461. Hamming Distance(easy)The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, return the Hamming distance between them.è¿™ä¸ªç”¨è¿ä½ç®—çš„æ–¹æ³•å¾ˆå·§å¦™è®¾x=1(0001),y=4(0100)xorå°±æ˜¯5(0101)xor%2æ˜¯1xor&gt;&gt;=1 å‘å³ç§»äº†ä¸€ä½ï¼Œæ­¤æ—¶æ˜¯xor=(0010)xor%2=0xor&gt;&gt;=1 å‘å³ç§»ä¸€ä½ï¼Œæ­¤æ—¶æ˜¯xor=(0001)xor%2=1xor&gt;&gt;=1 å‘å³ç§»ä¸€ä½ï¼Œæ­¤æ—¶æ˜¯xor=(0000)è¿™æ—¶è¿”å›å°±æ˜¯2 12345678class Solution: def hammingDistance(self, x: int, y: int) -&gt; int: xor=x^y res=0 while xor!=0: res+=xor%2 xor&gt;&gt;=1 return res"},{"title":"405. Convert a Number to Hexadecimal(easy)","path":"2022/11/06/405/","text":"405. Convert a Number to Hexadecimal(easy)Given an integer num, return a string representing its hexadecimal representation. For negative integers, twoâ€™s complement method is used.All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.Note: You are not allowed to use any built-in library method to directly solve this problem.åˆ†å¤§äº0å°äº0ä¸¤ç§æƒ…å†µï¼Œå¤§äº0åˆ™å¯¹16æ±‚ä½™ï¼Œå†é™¤ã€‚å°äº0åˆ™åŸºäº0xffffffffè¿›è¡Œè®¡ç®— 12345678910111213class Solution: def toHex(self, num: int) -&gt; str: if num==0: return &quot;0&quot; if num&lt;0: num=0xffffffff+1+num hex_digits=&quot;0123456789abcdef&quot; ans=&quot;&quot; while num: ans+=hex_digits[num%16] num//=16 return ans[::-1]"},{"title":"394. Decode String(medium)","path":"2022/11/06/394/","text":"394. Decode String(medium)Given an encoded string, return its decoded string.The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].The test cases are generated so that the length of the output will never exceed 10^5.12Input: s = &quot;3[a]2[bc]&quot;Output: &quot;aaabcbc&quot; é¢å¯¹æ‹¬å·çš„é¢˜ï¼Œæˆ‘ä»¬ç¬¬ä¸€ååº”å°±æ˜¯æ ˆï¼Œåˆ©ç”¨åˆ¤æ–­é€‰æ‹©ä»€ä¹ˆæ—¶å€™å¼¹å‡ºæ‹¬å· é¢˜è§£ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def decodeString(self, s: str) -&gt; str: &quot;&quot;&quot; When we hit an open bracket, we know we have parsed curNum for the contents of the bracket, so push (current_string, curNum) to the stack, so we can pop them on closing bracket to duplicate the enclosed string curNum times. &quot;&quot;&quot; stack=[] curNum=0 curString=&#x27;&#x27; for c in s: if c==&#x27;[&#x27;: # Just finished parsing this curNum, save current string and curNum for when we pop stack.append(curString) stack.append(curNum) # Reset current_string and curNum for this new frame curString=&#x27;&#x27; curNum=0 elif c==&#x27;]&#x27;: # We have completed this frame, get the last current_string and curNum from when the frame # opened, which is the curNum we need to duplicate the current current_string by num=stack.pop() prevString=stack.pop() curString=prevString+curString*num elif c.isdigit(): curNum=curNum*10+int(c) &quot;&quot;&quot; At the start, the curNum=0 and the string we want to process is &#x27;101[leetcode]&#x27; We start at c = &#x27;1&#x27; with curNum=0, curNum = curNum*10 + int(c) = 0 * 10 + 1 = 0 + 1 = 1. The next step when the c = &#x27;0&#x27; and curNum=1, curNum = curNum*10 + int(c) = 1 * 10 + 0 = 10 + 0 = 10. And finally, when we get to the second 1 at c=&#x27;1&#x27; and curNum=10, curNum = curNum*10 + int(c) = 10 * 10 + 1 = 100 + 1 = 101 So curNum ends at 101 by the time we start evaluating the &#x27;[&#x27;`. &quot;&quot;&quot; else: curString+=c return curString 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public String decodeString(String s) &#123; Deque&lt;Integer&gt; numStack = new ArrayDeque&lt;&gt;(); Deque&lt;String&gt; strStack = new ArrayDeque&lt;&gt;(); char[] chs = s.toCharArray(); int n = chs.length; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; n; i++)&#123; if(chs[i] - &#x27;0&#x27; &gt;= 0 &amp;&amp; chs[i] - &#x27;0&#x27; &lt;= 9) &#123; // é‡åˆ°æ•°å­— int num = 0; while(chs[i] - &#x27;0&#x27; &gt;= 0 &amp;&amp; chs[i] - &#x27;0&#x27; &lt;= 9)&#123; // æˆªå–æ•°å­— num = num * 10 + chs[i] - &#x27;0&#x27;; i++; &#125; numStack.push(num); &#125; if(chs[i] == &#x27;[&#x27;) strStack.push(String.valueOf(chs[i])); // é‡åˆ° &#x27;[&#x27; æ¨å…¥å­—ç¬¦ä¸²æ ˆ else if(chs[i] == &#x27;]&#x27;)&#123; // é‡åˆ° &#x27;]&#x27; StringBuilder curSb = new StringBuilder(); while(!strStack.peek().equals(String.valueOf(&#x27;[&#x27;)))&#123; // æ‹¼æ¥ &#x27;[&#x27; ä¹‹å‰çš„å­—ç¬¦ä¸² curSb.insert(0, strStack.pop()); &#125; strStack.pop(); // æ¨å‡º &#x27;[&#x27; int k = numStack.pop(); // æ¨å‡ºæ•°å­— String repeatedStr = repeate(curSb.toString(), k); // é‡å¤ k æ¬¡ strStack.push(repeatedStr); // ç„¶åæ¨å…¥å­—ç¬¦ä¸²æ ˆ &#125; else strStack.push(String.valueOf(chs[i])); &#125; StringBuilder res = new StringBuilder(); while(!strStack.isEmpty())&#123; res.insert(0, strStack.pop()); &#125; return res.toString(); &#125; private String repeate(String s, int k)&#123; // å€å¢æ‹¼æ¥ (å¿«é€Ÿå¹‚æ€æƒ³) StringBuilder res = new StringBuilder(); StringBuilder sb = new StringBuilder(s); while(k &gt; 0)&#123; if(k % 2 == 1) res = res.append(sb); sb = sb.append(sb); k /= 2; &#125; return res.toString(); &#125;&#125;"},{"title":"434. Number of Segments in a String(easy)","path":"2022/11/05/434/","text":"Given a string s, return the number of segments in the string.A segment is defined to be a contiguous sequence of non-space characters.ç›´æ¥ç”¨splitåˆ†å‰²å­—ç¬¦ä¸² 123class Solution: def countSegments(self, s: str) -&gt; int: return len(s.split())"},{"title":"441. Arranging Coins(easy)","path":"2022/11/05/441/","text":"441. Arranging Coins(easy)You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.Given the integer n, return the number of complete rows of the staircase you will build.è¿™é“é¢˜å°±æ˜¯ä¸ªç­‰å·®æ•°åˆ—ï¼Œä»1åŠ åˆ°iå±‚ï¼Œç„¶åå’Œnæ¯”è¾ƒå¤§å°ï¼Œæ‰€ä»¥æ•°å­¦æ–¹æ³•è§£å‡ºå³å¯ 1234class Solution: def arrangeCoins(self, n: int) -&gt; int: return int(sqrt(2 * n + 0.25) - 0.50)"},{"title":"448. Find All Numbers Disappeared in an Array(easy)","path":"2022/11/05/448/","text":"448. Find All Numbers Disappeared in an Array(easy)Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.è¿™é¢˜æ˜¯æ‰¾åˆ°ç¼ºå¤±çš„æ•°å­—æš´åŠ›è§£æ³• 12345678910111213141516class Solution: def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: n=len(nums) res=[] nums=sorted(set(nums)) if len(nums)&lt;n: nums.append(0) for i in range(1,n+1): if i &gt;len(nums): res.append(i) nums.append(i) if i!= nums[i-1]: res.append(i) nums.insert(i-1,i) return res python enumerateè§£æ³• 12345678910class Solution: def findDisappearedNumbers(self, nums): res = [] for x in nums: if nums[abs(x)-1] &gt; 0: nums[abs(x)-1]*=-1 for i, x in enumerate(nums): if x&gt; 0: res.append(i+1) return res"},{"title":"415. Add Strings(easy)","path":"2022/11/05/415/","text":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•°å­—ç›¸åŠ åå†è½¬å›å­—ç¬¦ä¸² 123class Solution: def addStrings(self, num1: str, num2: str) -&gt; str: return str(int(num1)+int(num2))"},{"title":"414. Third Maximum Number(easy)","path":"2022/11/05/414/","text":"414. Third Maximum Number(easy)Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.è¿™é‡Œå°±æ˜¯å¯¹æ•°ç»„æ’åºï¼Œç„¶åå–ç¬¬ä¸‰å¤§çš„æ•° 12345678class Solution: def thirdMax(self, nums: List[int]) -&gt; int: nums=sorted(set(nums),reverse= True) if len(nums)&gt;2: return nums[2] else: return nums[0]"},{"title":"409. Longest Palindrome(easy)","path":"2022/11/05/409/","text":"409. Longest Palindrome(easy)Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.Letters are case sensitive, for example, â€œAaâ€ is not considered a palindrome here.è¿™é“é¢˜å°±æ˜¯åˆ©ç”¨hashmapè®¡æ•°ï¼Œç„¶åå¶æ•°ç›´æ¥åŠ åˆ°ç»“æœï¼Œå¥‡æ•°åˆ†æƒ…å†µè®¨è®ºï¼Œåªæœ‰ä¸€ä¸ªçš„æƒ…å†µé‚£å°±æ”¾åˆ°æœ€ååŠ åœ¨ç»“æœé‡Œï¼Œå¦‚æœå¤§äº1çš„å¥‡æ•°ï¼Œå°±åœ¨ç»“æœåŠ ä¸Šæ•°é‡å‡1 12345678910111213141516class Solution: def longestPalindrome(self, s: str) -&gt; int: result=Counter(s) cnt=0 sums=0 for cha in result: if result[cha]%2==0: sums+=result[cha] elif result[cha]%2!=0 and result[cha]&gt;2: sums+=result[cha]-1 cnt+=1 else: cnt+=1 if cnt!=0: sums+=1 return sums"},{"title":"412. Fizz Buzz(easy)","path":"2022/11/05/412/","text":"412. Fizz BuzzGiven an integer n, return a string array answer (1-indexed) where:answer[i] == â€œFizzBuzzâ€ if i is divisible by 3 and 5.answer[i] == â€œFizzâ€ if i is divisible by 3.answer[i] == â€œBuzzâ€ if i is divisible by 5.answer[i] == i (as a string) if none of the above conditions are true. è¿™é“é¢˜æ˜¯hackerrankä¸€å¼€å§‹é‡åˆ°çš„é¢˜ 12345678910111213class Solution: def fizzBuzz(self, n: int) -&gt; List[str]: result=[] for i in range(1,n+1): if i%3 ==0 and i%5==0: result.append(&quot;FizzBuzz&quot;) elif i%3==0: result.append(&quot;Fizz&quot;) elif i%5==0: result.append(&quot;Buzz&quot;) else: result.append(str(i)) return result"},{"title":"1636. Sort Array by Increasing Frequency(easy)","path":"2022/10/31/1636/","text":"1636. Sort Array by Increasing Frequency(easy)Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.Return the sorted array.å¯¹hashmapçš„valueè¿›è¡Œå‡åºæ’åºï¼Œç®€å•ä½†æœ‰ç”¨å½“frequencyç›¸åŒæ—¶ï¼Œæ•°å€¼æŒ‰é™åºæ’åˆ— 123456class Solution: def frequencySort(self, nums: List[int]) -&gt; List[int]: cnt=Counter(nums) nums.sort(key=lambda x:(cnt[x],-x) ) return nums ä¾‹ï¼šè¾“å…¥nums = [2,3,1,3,2]å¾—åˆ° cnt : Counter({2: 2, 3: 2, 1: 1}) æ— å‚çš„ sort() ä¼šä¾æ¬¡å¯¹numsçš„å€¼å‡åºæ’åºè€Œ sort(key) ä¼šå…ˆæŠŠnumsçš„å€¼ä¼ ç»™è¡¨è¾¾å¼key,æŒ‰ç…§keyè¿”å›çš„å€¼å¤§å°å†ç»™å¯¹åº”çš„numsæ’åºç¬¬1æ¬¡ä¼ 2ï¼Œ(cnt[2], -2)) å¾—åˆ° (2,-2)ç¬¬2æ¬¡ä¼ 3ï¼Œ(cnt[3], -3)) å¾—åˆ° (2,-3)ç¬¬3æ¬¡ä¼ 1ï¼Œ(cnt[1], -1)) å¾—åˆ° (1,-1)ç¬¬4æ¬¡ä¼ 3ï¼Œ(cnt[3], -3)) å¾—åˆ° (2,-3)ç¬¬5æ¬¡ä¼ 2ï¼Œ(cnt[2], -2)) å¾—åˆ° (2,-2)æ’åºé¡ºåºä¸º(1,-1),(2,-3),(2,-3),(2,-2),(2,-2)å¯¹åº”çš„numsçš„å€¼ä¸º1,3,3,2,2 sortæ˜¯é’ˆå¯¹äºåˆ—è¡¨çš„æ’åˆ—æ–¹æ³•ã€‚é»˜è®¤å‡åºæ’åºã€‚key â€“ ä¸»è¦æ˜¯ç”¨æ¥è¿›è¡Œæ¯”è¾ƒçš„å…ƒç´ ï¼Œåªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œå…·ä½“çš„å‡½æ•°çš„å‚æ•°å°±æ˜¯å–è‡ªäºå¯è¿­ä»£å¯¹è±¡ä¸­ï¼ŒæŒ‡å®šå¯è¿­ä»£å¯¹è±¡ä¸­çš„ä¸€ä¸ªå…ƒç´ æ¥è¿›è¡Œæ’åºã€‚æ­¤å¤„ä¼ å…¥çš„æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œå…ˆä»¥ç¬¬ä¸€ä¸ªå­—æ®µè¿›è¡Œæ’åˆ—ã€‚ç¬¬ä¸€ä¸ªå­—æ®µä¸€æ ·ï¼Œå†ä»¥ç¬¬äºŒä¸ªå­—æ®µè¿›è¡Œæ’åºã€‚"},{"title":"8. String to Integer (atoi)(medium)","path":"2022/10/19/8/","text":"8. String to Integer (atoi)(medium)Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++â€™s atoi function).The algorithm for myAtoi(string s) is as follows:Read in and ignore any leading whitespace.Check if the next character (if not already at the end of the string) is â€˜-â€˜ or â€˜+â€™. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.Convert these digits into an integer (i.e. â€œ123â€ -&gt; 123, â€œ0032â€ -&gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.Return the integer as the final result. è¯·ä½ æ¥å®ç°ä¸€ä¸ª myAtoi(string s) å‡½æ•°ï¼Œä½¿å…¶èƒ½å°†å­—ç¬¦ä¸²è½¬æ¢æˆä¸€ä¸ª 32 ä½æœ‰ç¬¦å·æ•´æ•°ï¼ˆç±»ä¼¼ C/C++ ä¸­çš„ atoi å‡½æ•°ï¼‰ã€‚ 1234567891011è¾“å…¥ï¼šs = &quot;42&quot;è¾“å‡ºï¼š42è§£é‡Šï¼šåŠ ç²—çš„å­—ç¬¦ä¸²ä¸ºå·²ç»è¯»å…¥çš„å­—ç¬¦ï¼Œæ’å…¥ç¬¦å·æ˜¯å½“å‰è¯»å–çš„å­—ç¬¦ã€‚ç¬¬ 1 æ­¥ï¼š&quot;42&quot;ï¼ˆå½“å‰æ²¡æœ‰è¯»å…¥å­—ç¬¦ï¼Œå› ä¸ºæ²¡æœ‰å‰å¯¼ç©ºæ ¼ï¼‰ ^ç¬¬ 2 æ­¥ï¼š&quot;42&quot;ï¼ˆå½“å‰æ²¡æœ‰è¯»å…¥å­—ç¬¦ï¼Œå› ä¸ºè¿™é‡Œä¸å­˜åœ¨ &#x27;-&#x27; æˆ–è€… &#x27;+&#x27;ï¼‰ ^ç¬¬ 3 æ­¥ï¼š&quot;42&quot;ï¼ˆè¯»å…¥ &quot;42&quot;ï¼‰ ^è§£æå¾—åˆ°æ•´æ•° 42 ã€‚ç”±äº &quot;42&quot; åœ¨èŒƒå›´ [-231, 231 - 1] å†…ï¼Œæœ€ç»ˆç»“æœä¸º 42 ã€‚ æ–¹æ³•ä¸€ï¼šæ­£åˆ™è¡¨è¾¾å¼123class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall(&#x27;^[\\+\\-]?\\d+&#x27;, s.lstrip())), 2**31 - 1), -2**31) 1234567891011æ­£åˆ™è¡¨è¾¾reæ¨¡å—re.findallè¿”å›stringä¸­æ‰€æœ‰ä¸patternåŒ¹é…çš„å…¨éƒ¨å­—ç¬¦ä¸²,è¿”å›å½¢å¼ä¸ºæ•°ç»„ã€‚^ï¼šåŒ¹é…å­—ç¬¦ä¸²å¼€å¤´[\\+\\-]ï¼šä»£è¡¨ä¸€ä¸ª+å­—ç¬¦æˆ–-å­—ç¬¦?ï¼šå‰é¢ä¸€ä¸ªå­—ç¬¦å¯æœ‰å¯æ— \\dï¼šä¸€ä¸ªæ•°å­—+ï¼šå‰é¢ä¸€ä¸ªå­—ç¬¦çš„ä¸€ä¸ªæˆ–å¤šä¸ª\\Dï¼šä¸€ä¸ªéæ•°å­—å­—ç¬¦*ï¼šå‰é¢ä¸€ä¸ªå­—ç¬¦çš„0ä¸ªæˆ–å¤šä¸ªPython lstrip() æ–¹æ³•ç”¨äºæˆªæ‰å­—ç¬¦ä¸²å·¦è¾¹çš„ç©ºæ ¼æˆ–æŒ‡å®šå­—ç¬¦ è¯¦ç»†ç‰ˆ 12345678910import reclass Solution: def myAtoi(self, str: str) -&gt; int: INT_MAX = 2147483647 INT_MIN = -2147483648 str = str.lstrip() #æ¸…é™¤å·¦è¾¹å¤šä½™çš„ç©ºæ ¼ num_re = re.compile(r&#x27;^[\\+\\-]?\\d+&#x27;) #è®¾ç½®æ­£åˆ™è§„åˆ™ num = num_re.findall(str) #æŸ¥æ‰¾åŒ¹é…çš„å†…å®¹ num = int(*num) #ç”±äºè¿”å›çš„æ˜¯ä¸ªåˆ—è¡¨ï¼Œè§£åŒ…å¹¶ä¸”è½¬æ¢æˆæ•´æ•° return max(min(num,INT_MAX),INT_MIN) #è¿”å›å€¼ æ–¹æ³•äºŒï¼šæœ‰é™çŠ¶æ€æœºå‡†ç¡®åœ°è¯´ï¼Œè¿™æ˜¯ç¡®å®šæœ‰é™çŠ¶æ€æœºï¼ˆdeterministic finite automaton, DFAï¼‰ã€‚ æˆ‘ä»¬çš„ç¨‹åºåœ¨æ¯ä¸ªæ—¶åˆ»æœ‰ä¸€ä¸ªçŠ¶æ€ sï¼Œæ¯æ¬¡ä»åºåˆ—ä¸­è¾“å…¥ä¸€ä¸ªå­—ç¬¦ cï¼Œå¹¶æ ¹æ®å­—ç¬¦ c è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ sâ€™ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦å»ºç«‹ä¸€ä¸ªè¦†ç›–æ‰€æœ‰æƒ…å†µçš„ä» s ä¸ c æ˜ å°„åˆ° sâ€™ çš„è¡¨æ ¼å³å¯è§£å†³é¢˜ç›®ä¸­çš„é—®é¢˜ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738INT_MAX = 2 ** 31 - 1INT_MIN = -2 ** 31class Automaton: def __init__(self): self.state = &#x27;start&#x27; self.sign = 1 self.ans = 0 self.table = &#123; &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;in_number&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;], &#125; def get_col(self, c): if c.isspace(): return 0 if c == &#x27;+&#x27; or c == &#x27;-&#x27;: return 1 if c.isdigit(): return 2 return 3 def get(self, c): self.state = self.table[self.state][self.get_col(c)] if self.state == &#x27;in_number&#x27;: self.ans = self.ans * 10 + int(c) self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN) elif self.state == &#x27;signed&#x27;: self.sign = 1 if c == &#x27;+&#x27; else -1class Solution: def myAtoi(self, str: str) -&gt; int: automaton = Automaton() for c in str: automaton.get(c) return automaton.sign * automaton.ans"},{"title":"LeetCode16-deterministic-finite-automaton","path":"2022/10/19/LeetCode16-deterministic-finite-automaton/","text":"ç¡®å®šæœ‰é™çŠ¶æ€æœºï¼ˆdeterministic finite automaton, DFAï¼‰ã€‚ æˆ‘ä»¬çš„ç¨‹åºåœ¨æ¯ä¸ªæ—¶åˆ»æœ‰ä¸€ä¸ªçŠ¶æ€ sï¼Œæ¯æ¬¡ä»åºåˆ—ä¸­è¾“å…¥ä¸€ä¸ªå­—ç¬¦ cï¼Œå¹¶æ ¹æ®å­—ç¬¦ c è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ sâ€™ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦å»ºç«‹ä¸€ä¸ªè¦†ç›–æ‰€æœ‰æƒ…å†µçš„ä» s ä¸ c æ˜ å°„åˆ° sâ€™ çš„è¡¨æ ¼å³å¯è§£å†³é¢˜ç›®ä¸­çš„é—®é¢˜ã€‚ String to Integer (atoi)(medium) 1234567891011121314151617181920212223242526272829303132333435363738INT_MAX = 2 ** 31 - 1INT_MIN = -2 ** 31class Automaton: def __init__(self): self.state = &#x27;start&#x27; self.sign = 1 self.ans = 0 self.table = &#123; &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;in_number&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;], &#125; def get_col(self, c): if c.isspace(): return 0 if c == &#x27;+&#x27; or c == &#x27;-&#x27;: return 1 if c.isdigit(): return 2 return 3 def get(self, c): self.state = self.table[self.state][self.get_col(c)] if self.state == &#x27;in_number&#x27;: self.ans = self.ans * 10 + int(c) self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN) elif self.state == &#x27;signed&#x27;: self.sign = 1 if c == &#x27;+&#x27; else -1class Solution: def myAtoi(self, str: str) -&gt; int: automaton = Automaton() for c in str: automaton.get(c) return automaton.sign * automaton.ans æœ‰æ•ˆæ•°å­— UTF-8 Validation"},{"title":"692. Top K Frequent Words","path":"2022/10/18/692/","text":"Given an array of strings words and an integer k, return the k most frequent strings.Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.Top Ké—®é¢˜ 1234Input: words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2Output: [&quot;i&quot;,&quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order. Leetcodeé¢˜è§£ 12345678910111213141516171819202122232425262728class Solution: def topKFrequent(self, words: List[str], k: int) -&gt; List[str]: counter = Counter(words) occur = list(counter.items()) for i in range(k // 2 - 1, -1, -1): self.heapify(occur, i, k) for i in range(k, len(occur)): if occur[i][1] &gt; occur[0][1] or occur[i][1] == occur[0][1] and occur[i][0] &lt; occur[0][0]: occur[i], occur[0] = occur[0], occur[i] self.heapify(occur, 0, k) ans = deque() for i in range(k): ans.appendleft(occur[0][0]) occur[0] = occur[k - 1 - i] self.heapify(occur, 0, k - 1 - i) return list(ans) def heapify(self, heap: List[Tuple], root: int, length: int): smallest = root left = 2 * root + 1 right = left + 1 if left &lt; length and (heap[left][1] &lt; heap[smallest][1] or heap[left][1] == heap[smallest][1] and heap[left][0] &gt; heap[smallest][0]): smallest = left if right &lt; length and (heap[right][1] &lt; heap[smallest][1] or heap[right][1] == heap[smallest][1] and heap[right][0] &gt; heap[smallest][0]): smallest = right if smallest != root: heap[smallest], heap[root] = heap[root], heap[smallest] self.heapify(heap, smallest, length)"},{"title":"38. Count and Say(medium)","path":"2022/10/18/38/","text":"38. Count and Say(medium)The count-and-say sequence is a sequence of digit strings defined by the recursive formula:countAndSay(1) = â€œ1â€ countAndSay(n) is the way you would â€œsayâ€ the digit string from countAndSay(n-1), which is then converted into a different digit string.To determine how you â€œsayâ€ a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.For example, the saying and conversion for digit string â€œ3322251â€:Given a positive integer n, return the nth term of the count-and-say sequence.è¯´å®è¯è¿™é“é¢˜ç»™çš„ä¾‹å­è®©äººéå¸¸ç–‘æƒ‘ï¼Œä½†å…¶å®å°±æ˜¯ä¸€ä¸ªç±»ä¼¼äºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„é€’å½’æ•°åˆ—,å›½åŒºé¢˜åº“çš„é¢˜ç›®æè¿°æ›´è¯¦ç»†ä¹Ÿæ›´å‡†ç¡® 123456789101. 12. 113. 214. 12115. 111221ç¬¬ä¸€é¡¹æ˜¯æ•°å­— 1 æè¿°å‰ä¸€é¡¹ï¼Œè¿™ä¸ªæ•°æ˜¯ 1 å³ â€œ ä¸€ ä¸ª 1 â€ï¼Œè®°ä½œ &quot;11&quot;æè¿°å‰ä¸€é¡¹ï¼Œè¿™ä¸ªæ•°æ˜¯ 11 å³ â€œ äºŒ ä¸ª 1 â€ ï¼Œè®°ä½œ &quot;21&quot;æè¿°å‰ä¸€é¡¹ï¼Œè¿™ä¸ªæ•°æ˜¯ 21 å³ â€œ ä¸€ ä¸ª 2 + ä¸€ ä¸ª 1 â€ ï¼Œè®°ä½œ &quot;1211&quot;æè¿°å‰ä¸€é¡¹ï¼Œè¿™ä¸ªæ•°æ˜¯ 1211 å³ â€œ ä¸€ ä¸ª 1 + ä¸€ ä¸ª 2 + äºŒ ä¸ª 1 â€ ï¼Œè®°ä½œ &quot;111221&quot; å®˜æ–¹é¢˜è§£123456789101112131415161718192021class Solution: def countAndSay(self, n: int) -&gt; str: if n==1:return &quot;1&quot; if n==2: return &quot;11&quot; res=[1,1] for i in range(3,n+1): new_res=[] num=1 cur=res[0] for s in res[1:]: if s ==cur: num+=1 else: new_res.append(num) new_res.append(cur) num=1 cur=s new_res.append(num) new_res.append(cur) res=new_res return &#x27;&#x27;.join(list(map(str,res))) mapå‡½æ•°1map(function, iterable, ...) def square(x) : # è®¡ç®—å¹³æ–¹æ•°â€¦ return x ** 2â€¦map(square, [1,2,3,4,5]) # è®¡ç®—åˆ—è¡¨å„ä¸ªå…ƒç´ çš„å¹³æ–¹ list(map(square, [1,2,3,4,5])) # ä½¿ç”¨ list() è½¬æ¢ä¸ºåˆ—è¡¨[1, 4, 9, 16, 25]list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # ä½¿ç”¨ lambda åŒ¿åå‡½æ•°[1, 4, 9, 16, 25] ``` æ¯”å¦‚n=6,res=[3,1,2,2,1,1],é€šè¿‡mapå‡½æ•°list(map(str,res))ä»¥åæ˜¯[â€˜3â€™, â€˜1â€™, â€˜2â€™, â€˜2â€™, â€˜1â€™, â€˜1â€™]ã€‚å†é€šè¿‡â€™â€™.join()å‡½æ•°å°†listé‡Œçš„å­—ç¬¦è¿åœ¨ä¸€èµ·å°±è¿™é“é¢˜è€Œè¨€ï¼Œè½¬ä¸è½¬æ¢æˆlistéƒ½ä¸å½±å“ç»“æœï¼Œâ€™â€™.join(map(str,res))ä¹Ÿæ˜¯å¯ä»¥çš„"},{"title":"4. Median of Two Sorted Arrays(hard)","path":"2022/10/17/4/","text":"4. Median of Two Sorted Arrays(hard)Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).leetcodeé¢˜è§£è¿™é“é¢˜å¦‚æœæ—¶é—´å¤æ‚åº¦æ²¡æœ‰é™å®šåœ¨ O(log(m+n))ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ O(m+n) çš„ç®—æ³•è§£å†³ï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªæ•°ç»„ï¼Œæ¯”è¾ƒæŒ‡é’ˆä¸‹çš„å…ƒç´ å¤§å°ï¼Œä¸€å…±ç§»åŠ¨æ¬¡æ•°ä¸º (m+n + 1)/2ï¼Œä¾¿æ˜¯ä¸­ä½æ•°ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬ç†è§£ä»€ä¹ˆä¸­ä½æ•°ï¼šæŒ‡çš„æ˜¯è¯¥æ•°å·¦å³ä¸ªæ•°ç›¸ç­‰ã€‚ æ¯”å¦‚ï¼šodd : [1,| 2 |,3]ï¼Œ2 å°±æ˜¯è¿™ä¸ªæ•°ç»„çš„ä¸­ä½æ•°ï¼Œå·¦å³ä¸¤è¾¹éƒ½åªè¦ 1 ä½ï¼› even: [1,| 2, 3 |,4]ï¼Œ2,3 å°±æ˜¯è¿™ä¸ªæ•°ç»„çš„ä¸­ä½æ•°ï¼Œå·¦å³ä¸¤è¾¹ 1 ä½ï¼› é‚£ä¹ˆï¼Œç°åœ¨æˆ‘ä»¬æœ‰ä¸¤ä¸ªæ•°ç»„ï¼š num1: [a1,a2,a3,â€¦an] nums2: [b1,b2,b3,â€¦bn] [nums1[:left1],nums2[:left2] | nums1[left1:], nums2[left2:]] åªè¦ä¿è¯å·¦å³ä¸¤è¾¹ ä¸ªæ•° ç›¸åŒï¼Œä¸­ä½æ•°å°±åœ¨ | è¿™ä¸ªè¾¹ç•Œæ—è¾¹äº§ç”Ÿã€‚ å¦‚ä½•æ‰¾è¾¹ç•Œå€¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨äºŒåˆ†æ³•ï¼Œæˆ‘ä»¬å…ˆç¡®å®š num1 å– m1 ä¸ªæ•°çš„å·¦åŠè¾¹ï¼Œé‚£ä¹ˆ num2 å– m2 = (m+n+1)/2 - m1 çš„å·¦åŠè¾¹ï¼Œæ‰¾åˆ°åˆé€‚çš„ m1ï¼Œå°±ç”¨äºŒåˆ†æ³•æ‰¾ã€‚ å½“ [ [a1],[b1,b2,b3] | [a2,..an],[b4,â€¦bn] ] æˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒ b3 å’Œ a2 çš„å…³ç³»çš„å¤§å°ï¼Œå°±å¯ä»¥çŸ¥é“è¿™ç§åˆ†æ³•æ˜¯ä¸æ˜¯å‡†ç¡®çš„ï¼ ä¾‹å¦‚ï¼šæˆ‘ä»¬ä»¤ï¼š nums1 = [-1,1,3,5,7,9] nums2 =[2,4,6,8,10,12,14,16] å½“ m1 = 4,m2 = 3 ,å®ƒçš„ä¸­ä½æ•°å°±æ˜¯median = (num1[m1] + num2[m2])/2 æ—¶é—´å¤æ‚åº¦ï¼šO(log(min(m,n))) å¯¹äºä»£ç ä¸­è¾¹ç•Œæƒ…å†µï¼Œå¤§å®¶éœ€è¦è‡ªå·±ç¢ç£¨ã€‚ 12345678910111213141516171819202122232425262728293031class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: m, n = len(nums1), len(nums2) if m &gt; n: return self.findMedianSortedArrays(nums2, nums1) left, right = 0, m half = (m + n + 1) // 2 while left &lt; right: i = (left + right) // 2 j = half - i if nums1[i] &lt; nums2[j - 1]: left = i + 1 else: right = i i, j = left, half - left if i == 0: mid1 = nums2[j - 1] elif j == 0: mid1 = nums1[i - 1] else: mid1 = max(nums1[i - 1], nums2[j - 1]) if (m + n) &amp; 1: return mid1 if i == m: mid2 = nums2[j] elif j == n: mid2 = nums1[i] else: mid2 = min(nums1[i], nums2[j]) return (mid1 + mid2) / 2"},{"title":"1832. Check if the Sentence Is Pangram(easy)","path":"2022/10/17/1832/","text":"1832. Check if the Sentence Is Pangram(easy)A pangram is a sentence where every letter of the English alphabet appears at least once.Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.åˆ©ç”¨setçš„ç‰¹æ€§åˆ¤æ–­æ— é‡å¤åæ˜¯å¦æœ‰26ä¸ªå­—æ¯ 12345678class Solution: def checkIfPangram(self, sentence: str) -&gt; bool: if len(sentence)&lt;=25: return False if len(set(sentence))==26: return True else: return False"},{"title":"7. Reverse Integer(medium)","path":"2022/10/16/7/","text":"7. Reverse Integer(medium)Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned).leetcoddeé¢˜è§£åˆå§‹è§£ï¼šå°†æ•°ç»„è½¬æ¢æˆå­—ç¬¦ä¸²ï¼Œä»åå¾€å‰è¾“å‡ºå­—ç¬¦ä¸²å¾—åˆ°ç»“æœ 123456789101112def reverse_force(self, x: int) -&gt; int: if -10 &lt; x &lt; 10: return x str_x = str(x) if str_x[0] != &quot;-&quot;: str_x = str_x[::-1] x = int(str_x) else: str_x = str_x[:0:-1] x = int(str_x) x = -x return x if -2147483648 &lt; x &lt; 2147483647 else 0 ä¼˜åŒ–è§£ï¼š 1234567891011class Solution: def reverse(self, x: int) -&gt; int: y, res = abs(x), 0 # åˆ™å…¶æ•°å€¼èŒƒå›´ä¸º [âˆ’2^31, 2^31 âˆ’ 1] boundry = (1&lt;&lt;31) -1 if x&gt;0 else 1&lt;&lt;31 while y != 0: res = res*10 +y%10 if res &gt; boundry : return 0 y //=10 return res if x &gt;0 else -res è¿™é¢˜æ²¡æœ‰è€ƒä»€ä¹ˆæ·±çš„ä¸œè¥¿ï¼Œä¸è¿‡å¯ä»¥å¤ä¹ ä¸€ä¸‹ python çš„å­—ç¬¦è¿ç®—è¯­æ³•ï¼š å¤ä¹ ä¸€ä¸‹ python çš„ä½è¿ç®—ç¬¦ï¼š (a &amp; b)æŒ‰ä½ä¸è¿ç®—ç¬¦ï¼šå‚ä¸è¿ç®—çš„ä¸¤ä¸ªå€¼ï¼Œå¦‚æœä¸¤ä¸ªç›¸åº”ä½éƒ½ä¸º 1ï¼Œåˆ™è¯¥ä½çš„ç»“æœä¸º 1ï¼Œå¦åˆ™ä¸º 0 ã€‚è¾“å‡ºç»“æœ 12 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0000 1100 (a | b)æŒ‰ä½æˆ–è¿ç®—ç¬¦ï¼šåªè¦å¯¹åº”çš„äºŒä¸ªäºŒè¿›ä½æœ‰ä¸€ä¸ªä¸º1æ—¶ï¼Œç»“æœä½å°±ä¸º1ã€‚è¾“å‡ºç»“æœ 61 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0011 1101 (a ^ b)æŒ‰ä½å¼‚æˆ–è¿ç®—ç¬¦ï¼šå½“ä¸¤å¯¹åº”çš„äºŒè¿›ä½ç›¸å¼‚æ—¶ï¼Œç»“æœä¸º 1è¾“å‡ºç»“æœ 49 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0011 0001 (a )æŒ‰ä½å–åè¿ç®—ç¬¦ï¼šå¯¹æ•°æ®çš„æ¯ä¸ªäºŒè¿›åˆ¶ä½å–åï¼Œå³æŠŠ 1 å˜ä¸º 0ï¼ŒæŠŠ 0 å˜ä¸º 1 ã€‚x ç±»ä¼¼äº -x-1è¾“å‡ºç»“æœ -61 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 1100 0011ï¼Œåœ¨ä¸€ä¸ªæœ‰ç¬¦å·äºŒè¿›åˆ¶æ•°çš„è¡¥ç å½¢å¼ã€‚ a &lt;&lt; 2å·¦ç§»åŠ¨è¿ç®—ç¬¦ï¼šè¿ç®—æ•°çš„å„äºŒè¿›ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ï¼Œç”± &lt;&lt; å³è¾¹çš„æ•°å­—æŒ‡å®šäº†ç§»åŠ¨çš„ä½æ•°ï¼Œé«˜ä½ä¸¢å¼ƒï¼Œä½ä½è¡¥ 0ã€‚è¾“å‡ºç»“æœ 240 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 1111 0000 a &gt;&gt; 2å³ç§»åŠ¨è¿ç®—ç¬¦ï¼šæŠŠ â€œ&gt;&gt;â€ å·¦è¾¹çš„è¿ç®—æ•°çš„å„äºŒè¿›ä½å…¨éƒ¨å³ç§»è‹¥å¹²ä½ï¼Œ&gt;&gt; å³è¾¹çš„æ•°å­—æŒ‡å®šäº†ç§»åŠ¨çš„ä½æ•°è¾“å‡ºç»“æœ 15 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0000 1111 python èµ‹å€¼è¿ç®—ç¬¦ï¼š *= ä¹˜æ³•èµ‹å€¼è¿ç®—ç¬¦ c *= a ç­‰æ•ˆäº c = c * a/= é™¤æ³•èµ‹å€¼è¿ç®—ç¬¦ c /= a ç­‰æ•ˆäº c = c / a%= å–æ¨¡èµ‹å€¼è¿ç®—ç¬¦ c %= a ç­‰æ•ˆäº c = c % a**= å¹‚èµ‹å€¼è¿ç®—ç¬¦ c **= a ç­‰æ•ˆäº c = c ** a//= å–æ•´é™¤èµ‹å€¼è¿ç®—ç¬¦ c //= a ç­‰æ•ˆäº c = c // a ä½œè€…ï¼šstray_camelé“¾æ¥ï¼šhttps://leetcode.cn/problems/reverse-integer/solution/pythondan-chu-he-tui-ru-shu-zi-yi-chu-qian-jin-xin/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 1"},{"title":"2095. Delete the Middle Node of a Linked List(medium)","path":"2022/10/14/2095/","text":"2095. Delete the Middle Node of a Linked List(medium)You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list. The middle node of a linked list of size n is the âŒŠn / 2âŒ‹th node from the start using 0-based indexing, where âŒŠxâŒ‹ denotes the largest integer less than or equal to x. For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively. æ€è·¯ï¼šå…ˆéå†ä¸€éé“¾è¡¨ï¼Œåˆ¤æ–­é“¾è¡¨æ€»é•¿åº¦ï¼Œç„¶åç®—å‡ºä¸€åŠçš„é•¿åº¦nåœ¨å“ªé‡Œæœ€åéå†åˆ°n-1çš„ä½ç½®ï¼Œè·³è¿‡ä½ç½®nç›´æ¥è¿åˆ°n+1 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head.next==None: return None n=0 p1=p2=head while p1: p1=p1.next n+=1 k=n//2 for i in range(k-1): p2=p2.next #p2.next=p2.next.next p2.next = p2.next.next return head"},{"title":"401. Binary Watch(easy)","path":"2022/10/12/401/","text":"401. Binary Watch(easy)A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.For example, the below binary watch reads â€œ4:51â€. ä¸€å…±åä¸ªç¯ï¼Œå››ä¸ªæ˜¯äºŒè¿›åˆ¶æ˜¾ç¤ºå°æ—¶ï¼Œå…­ä¸ªæ˜¯äºŒè¿›åˆ¶æ˜¾ç¤ºåˆ†é’Ÿ å®˜æ–¹é¢˜è§£12345678class Solution: def readBinaryWatch(self, turnedOn: int) -&gt; List[str]: ans = list() for h in range(12): for m in range(60): if bin(h).count(&quot;1&quot;) + bin(m).count(&quot;1&quot;) == turnedOn: ans.append(f&quot;&#123;h&#125;:&#123;m:02d&#125;&quot;) return ans ç”±é¢˜æ„å¯çŸ¥ï¼Œå°æ—¶ç”± 4 ä¸ªæ¯”ç‰¹è¡¨ç¤ºï¼Œåˆ†é’Ÿç”± 6 ä¸ªæ¯”ç‰¹è¡¨ç¤ºï¼Œæ¯”ç‰¹ä½å€¼ä¸º 0 è¡¨ç¤ºç¯ç­ï¼Œä¸º 1 è¡¨ç¤ºç¯äº®ã€‚ æˆ‘ä»¬å¯ä»¥æšä¸¾å°æ—¶çš„æ‰€æœ‰å¯èƒ½å€¼ [0,11]ï¼Œä»¥åŠåˆ†é’Ÿçš„æ‰€æœ‰å¯èƒ½å€¼ [0,59]ï¼Œå¹¶è®¡ç®—äºŒè€…çš„äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°ä¹‹å’Œï¼Œè‹¥ä¸º turnedOnï¼Œåˆ™å°†å…¶åŠ å…¥åˆ°ç­”æ¡ˆä¸­ã€‚"},{"title":"404. Sum of Left Leaves(easy)","path":"2022/10/12/404/","text":"404. Sum of Left Leaves(easy)Given the root of a binary tree, return the sum of all left leaves.A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.å·¦å­æ ‘ä¹‹å’Œ Leetcodeé¢˜è§£123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int: def dfs(root, isLeft): if not root: return 0 if not root.left and not root.right: return root.val if isLeft else 0 return dfs(root.left, True) + dfs(root.right, False) return dfs(root, False)"},{"title":"389. Find the Difference(easy)","path":"2022/10/12/389/","text":"389. Find the Difference(easy)You are given two strings s and t.String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. è¿™é¢˜å’Œ383. Ransom Note(easy)æ–¹æ³•å‡ ä¹ä¸€æ ·ç”¨counterå¾—åˆ°æ¯ä¸ªå­—æ¯å’Œå¯¹åº”çš„ä¸ªæ•°ï¼Œç¬¬ä¸€æ­¥åˆ¤æ–­æ˜¯ä¸æ˜¯sé‡Œæ²¡æœ‰çš„å­—æ¯ï¼Œç„¶åæŠŠä¸ªæ•°ä¸æ–­å‡å»ï¼Œå‡åˆ°è´Ÿæ•°ï¼Œé‚£ä¸ªè´Ÿæ•°çš„å°±æ˜¯å¤šå‡ºæ¥çš„é‚£ä¸€ä¸ª 123456789101112131415class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: l1=Counter(s) l2=Counter(t) for char in t: if char not in s: return char else: l1[char]-=1 if l1[char]&lt;0: return char"},{"title":"237. Delete Node in a Linked List(medium)","path":"2022/10/12/237/","text":"237. Delete Node in a Linked List(medium)There is a singly-linked list head and we want to delete a node node in it.You are given the node to be deleted node. You will not be given access to the first node of head.All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:The value of the given node should not exist in the linked list.The number of nodes in the linked list should decrease by one.All the values before node should be in the same order.All the values after node should be in the same order. Custom testing:For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.We will build the linked list and pass the node to your function.The output will be the entire list after calling your function. è¿™é¢˜å…¶å®å¾ˆç®€å•ï¼Œå› ä¸ºåªç»™äº†éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹nodeï¼Œæ‰€ä»¥åªéœ€è¦ä½¿nodeçš„valç­‰äºä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œå½“å‰nodeçš„ä¸‹ä¸€ä¸ªé“¾æ¥åˆ°ä¸‹ä¸‹ä¸ª 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val=node.next.val node.next=node.next.next return"},{"title":"383. Ransom Note(easy)","path":"2022/10/12/383/","text":"383. Ransom Note(easy)Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.Each letter in magazine can only be used once in ransomNote.ç”¨counterå¾—åˆ°æ¯ä¸ªå­—æ¯å’Œå¯¹åº”çš„ä¸ªæ•°ï¼Œç¬¬ä¸€æ­¥åˆ¤æ–­æ˜¯ä¸æ˜¯magazineæœ‰æ‰€æœ‰çš„å­—æ¯ï¼Œç„¶åæŠŠä¸ªæ•°ä¸æ–­å‡å»ï¼Œå‡åˆ°è´Ÿæ•°ï¼Œè¯æ˜ä¸ªæ•°ä¸å¤Ÿ 12345678910111213class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool: l1=Counter(ransomNote) l2=Counter(magazine) for ch in ransomNote: if ch not in magazine: return False else: l2[ch]-=1 if l2[ch]&lt;0: return False return True"},{"title":"374. Guess Number Higher or Lower(easy)","path":"2022/10/12/374/","text":"374. Guess Number Higher or Lower(easy)We are playing the Guess Game. The game is as follows:I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: -1: Your guess is higher than the number I picked (i.e. num &gt; pick).1: Your guess is lower than the number I picked (i.e. num &lt; pick).0: your guess is equal to the number I picked (i.e. num == pick).Return the number that I picked. çŒœæ•°å­—ï¼Œæœ¬èº«æœ‰ä¸ªå†…ç½®å‡½æ•°guess(),ä¸€å¼€å§‹å°±ç›´æ¥å†™å¾ªç¯æŒ¨ä¸ªç®—æ˜¯ä¸æ˜¯ç›¸ç­‰ï¼Œå‘ç°åé¢è¶…æ—¶ï¼Œæ‰€ä»¥æ”¹ç”¨äºŒåˆ†æŸ¥æ‰¾ 12345678910111213141516171819202122# The guess API is already defined for you.# @param num, your guess# @return -1 if num is higher than the picked number# 1 if num is lower than the picked number# otherwise return 0# def guess(num: int) -&gt; int:class Solution: def guessNumber(self, n: int) -&gt; int: low=1 high=n while low&lt;=high: mid = low + (high - low) // 2 res=guess(mid) if res==0: return mid elif res&lt;0: high = mid-1 else: low=mid+1 return mid"},{"title":"346. Moving Average from Data Stream(easy)","path":"2022/10/12/346/","text":"346. Moving Average from Data Stream(easy)Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.Implement the MovingAverage class:MovingAverage(int size) Initializes the object with the size of the window size.double next(int val) Returns the moving average of the last size values of the stream. 123456789101112Input[&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;][[3], [1], [10], [3], [5]]Output[null, 1.0, 5.5, 4.66667, 6.0]ExplanationMovingAverage movingAverage = new MovingAverage(3);movingAverage.next(1); // return 1.0 = 1 / 1movingAverage.next(10); // return 5.5 = (1 + 10) / 2movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3 12345678910111213141516class MovingAverage: def __init__(self, size: int): self.res=[] self.size=size def next(self, val: int) -&gt; float: queue=self.res size=self.size queue.append(val) window_sum=sum(queue[-size:]) return window_sum/min(len(queue),size)# Your MovingAverage object will be instantiated and called as such:# obj = MovingAverage(size)# param_1 = obj.next(val)"},{"title":"157. Read N Characters Given Read4(easy)","path":"2022/10/12/157/","text":"157. Read N Characters Given Read4(easy)Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters.Method read4:The API read4 reads four consecutive characters from file, then writes those characters into the buffer array buf4. The return value is the number of actual characters read. Note that read4() has its own file pointer, much like FILE *fp in C. Definition of read4:1234 Parameter: char[] buf4 Returns: intbuf4[] is a destination, not a source. The results from read4 will be copied to buf4[]. ç»™ä½ ä¸€ä¸ªæ–‡ä»¶ï¼Œå¹¶ä¸”è¯¥æ–‡ä»¶åªèƒ½é€šè¿‡ç»™å®šçš„ read4 æ–¹æ³•æ¥è¯»å–ï¼Œè¯·å®ç°ä¸€ä¸ªæ–¹æ³•ä½¿å…¶èƒ½å¤Ÿè¯»å– n ä¸ªå­—ç¬¦ã€‚ read4 æ–¹æ³•ï¼š API read4 å¯ä»¥ä»æ–‡ä»¶ä¸­è¯»å– 4 ä¸ªè¿ç»­çš„å­—ç¬¦ï¼Œå¹¶ä¸”å°†å®ƒä»¬å†™å…¥ç¼“å­˜æ•°ç»„ buf ä¸­ã€‚ è¿”å›å€¼ä¸ºå®é™…è¯»å–çš„å­—ç¬¦ä¸ªæ•°ã€‚ æ³¨æ„ read4() è‡ªèº«æ‹¥æœ‰æ–‡ä»¶æŒ‡é’ˆï¼Œå¾ˆç±»ä¼¼äº C è¯­è¨€ä¸­çš„ FILE *fp ã€‚ read4 çš„å®šä¹‰ï¼š 123å‚æ•°ç±»å‹: char[] buf4è¿”å›ç±»å‹: intæ³¨æ„: buf4[] æ˜¯ç›®æ ‡ç¼“å­˜åŒºä¸æ˜¯æºç¼“å­˜åŒºï¼Œread4 çš„è¿”å›ç»“æœå°†ä¼šå¤åˆ¶åˆ° buf4[] å½“ä¸­ã€‚ read æ–¹æ³•ï¼šé€šè¿‡ä½¿ç”¨ read4 æ–¹æ³•ï¼Œå®ç° read æ–¹æ³•ã€‚è¯¥æ–¹æ³•å¯ä»¥ä»æ–‡ä»¶ä¸­è¯»å– n ä¸ªå­—ç¬¦å¹¶å°†å…¶å­˜å‚¨åˆ°ç¼“å­˜æ•°ç»„ buf ä¸­ã€‚æ‚¨ ä¸èƒ½ ç›´æ¥æ“ä½œæ–‡ä»¶ã€‚ è¿”å›å€¼ä¸ºå®é™…è¯»å–çš„å­—ç¬¦ã€‚ read çš„å®šä¹‰ï¼š 123å‚æ•°ç±»å‹: char[] buf, int nè¿”å›ç±»å‹: intæ³¨æ„: buf[] æ˜¯ç›®æ ‡ç¼“å­˜åŒºä¸æ˜¯æºç¼“å­˜åŒºï¼Œä½ éœ€è¦å°†ç»“æœå†™å…¥ buf[] ä¸­ã€‚ hint123ä½ ä¸èƒ½ç›´æ¥æ“ä½œè¯¥æ–‡ä»¶ï¼Œæ–‡ä»¶åªèƒ½é€šè¿‡ read4 è·å–è€Œ ä¸èƒ½ é€šè¿‡ readã€‚read å‡½æ•°åªåœ¨æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹è°ƒç”¨ä¸€æ¬¡ã€‚ä½ å¯ä»¥å‡å®šç›®æ ‡ç¼“å­˜æ•°ç»„ buf ä¿è¯æœ‰è¶³å¤Ÿçš„ç©ºé—´å­˜ä¸‹ n ä¸ªå­—ç¬¦ã€‚ 12345678910111213141516171819202122232425262728293031323334353637&quot;&quot;&quot;The read4 API is already defined for you. @param buf4, a list of characters @return an integer def read4(buf4):# Below is an example of how the read4 API can be called.file = File(&quot;abcdefghijk&quot;) # File is &quot;abcdefghijk&quot;, initially file pointer (fp) points to &#x27;a&#x27;buf4 = [&#x27; &#x27;] * 4 # Create buffer with enough space to store charactersread4(buf4) # read4 returns 4. Now buf = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;], fp points to &#x27;e&#x27;read4(buf4) # read4 returns 4. Now buf = [&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;], fp points to &#x27;i&#x27;read4(buf4) # read4 returns 3. Now buf = [&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,...], fp points to end of file&quot;&quot;&quot;class Solution: def read(self, buf, n): &quot;&quot;&quot; :type buf: Destination buffer (List[str]) :type n: Number of characters to read (int) :rtype: The number of actual characters read (int) &quot;&quot;&quot; temp = [&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;] count = read4(temp) s = temp[:count] while count &gt; 0: if len(s) &gt;= n: break count = read4(temp) s += temp[:count] total = min(n, len(s)) for i in range(total): buf[i] = s[i] return total"},{"title":"2434. Using a Robot to Print the Lexicographically Smallest String(medium)","path":"2022/10/12/2434/","text":"2434. Using a Robot to Print the Lexicographically Smallest String(medium)You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.Remove the last character of a string t and give it to the robot. The robot will write this character on paper. Return the lexicographically smallest string that can be written on the paper.å‘¨èµ›é¢˜ï¼Œä¸€é“å…³äºæ ˆçš„é¢˜ 123456789101112131415class Solution: def robotWithString(self, s: str) -&gt; str: d, stack, ans = Counter(s), [], [] for ch in s: d[ch]-= 1 stack.append(ch) if not d[ch]: d.pop(ch) while d and stack and min(d) &gt;= stack[-1]: ans += stack.pop() return &#x27;&#x27;.join(ans + stack[::-1])"},{"title":"359. Logger Rate Limiter(easy)","path":"2022/10/12/359/","text":"359. Logger Rate Limiter(easy)Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).All messages will come in chronological order. Several messages may arrive at the same timestamp.Implement the Logger class:Logger() Initializes the logger object.bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false. è¿™é¢˜çš„æ„æ€æ˜¯messageåŒ…å«ä¸åŒçš„çŸ­è¯­ï¼Œç›¸åŒçš„çŸ­è¯­ä¹‹é—´é—´éš”å¾—å¤§äºç­‰äº10ï¼Œä¸åŒçš„çŸ­è¯­å¯ä»¥ç›´æ¥è¿”å›true 1234567891011121314151617181920212223242526class Logger: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self._msg_dict = &#123;&#125; def shouldPrintMessage(self, timestamp: int, message: str) -&gt; bool: &quot;&quot;&quot; Returns true if the message should be printed in the given timestamp, otherwise returns false. &quot;&quot;&quot; if message not in self._msg_dict: # case 1). add the message to print self._msg_dict[message] = timestamp return True if timestamp - self._msg_dict[message] &gt;= 10: # case 2). update the timestamp of the message self._msg_dict[message] = timestamp return True else: return False # Your Logger object will be instantiated and called as such:# obj = Logger()# param_1 = obj.shouldPrintMessage(timestamp,message)"},{"title":"293. Flip Game(easy)","path":"2022/10/12/293/","text":"293. Flip Game(easy)You are playing a Flip Game with your friend.You are given a string currentState that contains only â€˜+â€™ and â€˜-â€˜. You and your friend take turns to flip two consecutive â€œ++â€ into â€œâ€“â€. The game ends when a person can no longer make a move, and therefore the other person will be the winner.Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].12Input: currentState = &quot;++++&quot;Output: [&quot;--++&quot;,&quot;+--+&quot;,&quot;++--&quot;] è¿ç€çš„++æ¢æˆâ€“ï¼Œçœ‹èƒ½è¾“å‡ºå¤šå°‘ä¸ª 1234567class Solution: def generatePossibleNextMoves(self, currentState: str) -&gt; List[str]: res=[] for i in range(len(currentState)-1): if currentState[i:i+2]==&quot;++&quot;: res.append(currentState[:i]+&#x27;--&#x27;+currentState[i+2:]) return res"},{"title":"367. Valid Perfect Square(easy)","path":"2022/10/12/367/","text":"367. Valid Perfect Square(easy)Given a positive integer num, write a function which returns True if num is a perfect square else False.Follow up: Do not use any built-in library function such as sqrt.åˆ¤æ–­æ˜¯å¦æ˜¯å¹³æ–¹æ•°ï¼Œå¯ä»¥é€šè¿‡ç­‰å·®æ•°åˆ—æ¥æ±‚ï¼Œç­‰å·®æ•°åˆ—a0=1, d=2ï¼Œæœ€åæ±‚å’Œçš„ç»“æœå°±æ˜¯n^2,æ‰€ä»¥é€šè¿‡è¯¥ç­‰å·®æ•°åˆ—æ¥æ±‚ 1234567891011class Solution: def isPerfectSquare(self, num: int) -&gt; bool: i=1 d=2 while num&gt;0: num-=i i+=d if num==0: return True else: return False"},{"title":"338. Counting Bits(easy)","path":"2022/10/12/338/","text":"338. Counting Bits(easy)Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1â€™s in the binary representation of i.123456Input: n = 2Output: [0,1,1]Explanation:0 --&gt; 01 --&gt; 12 --&gt; 10 å®˜æ–¹é¢˜è§£Use previous count results to generate the count for a new integer. DP + Most Significant Bit 12345678910111213141516class Solution: def countBits(self, n: int) -&gt; List[int]: ans = [0] * (n + 1) x = 0 b = 1 # [0, b) is calculated while b &lt;= n: # generate [b, 2b) or [b, n) from [0, b) while x &lt; b and x + b &lt;= n: ans[x + b] = ans[x] + 1 x += 1 x = 0 # reset x b &lt;&lt;= 1 # b = 2b return ans"},{"title":"292. Nim Game(easy)","path":"2022/10/12/292/","text":"292. Nim Game(easy)You are playing the following Nim Game with your friend:Initially, there is a heap of stones on the table.You and your friend will alternate taking turns, and you go first.On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.The one who removes the last stone is the winner.Given , the number of stones in the heap, return if you can win the game assuming both you and your friend play optimally, otherwise return .n truefalse æ€»ç»“å°±æ˜¯è®©å¯¹æ‰‹åªèƒ½æ‹¿åˆ°4æˆ–è€…4çš„å€æ•°ï¼Œè¿™æ ·ä»–æ‹¿å‡ ä¸ªæˆ‘éƒ½æœ‰æœºä¼šèµ¢ 123class Solution: def canWinNim(self, n: int) -&gt; bool: return n%4"},{"title":"270. Closest Binary Search Tree Value(easy)","path":"2022/10/12/270/","text":"270. Closest Binary Search Tree Value(easy)Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.äºŒå‰æœç´¢æ ‘ä¸Šä¸targetæœ€è¿‘çš„æ•°å­—leetcodeé¢˜è§£ 12345678910111213# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def closestValue(self, root, target): a = root.val kid = root.left if target &lt; a else root.right if not kid: return a b = self.closestValue(kid, target) return min((b, a), key=lambda x: abs(target - x))"},{"title":"976. Largest Perimeter Triangle(easy)","path":"2022/10/12/976/","text":"976. Largest Perimeter Triangle(easy)Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.ç»„æˆä¸‰è§’å½¢çš„æ¡ä»¶æ˜¯ä¸¤è¾¹ä¹‹å’Œå¤§äºç¬¬ä¸‰è¾¹ï¼Œå…ˆå°†æ•°ç»„æ’åºï¼Œç„¶åä»å¤§å¾€å°æŒ¨ä¸ªç®—èƒ½å¦ç»„æˆä¸‰è§’å½¢ï¼Œå¦‚æœå¯ä»¥å°±è¾“å‡ºï¼Œåˆ°æœ€åéƒ½æ²¡æœ‰å‘ç°å°±ç›´æ¥return 0 123456789101112class Solution: def largestPerimeter(self, nums: List[int]) -&gt; int: nums.sort(reverse=True) n=len(nums) for i in range(n-2): if nums[i]&gt;=nums[i+1]+nums[i+2]: continue elif nums[i]&lt;nums[i+1]+nums[i+2]: return sum(nums[i:i+3]) return 0"},{"title":"263. Ugly Number(easy)","path":"2022/10/12/263/","text":"263. Ugly Number(easy)An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.Given an integer n, return true if n is an ugly number.è¿™æ˜¯ä¸€ä¸ªç³»åˆ—é¢˜263. ä¸‘æ•°ï¼ˆç®€å•ï¼‰ ä¸‘æ•° IIï¼ˆä¸­ç­‰ï¼‰ ä¸‘æ•° IIIï¼ˆä¸­ç­‰ï¼‰ è¶…çº§ä¸‘æ•°ï¼ˆä¸­ç­‰ï¼‰ 123456789101112131415class Solution: def isUgly(self, n: int) -&gt; bool: if n&lt;1: return False while n%2==0 or n%3==0 or n%5==0: if n %2==0: n/=2 elif n%3==0: n/=3 elif n%5==0: n/=5 if n==1: return True return False"},{"title":"266. Palindrome Permutation(easy)","path":"2022/10/12/266/","text":"266. Palindrome Permutation(easy)Given a string s, return true if a permutation of the string could form a palindrome.è¿™é¢˜åˆ¤æ–­stringèƒ½å¦ç»„æˆå›æ–‡ä¸²ï¼Œå›æ–‡ä¸²çš„ç‰¹ç‚¹å°±æ˜¯æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªå­—æ¯æ˜¯å¥‡æ•°ï¼Œå…¶ä»–çš„éƒ½å¾—æ˜¯å¶æ•°ï¼Œè¿™é‡Œå¾ˆå·§å¦™çš„è¿ç”¨äº†setçš„å»é‡ç‰¹æ€§ï¼Œæœ€å¤šåªæœ‰ä¸€ä¸ªå­—æ¯ç•™åœ¨seté‡Œ Leetcodeé¢˜è§£ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: # Set: Iterate over the given string # Add the character when it is not there, Remove it when it is. # At the end, the length of the sets is lesser than 2 # TC O(n) n is the number of the character of string # SC O(1) the maximum size of the set would be 128 ASCII characters # This is bounded (constant), def canPermutePalindrome(self, s: str) -&gt; bool: sets = set() for char in s: if char not in sets: sets.add(char) else: sets.remove(char) return (len(sets) &lt;= 1) # # Hashmap: Count the number of occurence of characters# # TC O(n) n is the number of the character of string# # SC O(1) the maximum size of the map would be 128 ASCII characters# # This is bounded (constant)# def canPermutePalindrome(self, s: str) -&gt; bool:# # Iterate over a given string# # Count the number of occurence of characters# # key: Character, value: count# maps = collections.defaultdict(int)# for char in s:# if maps.get(char):# maps[char] += 1# else:# maps[char] = 1 # # Traverse over the map to find even number# count = 0# for key in maps:# count += maps[key] %2# # if maps[key] % 2 == 1:# # # Odd number of occuerence# # if the count is lesser than 2, it is palindrome# return (count &lt;= 1)"},{"title":"334. Increasing Triplet Subsequence(easy)","path":"2022/10/11/334/","text":"334. Increasing Triplet Subsequence(easy)Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.åœ¨ä¸€ä¸ªé˜Ÿåˆ—é‡Œæ‰¾åˆ°ä¸‰ä¸ªä¸æ–­å¢å¤§çš„æ•°ï¼Œä¸éœ€è¦è¿ç»­float(â€œinfâ€)æ˜¯ä¸€ä¸ªupper boundï¼Œä¹Ÿå°±æ˜¯æ— ç©·å¤§çš„è¾¹ç•Œä¸“é—¨ç”¨æ¥åšæ¯”è¾ƒç”¨çš„ 123456789101112class Solution: def increasingTriplet(self, nums: List[int]) -&gt; bool: first_num = float(&quot;inf&quot;) second_num = float(&quot;inf&quot;) for n in nums: if n &lt;= first_num:# ç¬¬ä¸€å°çš„æ•° first_num = n elif n &lt;= second_num:# ç¬¬äºŒå°çš„æ•° second_num = n else: #æœ€åä¸€ä¸ªæ•° return True return False"},{"title":"257. Binary Tree Paths(easy)","path":"2022/10/10/257/","text":"257. Binary Tree Paths(easy)Given the root of a binary tree, return all root-to-leaf paths in any order.A leaf is a node with no children.ä½œè€…ï¼šLeetCode-Solutioné“¾æ¥ï¼šhttps://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; def construct_paths(root, path): if root: path += str(root.val) if not root.left and not root.right: # å½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ paths.append(path) # æŠŠè·¯å¾„åŠ å…¥åˆ°ç­”æ¡ˆä¸­ else: path += &#x27;-&gt;&#x27; # å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œç»§ç»­é€’å½’éå† construct_paths(root.left, path) construct_paths(root.right, path) paths = [] construct_paths(root, &#x27;&#x27;) return paths"},{"title":"243. Shortest Word Distance(easy)","path":"2022/10/10/243/","text":"243. Shortest Word Distance(easy)Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest distance between these two words in the list.è¿™é¢˜å…ˆæ‰¾åˆ°å¯¹åº”wordçš„indexï¼Œä½†è¿™é‡Œæœ‰äº›caseæ˜¯wordå‡ºç°äº†å¾ˆå¤šæ¬¡ï¼Œæ‰€ä»¥å†åŠ å¾ªç¯éå†æ±‚æœ€å°å€¼ 123456789101112class Solution: def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int: l=wordsDict.index(word1) r=wordsDict.index(word2) l=[index for (index,value) in enumerate(wordsDict) if value==word1] r=[index for (index,value) in enumerate(wordsDict) if value==word2] res=abs(l[0]-r[0]) for i in l: for j in r: res=min(res,abs(i-j)) return res"},{"title":"232. Implement Queue using Stacks(easy)","path":"2022/10/10/232/","text":"232. Implement Queue using Stacks(easy)Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).Implement the MyQueue class:void push(int x) Pushes element x to the back of the queue.int pop() Removes the element from the front of the queue and returns it.int peek() Returns the element at the front of the queue.boolean empty() Returns true if the queue is empty, false otherwise.Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stackâ€™s standard operations.è¿™é¢˜å’Œ225. Implement Stack using Queues(easy)äº’ä¸ºé•œåƒ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue: def __init__(self): &quot;&quot;&quot; inä¸»è¦è´Ÿè´£pushï¼Œoutä¸»è¦è´Ÿè´£pop &quot;&quot;&quot; self.stack_in = [] self.stack_out = [] def push(self, x: int) -&gt; None: &quot;&quot;&quot; æœ‰æ–°å…ƒç´ è¿›æ¥ï¼Œå°±å¾€iné‡Œé¢push &quot;&quot;&quot; self.stack_in.append(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element from in front of queue and returns that element. &quot;&quot;&quot; if self.empty(): return None if self.stack_out: return self.stack_out.pop() else: for i in range(len(self.stack_in)): self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() def peek(self) -&gt; int: &quot;&quot;&quot; Get the front element. &quot;&quot;&quot; ans = self.pop() self.stack_out.append(ans) return ans def empty(self) -&gt; bool: &quot;&quot;&quot; åªè¦inæˆ–è€…outæœ‰å…ƒç´ ï¼Œè¯´æ˜é˜Ÿåˆ—ä¸ä¸ºç©º &quot;&quot;&quot; return not (self.stack_in or self.stack_out)# Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()"},{"title":"1328. Break a Palindrome(medium)","path":"2022/10/10/1328/","text":"1328. Break a Palindrome(medium)Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, â€œabccâ€ is lexicographically smaller than â€œabcdâ€ because the first position they differ is at the fourth character, and â€˜câ€™ is smaller than â€˜dâ€™.1234Input: palindrome = &quot;abccba&quot;Output: &quot;aaccba&quot;Explanation: There are many ways to make &quot;abccba&quot; not a palindrome, such as &quot;zbccba&quot;, &quot;aaccba&quot;, and &quot;abacba&quot;.Of all the ways, &quot;aaccba&quot; is the lexicographically smallest. è¿™é“é¢˜å…¶å®å¾ˆç®€å•ï¼Œæ˜¯ä¸ªè´ªå¿ƒæ‰¾å›æ–‡ä¸²ä¸­ï¼Œç¬¬ä¸€ä¸ªå¤§äºâ€™aâ€™çš„å­—ç¬¦ï¼Œæ›¿æ¢æˆâ€™aâ€™å¦‚æœæ²¡æœ‰ï¼Œè¯´æ˜æ•´ä¸²éƒ½æ˜¯aï¼Œæœ€åä¸€ä¸ªæ¢æˆbå°±è¡Œã€‚æ‰€ä»¥ç ´åè¿œæ¯”æ„å»ºè¦å®¹æ˜“ 12345678class Solution: def breakPalindrome(self, palindrome: str) -&gt; str: if len(palindrome)==1: return &quot;&quot; for i in range(len(palindrome)//2): if palindrome[i]&gt;&#x27;a&#x27;: return palindrome[:i]+&#x27;a&#x27;+palindrome[i+1:] return palindrome[:len(palindrome)-1]+ &#x27;b&#x27;"},{"title":"145. Binary Tree Postorder Traversal(easy)","path":"2022/10/09/145/","text":"145. Binary Tree Postorder Traversal(easy)Given the root of a binary tree, return the postorder traversal of its nodesâ€™ values.ååºéå†ï¼Œå’Œå‰åºéå†å‡ ä¹ä¸€æ · Leetcodeå®˜æ–¹é¢˜è§£123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: def postorder(root:TreeNode): if not root: return postorder(root.left) postorder(root.right) res.append(root.val) res=list() postorder(root) return res"},{"title":"144. Binary Tree Preorder Traversal(easy)","path":"2022/10/09/144/","text":"144. Binary Tree Preorder Traversal(easy)Given the root of a binary tree, return the preorder traversal of its nodesâ€™ values.Leetcodeå®˜æ–¹é¢˜è§£äºŒå‰æ ‘çš„å‰åºéå† # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: def preorder(root:TreeNode): if not root: return res.append(root.val) preorder(root.left) preorder(root.right) res=list() preorder(root) return res"},{"title":"258. Add Digits(easy)","path":"2022/10/09/258/","text":"258. Add Digits(easy)Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.å®˜æ–¹é¢˜è§£å…¶å®æ˜¯ä¸€é“æ•°å­¦é¢˜ 123class Solution: def addDigits(self, num: int) -&gt; int: return (num - 1) % 9 + 1 if num else 0"},{"title":"252. Meeting Rooms(easy)","path":"2022/10/09/252/","text":"252. Meeting Rooms(easy)Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.å®‰æ’ä¼šè®®çš„ç¬¬ä¸€é¢˜ï¼Œæ²¡æœ‰ä»€ä¹ˆæŠ€å·§ï¼Œå…ˆå°†æ•°ç»„æ’åºï¼Œç„¶ååˆ¤æ–­åä¸€ä¸ªä¼šè®®çš„å¼€å§‹æ—¶é—´æ˜¯ä¸æ˜¯å°äºå‰ä¸€ä¸ªä¼šè®®çš„ç»“æŸæ—¶é—´ 1234567class Solution: def canAttendMeetings(self, intervals: List[List[int]]) -&gt; bool: intervals.sort() for i in range(len(intervals)-1): if intervals[i][1]&gt;intervals[i+1][0]: return False return True"},{"title":"246. Strobogrammatic Numberï¼ˆeasy)","path":"2022/10/09/246/","text":"246. Strobogrammatic Numberï¼ˆeasy)Given a string num which represents an integer, return true if num is a strobogrammatic number.A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).12Input: num = &quot;69&quot;Output: true æœ‰ç‚¹åƒæ±‚å›æ–‡æ•°çš„æ–¹æ³•ï¼ŒåŒæŒ‡é’ˆï¼Œä½†æ˜¯æœ‰ç›¸åŒæ„é€ çš„æ•°å°±é‚£ä¹ˆå‡ å¯¹ï¼Œåˆ—å‡ºæ¥å³å¯ 123456789101112class Solution: def isStrobogrammatic(self, num: str) -&gt; bool: if not num: return False pairs= set([(&#x27;0&#x27;,&#x27;0&#x27;), (&#x27;1&#x27;,&#x27;1&#x27;), (&#x27;6&#x27;,&#x27;9&#x27;), (&#x27;8&#x27;,&#x27;8&#x27;), (&#x27;9&#x27;,&#x27;6&#x27;)]) l,r=0,len(num)-1 while l&lt;=r: if (num[l],num[r]) not in pairs: return False l+=1 r-=1 return True"},{"title":"228. Summary Ranges(easy)","path":"2022/10/09/228/","text":"228. Summary Ranges(easy)You are given a sorted unique integer array nums.A range [a,b] is the set of all integers from a to b (inclusive).Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.Each range [a,b] in the list should be output as:â€œa-&gt;bâ€ if a != bâ€œaâ€ if a == b 12345678910111213141516class Solution: def summaryRanges(self, nums: List[int]) -&gt; List[str]: res = [] cur = 0 while cur&lt;len(nums): start = cur while cur&lt;len(nums)-1 and nums[cur]+1==nums[cur+1]: cur+=1 if cur!=start: res.append(str(nums[start]) + &quot;-&gt;&quot; + str(nums[cur])) else: res.append(str(nums[cur])) cur+=1 return res"},{"title":"225. Implement Stack using Queues(easy)","path":"2022/10/09/225/","text":"225. Implement Stack using Queues(easy)Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).Implement the MyStack class:void push(int x) Pushes element x to the top of the stack.int pop() Removes the element on the top of the stack and returns it.int top() Returns the element on the top of the stack.boolean empty() Returns true if the stack is empty, false otherwise. Notes:You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queueâ€™s standard operations. 12345678910111213Input[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]Output[null, null, null, 2, 2, false]ExplanationMyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // return 2myStack.pop(); // return 2myStack.empty(); // return False Leetcodeå®˜æ–¹é¢˜è§£æ ˆæ˜¯ä¸€ç§åè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå…ƒç´ ä»é¡¶ç«¯å…¥æ ˆï¼Œç„¶åä»é¡¶ç«¯å‡ºæ ˆã€‚ é˜Ÿåˆ—æ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå…ƒç´ ä»åç«¯å…¥é˜Ÿï¼Œç„¶åä»å‰ç«¯å‡ºé˜Ÿã€‚ ä¸ºäº†æ»¡è¶³æ ˆçš„ç‰¹æ€§ï¼Œå³æœ€åå…¥æ ˆçš„å…ƒç´ æœ€å…ˆå‡ºæ ˆï¼Œåœ¨ä½¿ç”¨é˜Ÿåˆ—å®ç°æ ˆæ—¶ï¼Œåº”æ»¡è¶³é˜Ÿåˆ—å‰ç«¯çš„å…ƒç´ æ˜¯æœ€åå…¥æ ˆçš„å…ƒç´ ã€‚å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°æ ˆçš„æ“ä½œï¼Œå…¶ä¸­ queue1ç”¨äºå­˜å‚¨æ ˆå†…çš„å…ƒç´ ï¼Œqueue2ä½œä¸ºå…¥æ ˆæ“ä½œçš„è¾…åŠ©é˜Ÿåˆ—ã€‚ å…¥æ ˆæ“ä½œæ—¶ï¼Œé¦–å…ˆå°†å…ƒç´ å…¥é˜Ÿåˆ° queue2ï¼Œç„¶åå°† queue1çš„å…¨éƒ¨å…ƒç´ ä¾æ¬¡å‡ºé˜Ÿå¹¶å…¥é˜Ÿåˆ° queue2ï¼Œæ­¤æ—¶ queue2çš„å‰ç«¯çš„å…ƒç´ å³ä¸ºæ–°å…¥æ ˆçš„å…ƒç´ ï¼Œå†å°† queue1å’Œ queue2äº’æ¢ï¼Œåˆ™ queue1çš„å…ƒç´ å³ä¸ºæ ˆå†…çš„å…ƒç´ ï¼Œqueue1çš„å‰ç«¯å’Œåç«¯åˆ†åˆ«å¯¹åº”æ ˆé¡¶å’Œæ ˆåº•ã€‚ ç”±äºæ¯æ¬¡å…¥æ ˆæ“ä½œéƒ½ç¡®ä¿ queue1çš„å‰ç«¯å…ƒç´ ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œå› æ­¤å‡ºæ ˆæ“ä½œå’Œè·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œéƒ½å¯ä»¥ç®€å•å®ç°ã€‚å‡ºæ ˆæ“ä½œåªéœ€è¦ç§»é™¤ queue1çš„å‰ç«¯å…ƒç´ å¹¶è¿”å›å³å¯ï¼Œè·å¾—æ ˆé¡¶å…ƒç´ æ“ä½œåªéœ€è¦è·å¾— queue1çš„å‰ç«¯å…ƒç´ å¹¶è¿”å›å³å¯ï¼ˆä¸ç§»é™¤å…ƒç´ ï¼‰ã€‚ ç”±äº queue1ç”¨äºå­˜å‚¨æ ˆå†…çš„å…ƒç´ ï¼Œåˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºæ—¶ï¼Œåªéœ€è¦åˆ¤æ–­ queue1æ˜¯å¦ä¸ºç©ºå³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty()class MyStack: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.queue1 = collections.deque() self.queue2 = collections.deque() def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x onto stack. &quot;&quot;&quot; self.queue2.append(x) while self.queue1: self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element on top of the stack and returns that element. &quot;&quot;&quot; return self.queue1.popleft() def top(self) -&gt; int: &quot;&quot;&quot; Get the top element. &quot;&quot;&quot; return self.queue1[0] def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the stack is empty. &quot;&quot;&quot; return not self.queue1"},{"title":"190. Reverse Bits(easy)","path":"2022/10/09/190/","text":"Reverse bits of a given 32 bits unsigned integer.Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integerâ€™s internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2â€™s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.123Input: n = 00000010100101000001111010011100Output: 964176192 (00111001011110000010100101000000)Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. äºŒè¿›åˆ¶é¢ å€’é¡ºåºï¼Œç”¨ä½è¿ç®—çš„æ–¹æ³• 1234567891011class Solution: def reverseBits(n): res=0 ans=0 n1=0 for i in range(32): ans=res&lt;&lt;1 n1=n&amp;1 # n1=n&amp;1 res=ans|n1 # æˆ–è¿ç®—ï¼šåŒ0ä¸º0ï¼Œå¦åˆ™ä¸º1 n&gt;&gt;=1 # x &gt;&gt; y å³ç§»æ“ä½œï¼Œæœ€å·¦è¾¹ç”¨ 0 å¡«å…… return res"},{"title":"168. Excel Sheet Column Title(easy)","path":"2022/10/09/168/","text":"168. Excel Sheet Column Title(easy)Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.For example:12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 12Input: columnNumber = 1Output: &quot;A&quot; è¿™é“é¢˜å’Œ 171. Excel Sheet Column Number(easy)å±äºé•œåƒé¢˜ï¼Œå¯ä»¥ç”¨é«˜ä¸­å­¦è¿‡çš„åè¿›åˆ¶è½¬äºŒè¿›åˆ¶çš„æ€æƒ³ï¼Œåˆ©ç”¨æ±‚ä½™å’Œé™¤æ³•ä¸æ–­æ±‚å‡ºæ¯ä¸€ä½çš„ç³»æ•° 1234567891011class Solution: def convertToTitle(self, columnNumber: int) -&gt; str: ans=[] while columnNumber&gt;0: columnNumber-=1 current=columnNumber%26 columnNumber=columnNumber//26 ans.append(chr(current+ord(&#x27;A&#x27;))) #The chr() method converts an integer to its unicode character and returns it. return &#x27;&#x27;.join(ans[::-1]) # [::-1] , it starts from the end towards the first taking each element."},{"title":"342. Power of Four(easy)","path":"2022/10/08/342/","text":"342. Power of Four(easy)Given an integer n, return true if it is a power of four. Otherwise, return false.An integer n is a power of four, if there exists an integer x such that n == 4^x.123456789101112class Solution: def isPowerOfFour(self, n: int) -&gt; bool: hashset1=set() i=0 while math.pow(4,i)&lt;math.pow(2,31)-1: hashset1.add(math.pow(4,i)) i+=1 if n in hashset1: return True else: return False"},{"title":"326. Power of Three(easy)","path":"2022/10/08/326/","text":"326. Power of Three(easy)Given an integer n, return true if it is a power of three. Otherwise, return false.An integer n is a power of three, if there exists an integer x such that n == 3x.é€šç”¨ä»£ç  123456789101112class Solution: def isPowerOfThree(self, n: int) -&gt; bool: hashset1=set() i=0 while math.pow(3,i)&lt;math.pow(2,31)-1: hashset1.add(math.pow(3,i)) i+=1 if n in hashset1: return True else: return False"},{"title":"1380. Lucky Numbers in a Matrix(easy)","path":"2022/10/05/1380/","text":"1380. Lucky Numbers in a Matrix(easy)Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.class Solution: def luckyNumbers(self, matrix: List[List[int]]) -&gt; List[int]: m = len(matrix) n = len(matrix[0]) # Calculate the strength of each row. strengths = [] col=[] res=[] for i, row in enumerate(matrix): strength = row[0] ind=0 for j in range(1,n): if row[j]&lt;strength: ind=j strength=row[j] strengths.append((strength, ind)) for i in range(len(strengths)): col = [sub[strengths[i][1]] for sub in matrix] if strengths[i][0]==max(col): res.append(strengths[i][0]) return res"},{"title":"1337. The K Weakest Rows in a Matrix(easy)","path":"2022/10/05/1337/","text":"1337. The K Weakest Rows in a Matrix(easy)You are given an m x n binary matrix mat of 1â€™s (representing soldiers) and 0â€™s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1â€™s will appear to the left of all the 0â€™s in each row.A row i is weaker than a row j if one of the following is true:The number of soldiers in row i is less than the number of soldiers in row j.Both rows have the same number of soldiers and i &lt; j.Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.æ€è·¯åˆ†æˆä¸¤æ­¥ï¼Œç¬¬ä¸€æ­¥å…ˆæ±‚å‡ºæ¯è¡Œ1çš„ä¸ªæ•°ï¼Œç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„å‚¨å­˜ç¬¬äºŒæ­¥å†è¾“å‡ºå‰Kä¸ª leetcodeé¢˜è§£ 12345678910111213141516171819202122232425262728class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&gt; List[int]: # Note that there is a more conscise solution just below. This code # avoids the use of advanced language features. m = len(mat) n = len(mat[0]) # Calculate the strength of each row. strengths = [] for i, row in enumerate(mat): strength = 0 for j in range(n): if row[j] == 0: break strength += 1 strengths.append((strength, i)) # Sort all the strengths. This will sort firstly by strength # and secondly by index. strengths.sort() # Pull out and return the indexes of the smallest k entries. indexes = [] for i in range(k): indexes.append(strengths[i][1]) return indexes"},{"title":"1351. Count Negative Numbers in a Sorted Matrix","path":"2022/10/04/1351/","text":"1351. Count Negative Numbers in a Sorted MatrixGiven a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.è¿˜æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯æŒ¨ä¸ªéå†ä¸€é 12345678910class Solution: def countNegatives(self, grid: List[List[int]]) -&gt; int: n=len(grid) m=len(grid[0]) res=0 for i in range(n): for j in range(m): if grid[i][j]&lt;0: res+=1 return res"},{"title":"832. Flipping an Image(easy)","path":"2022/10/04/832/","text":"832. Flipping an Image(easy)Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.To flip an image horizontally means that each row of the image is reversed.For example, flipping [1,1,0] horizontally results in [0,1,1].To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.For example, inverting [0,1,1] results in [1,0,0].ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡éå†æ˜¯10äº’æ¢ï¼Œç¬¬äºŒæ¬¡éå†æ˜¯å‰åæ•°å­—äº’æ¢ 123456789101112131415161718192021class Solution: def flipAndInvertImage(self, image: List[List[int]]) -&gt; List[List[int]]: n=len(image) for i in range(n): for j in range(n): if image[i][j]==1: image[i][j]=0 else: image[i][j]=1 for i in range(n): if n%2==0: for j in range(n//2): tmp=image[i][j] image[i][j]=image[i][n-j-1] image[i][n-j-1]=tmp else: for j in range(n//2+1): tmp=image[i][j] image[i][j]=image[i][n-j-1] image[i][n-j-1]=tmp return image ç›¸å¯¹è½»ä¾¿çš„ç®—æ³•[::-1] é¡ºåºç›¸åæ“ä½œ[-1] è¯»å–å€’æ•°ç¬¬ä¸€ä¸ªå…ƒç´ [3::-1] ä»ä¸‹æ ‡ä¸º3ï¼ˆä»0å¼€å§‹ï¼‰çš„å…ƒç´ å¼€å§‹ç¿»è½¬è¯»å– 1234567891011121314class Solution: def flipAndInvertImage(self, image: List[List[int]]) -&gt; List[List[int]]: result=[] for i in image: result.append(i[::-1]) for i in range(len(result)): for j in range(len(result[i])): if result[i][j]==0: result[i][j]=1 else: result[i][j]=0 return result"},{"title":"2373. Largest Local Values in a Matrix(easy)","path":"2022/10/04/2373/","text":"2373. Largest Local Values in a Matrix(easy)You are given an n x n integer matrix grid.Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.Return the generated matrix.äºŒç»´çŸ©é˜µéå† 12345678class Solution: def largestLocal(self, grid: List[List[int]]) -&gt; List[List[int]]: n=len(grid) ans=[[0]*(n-2) for _ in range(n-2)] for i in range(n-2): for j in range(n-2): ans[i][j]=max(grid[x][y] for x in range(i,i+3) for y in range(j,j+3)) return ans"},{"title":"LeetCode-skill11-matrix","path":"2022/10/04/LeetCode-skill11-matrix/","text":"Richest Customer Wealth(easy) Spiral Matrix(medium)"},{"title":"1672. Richest Customer Wealth(easy)","path":"2022/10/04/1672/","text":"1672. Richest Customer Wealth(easy)You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the iâ€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹thâ€‹â€‹â€‹â€‹ customer has in the jâ€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹thâ€‹â€‹â€‹â€‹ bank. Return the wealth that the richest customer has.A customerâ€™s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.123456789101112class Solution: def maximumWealth(self, accounts: List[List[int]]) -&gt; int: res=0 for i in range(len(accounts)): res=max(res,sum(accounts[i])) return res``` ```pythonaccounts = [[1,2,3],[3,2,1]]print(len(accounts)) #2 è¡Œprint(len(accounts[0])) #3 åˆ—"},{"title":"171. Excel Sheet Column Number(easy)","path":"2022/10/03/171/","text":"171. Excel Sheet Column Number(easy)Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.For example:12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... è¿™é“é¢˜æ˜¯ä¸€ç»å…¸é¢˜ç›®ï¼Œç›¸å½“äºä»26è¿›åˆ¶è½¬æ¢æˆåè¿›åˆ¶ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡å‡†ç®—æ³•ï¼Œæˆ‘ä»¬ä»å³åˆ°å·¦è¿­ä»£æ•°å­—ï¼Œå¹¶å°†å®ƒä»¬ä¹˜ä»¥åŸºæ•°åˆ°æ•°å­—ä½ç½®çš„å¹‚ã€‚ä¸ºäº†å°†å­—æ¯è½¬æ¢ä¸ºæ•°å­—ï¼Œæˆ‘ä»¬ä½¿ç”¨ordï¼Œè¯¥æ–¹æ³•è¿”å›å­—æ¯çš„Unicodeä»£ç ã€‚é€šè¿‡å°†ä»£ç å‡å» 64ï¼Œæˆ‘ä»¬å¯ä»¥å°†å­—æ¯æ˜ å°„åˆ°ä» 1 åˆ° 26 çš„æ•°å­—ã€‚å’Œ 168. Excel Sheet Column Title(easy) æ˜¯ä¸€é“é•œåƒé¢˜ç›® 26è¿›åˆ¶è½¬æ¢ä¸ºåè¿›åˆ¶ï¼Œç›¸å½“äºK*(26^(n-1)) 12345678class Solution: def titleToNumber(self, columnTitle: str) -&gt; int: val=0 for i,c in enumerate(reversed(columnTitle)): val+=(26**i)*(ord(c) - ord(&#x27;A&#x27;) + 1) return val#** ä»£è¡¨ä¹˜æ–¹"},{"title":"LeetCode-skill10-Data-structure-design","path":"2022/10/03/LeetCode-skill10-Data-structure-design/","text":"Two Sum III - Data structure design(easy) Implement Stack using Queues(easy) Moving Average from Data Stream Logger Rate Limiter(easy) Online Stock Span(medium)"},{"title":"170. Two Sum III - Data structure design(easy)","path":"2022/10/03/170/","text":"170. Two Sum III - Data structure design(easy)Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.Implement the TwoSum class:TwoSum() Initializes the TwoSum object, with an empty array initially.void add(int number) Adds number to the data structure.boolean find(int value) Returns true if there exists any pair of numbers whose sum is equal to value, otherwise, it returns false. 12345678910111213Input[&quot;TwoSum&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;find&quot;, &quot;find&quot;][[], [1], [3], [5], [4], [7]]Output[null, null, null, null, true, false]ExplanationTwoSum twoSum = new TwoSum();twoSum.add(1); // [] --&gt; [1]twoSum.add(3); // [1] --&gt; [1,3]twoSum.add(5); // [1,3] --&gt; [1,3,5]twoSum.find(4); // 1 + 3 = 4, return truetwoSum.find(7); // No two integers sum up to 7, return false leetcodeé¢˜è§£ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TwoSum: def __init__(self): self.nums=[] self.is_sorted=False def add(self, number: int) -&gt; None: # Inserting while maintaining the ascending order. # for index, num in enumerate(self.nums): # if number &lt;= num: # self.nums.insert(index, number) # return ## larger than any number #self.nums.append(number) self.nums.append(number) self.is_sorted = False def find(self, value: int) -&gt; bool: &quot;&quot;&quot; Find if there exists any pair of numbers which sum is equal to the value. :type value: int :rtype: bool &quot;&quot;&quot; if not self.is_sorted: self.nums.sort() self.is_sorted = True low, high = 0, len(self.nums)-1 while low &lt; high: currSum = self.nums[low] + self.nums[high] if currSum &lt; value: low += 1 elif currSum &gt; value: high -= 1 else: # currSum == value return True return False # Your TwoSum object will be instantiated and called as such:# obj = TwoSum()# obj.add(number)# param_2 = obj.find(value)"},{"title":"1572. Matrix Diagonal Sum(easy)","path":"2022/10/03/1572/","text":"1572. Matrix Diagonal Sum(easy)Given a square matrix mat, return the sum of the matrix diagonals.Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.çŸ©é˜µå¯¹è§’çº¿ä¹‹å’Œï¼Œè¿™é¢˜å¾ˆå…¸å‹ é€è¡Œå–æ•°æ€è·¯ä¸ç®—æ³• é€è¡Œéå†ï¼Œè®°å½“å‰çš„è¡Œå·ä¸º iï¼Œå¯¹äºä¸€è¡Œæˆ‘ä»¬æŠŠ (i, i)ä½ç½®å’Œ (i, n - i - 1) åŠ å…¥ç­”æ¡ˆã€‚è¿™æ ·å¦‚æœ n æ˜¯å¥‡æ•°çš„è¯ï¼Œæœ€ä¸­é—´çš„æ ¼å­ä¼šè¢«åŠ å…¥ä¸¤æ¬¡ã€‚æ‰€ä»¥ n ä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦å‡æ‰çŸ©é˜µæœ€ä¸­å¿ƒçš„é‚£ä¸ªå€¼ã€‚ 12345678class Solution: def diagonalSum(self, mat: List[List[int]]) -&gt; int: n = len(mat) total = 0 mid = n // 2 for i in range(n): total += mat[i][i] + mat[i][n - 1 - i] return total - mat[mid][mid] * (n &amp; 1) n&amp;1æ˜¯ç”¨æ¥åˆ¤æ–­å¥‡å¶æ€§çš„n&amp;1 ä¸è¿ç®— å¯ä»¥åˆ¤æ–­næ˜¯å¦ä¸ºå¶æ•° å¦‚æœæ˜¯å¶æ•°ï¼Œn&amp;1è¿”å›0ï¼›å¦åˆ™è¿”å›1ï¼Œä¸ºå¥‡æ•°ã€‚ä¸€ä¸ªæ•´æ•° nï¼Œn&amp;1 è¿™ä¸ªè¡¨è¾¾å¼ å¯ä»¥ç”¨æ¥ åˆ¤æ–­ açš„å¥‡å¶æ€§ã€‚äºŒè¿›åˆ¶çš„æœ«ä½ä¸º 0è¡¨ç¤ºå¶æ•°ï¼Œæœ«ä½ä¸º 1è¡¨æ˜¯å¥‡æ•°ã€‚ä½¿ç”¨ n%2 æ¥åˆ¤æ–­å¥‡å¶æ€§ å’Œ n&amp;1 æ˜¯ä¸€æ ·çš„ä½œç”¨ï¼Œä½†æ˜¯ n&amp;1 è¦å¿«å¥½å¤šã€‚"},{"title":"163. Missing Ranges(easy)","path":"2022/10/03/163/","text":"163. Missing Ranges(easy)You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are in the inclusive range.A number x is considered missing if x is in the range [lower, upper] and x is not in nums.Return the smallest sorted list of ranges that cover every missing number exactly. That is, no element of nums is in any of the ranges, and each missing number is in one of the ranges.Each range [a,b] in the list should be output as:â€œa-&gt;bâ€ if a != bâ€œaâ€ if a == b 1234567Input: nums = [0,1,3,50,75], lower = 0, upper = 99Output: [&quot;2&quot;,&quot;4-&gt;49&quot;,&quot;51-&gt;74&quot;,&quot;76-&gt;99&quot;]Explanation: The ranges are:[2,2] --&gt; &quot;2&quot;[4,49] --&gt; &quot;4-&gt;49&quot;[51,74] --&gt; &quot;51-&gt;74&quot;[76,99] --&gt; &quot;76-&gt;99&quot; è¿™é¢˜æ˜¯é€šè¿‡lowerå’Œupperç¡®å®šä¸Šä¸‹è¾¹ç•Œï¼Œç„¶åå†æŒ¨ä¸ªå‰åç›¸å‡å¾—åˆ°èŒƒå›´ 12345678910111213141516171819202122class Solution: def findMissingRanges(self, nums: List[int], lower: int, upper: int) -&gt; List[str]: numList = nums nums = [lower - 1] for num in numList: nums.append(num) nums.append(upper + 1) ranges = list() for i in range(len(nums) - 1): dist = nums[i + 1] - nums[i] if dist &gt; 1: if dist == 2: ranges.append(str(nums[i] + 1)) else: start = nums[i] + 1 end = nums[i + 1] - 1 ranges.append(&quot;&#123;0:d&#125;-&gt;&#123;1:d&#125;&quot;.format(start, end)) return ranges"},{"title":"1155. Number of Dice Rolls With Target Sum(medium)","path":"2022/10/02/1155/","text":"Number of Dice Rolls With Target Sum(medium) You have n dice and each die has k faces numbered from 1 to k. Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7. è¿™é¢˜ä¹ä¸€çœ‹å°±æ˜¯dpï¼Œè€Œä¸”ç±»ä¼¼äºçˆ¬æ¥¼æ¢¯é—®é¢˜ï¼Œç›¸å½“äºä¸€æ¬¡çˆ¬Kä¸ªå°é˜¶ï¼Œä¸€å…±çˆ¬næ¬¡çˆ¬åˆ°targetçš„ä½ç½® 1234Input: n = 1, k = 6, target = 3Output: 1Explanation: You throw one die with 6 faces.There is only one way to get a sum of 3. é¢˜è§£We are asked to figure out how many times we get target sum with n dice with values 1..k.The important point is - sum of all faced-up numbers. So it cannot be a subset of n dice. It should be sum of all faced-up dice. We are going to pick the 1st dice with value 1. Then we going to pick the 2nd dice with value 1 and so on until we ran out of dice.sum([1,1,1,..1] n times) == target? Then we are going to pick the 1st dice with value 1 and the 2nd dice with value 2 and so on.sum([[1,2,1,..1] n times) == target? â€¦sum([[3,1,5,..4] n times) == target?â€¦ â€¦ n) sum([k,k,â€¦k] n times) == target?When we ran out of dice (n -&gt; 0) we check if the sum of all picked dice values == target. If yes, return 1, else return 0 for a specific permutation. They want us to count [1,2] and [2,1] as 2 different sets. The order of items is important. We are working with permutations. Find the target sum in all permutations of size n with element values ranging from 1â€¦k. 1234567891011121314151617181920212223242526272829303132333435class Solution: def numRollsToTarget(self, N: int, k: int, target: int) -&gt; int: # [1] 2 3 4 5 6 # 1 2 3 4 5 [6] # bottom-up/tabulation TC: (N*k*target) SC: (N*target) MOD = 10**9 + 7 dp = [[0] * (target + 1) for _ in range(N + 1)] dp[0][0] = 1 for n in range(1, N + 1): for i in range(1, k + 1): for t in range(i, target + 1): dp[n][t] += dp[n - 1][t - i] % MOD return dp[N][target] % MOD # top-down# @cache# def solve(n, t):# if n == 0:# return 1 if t == 0 else 0 # if we ran out of dice and we got our target value# count = 0# for j in range(1, k + 1):# if t - j &gt;= 0:# count += solve(n - 1, t - j) # return count # return solve(n, target) % MOD"},{"title":"119. Pascal's Triangle II(easy)","path":"2022/10/02/119/","text":"119. Pascalâ€™s Triangle II(easy)Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascalâ€™s triangle.In Pascalâ€™s triangle, each number is the sum of the two numbers directly above it as shown:è·Ÿ118å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œåªä¸è¿‡è¿™é“é¢˜æ˜¯è¾“å‡ºç‰¹å®šçš„æŸä¸€è¡Œ 123456789class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: if rowIndex==0:return [1] res=[[1]] while len(res)&lt;rowIndex+1: newRow=[a+b for a,b in zip([0]+res[-1],res[-1]+[0])] res.append(newRow) return newRow"},{"title":"139","path":"2022/10/02/139/","text":""},{"title":"118. Pascal's Triangle","path":"2022/10/02/118/","text":"118. Pascalâ€™s TriangleGiven an integer numRows, return the first numRows of Pascalâ€™s triangle.In Pascalâ€™s triangle, each number is the sum of the two numbers directly above it as shown:æ¨è¾‰ä¸‰è§’,ç®—æ˜¯æ•°å­¦é¢˜è§‚å¯Ÿä¸€ä¸‹è§„å¾‹ï¼Œå‘ç°å½“å‰ä¸€è¡Œåªæ¯”ä¸Šä¸€è¡Œå¤šäº†ä¸€ä¸ªå…ƒç´ ï¼Œæœ€æœ€å…³é”®çš„ä¸€ç‚¹ï¼šæœ¬è¡Œå…ƒç´ ç­‰äºä¸Šä¸€è¡Œå…ƒç´ å¾€åé”™ä¸€ä½å†é€ä¸ªç›¸åŠ ï¼š é¢˜è§£12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows == 0: return [] res = [[1]] while len(res) &lt; numRows: newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])] res.append(newRow) return res"},{"title":"125. Valid Palindrome","path":"2022/10/02/125/","text":"125. Valid PalindromeA phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.Given a string s, return true if it is a palindrome, or false otherwise.123Input: s = &quot;A man, a plan, a canal: Panama&quot;Output: trueExplanation: &quot;amanaplanacanalpanama&quot; is a palindrome. è¿™é‡Œæœ‰ä¸ªé‡è¦çš„å‡½æ•°isalnum()ï¼Œç”¨æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯å­—æ¯ 1234567891011121314class Solution: def isPalindrome(self, s: str) -&gt; bool: n=len(s) left,right=0,n-1 while left&lt;right: while left&lt;right and not s[left].isalnum(): left+=1 while left&lt;right and not s[right].isalnum(): right-=1 if left&lt;right: if s[left].lower()!=s[right].lower(): return False left,right=left+1,right-1 return True"},{"title":"111. Minimum Depth of Binary Tree(easy)","path":"2022/10/02/111/","text":"111. Minimum Depth of Binary Tree(easy)Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children.é¢˜è§£ æ ¹æ®å¤§ä½¬çš„Javaä»£ç å†™çš„python Java12345678910111213141516class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null) return 0; //è¿™é“é¢˜é€’å½’æ¡ä»¶é‡Œåˆ†ä¸ºä¸‰ç§æƒ…å†µ //1.å·¦å­©å­å’Œå³å­©å­éƒ½ä¸ºç©ºçš„æƒ…å†µï¼Œè¯´æ˜åˆ°è¾¾äº†å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›1å³å¯ if(root.left == null &amp;&amp; root.right == null) return 1; //2.å¦‚æœå·¦å­©å­å’Œå³å­©å­å…¶ä¸­ä¸€ä¸ªä¸ºç©ºï¼Œé‚£ä¹ˆéœ€è¦è¿”å›æ¯”è¾ƒå¤§çš„é‚£ä¸ªå­©å­çš„æ·±åº¦ int m1 = minDepth(root.left); int m2 = minDepth(root.right); //è¿™é‡Œå…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œè¯´æ˜m1å’Œm2æœ‰ä¸€ä¸ªå¿…ç„¶ä¸º0ï¼Œæ‰€ä»¥å¯ä»¥è¿”å›m1 + m2 + 1; if(root.left == null || root.right == null) return m1 + m2 + 1; //3.æœ€åä¸€ç§æƒ…å†µï¼Œä¹Ÿå°±æ˜¯å·¦å³å­©å­éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›æœ€å°æ·±åº¦+1å³å¯ return Math.min(m1,m2) + 1; &#125;&#125; Python12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def minDepth(self, root: Optional[TreeNode]) -&gt; int: if root==None: return 0 #è¿™é“é¢˜é€’å½’æ¡ä»¶é‡Œåˆ†ä¸ºä¸‰ç§æƒ…å†µ #1.å·¦å­©å­å’Œå³å­©å­éƒ½ä¸ºç©ºçš„æƒ…å†µï¼Œè¯´æ˜åˆ°è¾¾äº†å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›1å³å¯ if root.left==None and root.right==None: return 1 #2.å¦‚æœå·¦å­©å­å’Œå³å­©å­å…¶ä¸­ä¸€ä¸ªä¸ºç©ºï¼Œé‚£ä¹ˆéœ€è¦è¿”å›æ¯”è¾ƒå¤§çš„é‚£ä¸ªå­©å­çš„æ·±åº¦ m1=self.minDepth(root.left) m2=self.minDepth(root.right) #è¿™é‡Œå…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œè¯´æ˜m1å’Œm2æœ‰ä¸€ä¸ªå¿…ç„¶ä¸º0ï¼Œæ‰€ä»¥å¯ä»¥è¿”å›m1 + m2 + 1; if root.left==None or root.right==None: return m1+m2+1 #3.æœ€åä¸€ç§æƒ…å†µï¼Œä¹Ÿå°±æ˜¯å·¦å³å­©å­éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›æœ€å°æ·±åº¦+1å³å¯ return min(m1,m2)+1"},{"title":"108. Convert Sorted Array to Binary Search Tree(easy)","path":"2022/10/02/108/","text":"108. Convert Sorted Array to Binary Search Tree(easy)Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.ä¸­åºéå† ä¸­åºéå†ï¼Œæ€»æ˜¯é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œåˆ™æ ¹èŠ‚ç‚¹çš„ä¸‹æ ‡ä¸º \\textit{mid}=(\\textit{left}+\\textit{right})/2mid=(left+right)/2ï¼Œæ­¤å¤„çš„é™¤æ³•ä¸ºæ•´æ•°é™¤æ³•ã€‚ 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: def helper(left, right): if left &gt; right: return None # æ€»æ˜¯é€‰æ‹©ä¸­é—´ä½ç½®å·¦è¾¹çš„æ•°å­—ä½œä¸ºæ ¹èŠ‚ç‚¹ mid = (left + right) // 2 root = TreeNode(nums[mid]) root.left = helper(left, mid - 1) root.right = helper(mid + 1, right) return root return helper(0, len(nums) - 1)"},{"title":"100. Same Tree(easy)","path":"2022/10/02/100/","text":"100. Same Tree(easy)Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.12Input: p = [1,2,3], q = [1,2,3]Output: true Recursioné€’å½’ 123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool: if not p and not q: return True if not q or not p: return False if p.val!=q.val: return False return self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left)"},{"title":"94. Binary Tree Inorder Traversal(easy)","path":"2022/10/02/94/","text":"94. Binary Tree Inorder Traversal(easy)Given the root of a binary tree, return the inorder traversal of its nodesâ€™ values.äºŒå‰æ ‘çš„ä¸­åºéå† é€’å½’éå† å‰åºéå†ï¼šæ‰“å° - å·¦ - å³ä¸­åºéå†ï¼šå·¦ - æ‰“å° - å³ååºéå†ï¼šå·¦ - å³ - æ‰“å°é¢˜ç›®è¦æ±‚çš„æ˜¯ä¸­åºéå†ï¼Œé‚£å°±æŒ‰ç…§ å·¦-æ‰“å°-å³è¿™ç§é¡ºåºéå†æ ‘å°±å¯ä»¥äº†ï¼Œé€’å½’å‡½æ•°å®ç° ç»ˆæ­¢æ¡ä»¶ï¼šå½“å‰èŠ‚ç‚¹ä¸ºç©ºæ—¶å‡½æ•°å†…ï¼šé€’å½’çš„è°ƒç”¨å·¦èŠ‚ç‚¹ï¼Œæ‰“å°å½“å‰èŠ‚ç‚¹ï¼Œå†é€’å½’è°ƒç”¨å³èŠ‚ç‚¹æ—¶é—´å¤æ‚åº¦ï¼šO(n)ç©ºé—´å¤æ‚åº¦ï¼šO(h)ï¼Œh æ˜¯æ ‘çš„é«˜åº¦ 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: res=[] def dfs(root): if not root: return dfs(root.left) res.append(root.val) dfs(root.right) dfs(root) return res"},{"title":"70. Climbing Stairs(easy)","path":"2022/10/02/70/","text":"70. Climbing Stairs(easy)You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?12345Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps ä¸€é“ç»å…¸DPé¢˜å’Œæ–æ³¢é‚£å¥‘æ•°åˆ—ä¸ä¸€æ ·çš„æ˜¯ï¼Œä»–é—®çš„æ˜¯çˆ¬åˆ°nçš„é˜¶æ¢¯æœ‰å¤šå°‘ç§æ–¹æ³•çˆ¬åˆ°ç¬¬ x çº§å°é˜¶çš„æ–¹æ¡ˆæ•°æ˜¯çˆ¬åˆ°ç¬¬ x - 1 çº§å°é˜¶çš„æ–¹æ¡ˆæ•°å’Œçˆ¬åˆ°ç¬¬ x - 2 çº§å°é˜¶çš„æ–¹æ¡ˆæ•°çš„å’Œ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šdp[i]=dp[iâˆ’1]+dp[iâˆ’2]f(1) = 1 f(2) = 2å®˜æ–¹é¢˜è§£è¾¹ç•Œæ¡ä»¶ã€‚æˆ‘ä»¬æ˜¯ä»ç¬¬ 0 çº§å¼€å§‹çˆ¬çš„ï¼Œæ‰€ä»¥ä»ç¬¬ 0 çº§çˆ¬åˆ°ç¬¬ 0 çº§æˆ‘ä»¬å¯ä»¥çœ‹ä½œåªæœ‰ä¸€ç§æ–¹æ¡ˆï¼Œå³ f(0) = 1ï¼›ä»ç¬¬ 0 çº§åˆ°ç¬¬ 1 çº§ä¹Ÿåªæœ‰ä¸€ç§æ–¹æ¡ˆï¼Œå³çˆ¬ä¸€çº§ï¼Œf(1) = 1ã€‚è¿™ä¸¤ä¸ªä½œä¸ºè¾¹ç•Œæ¡ä»¶å°±å¯ä»¥ç»§ç»­å‘åæ¨å¯¼å‡ºç¬¬ n çº§çš„æ­£ç¡®ç»“æœã€‚æˆ‘ä»¬ä¸å¦¨å†™å‡ é¡¹æ¥éªŒè¯ä¸€ä¸‹ï¼Œæ ¹æ®è½¬ç§»æ–¹ç¨‹å¾—åˆ° f(2) = 2ï¼Œf(3) = 3ï¼Œf(4) = 5ï¼Œâ€¦â€¦ï¼Œæˆ‘ä»¬æŠŠè¿™äº›æƒ…å†µéƒ½æšä¸¾å‡ºæ¥ï¼Œå‘ç°è®¡ç®—çš„ç»“æœæ˜¯æ­£ç¡®çš„ã€‚ç”±äºè¿™é‡Œçš„ f(x) åªå’Œ f(x - 1) ä¸ f(x - 2) æœ‰å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ã€Œæ»šåŠ¨æ•°ç»„æ€æƒ³ã€æŠŠç©ºé—´å¤æ‚åº¦ä¼˜åŒ–æˆ O(1) 1234567891011class Solution: def climbStairs(self, n: int) -&gt; int: if n&lt;=2: return n before_last=1 last=2 for i in range(2,n): current=before_last+last before_last=last last = current return last"},{"title":"67. Add Binary(easy)","path":"2022/10/02/67/","text":"67. Add Binary(easy)Given two binary strings a and b, return their sum as a binary string.12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; å®ç°äºŒè¿›åˆ¶åŠ æ³•å®˜æ–¹é¢˜è§£ 12345678910111213141516171819202122232425class Solution: def addBinary(self, a, b) -&gt; str: n = max(len(a), len(b)) a, b = a.zfill(n), b.zfill(n) carry = 0 answer = [] for i in range(n - 1, -1, -1): if a[i] == &#x27;1&#x27;: carry += 1 if b[i] == &#x27;1&#x27;: carry += 1 if carry % 2 == 1: answer.append(&#x27;1&#x27;) else: answer.append(&#x27;0&#x27;) carry //= 2 if carry == 1: answer.append(&#x27;1&#x27;) answer.reverse() return &#x27;&#x27;.join(answer)"},{"title":"66. Plus One(easy)","path":"2022/10/02/66/","text":"66. Plus One(easy)You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0â€™s.Increment the large integer by one and return the resulting array of digits.è¿™é“é¢˜å¯ä»¥ç”¨æ•°å­¦æ–¹æ³•åˆ†ç±»å»ç®—ï¼Œä½†ä¹Ÿå¯ä»¥å…ˆæŠŠdigitsè½¬æ¢ä¸ºä¸€æ•´ä¸ªæ•°å­—ï¼ŒåŠ 1åï¼Œå†è½¬æ¢å›æ•°ç»„ class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: res=&quot;&quot;.join(str(digit) for digit in digits) res= int(res)+1 return str(res)"},{"title":"58. Length of Last Word(easy)","path":"2022/10/02/58/","text":"58. Length of Last Word(easy)Given a string s consisting of words and spaces, return the length of the last word in the string.A word is a maximal substring consisting of non-space characters only.1234class Solution: def lengthOfLastWord(self, s: str) -&gt; int: l=s.split() return len(l[-1])"},{"title":"35. Search Insert Position(easy)","path":"2022/10/02/35/","text":"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You must write an algorithm with O(log n) runtime complexity.åŸºç¡€åšæ³•ï¼Œéå† 123456789101112131415class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: res=0 if len(nums)==1: if target&gt;nums[0]: return 1 else: return 0 if target&gt;nums[-1]: return len(nums) for i in range(len(nums)): if nums[i]&gt;=target: res=i break return res äºŒåˆ†æŸ¥æ‰¾ 12345678910111213class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: length=len(nums) left = 0 right = length while left&lt;right: mid = int(left + (right - left) / 2) if nums[mid]&lt;target: left = mid+1 else: right= mid return left"},{"title":"14. Longest Common Prefix(easy)","path":"2022/10/02/14/","text":"14. Longest Common Prefix(easy)Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string â€œâ€.å®˜æ–¹é¢˜è§£ çºµå‘æ‰«ææ–¹æ³•ä¸€æ˜¯æ¨ªå‘æ‰«æï¼Œä¾æ¬¡éå†æ¯ä¸ªå­—ç¬¦ä¸²ï¼Œæ›´æ–°æœ€é•¿å…¬å…±å‰ç¼€ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯çºµå‘æ‰«æã€‚çºµå‘æ‰«ææ—¶ï¼Œä»å‰å¾€åéå†æ‰€æœ‰å­—ç¬¦ä¸²çš„æ¯ä¸€åˆ—ï¼Œæ¯”è¾ƒç›¸åŒåˆ—ä¸Šçš„å­—ç¬¦æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒåˆ™ç»§ç»­å¯¹ä¸‹ä¸€åˆ—è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœä¸ç›¸åŒåˆ™å½“å‰åˆ—ä¸å†å±äºå…¬å…±å‰ç¼€ï¼Œå½“å‰åˆ—ä¹‹å‰çš„éƒ¨åˆ†ä¸ºæœ€é•¿å…¬å…±å‰ç¼€ã€‚ 123456789101112class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return &quot;&quot; length, count = len(strs[0]), len(strs) for i in range(length): c = strs[0][i] if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)): return strs[0][:i] return strs[0]"},{"title":"1480. Running Sum of 1d Array(easy)","path":"2022/10/02/1480/","text":"Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]â€¦nums[i]). Return the running sum of nums. 123Input: nums = [1,2,3,4]Output: [1,3,6,10]Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. å…¶å®è¿™é¢˜å°±æ˜¯å‰ç¼€å’Œæ•°ç»„ 1234567class Solution: def runningSum(self, nums: List[int]) -&gt; List[int]: res=[0]*len(nums) res[0]=nums[0] for i in range(1,len(nums)): res[i]=nums[i]+res[i-1] return res"},{"title":"231. Power of Two(easy)","path":"2022/10/01/231/","text":"231. Power of Two(easy)Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.How to get / isolate the rightmost 1-bit : x &amp; (-x). How to turn off (= set to 0) the rightmost 1-bit : x &amp; (x - 1).å®˜æ–¹é¢˜è§£ Approach 1: Bitwise Operators : Get the Rightmost 1-bit"},{"title":"260. Single Number III(medium)","path":"2022/10/01/260/","text":"260. Single Number III(medium)Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.123Input: nums = [1,2,1,3,2,5]Output: [3,5]Explanation: [5, 3] is also a valid answer. çœ‹åˆ°å­—æ¯é¢‘ç‡çš„é¢˜è‚¯å®šæ˜¯å…ˆè€ƒè™‘hashmapï¼Œå…¨éƒ¨å­˜èµ·æ¥ç„¶åçœ‹valueä¸º1çš„å€¼æœ‰å“ªäº› 12345678910111213141516171819class Solution: def singleNumber(self, nums: List[int]) -&gt; List[int]: hashmap=&#123;&#125; res=[] if len(nums)==2: res.append(nums[0]) res.append(nums[1]) return res for num in nums: if num not in hashmap: hashmap[num]=1 else: hashmap[num]+=1 for i,value in hashmap.items(): if value==1: res.append(i) return res å®˜æ–¹é¢˜è§£ Two bitmasks"},{"title":"91. Decode Ways(medium)","path":"2022/10/01/91/","text":"91. Decode Ways(medium)A message containing letters from A-Z can be encoded into numbers using the following mapping:1234&#x27;A&#x27; -&gt; &quot;1&quot;&#x27;B&#x27; -&gt; &quot;2&quot;...&#x27;Z&#x27; -&gt; &quot;26&quot; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, â€œ11106â€ can be mapped into: â€œAAJFâ€ with the grouping (1 1 10 6)â€œKJFâ€ with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because â€œ06â€ cannot be mapped into â€˜Fâ€™ since â€œ6â€ is different from â€œ06â€. Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. 123Input: s = &quot;12&quot;Output: 2Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12). 123Input: s = &quot;226&quot;Output: 3Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). Leetcode Solution12345678910111213141516171819class Solution: def numDecodings(self, s: str) -&gt; int: if s[0] == &quot;0&quot;: return 0 two_back = 1 one_back = 1 for i in range(1, len(s)): current = 0 if s[i] != &quot;0&quot;: current = one_back two_digit = int(s[i - 1: i + 1]) if two_digit &gt;= 10 and two_digit &lt;= 26: current += two_back two_back = one_back one_back = current return one_back"},{"title":"137. Single Number II(medium)","path":"2022/10/01/137/","text":"137. Single Number(medium)Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.You must implement a solution with a linear runtime complexity and use only constant extra space.12Input: nums = [2,2,3,2]Output: 3 å®˜æ–¹é¢˜è§£ è¿™é‡Œç”¨åˆ°äº†å¼‚æˆ–XOR Letâ€™s start from XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc. XOR of zero and a bit results in that bit 0âŠ•x=x XOR of two equal bits (even if they are zeros) results in a zero xâŠ•x=0 and so on and so forth, i.e. one could see the bit in a bitmask only if it appears odd number of times.Thatâ€™s already great, so one could detect the bit which appears once, and the bit which appears three times. The problem is to distinguish between these two situations. AND and NOT To separate number that appears once from a number that appears three times letâ€™s use two bitmasks instead of one: seen_once and seen_twice. The idea is to change seen_once only if seen_twice is unchanged change seen_twice only if seen_once is unchanged 1234567891011121314151617181920class Solution: def singleNumber(self, nums: List[int]) -&gt; int: seen_once = seen_twice = 0 for num in nums: # first appearance: # add num to seen_once # don&#x27;t add to seen_twice because of presence in seen_once # second appearance: # remove num from seen_once # add num to seen_twice # third appearance: # don&#x27;t add to seen_once because of presence in seen_twice # remove num from seen_twice seen_once = ~seen_twice &amp; (seen_once ^ num) seen_twice = ~seen_once &amp; (seen_twice ^ num) return seen_once"},{"title":"136. Single Number(easy)","path":"2022/09/30/136/","text":"136. Single Number(easy)Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space.12Input: nums = [2,2,1]Output: 1 è¿™é“é¢˜çš„å…³é”®åœ¨äºå¼‚æˆ–è¿ç®—ï¼Œå¼‚æˆ–ä¹Ÿå«åŠåŠ è¿ç®—ï¼Œå…¶è¿ç®—æ³•åˆ™ç›¸å½“äºä¸å¸¦è¿›ä½çš„äºŒè¿›åˆ¶åŠ æ³•ï¼šäºŒè¿›åˆ¶ä¸‹ç”¨1è¡¨ç¤ºçœŸï¼Œ0è¡¨ç¤ºå‡ï¼Œåˆ™å¼‚æˆ–çš„è¿ç®—æ³•åˆ™ä¸ºï¼š0âŠ•0=0ï¼Œ1âŠ•0=1ï¼Œ0âŠ•1=1ï¼Œ1âŠ•1=0 å‡è®¾æ•°ç»„ä¸­æœ‰ 2m+1 ä¸ªæ•°ï¼Œå…¶ä¸­æœ‰ m ä¸ªæ•°å„å‡ºç°ä¸¤æ¬¡ï¼Œä¸€ä¸ªæ•°å‡ºç°ä¸€æ¬¡ã€‚a1âŠ•a1âŠ•a2âŠ•a2âŠ•a3âŠ•a3âŠ•a4âŠ•a4âŠ•a5âŠ•a5â‹¯â‹¯â‹¯âŠ•amâŠ•amâŠ•am+1=0âŠ•0âŠ•0âŠ•0âŠ•0âŠ•0âŠ•0âŠ•0âŠ•am+1=am+1â€‹ å› æ­¤ï¼Œæ•°ç»„ä¸­çš„å…¨éƒ¨å…ƒç´ çš„å¼‚æˆ–è¿ç®—ç»“æœå³ä¸ºæ•°ç»„ä¸­åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ã€‚ 1234class Solution: def singleNumber(self, nums: List[int]) -&gt; int: return reduce(lambda x, y: x ^ y, nums) python reduceThe reduce() function accepts a function and a sequence and returns a single value calculated as follows: Initially, the function is called with the first two items from the sequence and the result is returned.The function is then called again with the result obtained in step 1 and the next value in the sequence. This process keeps repeating until there are items in the sequence.The syntax of the reduce() function is as follows: Syntax: reduce(function, sequence[, initial]) -&gt; value When the initial value is provided, the function is called with the initial value and the first item from the sequence."},{"title":"191. Number of 1 Bits(easy)","path":"2022/09/30/191/","text":"191. Number of 1 Bits(easy)Write a function that takes an unsigned integer and returns the number of â€˜1â€™ bits it has (also known as the Hamming weight).Note:Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integerâ€™s internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2â€™s complement notation. Therefore, in Example 3, the input represents the signed integer. -3.1234567class Solution(object): def hammingWeight(self, n): res = 0 while n: res += n &amp; 1 n &gt;&gt;= 1 return res"},{"title":"LeetCode-skill9-bitwise","path":"2022/09/30/LeetCode-skill9-bitwise/","text":"ä½è¿ç®— Bit Manipulation n &amp; 1 ä½¿ç”¨ n &amp; 1 å¾—åˆ°äºŒè¿›åˆ¶æœ«å°¾æ˜¯å¦ä¸º 1ï¼›n &gt;&gt;= 1 æŠŠ n å³ç§» 1 ä½ï¼Œç›´è‡³ç»“æŸã€‚ bitæ“ä½œ&amp; ç¬¦å·ï¼Œx &amp; y ï¼Œä¼šå°†ä¸¤ä¸ªåè¿›åˆ¶æ•°åœ¨äºŒè¿›åˆ¶ä¸‹è¿›è¡Œä¸è¿ç®— ä¸è¿ç®—ï¼šåŒ1ä¸º1ï¼Œå¦åˆ™ä¸º0 12340 &amp; 0 = 00 &amp; 1 = 01 &amp; 0 = 01 &amp; 1 = 1 | ç¬¦å·ï¼Œx | y ï¼Œä¼šå°†ä¸¤ä¸ªåè¿›åˆ¶æ•°åœ¨äºŒè¿›åˆ¶ä¸‹è¿›è¡Œæˆ–è¿ç®— æˆ–è¿ç®—ï¼šåŒ0ä¸º0ï¼Œå¦åˆ™ä¸º1 12340 | 0 = 01 | 0 = 10 | 1 = 11 | 1 = 1 ^ ç¬¦å·ï¼Œx ^ y ï¼Œä¼šå°†ä¸¤ä¸ªåè¿›åˆ¶æ•°åœ¨äºŒè¿›åˆ¶ä¸‹è¿›è¡Œå¼‚æˆ–è¿ç®— å¼‚æˆ–ï¼šç›¸åŒä¸º0ï¼Œä¸åŒä¸º1 12340 ^ 0 = 00 ^ 1 = 11 ^ 0 = 11 ^ 1 = 0 &lt;&lt; ç¬¦å·ï¼Œx &lt;&lt; y å·¦ç§»æ“ä½œï¼Œæœ€å³è¾¹ç”¨ 0 å¡«å…… 10011 =&gt; 0110 ç¬¦å·ï¼Œx &gt;&gt; y å³ç§»æ“ä½œï¼Œæœ€å·¦è¾¹ç”¨ 0 å¡«å……~ ç¬¦å·ï¼Œ~x ï¼ŒæŒ‰ä½å–åæ“ä½œï¼Œå°† x åœ¨äºŒè¿›åˆ¶ä¸‹çš„æ¯ä¸€ä½å–å 1~0 = 1 x ^ 0 = x ä»»ä½•æ•°ä¸0å¼‚æˆ–ï¼Œç»“æœéƒ½æ˜¯å®ƒæœ¬èº«x ^ x = 0 ä»»ä½•æ•°ä¸å®ƒæœ¬èº«å¼‚æˆ–ï¼Œç»“æœéƒ½æ˜¯0x ^ 1s = x (1sä¸ºå…¨1) ä¸€ä¸ªæ•°å’Œå…¨1å¼‚æˆ–ï¼Œç›¸å½“äºå–åx ^ (x) = 1s ä¸€ä¸ªæ•°å’Œå®ƒå–ååçš„ç»“æœå¼‚æˆ–ï¼Œç»“æœä¸ºå…¨1c = a ^ b =&gt; a ^ c = b, b ^ c = a äº¤æ¢ä¸¤ä¸ªæ•°a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c åŠ æ³•ï¼ˆå¼‚æˆ–ï¼‰ç»“åˆå¾‹ x &amp; (0&lt;&lt;n) å°†xæœ€å³è¾¹çš„nä½æ¸…é›¶(x&gt;&gt;n) &amp; 1 è·å–xçš„ç¬¬nä½å€¼ï¼ˆ0æˆ–è€…1ï¼‰x &amp; (1&lt;&lt;n) è·å–xçš„ç¬¬nä½çš„å¹‚å€¼x ä¸¨ (1&lt;&lt;n) ä»…å°†ç¬¬nä½ç½®ä¸º1x &amp; ((1&lt;&lt;n) - 1) å°†xæœ€é«˜ä½è‡³ç¬¬nä½ï¼ˆåŒ…å«ï¼‰æ¸…é›¶x &amp; ((1 &lt;&lt; n)) ä»…å°†ç¬¬nä½ç½®ä¸º0 æ•´æ•°é›†åˆsetä½è¿ç®—æ•´æ•°é›†åˆåšæ ‡å¿—æ—¶ï¼Œæ¯”å¦‚å›æº¯æ—¶çš„visitedæ ‡å¿—æ•°ç»„vstd è®¿é—® i ï¼švstd | (1 &lt;&lt; i)vstd ç¦»å¼€ i ï¼švstd &amp; ~(1 &lt;&lt; i)vstd ä¸åŒ…å« i : not vstd &amp; (1 &lt;&lt; i) å¹¶é›† ï¼šA | Bäº¤é›† ï¼šA &amp; Bå…¨é›† ï¼š(1 &lt;&lt; n) - 1è¡¥é›† ï¼š((1 &lt;&lt; n) - 1) ^ Aå­é›† ï¼š(A &amp; B) == Båˆ¤æ–­æ˜¯å¦æ˜¯ 2 çš„å¹‚ ï¼šA &amp; (A - 1) == 0æœ€ä½ä½çš„ 1 å˜ä¸º 0 ï¼šn &amp;= (n - 1)æœ€ä½ä½çš„ 1ï¼šA &amp; (-A)ï¼Œæœ€ä½ä½çš„ 1 ä¸€èˆ¬è®°ä¸º lowbit(A) è¿™é¢˜æ²¡æœ‰è€ƒä»€ä¹ˆæ·±çš„ä¸œè¥¿ï¼Œä¸è¿‡å¯ä»¥å¤ä¹ ä¸€ä¸‹ python çš„å­—ç¬¦è¿ç®—è¯­æ³•ï¼š å¤ä¹ ä¸€ä¸‹ python çš„ä½è¿ç®—ç¬¦ï¼š (a &amp; b)æŒ‰ä½ä¸è¿ç®—ç¬¦ï¼šå‚ä¸è¿ç®—çš„ä¸¤ä¸ªå€¼ï¼Œå¦‚æœä¸¤ä¸ªç›¸åº”ä½éƒ½ä¸º 1ï¼Œåˆ™è¯¥ä½çš„ç»“æœä¸º 1ï¼Œå¦åˆ™ä¸º 0 ã€‚è¾“å‡ºç»“æœ 12 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0000 1100 (a | b)æŒ‰ä½æˆ–è¿ç®—ç¬¦ï¼šåªè¦å¯¹åº”çš„äºŒä¸ªäºŒè¿›ä½æœ‰ä¸€ä¸ªä¸º1æ—¶ï¼Œç»“æœä½å°±ä¸º1ã€‚è¾“å‡ºç»“æœ 61 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0011 1101 (a ^ b)æŒ‰ä½å¼‚æˆ–è¿ç®—ç¬¦ï¼šå½“ä¸¤å¯¹åº”çš„äºŒè¿›ä½ç›¸å¼‚æ—¶ï¼Œç»“æœä¸º 1è¾“å‡ºç»“æœ 49 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0011 0001 (a )æŒ‰ä½å–åè¿ç®—ç¬¦ï¼šå¯¹æ•°æ®çš„æ¯ä¸ªäºŒè¿›åˆ¶ä½å–åï¼Œå³æŠŠ 1 å˜ä¸º 0ï¼ŒæŠŠ 0 å˜ä¸º 1 ã€‚x ç±»ä¼¼äº -x-1è¾“å‡ºç»“æœ -61 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 1100 0011ï¼Œåœ¨ä¸€ä¸ªæœ‰ç¬¦å·äºŒè¿›åˆ¶æ•°çš„è¡¥ç å½¢å¼ã€‚ a &lt;&lt; 2å·¦ç§»åŠ¨è¿ç®—ç¬¦ï¼šè¿ç®—æ•°çš„å„äºŒè¿›ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ï¼Œç”± &lt;&lt; å³è¾¹çš„æ•°å­—æŒ‡å®šäº†ç§»åŠ¨çš„ä½æ•°ï¼Œé«˜ä½ä¸¢å¼ƒï¼Œä½ä½è¡¥ 0ã€‚è¾“å‡ºç»“æœ 240 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 1111 0000 a &gt;&gt; 2å³ç§»åŠ¨è¿ç®—ç¬¦ï¼šæŠŠ â€œ&gt;&gt;â€ å·¦è¾¹çš„è¿ç®—æ•°çš„å„äºŒè¿›ä½å…¨éƒ¨å³ç§»è‹¥å¹²ä½ï¼Œ&gt;&gt; å³è¾¹çš„æ•°å­—æŒ‡å®šäº†ç§»åŠ¨çš„ä½æ•°è¾“å‡ºç»“æœ 15 ï¼ŒäºŒè¿›åˆ¶è§£é‡Šï¼š 0000 1111 python èµ‹å€¼è¿ç®—ç¬¦ï¼š *= ä¹˜æ³•èµ‹å€¼è¿ç®—ç¬¦ c *= a ç­‰æ•ˆäº c = c * a/= é™¤æ³•èµ‹å€¼è¿ç®—ç¬¦ c /= a ç­‰æ•ˆäº c = c / a%= å–æ¨¡èµ‹å€¼è¿ç®—ç¬¦ c %= a ç­‰æ•ˆäº c = c % a**= å¹‚èµ‹å€¼è¿ç®—ç¬¦ c **= a ç­‰æ•ˆäº c = c ** a//= å–æ•´é™¤èµ‹å€¼è¿ç®—ç¬¦ c //= a ç­‰æ•ˆäº c = c // a Reverse Bits(easy) Number of 1 Bits è®¡ç®—æ•°å­—çš„äºŒè¿›åˆ¶ä¸­æœ‰å¤šå°‘ä¸ª1ã€‚ Single Numberæ‰¾å‡ºæ•°ç»„ä¸­ä¸é‡å¤çš„å…ƒç´ ã€‚å…¶å®ƒå…ƒç´ å‡ºç°ä¸¤æ¬¡ã€‚åŸé¢˜ Single Number IIæ‰¾å‡ºæ•°ç»„ä¸­å‡ºç°ä¸€æ¬¡çš„å…ƒç´ ï¼Œå…¶å®ƒå…ƒç´ å‡ºç°ä¸‰æ¬¡ã€‚åŸé¢˜ Add Binary(easy)äºŒè¿›åˆ¶åŠ æ³• Reverse Integer(medium)"},{"title":"218. The Skyline Problem(hard)","path":"2022/09/29/218/","text":"218. The Skyline Problem(hard)A cityâ€™s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:lefti is the x coordinate of the left edge of the ith building.righti is the x coordinate of the right edge of the ith building.heighti is the height of the ith building. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.The skyline should be represented as a list of â€œkey pointsâ€ sorted by their x-coordinate in the form [[x1,y1],[x2,y2],â€¦]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skylineâ€™s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skylineâ€™s contour.Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [â€¦,[2 3],[4 5],[7 5],[11 5],[12 7],â€¦] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [â€¦,[2 3],[4 5],[12 7],â€¦]12345Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]Explanation:Figure A shows the buildings of the input.Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution(object): def getSkyline(self, buildings: List[List[int]]) -&gt; List[List[int]]: # Iterate over the left and right edges of all the buildings, # If its a left edge, add (left, height) to &#x27;edges&#x27;. # Otherwise, add (right, -height) to &#x27;edges&#x27;. edges = [] for left, right, height in buildings: edges.append([left, height]) edges.append([right, -height]) edges.sort() # Initailize two empty priority queues &#x27;live&#x27; and &#x27;past&#x27; # for the live buildings and the past buildings. live, past = [], [] answer = [] idx = 0 # Iterate over all the sorted edges. while idx &lt; len(edges): # Since we might have multiple edges at same x, # Let the &#x27;curr_x&#x27; be the current position. curr_x = edges[idx][0] # While we are handling the edges at &#x27;curr_x&#x27;: while idx &lt; len(edges) and edges[idx][0] == curr_x: height = edges[idx][1] # If &#x27;height&#x27; &gt; 0, meaning a building of height &#x27;height&#x27; # is live, push &#x27;height&#x27; to &#x27;live&#x27;. # Otherwise, a building of height &#x27;height&#x27; is passed, # push the height to &#x27;past&#x27;. if height &gt; 0: heapq.heappush(live, -height) else: heapq.heappush(past, height) idx += 1 # While the top height from &#x27;live&#x27; equals to that from &#x27;past&#x27;, # Remove top height from both &#x27;live&#x27; and &#x27;past&#x27;. while past and past[0] == live[0]: heapq.heappop(live) heapq.heappop(past) # Get the maximum height from &#x27;live&#x27;. max_height = -live[0] if live else 0 # If the height changes at &#x27;curr_x&#x27;, we add this # skyline key point [curr_x, max_height] to &#x27;answer&#x27;. if not answer or answer[-1][1] != max_height: answer.append([curr_x, max_height]) # Return &#x27;answer&#x27; as the skyline. return answer"},{"title":"189. Rotate Array(medium)","path":"2022/09/29/189/","text":"189. Rotate Array(medium)Given an array, rotate the array to the right by k steps, where k is non-negative.123456Input: nums = [1,2,3,4,5,6,7], k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] è¿™é“é¢˜å…¶å®ä¸åƒæ˜¯rotateï¼Œæ„æ€æ˜¯æŠŠæœ€åä¸€ä¸ªæ•°ä¸æ–­çš„ç§»åˆ°ç¬¬ä¸€ä½ï¼Œå°±è·Ÿå¼€ç«è½¦ä¼¼çš„ã€‚æŠŠè¿™ä¸ªæ•°ç»„åˆ†æˆä¸¤éƒ¨åˆ†ï¼ŒPart1[P1] å’Œ Part2[P2]ä¸¾ä¸ªä¾‹å­ï¼š[P1] æ˜¯æœ€åä¸‰ä½æ•°å­—ä¹‹å‰çš„æ•°å­—ï¼Œ[1,2,3,4][P2] æ˜¯æˆ‘ä»¬è¦ç¿»è½¬çš„æ•°å­— [5,6,7]ç„¶ååˆ†åˆ«æŠŠP1 å’ŒP2å‰åè°ƒè½¬P1=[4321]P2=[765]è¿™æ ·æ•´ä¸ªæ•°ç»„å°±æ˜¯[4321765]å°†æœ€åä¸‰ä½ä¸å‰ä¸‰ä½äº’æ¢ä½ç½®å°±æ˜¯[5,6,7,1,2,3,4][P1] is defined as the array part just before the last 3 values. What I mean is something like [1,2,3,4][P2] is defined as the array part just after remaining values which we have to rotate [5,6,7] ä½†æ˜¯è¿™é‡Œæ ¹æ®Kæœ‰ä¸åŒçš„æƒ…å†µï¼Œæ¯”å¦‚è¯´k = 101, å°±æ˜¯è¯´Kå¤§äºæ•´ä¸ªæ•°ç»„é•¿åº¦äº†ï¼Œä½†æˆ‘ä»¬ä¸éœ€è¦ç¿»è½¬æ•°ç»„101æ¬¡ï¼Œåˆ©ç”¨Kå¯¹æ•°ç»„é•¿åº¦æ±‚ä½™å°±è¡Œï¼Œå› ä¸ºè½¬è¿‡7æ¬¡ä»¥åå°±æ˜¯ [1,2,3,4,5,6,7] 123456789101112131415161718192021222324class Solution: def reverse (self, nums, i, j) : li = i ri = j while li &lt; ri: temp = nums[li] nums[li] = nums[ri] nums[ri] = temp li += 1 ri -= 1 def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; k = k % len(nums) if k &lt; 0 : k += len(nums) self.reverse(nums, 0, len(nums) - k - 1); self.reverse(nums, len(nums) - k, len(nums) - 1); self.reverse(nums, 0, len(nums) - 1);"},{"title":"622. Design Circular Queue(medium)","path":"2022/09/25/622/","text":"622. Design Circular Queue(medium)Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called â€œRing Bufferâ€.One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.Implementation the MyCircularQueue class:MyCircularQueue(k) Initializes the object with the size of the queue to be k.int Front() Gets the front item from the queue. If the queue is empty, return -1.int Rear() Gets the last item from the queue. If the queue is empty, return -1.boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.boolean isEmpty() Checks whether the circular queue is empty or not.boolean isFull() Checks whether the circular queue is full or not. You must solve the problem without using the built-in queue data structure in your programming language.1234567891011121314151617Input[&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;][[3], [1], [2], [3], [4], [], [], [], [4], []]Output[null, true, true, true, false, 3, true, true, true, 4]ExplanationMyCircularQueue myCircularQueue = new MyCircularQueue(3);myCircularQueue.enQueue(1); // return TruemyCircularQueue.enQueue(2); // return TruemyCircularQueue.enQueue(3); // return TruemyCircularQueue.enQueue(4); // return FalsemyCircularQueue.Rear(); // return 3myCircularQueue.isFull(); // return TruemyCircularQueue.deQueue(); // return TruemyCircularQueue.enQueue(4); // return TruemyCircularQueue.Rear(); // return 4 å¾ªç¯é˜Ÿåˆ—å°±æ˜¯å°†é˜Ÿåˆ—å­˜å‚¨ç©ºé—´çš„æœ€åä¸€ä¸ªä½ç½®ç»•åˆ°ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå½¢æˆé€»è¾‘ä¸Šçš„ç¯çŠ¶ç©ºé—´ï¼Œä¾›é˜Ÿåˆ—å¾ªç¯ä½¿ç”¨ã€‚åœ¨å¾ªç¯é˜Ÿåˆ—ç»“æ„ä¸­ï¼Œå½“å­˜å‚¨ç©ºé—´çš„æœ€åä¸€ä¸ªä½ç½®å·²è¢«ä½¿ç”¨è€Œå†è¦è¿›å…¥é˜Ÿè¿ç®—æ—¶ï¼Œåªéœ€è¦å­˜å‚¨ç©ºé—´çš„ç¬¬ä¸€ä¸ªä½ç½®ç©ºé—²ï¼Œä¾¿å¯å°†å…ƒç´ åŠ å…¥åˆ°ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå³å°†å­˜å‚¨ç©ºé—´çš„ç¬¬ä¸€ä¸ªä½ç½®ä½œä¸ºé˜Ÿå°¾ã€‚å¾ªç¯é˜Ÿåˆ—å¯ä»¥æ›´ç®€å•é˜²æ­¢ä¼ªæº¢å‡ºçš„å‘ç”Ÿï¼Œä½†é˜Ÿåˆ—å¤§å°æ˜¯å›ºå®šçš„ã€‚ åœ¨å¾ªç¯é˜Ÿåˆ—ä¸­ï¼Œå½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œæœ‰front=rearï¼Œè€Œå½“æ‰€æœ‰é˜Ÿåˆ—ç©ºé—´å…¨å æ»¡æ—¶ï¼Œä¹Ÿæœ‰front=rearã€‚ä¸ºäº†åŒºåˆ«è¿™ä¸¤ç§æƒ…å†µï¼Œè§„å®šå¾ªç¯é˜Ÿåˆ—æœ€å¤šåªèƒ½æœ‰MaxSize-1ä¸ªé˜Ÿåˆ—å…ƒç´ ï¼Œå½“å¾ªç¯é˜Ÿåˆ—ä¸­åªå‰©ä¸‹ä¸€ä¸ªç©ºå­˜å‚¨å•å…ƒæ—¶ï¼Œé˜Ÿåˆ—å°±å·²ç»æ»¡äº†ã€‚å› æ­¤ï¼Œé˜Ÿåˆ—åˆ¤ç©ºçš„æ¡ä»¶æ˜¯front=rearï¼Œè€Œé˜Ÿåˆ—åˆ¤æ»¡çš„æ¡ä»¶æ˜¯front=ï¼ˆrear+1)%MaxSizeã€‚ Solutionå¯¹äºä¸€ä¸ªå›ºå®šå¤§å°çš„æ•°ç»„ï¼Œåªè¦çŸ¥é“é˜Ÿå°¾ rear ä¸é˜Ÿé¦– frontï¼Œå³å¯è®¡ç®—å‡ºé˜Ÿåˆ—å½“å‰çš„é•¿åº¦ï¼šfront=ï¼ˆrear+1)%capacity å¾ªç¯é˜Ÿåˆ—çš„å±æ€§å¦‚ä¸‹:elementsï¼šä¸€ä¸ªå›ºå®šå¤§å°çš„æ•°ç»„ï¼Œç”¨äºä¿å­˜å¾ªç¯é˜Ÿåˆ—çš„å…ƒç´ ã€‚capacityï¼šå¾ªç¯é˜Ÿåˆ—çš„å®¹é‡ï¼Œå³é˜Ÿåˆ—ä¸­æœ€å¤šå¯ä»¥å®¹çº³çš„å…ƒç´ æ•°é‡ã€‚frontï¼šé˜Ÿåˆ—é¦–å…ƒç´ å¯¹åº”çš„æ•°ç»„çš„ç´¢å¼•ã€‚rearï¼šé˜Ÿåˆ—å°¾å…ƒç´ å¯¹åº”çš„ç´¢å¼•çš„ä¸‹ä¸€ä¸ªç´¢å¼•ã€‚å¾ªç¯é˜Ÿåˆ—çš„æ¥å£æ–¹æ³•å¦‚ä¸‹ï¼š MyCircularQueue(int k): åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒåŒæ—¶base æ•°ç»„çš„ç©ºé—´åˆå§‹åŒ–å¤§å°ä¸º k + 1ã€‚front,rear å…¨éƒ¨åˆå§‹åŒ–ä¸º 0ã€‚enQueue(int value)ï¼šåœ¨é˜Ÿåˆ—çš„å°¾éƒ¨æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶åŒæ—¶å°†é˜Ÿå°¾çš„ç´¢å¼• rear æ›´æ–°ä¸º (rear+1)%capacityã€‚deQueue()ï¼šä»é˜Ÿé¦–å–å‡ºä¸€ä¸ªå…ƒç´ ï¼Œå¹¶åŒæ—¶å°†é˜Ÿé¦–çš„ç´¢å¼• front æ›´æ–°ä¸º (front+1)% capacityã€‚Front()ï¼šè¿”å›é˜Ÿé¦–çš„å…ƒç´ ï¼Œéœ€è¦æ£€æµ‹é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚Rear()ï¼šè¿”å›é˜Ÿå°¾çš„å…ƒç´ ï¼Œéœ€è¦æ£€æµ‹é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚isEmpty()ï¼šæ£€æµ‹é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œæ ¹æ®ä¹‹å‰çš„å®šä¹‰åªéœ€åˆ¤æ–­ rear æ˜¯å¦ç­‰äº frontã€‚isFull()ï¼šæ£€æµ‹é˜Ÿåˆ—æ˜¯å¦å·²æ»¡ï¼Œæ ¹æ®ä¹‹å‰çš„å®šä¹‰åªéœ€åˆ¤æ–­ front æ˜¯å¦ç­‰äº (rear+1)% capacityã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyCircularQueue: def __init__(self, k: int): self.front=self.rear=0 self.elements=[0]*(k+1) def enQueue(self, value: int) -&gt; bool: if self.isFull(): return False self.elements[self.rear]=value self.rear=(self.rear+1)%len(self.elements) return True def deQueue(self) -&gt; bool: if self.isEmpty(): return False self.front=(self.front+1)%len(self.elements) return True def Front(self) -&gt; int: return -1 if self.isEmpty() else self.elements[self.front] def Rear(self) -&gt; int: return -1 if self.isEmpty() else self.elements[(self.rear - 1) % len(self.elements)] def isEmpty(self) -&gt; bool: return self.rear==self.front def isFull(self) -&gt; bool: return (self.rear+1)%len(self.elements)==self.front # Your MyCircularQueue object will be instantiated and called as such:# obj = MyCircularQueue(k)# param_1 = obj.enQueue(value)# param_2 = obj.deQueue()# param_3 = obj.Front()# param_4 = obj.Rear()# param_5 = obj.isEmpty()# param_6 = obj.isFull()"},{"title":"1002. Find Common Characters(easy)","path":"2022/09/25/1002/","text":"1002. Find Common Characters(easy)Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.12Input: words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] è¿™ä¸ªå°±æ˜¯åˆ©ç”¨hashmapåˆ¤æ–­æ•°é‡å’Œæ˜¯å¦å­˜åœ¨ï¼Œç„¶åç”¨&amp;=åˆ¤æ–­ç›¸åŒå€¼ 123456class Solution: def commonChars(self, words: List[str]) -&gt; List[str]: res = collections.Counter(words[0]) for word in words: res &amp;=collections.Counter(word) return list(res.elements())"},{"title":"1081. Smallest Subsequence of Distinct Characters(medium)","path":"2022/09/24/1081/","text":"1081. Smallest Subsequence of Distinct Characters(medium)Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.ç›¸ä¼¼é¢˜å‹316. å»é™¤é‡å¤å­—æ¯(å›°éš¾)321. æ‹¼æ¥æœ€å¤§æ•°(å›°éš¾)402. ç§»æ‰ K ä½æ•°å­—(ä¸­ç­‰)1081. ä¸åŒå­—ç¬¦çš„æœ€å°å­åºåˆ—ï¼ˆä¸­ç­‰ï¼‰ Solutionè¿™é¢˜å’Œ316ä¸€æ¨¡ä¸€æ ·ï¼Œä»£ç ä¸éœ€è¦æ›´æ”¹ class Solution: def smallestSubsequence(self, s: str) -&gt; str: stack=[] remain_counter=collections.Counter(s) for c in s: if c not in stack: while stack and c&lt;stack[-1] and remain_counter[stack[-1]]&gt;0: stack.pop() stack.append(c) remain_counter[c]-=1 return &#39;&#39;.join(stack)"},{"title":"321. Create Maximum Number(hard)","path":"2022/09/24/321/","text":"321. Create Maximum Number(hard)You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.Return an array of the k digits representing the answer.ç›¸ä¼¼é¢˜å‹316. å»é™¤é‡å¤å­—æ¯(å›°éš¾)321. æ‹¼æ¥æœ€å¤§æ•°(å›°éš¾)402. ç§»æ‰ K ä½æ•°å­—(ä¸­ç­‰)1081. ä¸åŒå­—ç¬¦çš„æœ€å°å­åºåˆ—ï¼ˆä¸­ç­‰ï¼‰ 12Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5Output: [9,8,6,5,3] Solutionå‰ç½®çŸ¥è¯† åˆ†æ²» æ•°å­¦æ€è·¯å’Œ316. å»é™¤é‡å¤å­—æ¯ ç±»ä¼¼ï¼Œåªä¸ä¸è¿‡è¿™ä¸€æ¬¡æ˜¯ä¸¤ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªï¼Œå¹¶ä¸”æ˜¯æ±‚æœ€å¤§æ•°ã€‚ æœ€å¤§æœ€å°æ˜¯æ— å…³ç´§è¦çš„ï¼Œå…³é”®åœ¨äºæ˜¯ä¸¤ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”è¦æ±‚ä»ä¸¤ä¸ªæ•°ç»„é€‰å–çš„å…ƒç´ ä¸ªæ•°åŠ èµ·æ¥ä¸€å…±æ˜¯ kã€‚ ç„¶è€Œåœ¨ä¸€ä¸ªæ•°ç»„ä¸­å– k ä¸ªæ•°å­—ï¼Œå¹¶ä¿æŒå…¶æœ€å°ï¼ˆæˆ–è€…æœ€å¤§ï¼‰ï¼Œæˆ‘ä»¬å·²ç»ä¼šäº†ã€‚ä½†æ˜¯å¦‚æœé—®é¢˜æ‰©å±•åˆ°ä¸¤ä¸ªï¼Œä¼šæœ‰ä»€ä¹ˆå˜åŒ–å‘¢ï¼Ÿ å®é™…ä¸Šï¼Œé—®é¢˜æœ¬è´¨å¹¶æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚ å‡è®¾æˆ‘ä»¬ä» nums1 ä¸­å–äº† k1 ä¸ªï¼Œä» num2 ä¸­å–äº† k2 ä¸ªï¼Œå…¶ä¸­ k1 + k2 = kã€‚è€Œ k1 å’Œ k2 è¿™ ä¸¤ä¸ªå­é—®é¢˜æˆ‘ä»¬æ˜¯ä¼šè§£å†³çš„ã€‚ç”±äºè¿™ä¸¤ä¸ªå­é—®é¢˜æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦åˆ†åˆ«æ±‚è§£ï¼Œç„¶åå°†ç»“æœåˆå¹¶å³å¯ã€‚ å‡å¦‚ k1 å’Œ k2 ä¸ªæ•°å­—ï¼Œå·²ç»å–å‡ºæ¥äº†ã€‚é‚£ä¹ˆå‰©ä¸‹è¦åšçš„å°±æ˜¯å°†è¿™ä¸ªé•¿åº¦åˆ†åˆ«ä¸º k1 å’Œ k2 çš„æ•°å­—ï¼Œåˆå¹¶æˆä¸€ä¸ªé•¿åº¦ä¸º k çš„æ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ€å¤§çš„æ•°ç»„ã€‚ ä»¥é¢˜ç›®çš„ nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 ä¸ºä¾‹ã€‚ å‡å¦‚æˆ‘ä»¬ä» num1 ä¸­å–å‡º 1 ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆå°±è¦ä» nums2 ä¸­å–å‡º 4 ä¸ªæ•°å­—ã€‚ è¿ç”¨ç¬¬ä¸€é¢˜çš„æ–¹æ³•ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºåº”è¯¥å– nums1 çš„ [6]ï¼Œå¹¶å– nums2 çš„ [9,5,8,3]ã€‚ å¦‚ä½•å°† [6] å’Œ [9,5,8,3]ï¼Œä½¿å¾—æ•°å­—å°½å¯èƒ½å¤§ï¼Œå¹¶ä¸”ä¿æŒç›¸å¯¹ä½ç½®ä¸å˜å‘¢ï¼Ÿ å®é™…ä¸Šè¿™ä¸ªè¿‡ç¨‹æœ‰ç‚¹ç±»ä¼¼å½’å¹¶æ’åºä¸­çš„æ²»ï¼Œè€Œä¸Šé¢æˆ‘ä»¬åˆ†åˆ«è®¡ç®— num1 å’Œ num2 çš„æœ€å¤§æ•°çš„è¿‡ç¨‹ç±»ä¼¼å½’å¹¶æ’åºä¸­çš„åˆ†ã€‚ æˆ‘ä»¬å°†ä» num1 ä¸­æŒ‘é€‰çš„ k1 ä¸ªæ•°ç»„æˆçš„æ•°ç»„ç§°ä¹‹ä¸º Aï¼Œå°†ä» num2 ä¸­æŒ‘é€‰çš„ k2 ä¸ªæ•°ç»„æˆçš„æ•°ç»„ç§°ä¹‹ä¸º Bï¼Œ 1234567def merge(A, B): ans = [] while A or B: bigger = A if A &gt; B else B ans.append(bigger[0]) bigger.pop(0) return ans è¿™é‡Œéœ€è¦è¯´æ˜ä¸€ä¸‹ã€‚ åœ¨å¾ˆå¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼šå¦‚æœ A å’Œ B æ˜¯ä¸¤ä¸ªæ•°ç»„ï¼Œå½“å‰ä»…å½“ A çš„é¦–ä¸ªå…ƒç´ å­—å…¸åºå¤§äº B çš„é¦–ä¸ªå…ƒç´ ï¼ŒA &gt; B è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚ æ¯”å¦‚ï¼š 1234567A = [1,2]B = [2]A &lt; B # TrueA = [1,2]B = [1,2,3]A &lt; B # False å…·ä½“ç®—æ³•ï¼šä» nums1 ä¸­ å– min(i, len(nums1)) ä¸ªæ•°å½¢æˆæ–°çš„æ•°ç»„ Aï¼ˆå–çš„é€»è¾‘åŒç¬¬ä¸€é¢˜ï¼‰ï¼Œå…¶ä¸­ i ç­‰äº 0,1,2, â€¦ kã€‚ä» nums2 ä¸­ å¯¹åº”å– min(j, len(nums2)) ä¸ªæ•°å½¢æˆæ–°çš„æ•°ç»„ Bï¼ˆå–çš„é€»è¾‘åŒç¬¬ä¸€é¢˜ï¼‰ï¼Œå…¶ä¸­ j ç­‰äº k - iã€‚å°† A å’Œ B æŒ‰ç…§ä¸Šé¢çš„ merge æ–¹æ³•åˆå¹¶ä¸Šé¢æˆ‘ä»¬æš´åŠ›äº† k ç§ç»„åˆæƒ…å†µï¼Œæˆ‘ä»¬åªéœ€è¦å°† k ç§æƒ…å†µå–å‡ºæœ€å¤§å€¼å³å¯ã€‚ 1234567891011121314151617181920212223class Solution: def maxNumber(self, nums1, nums2, k): def pick_max(nums, k): stack = [] drop = len(nums) - k for num in nums: while drop and stack and stack[-1] &lt; num: stack.pop() drop -= 1 stack.append(num) return stack[:k] def merge(A, B): ans = [] while A or B: bigger = A if A &gt; B else B ans.append(bigger[0]) bigger.pop(0) return ans return max(merge(pick_max(nums1, i), pick_max(nums2, k-i)) for i in range(k+1) if i &lt;= len(nums1) and k-i &lt;= len(nums2)) å¤æ‚åº¦åˆ†ææ—¶é—´å¤æ‚åº¦ï¼špick_max çš„æ—¶é—´å¤æ‚åº¦ä¸º O(M + N)O(M+N) ï¼Œå…¶ä¸­ MM ä¸º nums1 çš„é•¿åº¦ï¼ŒNN ä¸º nums2 çš„é•¿åº¦ã€‚ merge çš„æ—¶é—´å¤æ‚åº¦ä¸º O(k)O(k)ï¼Œå†åŠ ä¸Šå¤–å±‚éå†æ‰€æœ‰çš„ k ä¸­å¯èƒ½æ€§ã€‚å› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º O(k^2 * (M + N))O(k^2 âˆ—(M+N))ã€‚ç©ºé—´å¤æ‚åº¦ï¼šæˆ‘ä»¬ä½¿ç”¨äº†é¢å¤–çš„ stack å’Œ ans æ•°ç»„ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º O(max(M, N, k))ï¼Œå…¶ä¸­ MM ä¸º nums1 çš„é•¿åº¦ï¼ŒNN ä¸º nums2 çš„é•¿åº¦ã€‚"},{"title":"316. Remove Duplicate Letters","path":"2022/09/24/316/","text":"316. Remove Duplicate Letters(medium)Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.12Input: s = &quot;bcabc&quot;Output: &quot;abc&quot; ç›¸ä¼¼é¢˜å‹316. å»é™¤é‡å¤å­—æ¯(å›°éš¾)321. æ‹¼æ¥æœ€å¤§æ•°(å›°éš¾)402. ç§»æ‰ K ä½æ•°å­—(ä¸­ç­‰)1081. ä¸åŒå­—ç¬¦çš„æœ€å°å­åºåˆ—ï¼ˆä¸­ç­‰ï¼‰ è¿™é“é¢˜å’Œ402. ç§»æ‰ K ä½æ•°å­—(ä¸­ç­‰)å·®ä¸å¤šï¼Œä¹Ÿæ˜¯åˆ©ç”¨æ ˆçš„ç‰¹æ€§å‡å°‘æ—¶é—´å¤æ‚åº¦ Solutionå‡½æ•°å“ˆå¸Œè¡¨åœ¨pythonä¸­å¯ä»¥ç”¨collections.Counterè®¡æ•°æ¥ä½“ç°ã€‚è¯¥æ–¹æ³•ç”¨äºç»Ÿè®¡æŸåºåˆ—ä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œä»¥é”®å€¼å¯¹çš„æ–¹å¼å­˜åœ¨å­—å…¸ä¸­ã€‚ä½†ç±»å‹å…¶å®æ˜¯Counterã€‚ 12345nums = [1, 2, 3, 1, 2, 1]counts = collections.Counter(nums)print(counts)## Counter(&#123;1: 3, 2: 2, 3: 1&#125;) å‡­å€Ÿè¿™ä¸ªç»“æ„ï¼Œå¯ä»¥è®¡ç®—å‡ºæŸä¸ªåºåˆ—ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„æŸä¸ªå…ƒç´ ã€‚ä¹Ÿå³åœ¨å¾—åˆ°äº†countsä¹‹åæ±‚maxå³å¯ã€‚ä½†è¿™ä¸ªmaxéœ€è¦ç»™ä¾æ®ç´¢å¼•ã€‚ 12print(max(counts)) # 3ï¼Œè¿™é‡Œåªæ˜¯æ±‚å¾—æœ€å¤§çš„é”®å€¼print(max(counts.keys(), key=counts.get)) # 1ï¼Œè¿™é‡Œæ˜¯æŒ‰ç…§keyæ–¹æ³•æ±‚æœ€å¤§ è¿™é‡Œmaxæ˜¯ä¸¤ä¸ªå‚æ•°ï¼Œå‰ä¸€ä¸ªä»£è¡¨è¦maxçš„æ˜¯ä»€ä¹ˆï¼Œä¹Ÿå°±æ˜¯è¦è¿”å›æœ€å¤§é”®ï¼Œåé¢çš„keyä»£è¡¨è¦è¿”å›çš„æœ€å¤§çš„ä¾æ®æ˜¯ä»€ä¹ˆï¼Œé»˜è®¤æ˜¯æœ¬èº«ï¼Œä½†è¿™é‡Œç»™äº†keyæ–¹æ³•ï¼Œcount.getä¹Ÿå°±æ˜¯æ±‚å€¼ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•å°±æ˜¯è¯´è¿”å›ä¸€ä¸ªæœ€å¤§é”®ï¼Œä½†è¿™ä¸ªæœ€å¤§çš„ä¾æ®æ˜¯å€¼ã€‚å¦‚æœæŸä¸ªé”®å€¼å¯¹çš„å€¼æ˜¯æœ€å¤§çš„ï¼Œé‚£å°±è¿”å›å…¶é”®ã€‚ 12dic = dict(counts)print(dic.get(1)) # 4 getåœ¨å­—å…¸ä¸­å°±æ˜¯ä¼ ä¸€ä¸ªé”®ï¼Œæ ¹æ®é”®æ±‚å¯¹åº”çš„å€¼ã€‚ å‰é¢æ˜¯ä¸€ç§ç†è§£ï¼Œä½†maxçš„ä¸¤ä¸ªå‚æ•°ä¹Ÿå¯ä»¥ç†è§£ä¸ºkeyåé¢çš„æ–¹æ³•æ˜¯è¦å°†å‰é¢çš„ç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºå‚æ•°ï¼Œä¹Ÿå°±æ˜¯counts.keys()è¦ä½œä¸ºcounts.getçš„å‚æ•°ï¼Œç„¶åæ±‚maxã€‚å³geté”®å¯¹åº”çš„å€¼ï¼Œç„¶åè¿”å›æœ€å¤§çš„å€¼å¯¹åº”çš„é”®ï¼ˆæ„Ÿè§‰pythonä¸­å­˜åœ¨å¾ˆå¤šè¿™ç§æƒ…å†µï¼Œæ¯”å¦‚lambdaè¡¨è¾¾å¼ï¼Œåé¢ä¹Ÿæ˜¯ä¼ ä¸€ä¸ªfuncæ¥å°†å‰é¢çš„å‚æ•°å¸¦å…¥ï¼‰ å‰ç½®çŸ¥è¯†å­—å…¸åºæ•°å­¦æ€è·¯ä¸ä¸Šé¢é¢˜ç›®ä¸åŒï¼Œè¿™é“é¢˜æ²¡æœ‰ä¸€ä¸ªå…¨å±€çš„åˆ é™¤æ¬¡æ•° kã€‚è€Œæ˜¯å¯¹äºæ¯ä¸€ä¸ªåœ¨å­—ç¬¦ä¸² s ä¸­å‡ºç°çš„å­—æ¯ c éƒ½æœ‰ä¸€ä¸ª k å€¼ã€‚è¿™ä¸ª k æ˜¯ c å‡ºç°æ¬¡æ•° - 1ã€‚ æ²¿ç”¨ä¸Šé¢çš„çŸ¥è¯†çš„è¯ï¼Œæˆ‘ä»¬é¦–å…ˆè¦åšçš„å°±æ˜¯è®¡ç®—æ¯ä¸€ä¸ªå­—ç¬¦çš„ kï¼Œå¯ä»¥ç”¨ä¸€ä¸ªå­—å…¸æ¥æè¿°è¿™ç§å…³ç³»ï¼Œå…¶ä¸­ key ä¸º å­—ç¬¦ cï¼Œvalue ä¸ºå…¶å‡ºç°çš„æ¬¡æ•°ã€‚ å…·ä½“ç®—æ³•ï¼šå»ºç«‹ä¸€ä¸ªå­—å…¸ã€‚å…¶ä¸­ key ä¸º å­—ç¬¦ cï¼Œvalue ä¸ºå…¶å‡ºç°çš„å‰©ä½™æ¬¡æ•°ã€‚ä»å·¦å¾€å³éå†å­—ç¬¦ä¸²ï¼Œæ¯æ¬¡éå†åˆ°ä¸€ä¸ªå­—ç¬¦ï¼Œå…¶å‰©ä½™å‡ºç°æ¬¡æ•° - 1.å¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœå…¶å¯¹åº”çš„å‰©ä½™å‡ºç°æ¬¡æ•°å¤§äº 1ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä¸¢å¼ƒï¼ˆä¹Ÿå¯ä»¥é€‰æ‹©ä¸ä¸¢å¼ƒï¼‰ï¼Œå¦åˆ™ä¸å¯ä»¥ä¸¢å¼ƒã€‚æ˜¯å¦ä¸¢å¼ƒçš„æ ‡å‡†å’Œä¸Šé¢é¢˜ç›®ç±»ä¼¼ã€‚å¦‚æœæ ˆä¸­ç›¸é‚»çš„å…ƒç´ å­—å…¸åºæ›´å¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬é€‰æ‹©ä¸¢å¼ƒç›¸é‚»çš„æ ˆä¸­çš„å…ƒç´ ã€‚è¿˜è®°å¾—ä¸Šé¢é¢˜ç›®çš„è¾¹ç•Œæ¡ä»¶ä¹ˆï¼Ÿå¦‚æœæ ˆä¸­å‰©ä¸‹çš„å…ƒç´ å¤§äº n - knâˆ’kï¼Œæˆ‘ä»¬é€‰æ‹©æˆªå–å‰ n - knâˆ’k ä¸ªæ•°å­—ã€‚ç„¶è€Œæœ¬é¢˜ä¸­çš„ k æ˜¯åˆ†æ•£åœ¨å„ä¸ªå­—ç¬¦ä¸­çš„ï¼Œå› æ­¤è¿™ç§æ€è·¯ä¸å¯è¡Œçš„ã€‚ ä¸è¿‡ä¸å¿…æ‹…å¿ƒã€‚ç”±äºé¢˜ç›®æ˜¯è¦æ±‚åªå‡ºç°ä¸€æ¬¡ã€‚æˆ‘ä»¬å¯ä»¥åœ¨éå†çš„æ—¶å€™ç®€å•åœ°åˆ¤æ–­å…¶æ˜¯å¦åœ¨æ ˆä¸Šå³å¯ã€‚ 123456789101112class Solution: def removeDuplicateLetters(self, s) -&gt; int: stack = [] remain_counter = collections.Counter(s) for c in s: if c not in stack: while stack and c &lt; stack[-1] and remain_counter[stack[-1]] &gt; 0: stack.pop() stack.append(c) remain_counter[c] -= 1 return &#x27;&#x27;.join(stack) å¤æ‚åº¦åˆ†æ æ—¶é—´å¤æ‚åº¦ï¼šç”±äºåˆ¤æ–­å½“å‰å­—ç¬¦æ˜¯å¦åœ¨æ ˆä¸Šå­˜åœ¨éœ€è¦ O(N)çš„æ—¶é—´ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ O(N^2)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚ç©ºé—´å¤æ‚åº¦ï¼šæˆ‘ä»¬ä½¿ç”¨äº†é¢å¤–çš„æ ˆæ¥å­˜å‚¨æ•°å­—ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚ ä¼˜åŒ–ï¼šåˆ©ç”¨hashsetç©ºé—´æ¢æ—¶é—´ 123456789101112131415class Solution: def removeDuplicateLetters(self, s) -&gt; int: stack = [] seen = set() remain_counter = collections.Counter(s) for c in s: if c not in seen: while stack and c &lt; stack[-1] and remain_counter[stack[-1]] &gt; 0: seen.discard(stack.pop()) seen.add(c) stack.append(c) remain_counter[c] -= 1 return &#x27;&#x27;.join(stack) å¤æ‚åº¦åˆ†æ æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚ç©ºé—´å¤æ‚åº¦ï¼šæˆ‘ä»¬ä½¿ç”¨äº†é¢å¤–çš„æ ˆå’Œ hashsetï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º O(N)ï¼Œå…¶ä¸­ N ä¸ºå­—ç¬¦ä¸²é•¿åº¦ã€‚"},{"title":"985. Sum of Even Numbers After Queries(medium)","path":"2022/09/21/985/","text":"985. Sum of Even Numbers After Queries(medium)You are given an integer array nums and an array queries where queries[i] = [vali, indexi].For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.Return an integer array answer where answer[i] is the answer to the ith query.1234567Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]Output: [8,6,2,4]Explanation: At the beginning, the array is [1,2,3,4].After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. è¿™é“é¢˜çš„æ€è·¯å¾ˆæœ‰ç‰¹ç‚¹ï¼Œç»´æŠ¤ä¸€ä¸ªæ•°ç»„ï¼Œå…ˆæŠŠåŸæ•°ç»„çš„å¶æ•°å’Œæ±‚å‡ºæ¥ï¼Œæ¥ä¸‹æ¥æ ¹æ®queriesä¸æ–­è°ƒæ•´ Sï¼Œå³æ¯ä¸€æ­¥æ“ä½œä¹‹åæ•´ä¸ªæ•°ç»„çš„å¶æ•°å’Œã€‚æ“ä½œæ•°ç»„ä¸­çš„æŸä¸€ä¸ªå…ƒç´  A[index] çš„æ—¶å€™ï¼Œæ•°ç»„ A å…¶ä»–ä½ç½®çš„å…ƒç´ éƒ½åº”ä¿æŒä¸å˜ã€‚å¦‚æœ A[index] æ˜¯å¶æ•°ï¼Œæˆ‘ä»¬å°±ä» S ä¸­å‡å»å®ƒï¼Œç„¶åè®¡ç®— A[index] + val å¯¹ S çš„å½±å“ï¼ˆå¦‚æœæ˜¯å¶æ•°åˆ™åœ¨ S ä¸­åŠ ä¸Šå®ƒï¼‰ã€‚ç›¸å½“äºå†è®¡ç®—å‰å…ˆæŠŠè¿™ä¸ªvalueå‡å»ï¼ˆå¦‚æœæ˜¯å¶æ•°ï¼‰ï¼Œç®—ä¸Šæ–°åŠ å…¥çš„indexå†è®¡ç®—å¯¹æ•´ä¸ªå’Œçš„å½±å“ï¼ˆå¦‚æœæ˜¯å¶æ•°ï¼‰ 123456789101112131415class Solution: def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -&gt; List[int]: even_sum=0 for num in nums: if num%2==0: even_sum+=num ans=[] for val,i in queries: if nums[i]%2==0: even_sum-=nums[i] nums[i]+=val if nums[i]%2==0: even_sum+=nums[i] ans.append(even_sum) return ans"},{"title":"402. Remove K Digits(medium)","path":"2022/09/21/402/","text":"402. Remove K Digits(medium)Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.ç›¸ä¼¼é¢˜å‹316. å»é™¤é‡å¤å­—æ¯(å›°éš¾)321. æ‹¼æ¥æœ€å¤§æ•°(å›°éš¾)402. ç§»æ‰ K ä½æ•°å­—(ä¸­ç­‰)1081. ä¸åŒå­—ç¬¦çš„æœ€å°å­åºåˆ—ï¼ˆä¸­ç­‰ï¼‰ ç»™å®šä¸€ä¸ªä»¥å­—ç¬¦ä¸²è¡¨ç¤ºçš„éè´Ÿæ•´æ•° numï¼Œç§»é™¤è¿™ä¸ªæ•°ä¸­çš„ k ä½æ•°å­—ï¼Œä½¿å¾—å‰©ä¸‹çš„æ•°å­—æœ€å°ã€‚ æ³¨æ„:num çš„é•¿åº¦å°äº 10002 ä¸” â‰¥ kã€‚num ä¸ä¼šåŒ…å«ä»»ä½•å‰å¯¼é›¶ã€‚ 123456789101112131415ç¤ºä¾‹ 1 :è¾“å…¥: num = &quot;1432219&quot;, k = 3è¾“å‡º: &quot;1219&quot;è§£é‡Š: ç§»é™¤æ‰ä¸‰ä¸ªæ•°å­— 4, 3, å’Œ 2 å½¢æˆä¸€ä¸ªæ–°çš„æœ€å°çš„æ•°å­— 1219ã€‚ç¤ºä¾‹ 2 :è¾“å…¥: num = &quot;10200&quot;, k = 1è¾“å‡º: &quot;200&quot;è§£é‡Š: ç§»æ‰é¦–ä½çš„ 1 å‰©ä¸‹çš„æ•°å­—ä¸º 200. æ³¨æ„è¾“å‡ºä¸èƒ½æœ‰ä»»ä½•å‰å¯¼é›¶ã€‚ç¤ºä¾‹ 3 :è¾“å…¥: num = &quot;10&quot;, k = 2è¾“å‡º: &quot;0&quot;è§£é‡Š: ä»åŸæ•°å­—ç§»é™¤æ‰€æœ‰çš„æ•°å­—ï¼Œå‰©ä½™ä¸ºç©ºå°±æ˜¯ 0ã€‚ å‡½æ•° 1231. strip():- This method is used to delete all the leading and trailing characters mentioned in its argument.2. lstrip():- This method is used to delete all the leading characters mentioned in its argument.3. rstrip():- This method is used to delete all the trailing characters mentioned in its argument. 123456789101112131415161718# Python code to demonstrate working of# strip(), lstrip() and rstrip()str = &quot;---geeksforgeeks---&quot;# using strip() to delete all &#x27;-&#x27;print ( &quot; String after stripping all &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.strip(&#x27;-&#x27;) )# String after stripping all &#x27;-&#x27; is : geeksforgeeks# using lstrip() to delete all trailing &#x27;-&#x27;print ( &quot; String after stripping all leading &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.lstrip(&#x27;-&#x27;) )# String after stripping all leading &#x27;-&#x27; is : geeksforgeeks---# using rstrip() to delete all leading &#x27;-&#x27;print ( &quot; String after stripping all trailing &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.rstrip(&#x27;-&#x27;) )# String after stripping all trailing &#x27;-&#x27; is : ---geeksforgeeks Python join() æ–¹æ³•ç”¨äºå°†åºåˆ—ä¸­çš„å…ƒç´ ä»¥æŒ‡å®šçš„å­—ç¬¦è¿æ¥ç”Ÿæˆä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ã€‚str.join(sequence) sequence â€“ è¦è¿æ¥çš„å…ƒç´ åºåˆ—ã€‚ 12345s1 = &quot;-&quot;s2 = &quot;&quot;seq = (&quot;r&quot;, &quot;u&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;b&quot;) # å­—ç¬¦ä¸²åºåˆ—print (s1.join( seq )) #r-u-n-o-o-bprint (s2.join( seq )) #runoob 123456or &#x27;0&#x27;ç±»ä¼¼äºif åˆ¤æ–­if variable_1: x = variable_1else: x = 0 Solutionå› æ­¤æˆ‘ä»¬çš„æ€è·¯å°±æ˜¯ï¼š ä»å·¦åˆ°å³éå†å¯¹äºéå†åˆ°çš„å…ƒç´ ï¼Œæˆ‘ä»¬é€‰æ‹©ä¿ç•™ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€‰æ‹©æ€§ä¸¢å¼ƒå‰é¢ç›¸é‚»çš„å…ƒç´ ã€‚ä¸¢å¼ƒä¸å¦çš„ä¾æ®å¦‚ä¸Šé¢çš„å‰ç½®çŸ¥è¯†ä¸­é˜è¿°ä¸­çš„æ–¹æ³•ã€‚ ç„¶è€Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœç»™å®šçš„æ•°å­—æ˜¯ä¸€ä¸ªå•è°ƒé€’å¢çš„æ•°å­—ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ç®—æ³•ä¼šæ°¸è¿œé€‰æ‹©ä¸ä¸¢å¼ƒã€‚è¿™ä¸ªé¢˜ç›®ä¸­è¦æ±‚çš„ï¼Œæˆ‘ä»¬è¦æ°¸è¿œç¡®ä¿ä¸¢å¼ƒ k ä¸ªçŸ›ç›¾ã€‚ ä¸€ä¸ªç®€å•çš„æ€è·¯å°±æ˜¯ï¼š æ¯æ¬¡ä¸¢å¼ƒä¸€æ¬¡ï¼Œk å‡å» 1ã€‚å½“ k å‡åˆ° 0 ï¼Œæˆ‘ä»¬å¯ä»¥æå‰ç»ˆæ­¢éå†ã€‚è€Œå½“éå†å®Œæˆï¼Œå¦‚æœ k ä»ç„¶å¤§äº 0ã€‚ä¸å¦¨å‡è®¾æœ€ç»ˆè¿˜å‰©ä¸‹ x ä¸ªéœ€è¦ä¸¢å¼ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦é€‰æ‹©åˆ é™¤æœ«å°¾ x ä¸ªå…ƒç´ ã€‚ æˆ‘ä»¬éœ€è¦æŠŠæ€è·¯é€†è½¬è¿‡æ¥ã€‚åˆšæ‰æˆ‘çš„å…³æ³¨ç‚¹ä¸€ç›´æ˜¯ä¸¢å¼ƒï¼Œé¢˜ç›®è¦æ±‚æˆ‘ä»¬ä¸¢å¼ƒ k ä¸ªã€‚åè¿‡æ¥è¯´ï¼Œä¸å°±æ˜¯è®©æˆ‘ä»¬ä¿ç•™ n - knâˆ’k ä¸ªå…ƒç´ ä¹ˆï¼Ÿå…¶ä¸­ n ä¸ºæ•°å­—é•¿åº¦ã€‚ é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦æŒ‰ç…§ä¸Šé¢çš„æ–¹æ³•éå†å®Œæˆä¹‹åï¼Œå†æˆªå–å‰n - kä¸ªå…ƒç´ å³å¯ã€‚ æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œæˆ‘ä»¬æ¥é€‰æ‹©æ•°æ®ç»“æ„ã€‚ç”±äºæˆ‘ä»¬éœ€è¦ä¿ç•™å’Œä¸¢å¼ƒç›¸é‚»çš„å…ƒç´ ï¼Œå› æ­¤ä½¿ç”¨æ ˆè¿™ç§åœ¨ä¸€ç«¯è¿›è¡Œæ·»åŠ å’Œåˆ é™¤çš„æ•°æ®ç»“æ„æ˜¯å†åˆé€‚ä¸è¿‡äº†ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹ä»£ç å®ç°ã€‚ 12345678910class Solution: def removeKdigits(self, num: str, k: int) -&gt; str: stack=[] remain= len(num)-k for digit in num: while k and stack and stack[-1]&gt;digit: stack.pop() k-=1 stack.append(digit) return &#x27;&#x27;.join(stack[:remain]).lstrip(&#x27;0&#x27;) or &#x27;0&#x27;"},{"title":"718","path":"2022/09/21/718/","text":""},{"title":"739. Daily Temperatures(medium)","path":"2022/09/20/739/","text":"739. Daily Temperatures(medium)Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.å•è°ƒæ ˆå¯ä»¥ç»´æŠ¤ä¸€ä¸ªå­˜å‚¨ä¸‹æ ‡çš„å•è°ƒæ ˆï¼Œä»æ ˆåº•åˆ°æ ˆé¡¶çš„ä¸‹æ ‡å¯¹åº”çš„æ¸©åº¦åˆ—è¡¨ä¸­çš„æ¸©åº¦ä¾æ¬¡é€’å‡ã€‚å¦‚æœä¸€ä¸ªä¸‹æ ‡åœ¨å•è°ƒæ ˆé‡Œï¼Œåˆ™è¡¨ç¤ºå°šæœªæ‰¾åˆ°ä¸‹ä¸€æ¬¡æ¸©åº¦æ›´é«˜çš„ä¸‹æ ‡ã€‚ æ­£å‘éå†æ¸©åº¦åˆ—è¡¨ã€‚å¯¹äºæ¸©åº¦åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´  temperatures[i]ï¼Œå¦‚æœæ ˆä¸ºç©ºï¼Œåˆ™ç›´æ¥å°† i è¿›æ ˆï¼Œå¦‚æœæ ˆä¸ä¸ºç©ºï¼Œåˆ™æ¯”è¾ƒæ ˆé¡¶å…ƒç´  prevIndex å¯¹åº”çš„æ¸©åº¦ temperatures[prevIndex] å’Œå½“å‰æ¸©åº¦ temperatures[i]ï¼Œå¦‚æœ temperatures[i] &gt; temperatures[prevIndex]ï¼Œåˆ™å°† prevIndex ç§»é™¤ï¼Œå¹¶å°† prevIndex å¯¹åº”çš„ç­‰å¾…å¤©æ•°èµ‹ä¸º i - prevIndexï¼Œé‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°æ ˆä¸ºç©ºæˆ–è€…æ ˆé¡¶å…ƒç´ å¯¹åº”çš„æ¸©åº¦å°äºç­‰äºå½“å‰æ¸©åº¦ï¼Œç„¶åå°† i è¿›æ ˆã€‚ ä¸ºä»€ä¹ˆå¯ä»¥åœ¨å¼¹æ ˆçš„æ—¶å€™æ›´æ–° ans[prevIndex] å‘¢ï¼Ÿå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå³å°†è¿›æ ˆçš„ i å¯¹åº”çš„ temperatures[i] ä¸€å®šæ˜¯ temperatures[prevIndex] å³è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„å…ƒç´ ï¼Œè¯•æƒ³å¦‚æœ prevIndex å’Œ i æœ‰æ¯”å®ƒå¤§çš„å…ƒç´ ï¼Œå‡è®¾ä¸‹æ ‡ä¸º jï¼Œé‚£ä¹ˆ prevIndex ä¸€å®šä¼šåœ¨ä¸‹æ ‡ j çš„é‚£ä¸€è½®è¢«å¼¹æ‰ã€‚ ç”±äºå•è°ƒæ ˆæ»¡è¶³ä»æ ˆåº•åˆ°æ ˆé¡¶å…ƒç´ å¯¹åº”çš„æ¸©åº¦é€’å‡ï¼Œå› æ­¤æ¯æ¬¡æœ‰å…ƒç´ è¿›æ ˆæ—¶ï¼Œä¼šå°†æ¸©åº¦æ›´ä½çš„å…ƒç´ å…¨éƒ¨ç§»é™¤ï¼Œå¹¶æ›´æ–°å‡ºæ ˆå…ƒç´ å¯¹åº”çš„ç­‰å¾…å¤©æ•°ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿ç­‰å¾…å¤©æ•°ä¸€å®šæ˜¯æœ€å°çš„ã€‚ ä»¥ä¸‹ç”¨ä¸€ä¸ªå…·ä½“çš„ä¾‹å­å¸®åŠ©è¯»è€…ç†è§£å•è°ƒæ ˆã€‚å¯¹äºæ¸©åº¦åˆ—è¡¨ [73,74,75,71,69,72,76,73]ï¼Œå•è°ƒæ ˆ stack çš„åˆå§‹çŠ¶æ€ä¸ºç©ºï¼Œç­”æ¡ˆ ans çš„åˆå§‹çŠ¶æ€æ˜¯ [0,0,0,0,0,0,0,0]ï¼ŒæŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ›´æ–°å•è°ƒæ ˆå’Œç­”æ¡ˆï¼Œå…¶ä¸­å•è°ƒæ ˆå†…çš„å…ƒç´ éƒ½æ˜¯ä¸‹æ ‡ï¼Œæ‹¬å·å†…çš„æ•°å­—è¡¨ç¤ºä¸‹æ ‡åœ¨æ¸©åº¦åˆ—è¡¨ä¸­å¯¹åº”çš„æ¸©åº¦ã€‚ 123456789101112class Solution: def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]: length = len(temperatures) ans = [0] * length stack = [] for i in range(length): temperature = temperatures[i] while stack and temperature &gt; temperatures[stack[-1]]: prev_index = stack.pop() ans[prev_index] = i - prev_index stack.append(i) return ans KMP è¿™æ˜¯è¯„è®ºé‡Œçš„è§£æ³•ï¼Œç›¸å¯¹æ›´å¥½ç†è§£ä¸€äº› 1234567891011121314class Solution: def dailyTemperatures(self, T: List[int]) -&gt; List[int]: n=len(T) ans=[0]*n for i in range(n-2,-1,-1): now=i+1 while T[now]&lt;=T[i]: if ans[now]: now+=ans[now] else: break else: ans[i]=now-i return ans"},{"title":"496. Next Greater Element I(easy)","path":"2022/09/20/496/","text":"496. Next Greater Element I(easy)The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2]Output: [-1,3,-1]Explanation: The next greater element for each value of nums1 is as follows:- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. å•è°ƒæ ˆ + å“ˆå¸Œè¡¨æ€è·¯ æˆ‘ä»¬å¯ä»¥å…ˆé¢„å¤„ç† nums2 ï¼Œä½¿æŸ¥è¯¢ nums1ä¸­çš„æ¯ä¸ªå…ƒç´ åœ¨ nums2ä¸­å¯¹åº”ä½ç½®çš„å³è¾¹çš„ç¬¬ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ å€¼æ—¶ä¸éœ€è¦å†éå† nums2ã€‚äºæ˜¯ï¼Œæˆ‘ä»¬å°†é¢˜ç›®åˆ†è§£ä¸ºä¸¤ä¸ªå­é—®é¢˜ï¼š ç¬¬ 1 ä¸ªå­é—®é¢˜ï¼šå¦‚ä½•æ›´é«˜æ•ˆåœ°è®¡ç®— nums2ä¸­æ¯ä¸ªå…ƒç´ å³è¾¹çš„ç¬¬ä¸€ä¸ªæ›´å¤§çš„å€¼ï¼› ç¬¬ 2 ä¸ªå­é—®é¢˜ï¼šå¦‚ä½•å­˜å‚¨ç¬¬ 1 ä¸ªå­é—®é¢˜çš„ç»“æœã€‚ ç®—æ³• æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å•è°ƒæ ˆæ¥è§£å†³ç¬¬ 1 ä¸ªå­é—®é¢˜ã€‚å€’åºéå† nums2ï¼Œå¹¶ç”¨å•è°ƒæ ˆä¸­ç»´æŠ¤å½“å‰ä½ç½®å³è¾¹çš„æ›´å¤§çš„å…ƒç´ åˆ—è¡¨ï¼Œä»æ ˆåº•åˆ°æ ˆé¡¶çš„å…ƒç´ æ˜¯å•è°ƒé€’å‡çš„ã€‚ å…·ä½“åœ°ï¼Œæ¯æ¬¡æˆ‘ä»¬ç§»åŠ¨åˆ°æ•°ç»„ä¸­ä¸€ä¸ªæ–°çš„ä½ç½® iï¼Œå°±å°†å½“å‰å•è°ƒæ ˆä¸­æ‰€æœ‰å°äº nums2[i]çš„å…ƒç´ å¼¹å‡ºå•è°ƒæ ˆï¼Œå½“å‰ä½ç½®å³è¾¹çš„ç¬¬ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ å³ä¸ºæ ˆé¡¶å…ƒç´ ï¼Œå¦‚æœæ ˆä¸ºç©ºåˆ™è¯´æ˜å½“å‰ä½ç½®å³è¾¹æ²¡æœ‰æ›´å¤§çš„å…ƒç´ ã€‚éšåæˆ‘ä»¬å°†ä½ç½® i çš„å…ƒç´ å…¥æ ˆã€‚ å¯ä»¥ç»“åˆä»¥ä¸‹ä¾‹å­æ¥ç†è§£ã€‚ å› ä¸ºé¢˜ç›®è§„å®šäº† nums2æ˜¯æ²¡æœ‰é‡å¤å…ƒç´ çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨æ¥è§£å†³ç¬¬ 2 ä¸ªå­é—®é¢˜ï¼Œå°†å…ƒç´ å€¼ä¸å…¶å³è¾¹ç¬¬ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ å€¼çš„å¯¹åº”å…³ç³»å­˜å…¥å“ˆå¸Œè¡¨ã€‚ ç»†èŠ‚ å› ä¸ºåœ¨è¿™é“é¢˜ä¸­æˆ‘ä»¬åªéœ€è¦ç”¨åˆ° nums2ä¸­å…ƒç´ çš„é¡ºåºè€Œä¸éœ€è¦ç”¨åˆ°ä¸‹æ ‡ï¼Œæ‰€ä»¥æ ˆä¸­ç›´æ¥å­˜å‚¨ nums2ä¸­å…ƒç´ çš„å€¼å³å¯ã€‚ 1234567891011class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: res = &#123;&#125; stack = [] for num in reversed(nums2): while stack and num &gt;= stack[-1]: stack.pop() res[num] = stack[-1] if stack else -1 stack.append(num) return [res[num] for num in nums1]"},{"title":"380. Insert Delete GetRandom O(1)(medium)","path":"2022/09/13/380/","text":"380. Insert Delete GetRandom O(1)(medium)Implement the RandomizedSet class:RandomizedSet() Initializes the RandomizedSet object.bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.int getRandom() Returns a random element from the current set of elements (itâ€™s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity.123456789101112131415Input[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;][[], [1], [2], [2], [], [1], [2], []]Output[null, true, false, true, 2, true, false, 2]ExplanationRandomizedSet randomizedSet = new RandomizedSet();randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.randomizedSet.remove(2); // Returns false as 2 does not exist in the set.randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].randomizedSet.insert(2); // 2 was already in the set, so return false.randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Solutionæœ¬é¢˜çš„éš¾ç‚¹åœ¨äºä¸¤ç‚¹ï¼š 1ã€æ’å…¥ï¼Œåˆ é™¤ï¼Œè·å–éšæœºå…ƒç´ è¿™ä¸‰ä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦å¿…é¡»éƒ½æ˜¯ O(1)ã€‚ 2ã€getRandom æ–¹æ³•è¿”å›çš„å…ƒç´ å¿…é¡»ç­‰æ¦‚ç‡è¿”å›éšæœºå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœé›†åˆé‡Œé¢æœ‰ n ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ è¢«è¿”å›çš„æ¦‚ç‡å¿…é¡»æ˜¯ 1/nã€‚ æˆ‘ä»¬å…ˆæ¥åˆ†æä¸€ä¸‹ï¼šå¯¹äºæ’å…¥ï¼Œåˆ é™¤ï¼ŒæŸ¥æ‰¾è¿™å‡ ä¸ªæ“ä½œï¼Œå“ªç§æ•°æ®ç»“æ„çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼Ÿ HashSet è‚¯å®šç®—ä¸€ä¸ªå¯¹å§ã€‚å“ˆå¸Œé›†åˆçš„åº•å±‚åŸç†å°±æ˜¯ä¸€ä¸ªå¤§æ•°ç»„ï¼Œæˆ‘ä»¬æŠŠå…ƒç´ é€šè¿‡å“ˆå¸Œå‡½æ•°æ˜ å°„åˆ°ä¸€ä¸ªç´¢å¼•ä¸Šï¼›å¦‚æœç”¨æ‹‰é“¾æ³•è§£å†³å“ˆå¸Œå†²çªï¼Œé‚£ä¹ˆè¿™ä¸ªç´¢å¼•å¯èƒ½è¿ç€ä¸€ä¸ªé“¾è¡¨æˆ–è€…çº¢é»‘æ ‘ã€‚ é‚£ä¹ˆè¯·é—®å¯¹äºè¿™æ ·ä¸€ä¸ªæ ‡å‡†çš„ HashSetï¼Œä½ èƒ½å¦åœ¨ O(1) çš„æ—¶é—´å†…å®ç° getRandom å‡½æ•°ï¼Ÿ å…¶å®æ˜¯ä¸èƒ½çš„ï¼Œå› ä¸ºæ ¹æ®åˆšæ‰è¯´åˆ°çš„åº•å±‚å®ç°ï¼Œå…ƒç´ æ˜¯è¢«å“ˆå¸Œå‡½æ•°ã€Œåˆ†æ•£ã€åˆ°æ•´ä¸ªæ•°ç»„é‡Œé¢çš„ï¼Œæ›´åˆ«è¯´è¿˜æœ‰æ‹‰é“¾æ³•ç­‰ç­‰è§£å†³å“ˆå¸Œå†²çªçš„æœºåˆ¶ï¼Œæ‰€ä»¥åšä¸åˆ° O(1) æ—¶é—´ã€Œç­‰æ¦‚ç‡ã€éšæœºè·å–å…ƒç´ ã€‚ é™¤äº† HashSetï¼Œè¿˜æœ‰ä¸€äº›ç±»ä¼¼çš„æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚å“ˆå¸Œé“¾è¡¨ LinkedHashSetï¼Œæˆ‘ä»¬åæ–‡ æ‰‹æŠŠæ‰‹å®ç°LRUç®—æ³• å’Œ æ‰‹æŠŠæ‰‹å®ç°LFUç®—æ³• è®²è¿‡è¿™ç±»æ•°æ®ç»“æ„çš„å®ç°åŸç†ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯å“ˆå¸Œè¡¨é…åˆåŒé“¾è¡¨ï¼Œå…ƒç´ å­˜å‚¨åœ¨åŒé“¾è¡¨ä¸­ã€‚ ä½†æ˜¯ï¼ŒLinkedHashSet åªæ˜¯ç»™ HashSet å¢åŠ äº†æœ‰åºæ€§ï¼Œä¾ç„¶æ— æ³•æŒ‰è¦æ±‚å®ç°æˆ‘ä»¬çš„ getRandom å‡½æ•°ï¼Œå› ä¸ºåº•å±‚ç”¨é“¾è¡¨ç»“æ„å­˜å‚¨å…ƒç´ çš„è¯ï¼Œæ˜¯æ— æ³•åœ¨ O(1) çš„æ—¶é—´å†…è®¿é—®æŸä¸€ä¸ªå…ƒç´ çš„ã€‚ æ ¹æ®ä¸Šé¢çš„åˆ†æï¼Œå¯¹äº getRandom æ–¹æ³•ï¼Œå¦‚æœæƒ³ã€Œç­‰æ¦‚ç‡ã€ä¸”ã€Œåœ¨ O(1) çš„æ—¶é—´ã€å–å‡ºå…ƒç´ ï¼Œä¸€å®šè¦æ»¡è¶³ï¼šåº•å±‚ç”¨æ•°ç»„å®ç°ï¼Œä¸”æ•°ç»„å¿…é¡»æ˜¯ç´§å‡‘çš„ã€‚ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥ç”Ÿæˆéšæœºæ•°ä½œä¸ºç´¢å¼•ï¼Œä»æ•°ç»„ä¸­å–å‡ºè¯¥éšæœºç´¢å¼•å¯¹åº”çš„å…ƒç´ ï¼Œä½œä¸ºéšæœºå…ƒç´ ã€‚ ä½†å¦‚æœç”¨æ•°ç»„å­˜å‚¨å…ƒç´ çš„è¯ï¼Œæ’å…¥ï¼Œåˆ é™¤çš„æ—¶é—´å¤æ‚åº¦æ€ä¹ˆå¯èƒ½æ˜¯ O(1) å‘¢ï¼Ÿ å¯ä»¥åšåˆ°ï¼å¯¹æ•°ç»„å°¾éƒ¨è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œä¸ä¼šæ¶‰åŠæ•°æ®æ¬ç§»ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ã€‚ æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åœ¨ O(1) çš„æ—¶é—´åˆ é™¤æ•°ç»„ä¸­çš„æŸä¸€ä¸ªå…ƒç´  valï¼Œå¯ä»¥å…ˆæŠŠè¿™ä¸ªå…ƒç´ äº¤æ¢åˆ°æ•°ç»„çš„å°¾éƒ¨ï¼Œç„¶åå† pop æ‰ã€‚ äº¤æ¢ä¸¤ä¸ªå…ƒç´ å¿…é¡»é€šè¿‡ç´¢å¼•è¿›è¡Œäº¤æ¢å¯¹å§ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå“ˆå¸Œè¡¨ valToIndex æ¥è®°å½•æ¯ä¸ªå…ƒç´ å€¼å¯¹åº”çš„ç´¢å¼•ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class RandomizedSet: def __init__(self): # å­˜å‚¨å…ƒç´ çš„å€¼ self.nums=[] # è®°å½•æ¯ä¸ªå…ƒç´ å¯¹åº”åœ¨ nums ä¸­çš„ç´¢å¼• self.valToIndex=&#123;&#125; def insert(self, val: int) -&gt; bool: #è‹¥ val å·²å­˜åœ¨ï¼Œä¸ç”¨å†æ’å…¥ if val in self.valToIndex: return False #è‹¥ val ä¸å­˜åœ¨ï¼Œæ’å…¥åˆ° nums å°¾éƒ¨ï¼Œ #å¹¶è®°å½• val å¯¹åº”çš„ç´¢å¼•å€¼ self.valToIndex[val]=len(self.nums) self.nums.append(val) return True def remove(self, val: int) -&gt; bool: #è‹¥ val ä¸å­˜åœ¨ï¼Œä¸ç”¨å†åˆ é™¤ if val not in self.valToIndex: return False #å…ˆæ‹¿åˆ° val çš„ç´¢å¼• index= self.valToIndex[val] #å°†æœ€åä¸€ä¸ªå…ƒç´ å¯¹åº”çš„ç´¢å¼•ä¿®æ”¹ä¸º index self.nums[index]=self.nums[-1] #äº¤æ¢ val å’Œæœ€åä¸€ä¸ªå…ƒç´  self.valToIndex[self.nums[index]]=index #åœ¨æ•°ç»„ä¸­åˆ é™¤å…ƒç´  val self.nums.pop() #åˆ é™¤å…ƒç´  val å¯¹åº”çš„ç´¢å¼•(hashmap) del self.valToIndex[val] return True def getRandom(self) -&gt; int: # éšæœºè·å– nums ä¸­çš„ä¸€ä¸ªå…ƒç´  return choice(self.nums) # Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()"},{"title":"647. Palindromic Substrings(medium)","path":"2022/09/13/647/","text":"647. Palindromic Substrings(medium)Given a string s, return the number of palindromic substrings in it.A string is a palindrome when it reads the same backward as forward.A substring is a contiguous sequence of characters within the string.123456789class Solution: def countSubstrings(self, s: str) -&gt; int: L, r = len(s), 0 for i in range(L): for a,b in [(i,i),(i,i+1)]: while a &gt;= 0 and b &lt; L and s[a] == s[b]: a -= 1; b += 1 r += (b-a)//2 return r"},{"title":"870. Advantage Shuffle(medium)","path":"2022/09/12/870/","text":"870. Advantage Shuffle(medium)You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] &gt; nums2[i].Return any permutation of nums1 that maximizes its advantage with respect to nums2.12Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]Output: [2,11,7,15] 12Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]Output: [2,11,7,15] ç±»ä¼¼äºç”°å¿Œèµ›é©¬çš„æ•…äº‹ï¼Œæ’åºnums2ä½¿å¾—nums2æ¯”nums1æœ‰ä¼˜åŠ¿ SolutionæŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå¯ä»¥è€ƒè™‘è´ªå¿ƒçš„æ€ç»´æ¨¡å¼ã€‚ é¦–å…ˆéœ€è¦å°†nums2æŒ‰ç…§[value,index]çš„æ¨¡å¼åŠ å…¥ä¿å­˜è‡³æ•°ç»„ä¸­ï¼Œæœ€ç»ˆæŒ‰ç…§valueå€¼é€†åºç”Ÿæˆä¸€ä¸ªäºŒç»´æ•°ç»„ä¹‹åå¯¹nums1è¿›è¡Œæ’åºåˆ†é…leftã€rightæŒ‡é’ˆæŒ‡å‘nums1çš„å¤´å°¾èŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸ºnums1çš„åˆå§‹åŒ–æ•°ç»„retï¼Œå¼€å§‹å¾ªç¯äºŒç»´æ•°ç»„æŒ‰ç…§ä¸Šé¢çš„æ€è·¯å¦‚æœrightèŠ‚ç‚¹æ¯”nums2å½“å‰çš„ä¸‹è¡¨æ•°å­—å¤§ï¼Œé‚£å°±æ˜¯å¼ºå¼ºå¯¹ç¢°ï¼Œæ­£é¢ç¡¬åˆšå¦‚æœä¸æ•Œåˆ™ç”¨leftèŠ‚ç‚¹çš„å°å…µä»¥æ¬¡å……å¥½ä¸è®º1ã€2å¦‚ä½•é€‰æ‹©ï¼Œéƒ½å°†leftæˆ–rightå¯¹åº”çš„numï¼Œæ ¹æ®äºŒç»´æ•°ç»„çš„indexå°†valueä¿å­˜è‡³retæ•°ç»„æœ€ç»ˆè¿”å›retæ•°ç»„å³å¯ 1234567891011121314151617181920212223class Solution(object): def advantageCount(self, A, B): sortedA = sorted(A) sortedB = sorted(B) # assigned[b] = list of a that are assigned to beat b # remaining = list of a that are not assigned to any b assigned = &#123;b: [] for b in B&#125; remaining = [] # populate (assigned, remaining) appropriately # sortedB[j] is always the smallest unassigned element in B j = 0 for a in sortedA: if a &gt; sortedB[j]: assigned[sortedB[j]].append(a) j += 1 else: remaining.append(a) # Reconstruct the answer from annotations (assigned, remaining) return [assigned[b].pop() if assigned[b] else remaining.pop() for b in B]"},{"title":"528. Random Pick with Weight(medium)","path":"2022/09/12/528/","text":"528. Random Pick with Weight(medium)You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).å‰ç¼€å’Œæ•°ç»„åŠ äºŒåˆ†æœç´¢çš„é¢˜ç›® Solution1234567891011121314class Solution: def __init__(self, w: List[int]): self.pre = list(accumulate(w)) self.total = sum(w) def pickIndex(self) -&gt; int: x = random.randint(1, self.total) return bisect_left(self.pre, x) # Your Solution object will be instantiated and called as such:# obj = Solution(w)# param_1 = obj.pickIndex()"},{"title":"567. Permutation in String(medium)","path":"2022/09/11/567/","text":"567. Permutation in String(medium)Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.In other words, return true if one of s1â€™s permutations is the substring of s2."},{"title":"1356. Sort Integers by The Number of 1 Bits(easy)","path":"2022/09/11/1356/","text":"1356. Sort Integers by The Number of 1 Bits(easy)You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1â€™s in their binary representation and in case of two or more integers have the same number of 1â€™s you have to sort them in ascending order.Return the array after sorting it.1234567Input: arr = [0,1,2,3,4,5,6,7,8]Output: [0,1,2,4,8,3,5,6,7]Explantion: [0] is the only integer with 0 bits.[1,2,4,8] all have 1 bit.[3,5,6] have 2 bits.[7] has 3 bits.The sorted array by bits is [0,1,2,4,8,3,5,6,7] Solutionclass Solution: def sortByBits(self, arr: List[int]) -&gt; List[int]: return sorted(arr, key = lambda num : (sum((num &gt;&gt; i) &amp; 1 for i in range(32)), num))"},{"title":"76. Minimum Window Substring(hard)","path":"2022/09/11/76/","text":"76. Minimum Window Substring(hard)Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string â€œâ€.The testcases will be generated such that the answer is unique.A substring is a contiguous sequence of characters within the string.è¿™é“é¢˜æ˜¯æ»‘åŠ¨çª—å£çš„ç»å…¸é¢˜ç›®ï¼Œæ»‘åŠ¨çª—å£ç®—æ³•çš„æ€è·¯æ˜¯è¿™æ ·ï¼š æˆ‘ä»¬åœ¨å­—ç¬¦ä¸² S ä¸­ä½¿ç”¨åŒæŒ‡é’ˆä¸­çš„å·¦å³æŒ‡é’ˆæŠ€å·§ï¼Œåˆå§‹åŒ– left = right = 0ï¼ŒæŠŠç´¢å¼•å·¦é—­å³å¼€åŒºé—´ [left, right) ç§°ä¸ºä¸€ä¸ªã€Œçª—å£ã€ã€‚ PSï¼šç†è®ºä¸Šä½ å¯ä»¥è®¾è®¡ä¸¤ç«¯éƒ½å¼€æˆ–è€…ä¸¤ç«¯éƒ½é—­çš„åŒºé—´ï¼Œä½†è®¾è®¡ä¸ºå·¦é—­å³å¼€åŒºé—´æ˜¯æœ€æ–¹ä¾¿å¤„ç†çš„ã€‚å› ä¸ºè¿™æ ·åˆå§‹åŒ– left = right = 0 æ—¶åŒºé—´ [0, 0) ä¸­æ²¡æœ‰å…ƒç´ ï¼Œä½†åªè¦è®© right å‘å³ç§»åŠ¨ï¼ˆæ‰©å¤§ï¼‰ä¸€ä½ï¼ŒåŒºé—´ [0, 1) å°±åŒ…å«ä¸€ä¸ªå…ƒç´  0 äº†ã€‚å¦‚æœä½ è®¾ç½®ä¸ºä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ï¼Œé‚£ä¹ˆè®© right å‘å³ç§»åŠ¨ä¸€ä½åå¼€åŒºé—´ (0, 1) ä»ç„¶æ²¡æœ‰å…ƒç´ ï¼›å¦‚æœä½ è®¾ç½®ä¸ºä¸¤ç«¯éƒ½é—­çš„åŒºé—´ï¼Œé‚£ä¹ˆåˆå§‹åŒºé—´ [0, 0] å°±åŒ…å«äº†ä¸€ä¸ªå…ƒç´ ã€‚è¿™ä¸¤ç§æƒ…å†µéƒ½ä¼šç»™è¾¹ç•Œå¤„ç†å¸¦æ¥ä¸å¿…è¦çš„éº»çƒ¦ã€‚ æˆ‘ä»¬å…ˆä¸æ–­åœ°å¢åŠ  right æŒ‡é’ˆæ‰©å¤§çª—å£ [left, right)ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼ˆåŒ…å«äº† T ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼‰ã€‚ æ­¤æ—¶ï¼Œæˆ‘ä»¬åœæ­¢å¢åŠ  rightï¼Œè½¬è€Œä¸æ–­å¢åŠ  left æŒ‡é’ˆç¼©å°çª—å£ [left, right)ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ä¸å†ç¬¦åˆè¦æ±‚ï¼ˆä¸åŒ…å« T ä¸­çš„æ‰€æœ‰å­—ç¬¦äº†ï¼‰ã€‚åŒæ—¶ï¼Œæ¯æ¬¡å¢åŠ  leftï¼Œæˆ‘ä»¬éƒ½è¦æ›´æ–°ä¸€è½®ç»“æœã€‚ é‡å¤ç¬¬ 2 å’Œç¬¬ 3 æ­¥ï¼Œç›´åˆ° right åˆ°è¾¾å­—ç¬¦ä¸² S çš„å°½å¤´ã€‚ è¿™ä¸ªæ€è·¯å…¶å®ä¹Ÿä¸éš¾ï¼Œç¬¬ 2 æ­¥ç›¸å½“äºåœ¨å¯»æ‰¾ä¸€ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œç„¶åç¬¬ 3 æ­¥åœ¨ä¼˜åŒ–è¿™ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œæœ€ç»ˆæ‰¾åˆ°æœ€ä¼˜è§£ï¼Œä¹Ÿå°±æ˜¯æœ€çŸ­çš„è¦†ç›–å­ä¸²ã€‚å·¦å³æŒ‡é’ˆè½®æµå‰è¿›ï¼Œçª—å£å¤§å°å¢å¢å‡å‡ï¼Œçª—å£ä¸æ–­å‘å³æ»‘åŠ¨ï¼Œè¿™å°±æ˜¯ã€Œæ»‘åŠ¨çª—å£ã€è¿™ä¸ªåå­—çš„æ¥å†ã€‚ ä¸‹é¢ç”»å›¾ç†è§£ä¸€ä¸‹ï¼Œneeds å’Œ window ç›¸å½“äºè®¡æ•°å™¨ï¼Œåˆ†åˆ«è®°å½• T ä¸­å­—ç¬¦å‡ºç°æ¬¡æ•°å’Œã€Œçª—å£ã€ä¸­çš„ç›¸åº”å­—ç¬¦çš„å‡ºç°æ¬¡æ•°ã€‚ C++è§£æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦ int start = 0, len = INT_MAX; while (right &lt; s.size()) &#123; // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦ char c = s[right]; // æ‰©å¤§çª—å£ right++; // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼© while (valid == need.size()) &#123; // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸² if (right - left &lt; len) &#123; start = left; len = right - left; &#125; // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦ char d = s[left]; // ç¼©å°çª—å£ left++; // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; // è¿”å›æœ€å°è¦†ç›–å­ä¸² return len == INT_MAX ? &quot;&quot; : s.substr(start, len);&#125; pythonè§£æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def minWindow(self, s: str, t: str) -&gt; str: # hash table to store the required char frequency need = collections.Counter(t) # total character count we need to care about missing = len(t) # windowStart and windowEnd to be windowStart, windowEnd = 0, 0 i = 0 # iterate over s starting over index 1 for j, char in enumerate(s, 1): # j is index,char is value # if char is required then decrease missing if need[char] &gt; 0: missing -= 1 # decrease the freq of char from need (maybe be negative - which basically denotes # that we have few extra characters which are not required but present in between current window) need[char] -= 1 # we found a valid window if missing == 0: # chars from start to find the real windowStart while i &lt; j and need[s[i]] &lt; 0: need[s[i]] += 1 i += 1 # if it&#x27;s only one char case or curr window is smaller, then update window if windowEnd == 0 or j-i &lt; windowEnd-windowStart: windowStart, windowEnd = i, j # now resetting the window to make it invalid # sure the first appearing char satisfies need[char]&gt;0 need[s[i]] += 1 # missed this first char, so add missing by 1 missing += 1 #update i to windowStart+1 for next window i += 1 return s[windowStart:windowEnd]"},{"title":"LeetCode-skill8-two_pointers","path":"2022/09/11/LeetCode-skill8-two-pointers/","text":"[æ»‘åŠ¨çª—å£æ¡†æ¶pythonï¼š](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/ Longest Substring Without Repeating Characters(medium) 1234567891011121314151617181920from collections import defaultdictclass Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: lookup=defaultdict(int) start=0 end=0 max_len=0 counter=0 while end&lt;len(s): if lookup[s[end]]&gt;0: counter+=1 lookup[s[end]]+=1 end+=1 while counter&gt;0: if lookup[s[start]]&gt;1: counter-=1 lookup[s[start]]-=1 start+=1 max_len=max(max_len,end-start) return max_len Minimum Window Substring(hard) 1234567891011121314151617181920212223242526class Solution: def minWindow(self, s: &#x27;str&#x27;, t: &#x27;str&#x27;) -&gt; &#x27;str&#x27;: from collections import defaultdict lookup = defaultdict(int) for c in t: lookup[c] += 1 start = 0 end = 0 min_len = float(&quot;inf&quot;) counter = len(t) res = &quot;&quot; while end &lt; len(s): if lookup[s[end]] &gt; 0: counter -= 1 lookup[s[end]] -= 1 end += 1 while counter == 0: if min_len &gt; end - start: min_len = end - start res = s[start:end] if lookup[s[start]] == 0: counter += 1 lookup[s[start]] += 1 start += 1 return res 12345678910111213141516171819202122232425262728/* æ»‘åŠ¨çª—å£ç®—æ³•æ¡†æ¶ */void slidingWindow(string s) &#123; unordered_map&lt;char, int&gt; window; int left = 0, right = 0; while (right &lt; s.size()) &#123; // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦ char c = s[right]; // å¢å¤§çª—å£ right++; // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... /*** debug è¾“å‡ºçš„ä½ç½® ***/ printf(&quot;window: [%d, %d)\\n&quot;, left, right); /********************/ // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼© while (window needs shrink) &#123; // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦ char d = s[left]; // ç¼©å°çª—å£ left++; // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... &#125; &#125;&#125; 1234567891011121314151617181920212223def slidingWindow(string s): window=&#123;&#125; int left = 0, right = 0 while right&lt;len(s): #c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦ c=s[right] # å¢å¤§çª—å£ right+=1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... #*** debug è¾“å‡ºçš„ä½ç½® ***/ print(&quot;window: [%d, %d)\\n&quot;, left, right) #********************/ # åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼© while (window needs shrink) #d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦ d = s[left] #ç¼©å°çª—å£ left+=1 #è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ..."},{"title":"1360. Number of Days Between Two Dates","path":"2022/09/09/1360/","text":"1360. Number of Days Between Two Dates(easy)Write a program to count the number of days between two dates.The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.12Input: date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;Output: 1 å®˜æ–¹é¢˜è§£:When m=1 or m=2 (January or February), we let m=13 or m=14 and let y decreased by 1. Imagine it is 13th or 14th month of the last year. By doing that, we let the magical formula also work for those two months. (153 * m + 8) // 5 is just a carefully designed way to record the days of each month. More specifically, it is designed to record the difference of days between two months. Suppose we have March 1st and April 1st, (153 * 3 + 8) // 5 = 93 while (153 * 4 + 8) // 5 = 124, the difference is 31 which is the number of days in March. Suppose we have April 1st to May 1st, (153 * 4 + 8) // 5 = 124 and (153 * 5 + 8) // 5 = 154, the difference is now 30 which is the number of days in April. You can also check other months. I learned this formula somewhere else before. It is not something to come up with in minutes.é¦–å…ˆæŠŠ1æœˆ2æœˆåŠ 12å½“ä½œ13å’Œ14æœˆï¼Œè¿™æ ·ä½¿å¾—ä»–ä»¬ä¹Ÿå¯ä»¥å¥—ç”¨å…¬å¼è¿™é‡Œæœ‰ä¸€ä¸ªå…³é”®çš„å‡½æ•°(153 * m + 8) // 5ï¼Œé€šè¿‡å‰åæœˆä»£å…¥ä»¥åçš„ç›¸å‡ï¼Œå¯ä»¥åŒºåˆ†ä¸åŒæœˆä»½çš„é•¿åº¦ï¼Œç¡®å®æ˜¯éå¸¸ç¥å¥‡ 12345678910class Solution: def daysBetweenDates(self, date1: str, date2: str) -&gt; int: def f(date): y, m, d = map(int, date.split(&#x27;-&#x27;)) if m &lt; 3: m += 12 y -= 1 return 365 * y + y // 4 + y // 400 - y // 100 + d + (153 * m + 8) // 5 return abs(f(date1) - f(date2))"},{"title":"practicecodesignal4","path":"2022/09/05/practicecodesignal4/","text":"def samesign(a,b): if a/abs(a) == b/abs(b): return True else: return False def countSawSubarrays(arr): n = len(arr) if n&lt;2: return 0 s = 0 e = 1 count = 0 while(e&lt;n): sign = arr[e] - arr[s] while(e&lt;n and arr[e] != arr[e-1] and samesign(arr[e] - arr[e-1], sign)): sign = -1*sign e+=1 size = e-s if (size==1): e+=1 count += (size*(size-1))//2 s = e-1 e = s+1 return count arr1 = [9,8,7,6,5]print(countSawSubarrays(arr1))arr2 = [1,2,1,3,4,-2]print(countSawSubarrays(arr2))arr3 = [1,2,1,2,1]print(countSawSubarrays(arr3))arr4 = [10,10,10]print(countSawSubarrays(arr4)) def solution(matrix, a, b): if a + b - 1 &gt; min(len(matrix), len(matrix[0])): return 0 ret = 0 for w, h in ((a, b), (b, a)): # for every possible leftmost axb/bxa rectangle... for start in range(min(len(matrix), len(matrix[0])) - (a + b - 1) + 1): i = start cur = 0 deques = [] j1 = j2 = w - 1 # build the rectangle while j1 &lt;= j2: for k in range(j1, j2 + 1): cur += matrix[i][k] deques.append((j1, j2)) j1 += (-1 if i - start &lt; w - 1 else 1) j2 += (1 if i - start &lt; h - 1 else -1) i += 1 stop = False # slide it to the right until you can&#39;t anymore while True: ret = max(ret, cur) for ind, tup in enumerate(deques): j1, j2 = tup i = start + ind if j2 == len(matrix[0]) - 1: stop = True break j2 += 1 cur += matrix[i][j2] - matrix[i][j1] j1 += 1 deques[ind] = (j1, j2) if stop: break return ret You are given an array of integers numbers and two integers left and right. You task is to calculate a boolean array result, where result[i] = true if there exists an integer x, such that numbers[i] = (i + 1) * x and left â‰¤ x â‰¤ right. Otherwise, result[i] should be set to false. You are given two strings - pattern and source. The first string pattern contains only the symbols 0 and 1, and the second string source contains only lowercase English letters. Letâ€™s say that pattern matches a substring source[l..r] of source if the following three conditions are met:they have equal length,for each 0 in pattern the corresponding letter in the substring is a vowel,for each 1 in pattern the corresponding letter is a consonant.Your task is to calculate the number of substrings of source that match pattern. Note: In this task we define the vowels as â€˜aâ€™, â€˜eâ€™, â€˜iâ€™, â€˜oâ€™, â€˜uâ€™, and â€˜yâ€™. All other letters are consonants. Given a matrix of integers, weâ€™d like to consider the sum of the elements within the area of a 45Â° rotated rectangle. More formally, the area is bounded by two diagonals parallel to the main diagonal and two diagonals parallel to the secondary diagonal. The dimensions of the rotated rectangle are defined by the number of elements along the borders of the rectangle. A sawtooth sequence is a sequence of numbers that alternate between increasing and decreasing. In other words, each element is either strictly greater than its neighbouring elements or strictly less than its neighbouring elements."},{"title":"LeetCode-skill7-box_blur","path":"2022/09/03/LeetCode-skill7-box-blur/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980def square_matrix(square): &quot;&quot;&quot; This function will calculate the value x (i.e. blurred pixel value) for each 3 * 3 blur image. &quot;&quot;&quot; tot_sum = 0 # Calculate sum of all the pixels in 3 * 3 matrix for i in range(3): for j in range(3): tot_sum += square[i][j] return tot_sum // 9 # return the average of the sum of pixelsdef boxBlur(image): &quot;&quot;&quot; This function will calculate the blurred image for given n * n image. &quot;&quot;&quot; square = [] # This will store the 3 * 3 matrix # which will be used to find its blurred pixel square_row = [] # This will store one row of a 3 * 3 matrix and # will be appended in square blur_row = [] # Here we will store the resulting blurred # pixels possible in one row # and will append this in the blur_img blur_img = [] # This is the resulting blurred image # number of rows in the given image n_rows = len(image) # number of columns in the given image n_col = len(image[0]) # rp is row pointer and cp is column pointer rp, cp = 0, 0 # This while loop will be used to # calculate all the blurred pixel in the first row while rp &lt;= n_rows - 3: while cp &lt;= n_col-3: for i in range(rp, rp + 3): for j in range(cp, cp + 3): # append all the pixels in a row of 3 * 3 matrix square_row.append(image[i][j]) # append the row in the square i.e. 3 * 3 matrix square.append(square_row) square_row = [] # calculate the blurred pixel for given 3 * 3 matrix # i.e. square and append it in blur_row blur_row.append(square_matrix(square)) square = [] # increase the column pointer cp = cp + 1 # append the blur_row in blur_image blur_img.append(blur_row) blur_row = [] rp = rp + 1 # increase row pointer cp = 0 # start column pointer from 0 again # Return the resulting pixel matrix return blur_img# Driver codeimage = [[7, 4, 0, 1], [5, 6, 2, 2], [6, 10, 7, 8], [1, 4, 2, 0]] print(boxBlur(image))"},{"title":"codesignal-reverseInParentheses","path":"2022/09/02/codesignal-reverseInParentheses/","text":"12345678910111213141516171819202122232425def solution(inputString): &quot;&quot;&quot; Reverse the strings contained in each pair of matching parentheses, starting from the innermost pair. The results string should not contain any parentheses. &gt;&gt;&gt; reverse_parentheses(&#x27;a(bc)de&#x27;) &#x27;acbde&#x27; &gt;&gt;&gt; reverse_parentheses( ... &#x27;The ((quick (brown) (fox) jumps over the lazy) dog)&#x27; ... ) &#x27;The god quick nworb xof jumps over the lazy&#x27; &quot;&quot;&quot; chars = list(inputString) open_bracket_indexes = [] for i, c in enumerate(chars): if c == &#x27;(&#x27;: open_bracket_indexes.append(i) elif c == &#x27;)&#x27;: j = open_bracket_indexes.pop() chars[j:i] = chars[i:j:-1] if open_bracket_indexes: raise ArgumentError(&#x27;Unclosed parenthesis&#x27;) return &#x27;&#x27;.join(c for c in chars if c not in &#x27;()&#x27;)"},{"title":"485. Max Consecutive Ones(easy)","path":"2022/09/01/485/","text":"485. Max Consecutive Ones(easy)Given a binary array nums, return the maximum number of consecutive 1â€™s in the array.123Input: nums = [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. è¿™é¢˜æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œæ¯”è¾ƒç®€å•ï¼Œè®¾ç½®ä¸¤ä¸ªç‹¬ç«‹å˜é‡ç„¶åéå†å°±è¡Œäº† class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: cnt=0 ans=0 for num in nums: if num==1: cnt+=1 ans = max(ans,cnt) elif num==0: cnt=0 return ans"},{"title":"1909. Remove One Element to Make the Array Strictly Increasing(easy)","path":"2022/09/01/1909/","text":"1909. Remove One Element to Make the Array Strictly Increasing(easy)Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.The array nums is strictly increasing if nums[i - 1] &lt; nums[i] for each index (1 &lt;= i &lt; nums.length).1234Input: nums = [1,2,10,5,7]Output: trueExplanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].[1,2,5,7] is strictly increasing, so return true. 1234567891011121314151617181920class Solution: def canBeIncreasing(self, nums: List[int]) -&gt; bool: n = len(nums) # æ£€æŸ¥æ•°ç»„ nums åœ¨åˆ å»ä¸‹æ ‡ä¸º idx çš„å…ƒç´ åæ˜¯å¦ä¸¥æ ¼é€’å¢ def check(idx: int) -&gt; bool: for i in range(1, n - 1): prev, curr = i - 1, i if prev &gt;= idx: prev += 1 if curr &gt;= idx: curr += 1 if nums[curr] &lt;= nums[prev]: return False return True for i in range(1, n): # å¯»æ‰¾éé€’å¢ç›¸é‚»ä¸‹æ ‡å¯¹ if nums[i] &lt;= nums[i-1]: return check(i) or check(i - 1) return True ä½œè€…ï¼šLeetCode-Solutioné“¾æ¥ï¼šhttps://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution/shan-chu-yi-ge-yuan-su-shi-shu-zu-yan-ge-tnr7/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"59. Spiral Matrix II(medium)","path":"2022/08/31/59/","text":"59. Spiral Matrix II(medium)Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.è¿™é“é¢˜å’Œ54. Spiral Matrix(medium)å‡ ä¹ä¸€æ¨¡ä¸€æ ·leetcodeå®˜æ–¹é¢˜è§£ 1234567891011121314151617181920212223242526class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left &lt;= right and top &lt;= bottom: for col in range(left, right + 1): matrix[top][col] = num num += 1 for row in range(top + 1, bottom + 1): matrix[row][right] = num num += 1 if left &lt; right and top &lt; bottom: for col in range(right - 1, left, -1): matrix[bottom][col] = num num += 1 for row in range(bottom, top, -1): matrix[row][left] = num num += 1 left += 1 right -= 1 top += 1 bottom -= 1 return matrix"},{"title":"151. Reverse Words in a String(medium)","path":"2022/08/31/151/","text":"151. Reverse Words in a String(medium)Given an input string s, reverse the order of the words.A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.Return a string of the words in reverse order concatenated by a single space.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.123Input: s = &quot;the sky is blue&quot;Output: &quot;blue is sky the&quot; å®˜æ–¹é¢˜è§£å¾ˆå¤šè¯­è¨€å¯¹å­—ç¬¦ä¸²æä¾›äº† splitï¼ˆæ‹†åˆ†ï¼‰ï¼Œreverseï¼ˆç¿»è½¬ï¼‰å’Œ joinï¼ˆè¿æ¥ï¼‰ç­‰æ–¹æ³•ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç®€å•çš„è°ƒç”¨å†…ç½®çš„ API å®Œæˆæ“ä½œï¼š ä½¿ç”¨ split å°†å­—ç¬¦ä¸²æŒ‰ç©ºæ ¼åˆ†å‰²æˆå­—ç¬¦ä¸²æ•°ç»„ï¼›ä½¿ç”¨ reverse å°†å­—ç¬¦ä¸²æ•°ç»„è¿›è¡Œåè½¬ï¼›ä½¿ç”¨ join æ–¹æ³•å°†å­—ç¬¦ä¸²æ•°ç»„æ‹¼æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ Solution123class Solution: def reverseWords(self, s: str) -&gt; str: return &quot; &quot;.join(reversed(s.split())) å¤æ‚åº¦åˆ†æ æ—¶é—´å¤æ‚åº¦ï¼šO(n)O(n)ï¼Œå…¶ä¸­ nn ä¸ºè¾“å…¥å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(n)O(n)ï¼Œç”¨æ¥å­˜å‚¨å­—ç¬¦ä¸²åˆ†å‰²ä¹‹åçš„ç»“æœã€‚"},{"title":"54. Spiral Matrix(medium)","path":"2022/08/31/54/","text":"54. Spiral Matrix(medium)Given an m x n matrix, return all elements of the matrix in spiral order.leetcodeå®˜æ–¹é¢˜è§£æ–¹æ³•äºŒï¼šæŒ‰å±‚æ¨¡æ‹Ÿå¯ä»¥å°†çŸ©é˜µçœ‹æˆè‹¥å¹²å±‚ï¼Œé¦–å…ˆè¾“å‡ºæœ€å¤–å±‚çš„å…ƒç´ ï¼Œå…¶æ¬¡è¾“å‡ºæ¬¡å¤–å±‚çš„å…ƒç´ ï¼Œç›´åˆ°è¾“å‡ºæœ€å†…å±‚çš„å…ƒç´ ã€‚ å®šä¹‰çŸ©é˜µçš„ç¬¬ kk å±‚æ˜¯åˆ°æœ€è¿‘è¾¹ç•Œè·ç¦»ä¸º kk çš„æ‰€æœ‰é¡¶ç‚¹ã€‚ä¾‹å¦‚ï¼Œä¸‹å›¾çŸ©é˜µæœ€å¤–å±‚å…ƒç´ éƒ½æ˜¯ç¬¬ 11 å±‚ï¼Œæ¬¡å¤–å±‚å…ƒç´ éƒ½æ˜¯ç¬¬ 22 å±‚ï¼Œå‰©ä¸‹çš„å…ƒç´ éƒ½æ˜¯ç¬¬ 33 å±‚ã€‚ 12345[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]] å¯¹äºæ¯å±‚ï¼Œä»å·¦ä¸Šæ–¹å¼€å§‹ä»¥é¡ºæ—¶é’ˆçš„é¡ºåºéå†æ‰€æœ‰å…ƒç´ ã€‚å‡è®¾å½“å‰å±‚çš„å·¦ä¸Šè§’ä½äº (top,left)ï¼Œå³ä¸‹è§’ä½äº (bottom,right)ï¼ŒæŒ‰ç…§å¦‚ä¸‹é¡ºåºéå†å½“å‰å±‚çš„å…ƒç´ ã€‚ ä»å·¦åˆ°å³éå†ä¸Šä¾§å…ƒç´ ï¼Œä¾æ¬¡ä¸º (top,left) åˆ° (top,right)ã€‚ ä»ä¸Šåˆ°ä¸‹éå†å³ä¾§å…ƒç´ ï¼Œä¾æ¬¡ä¸º (top+1,right) åˆ° (bottom,right)ã€‚ å¦‚æœ left &lt; right ä¸” top &lt; bottomï¼Œåˆ™ä»å³åˆ°å·¦éå†ä¸‹ä¾§å…ƒç´ ï¼Œä¾æ¬¡ä¸º (bottom,rightâˆ’1) åˆ° (bottom,left+1)ï¼Œä»¥åŠä»ä¸‹åˆ°ä¸Šéå†å·¦ä¾§å…ƒç´ ï¼Œä¾æ¬¡ä¸º (bottom,left) åˆ° (top+1,left)ã€‚ éå†å®Œå½“å‰å±‚çš„å…ƒç´ ä¹‹åï¼Œå°† left å’Œ top åˆ†åˆ«å¢åŠ  1ï¼Œå°† right å’Œ bottom åˆ†åˆ«å‡å°‘ 1ï¼Œè¿›å…¥ä¸‹ä¸€å±‚ç»§ç»­éå†ï¼Œç›´åˆ°éå†å®Œæ‰€æœ‰å…ƒç´ ä¸ºæ­¢ã€‚ 1234567891011121314151617181920class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix or not matrix[0]: return list() rows, columns = len(matrix), len(matrix[0]) order = list() left, right, top, bottom = 0, columns - 1, 0, rows - 1 while left &lt;= right and top &lt;= bottom: for column in range(left, right + 1): order.append(matrix[top][column]) for row in range(top + 1, bottom + 1): order.append(matrix[row][right]) if left &lt; right and top &lt; bottom: for column in range(right - 1, left, -1): order.append(matrix[bottom][column]) for row in range(bottom, top, -1): order.append(matrix[row][left]) left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1 return order"},{"title":"36. Valid Sudoku(medium)","path":"2022/08/31/36/","text":"36. Valid Sudoku(medium)Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable.Only the filled cells need to be validated according to the mentioned rules.1234567891011Input: board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true 123456789101112131415161718192021222324252627282930313233class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: N = 9 # Use binary number to check previous occurrence rows = [0] * N cols = [0] * N boxes = [0] * N for r in range(N): for c in range(N): # Check if the position is filled with number if board[r][c] == &quot;.&quot;: continue pos = int(board[r][c]) - 1 # Check the row if rows[r] &amp; (1 &lt;&lt; pos): return False rows[r] |= (1 &lt;&lt; pos) # Check the column if cols[c] &amp; (1 &lt;&lt; pos): return False cols[c] |= (1 &lt;&lt; pos) # Check the box idx = (r // 3) * 3 + c // 3 if boxes[idx] &amp; (1 &lt;&lt; pos): return False boxes[idx] |= (1 &lt;&lt; pos) return True leetcodeé¢˜è§£12345678910111213141516class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row = [[0] * 9 for _ in range(9)] col = [[0] * 9 for _ in range(9)] block = [[0] * 9 for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] != &#x27;.&#x27;: num = int(board[i][j]) - 1 b = (i // 3) * 3 + j // 3 if row[i][num] or col[j][num] or block[b][num]: return False row[i][num] = col[j][num] = block[b][num] = 1 return True"},{"title":"48. Rotate Image(medium)","path":"2022/08/30/48/","text":"48. Rotate Image(medium)You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.12Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]Output: [[7,4,1],[8,5,2],[9,6,3]] è¿™é¢˜æœ‰ä¸€ä¸ªéå¸¸å·§å¦™çš„ç”¨ç¿»è½¬ä»£æ›¿æ—‹è½¬çš„æ–¹æ³•ï¼Œä½œä¸ºä¾‹å­ï¼Œ$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} \\tag{1}$$å…ˆå°†å…¶é€šè¿‡æ°´å¹³è½´ç¿»è½¬å¾—åˆ°ï¼š $$ \\begin{bmatrix} 7 &amp; 8 &amp; 9 \\ 4 &amp; 5 &amp; 6 \\ 1 &amp; 2 &amp; 3 \\end{bmatrix} \\tag{2}$$ å†æ ¹æ®ä¸»å¯¹è§’çº¿ç¿»è½¬å¾—åˆ°ï¼š$$ \\begin{bmatrix} 7 &amp; 4 &amp; 1 \\ 8 &amp; 5 &amp; 2 \\ 9 &amp; 6 &amp; 3 \\end{bmatrix} \\tag{3}$$ è¿™æ ·å°±å¯ä»¥çœ‹å‡ºæ¥äº†ï¼Œclockwiseæ—‹è½¬90Â°å°±ç›¸å½“äºå…ˆæ°´å¹³ç¿»è½¬å†æ ¹æ®ä¸»å¯¹è§’çº¿ç¿»è½¬ å®˜æ–¹é¢˜è§£ 123456789101112class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix) for i in range(n//2): for j in range(n): matrix[i][j],matrix[n-i-1][j]=matrix[n-i-1][j],matrix[i][j] for i in range(n): for j in range(i): matrix[i][j],matrix[j][i]=matrix[j][i],matrix[i][j]"},{"title":"1094. Car Pooling(medium)","path":"2022/08/30/1094/","text":"1094. Car Pooling(medium)There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the carâ€™s initial location.Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.12Input: trips = [[2,1,5],[3,3,7]], capacity = 4Output: false å·®åˆ†æ•°ç»„ç»å…¸é¢˜ leetcodeé¢˜è§£123456789101112131415161718192021222324252627class Solution: def carPooling(self, trips: List[List[int]], capacity: int) -&gt; bool: # ç¡®å®šæœ€å¤šæœ‰å‡ ç«™-&gt;æ•°ç»„é•¿åº¦ stations = 0 for change_list in trips: if change_list[2]+1 &gt; stations: stations = change_list[2] + 1 # åŸæ•°ç»„ï¼Œä¸æ¥å®¢æ—¶æ¯ç«™äººæ•° ori = [0] * stations # æ ¸å¿ƒæ­¥éª¤1. æ„é€ å·®åˆ†æ•°ç»„ diff = [0] * stations # æ ¸å¿ƒæ­¥éª¤2. å·®åˆ†æ•°ç»„è®°å½•ä¿®æ”¹ for cnt, start, end in trips: diff[start] += cnt # diffä¸‹æ ‡ä¸ºåŒºé—´ç»ˆç‚¹+1ï¼Œå› ä¸ºä¿®æ”¹åŒºé—´ä¸º[start, end-1]ï¼Œæ‰€ä»¥diffä¸‹è¡¨ä¸ºend if end &lt; stations: diff[end] -= cnt # æ ¸å¿ƒæ­¥éª¤3. å·®åˆ†æ•°ç»„æ¨å‡ºä¿®æ”¹åçš„æ•°ç»„ï¼Œå¹¶åˆ¤æ–­ä¿®æ”¹åçš„æ•°ç»„ä¸­æ˜¯å¦æœ‰è¶…è½½çš„ for i in range(stations): if not i: res_i_1 = 0 res_i = res_i_1 + diff[i] # ç¬¬iç«™äººæ•° res_i_1 = res_i if res_i &gt; capacity: return False return True"},{"title":"1109. Corporate Flight Bookings(medium)","path":"2022/08/30/1109/","text":"1109. Corporate Flight Bookings(medium)There are n flights that are labeled from 1 to n.You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.è¿™é“é¢˜åˆæ˜¯ä¸€ä¸ªæ ‡å‡†çš„å·®åˆ†æ•°ç»„é¢˜ï¼Œä¸370é¢˜å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œå·®åˆ«åœ¨äºlengthæ˜¯0-4è¿˜æ˜¯1-5 class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]: res = [0]*(n+1) for booking in bookings: start,end,v = booking s=start-1 e=end-1 res[s]+=v res[e+1]-=v for i in range(1,n): res[i] += res[i-1] return res[:-1]"},{"title":"370. Range Addition(medium)","path":"2022/08/30/370/","text":"370. Range Addition(medium)You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], â€¦, arr[endIdxi] by inci.Return arr after applying all the updates.Example12Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]Output: [-2,0,3,5,3] leetcodeé¢˜è§£ å·®åˆ†æ•°ç»„ç»å…¸é¢˜ç›® 1234567891011121314class Solution: def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]: res = [0]*length for update in updates: start, end, inc = update res[start]+=inc if end+1&lt;=length -1:#if endIdx + 1 is not out of range. If it is out of range, we don&#x27;t do anything res[end+1]-=inc sum = 0 for i in range(length): sum+= res[i] res[i]=sum return res å…¶å®è¿™ä¸ªæ–¹æ³•å¹¶ä¸æ˜¯å·®åˆ†æ•°ç»„ï¼Œè¿˜æ˜¯å‰ç¼€å’Œæ•°ç»„ï¼Œä¹Ÿå°±æ˜¯è¯´å·®åˆ†æ•°ç»„å’Œå‰ç¼€å’Œæ•°ç»„å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Ÿ 123456789101112class Solution: def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]: res = [0] * (length + 1) for s, e, v in updates: res[s] += v res[e+1] -= v for i in range(1, length):#åŠ ä¸Šå‰é¢çš„æ•°å­— res[i] += res[i-1] return res[:-1]"},{"title":"LeetCode-skill6-stack","path":"2022/08/30/LeetCode-skill6-stack/","text":"1. æ ˆçš„å®šä¹‰æ ˆæ˜¯ä¸€ç§å…ˆè¿›åå‡ºï¼ˆFILO: First In Last Out,ï¼‰çš„çº¿æ€§ç»“æ„ï¼Œå³å‹æ ˆå’Œå¼¹æ ˆå‡åœ¨æ ˆçš„å°¾éƒ¨å®Œæˆã€‚å‹æ ˆï¼šå³æ ˆæ·»åŠ æˆå‘˜ï¼Œåœ¨æ ˆçš„å°¾éƒ¨å®Œæˆå¼¹æ ˆï¼šå³æ ˆåˆ é™¤æˆå‘˜ï¼Œåœ¨æ ˆçš„å°¾éƒ¨å®Œæˆåœ¨åˆ›å»ºæ ˆæ—¶ï¼Œå¦‚æœä»¥æ•°ç»„çš„æ•°æ®ç»“æ„ä¸ºåŸºç¡€æ—¶ï¼Œä»¥æ•°ç»„çš„å°¾éƒ¨ä¸ºæ ˆçš„å°¾éƒ¨ï¼›åœ¨åˆ›å»ºæ ˆæ—¶ï¼Œå¦‚æœä»¥é“¾è¡¨çš„æ•°æ®ç»“æ„ä¸ºåŸºç¡€æ—¶ï¼Œä»¥é“¾è¡¨çš„å¤´éƒ¨ä¸ºæ ˆçš„å°¾éƒ¨ï¼› 2. æ ˆçš„åŠŸèƒ½æˆå‘˜å‡½æ•°push(): åœ¨æ ˆçš„å°¾éƒ¨æ·»åŠ æˆå‘˜pop(): åœ¨æ ˆçš„å°¾éƒ¨åˆ é™¤æˆå‘˜top(): è¿”å›æ ˆçš„å¤´éƒ¨æˆå‘˜is_Empty(): æ£€æµ‹æ ˆæ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ºç©ºï¼Œåˆ™è¿”å›Trueï¼Œ å¦åˆ™è¿”å›Falselength(): è¿”å›æ ˆçš„æˆå‘˜æ•°é‡travel(): éå†æ ˆçš„æ‰€æœ‰æˆå‘˜ å¸¸è§æ ˆçš„å‡½æ•°æ“ä½œåŒ…æ‹¬empty() â€“ è¿”å›æ ˆæ˜¯å¦ä¸ºç©º â€“ Time Complexity : O(1) size() â€“ è¿”å›æ ˆçš„é•¿åº¦ â€“ Time Complexity : O(1) top() â€“ æŸ¥çœ‹æ ˆé¡¶å…ƒç´  â€“ Time Complexity : O(1) push(g) â€“ å‘æ ˆé¡¶æ·»åŠ å…ƒç´  â€“ Time Complexity : O(1) pop() â€“ åˆ é™¤æ ˆé¡¶å…ƒç´  â€“ Time Complexity : O(1) pythonä¸­æ ˆå¯ä»¥ç”¨ä»¥ä¸‹ä¸‰ç§æ–¹æ³•å®ç°ï¼š ï¼‘)list ï¼’)collections.deque ï¼“)queue.LifoQueue ä½¿ç”¨åˆ—è¡¨å®ç°æ ˆ pythonçš„å†…ç½®æ•°æ®ç»“æ„listå¯ä»¥ç”¨æ¥å®ç°æ ˆï¼Œç”¨append()å‘æ ˆé¡¶æ·»åŠ å…ƒç´ , pop() å¯ä»¥ä»¥åè¿›å…ˆå‡ºçš„é¡ºåºåˆ é™¤å…ƒç´  ä½†æ˜¯åˆ—è¡¨æœ¬èº«æœ‰ä¸€äº›ç¼ºç‚¹ï¼Œä¸»è¦é—®é¢˜å°±æ˜¯å½“åˆ—è¡¨ä¸æ–­æ‰©å¤§çš„æ—¶å€™ä¼šé‡åˆ°é€Ÿåº¦ç“¶é¢ˆï¼åˆ—è¡¨æ˜¯åŠ¨æ€æ•°ç»„ï¼Œå› æ­¤å¾€å…¶ä¸­æ·»åŠ æ–°å…ƒç´ è€Œæ²¡æœ‰ç©ºé—´ä¿å­˜æ–°çš„å…ƒç´ æ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨é‡æ–°åˆ†é…å†…å­˜å—ï¼Œå¹¶å°†åŸæ¥çš„å†…å­˜ä¸­çš„å€¼å¤åˆ¶åˆ°æ–°çš„å†…å­˜å—ä¸­ï¼è¿™å°±å¯¼è‡´äº†ä¸€äº›append()æ“ä½œä¼šæ¶ˆè€—æ›´å¤šçš„æ—¶é—´ ä½¿ç”¨collections.dequeå®ç°æ ˆ pythonä¸­æ ˆä¹Ÿå¯ä»¥ç”¨dequeç±»å®ç°ï¼Œå½“æˆ‘ä»¬æƒ³è¦åœ¨å®ç°åœ¨å®¹å™¨ä¸¤ç«¯æ›´å¿«é€Ÿåœ°è¿›è¡Œappendå’Œpopæ“ä½œæ—¶ï¼Œdequeæ¯”åˆ—è¡¨æ›´åˆé€‚ï¼dequeå¯ä»¥æä¾›O(1)æ—¶é—´çš„appendå’Œpopæ“ä½œï¼Œè€Œåˆ—è¡¨åˆ™éœ€è¦O(n)æ—¶é—´. ä½¿ç”¨queue moduleå®ç°æ ˆ Queueæ¨¡å—æœ‰LIFO queueï¼Œä¹Ÿå°±æ˜¯æ ˆç»“æ„ï¼ç”¨put()å’Œget()æ“ä½œä»Queueä¸­æ·»åŠ å’Œè·å¾—æ•°æ®"},{"title":"20. Valid Parentheses(easy)","path":"2022/08/30/20/","text":"20. Valid Parentheses(easy)Given a string s containing just the characters â€˜(â€˜, â€˜)â€™, â€˜{â€˜, â€˜}â€™, â€˜[â€˜ and â€˜]â€™, determine if the input string is valid.An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.12Input: s = &quot;()[]&#123;&#125;&quot;Output: true æ‹¬å·é¢˜ä¸€å…±ä¸‰é¢˜ï¼š20. æœ‰æ•ˆçš„æ‹¬å·20. Valid Parentheses921.ä½¿æ‹¬å·æœ‰æ•ˆçš„æœ€å°æ’å…¥921. Minimum Add to Make Parentheses Valid1541.å¹³è¡¡æ‹¬å·ä¸²çš„æœ€å°‘æ’å…¥1541. Minimum Insertions to Balance a Parentheses String å®˜æ–¹é¢˜è§£åˆ¤æ–­æ‹¬å·çš„æœ‰æ•ˆæ€§å¯ä»¥ä½¿ç”¨ã€Œæ ˆã€è¿™ä¸€æ•°æ®ç»“æ„æ¥è§£å†³ã€‚ æˆ‘ä»¬éå†ç»™å®šçš„å­—ç¬¦ä¸² sã€‚å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå·¦æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬ä¼šæœŸæœ›åœ¨åç»­çš„éå†ä¸­ï¼Œæœ‰ä¸€ä¸ªç›¸åŒç±»å‹çš„å³æ‹¬å·å°†å…¶é—­åˆã€‚ç”±äºåé‡åˆ°çš„å·¦æ‹¬å·è¦å…ˆé—­åˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå·¦æ‹¬å·æ”¾å…¥æ ˆé¡¶ã€‚ å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå³æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªç›¸åŒç±»å‹çš„å·¦æ‹¬å·é—­åˆã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å–å‡ºæ ˆé¡¶çš„å·¦æ‹¬å·å¹¶åˆ¤æ–­å®ƒä»¬æ˜¯å¦æ˜¯ç›¸åŒç±»å‹çš„æ‹¬å·ã€‚å¦‚æœä¸æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œæˆ–è€…æ ˆä¸­å¹¶æ²¡æœ‰å·¦æ‹¬å·ï¼Œé‚£ä¹ˆå­—ç¬¦ä¸² s æ— æ•ˆï¼Œè¿”å› Falseã€‚ä¸ºäº†å¿«é€Ÿåˆ¤æ–­æ‹¬å·çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸€ç§æ‹¬å·ã€‚å“ˆå¸Œè¡¨çš„é”®ä¸ºå³æ‹¬å·ï¼Œå€¼ä¸ºç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚ åœ¨éå†ç»“æŸåï¼Œå¦‚æœæ ˆä¸­æ²¡æœ‰å·¦æ‹¬å·ï¼Œè¯´æ˜æˆ‘ä»¬å°†å­—ç¬¦ä¸² s ä¸­çš„æ‰€æœ‰å·¦æ‹¬å·é—­åˆï¼Œè¿”å› Trueï¼Œå¦åˆ™è¿”å› Falseã€‚ æ³¨æ„åˆ°æœ‰æ•ˆå­—ç¬¦ä¸²çš„é•¿åº¦ä¸€å®šä¸ºå¶æ•°ï¼Œå› æ­¤å¦‚æœå­—ç¬¦ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å› Falseï¼Œçœå»åç»­çš„éå†åˆ¤æ–­è¿‡ç¨‹ã€‚ é¢˜è§£1 12345678class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;?&#x27;: &#x27;?&#x27;&#125; stack = [&#x27;?&#x27;] for c in s: if c in dic: stack.append(c) elif dic[stack.pop()] != c: return False return len(stack) == 1 é¢˜è§£2 1234567891011121314151617181920class Solution: def isValid(self, s: str) -&gt; bool: if len(s) % 2 == 1: return False pairs = &#123; &quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;, &#125; stack = list() for ch in s: if ch in pairs: if not stack or stack[-1] != pairs[ch]: return False stack.pop() else: stack.append(ch) return not stack"},{"title":"LeetCode-skill5-difference-array","path":"2022/08/29/LeetCode-skill5-difference-array/","text":"æœ¬æ–‡è®²ä¸€ä¸ªå’Œå‰ç¼€å’Œæ€æƒ³éå¸¸ç±»ä¼¼çš„ç®—æ³•æŠ€å·§ã€Œå·®åˆ†æ•°ç»„ã€ï¼Œå·®åˆ†æ•°ç»„çš„ä¸»è¦é€‚ç”¨åœºæ™¯æ˜¯é¢‘ç¹å¯¹åŸå§‹æ•°ç»„çš„æŸä¸ªåŒºé—´çš„å…ƒç´ è¿›è¡Œå¢å‡ã€‚ æ¯”å¦‚è¯´ï¼Œæˆ‘ç»™ä½ è¾“å…¥ä¸€ä¸ªæ•°ç»„ numsï¼Œç„¶ååˆè¦æ±‚ç»™åŒºé—´ nums[2..6] å…¨éƒ¨åŠ  1ï¼Œå†ç»™ nums[3..9] å…¨éƒ¨å‡ 3ï¼Œå†ç»™ nums[0..4] å…¨éƒ¨åŠ  2ï¼Œå†ç»™â€¦ ä¸€é€šæ“ä½œçŒ›å¦‚è™ï¼Œç„¶åé—®ä½ ï¼Œæœ€å nums æ•°ç»„çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿ å¸¸è§„çš„æ€è·¯å¾ˆå®¹æ˜“ï¼Œä½ è®©æˆ‘ç»™åŒºé—´ nums[i..j] åŠ ä¸Š valï¼Œé‚£æˆ‘å°±ä¸€ä¸ª for å¾ªç¯ç»™å®ƒä»¬éƒ½åŠ ä¸Šå‘—ï¼Œè¿˜èƒ½å’‹æ ·ï¼Ÿè¿™ç§æ€è·¯çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œç”±äºè¿™ä¸ªåœºæ™¯ä¸‹å¯¹ nums çš„ä¿®æ”¹éå¸¸é¢‘ç¹ï¼Œæ‰€ä»¥æ•ˆç‡ä¼šå¾ˆä½ä¸‹ã€‚ è¿™é‡Œå°±éœ€è¦å·®åˆ†æ•°ç»„çš„æŠ€å·§ï¼Œç±»ä¼¼å‰ç¼€å’ŒæŠ€å·§æ„é€ çš„ prefix æ•°ç»„ï¼Œæˆ‘ä»¬å…ˆå¯¹ nums æ•°ç»„æ„é€ ä¸€ä¸ª diff å·®åˆ†æ•°ç»„ï¼Œdiff[i] å°±æ˜¯ nums[i] å’Œ nums[i-1] ä¹‹å·®ï¼š 1234567int[] diff = new int[nums.length];// æ„é€ å·®åˆ†æ•°ç»„diff[0] = nums[0];for (int i = 1; i &lt; nums.length; i++) &#123; diff[i] = nums[i] - nums[i - 1];&#125; é€šè¿‡è¿™ä¸ª diff å·®åˆ†æ•°ç»„æ˜¯å¯ä»¥åæ¨å‡ºåŸå§‹æ•°ç»„ nums çš„ï¼Œä»£ç é€»è¾‘å¦‚ä¸‹ï¼š 123456int[] res = new int[diff.length];// æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„res[0] = diff[0];for (int i = 1; i &lt; diff.length; i++) &#123; res[i] = res[i - 1] + diff[i];&#125; åŸç†å¾ˆç®€å•ï¼Œå›æƒ³ diff æ•°ç»„åæ¨ nums æ•°ç»„çš„è¿‡ç¨‹ï¼Œdiff[i] += 3 æ„å‘³ç€ç»™ nums[i..] æ‰€æœ‰çš„å…ƒç´ éƒ½åŠ äº† 3ï¼Œç„¶å diff[j+1] -= 3 åˆæ„å‘³ç€å¯¹äº nums[j+1..] æ‰€æœ‰å…ƒç´ å†å‡ 3ï¼Œé‚£ç»¼åˆèµ·æ¥ï¼Œæ˜¯ä¸æ˜¯å°±æ˜¯å¯¹ nums[i..j] ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½åŠ  3 äº†ï¼Ÿ åªè¦èŠ±è´¹ O(1) çš„æ—¶é—´ä¿®æ”¹ diff æ•°ç»„ï¼Œå°±ç›¸å½“äºç»™ nums çš„æ•´ä¸ªåŒºé—´åšäº†ä¿®æ”¹ã€‚å¤šæ¬¡ä¿®æ”¹ diffï¼Œç„¶åé€šè¿‡ diff æ•°ç»„åæ¨ï¼Œå³å¯å¾—åˆ° nums ä¿®æ”¹åçš„ç»“æœã€‚ ç°åœ¨æˆ‘ä»¬æŠŠå·®åˆ†æ•°ç»„æŠ½è±¡æˆä¸€ä¸ªç±»ï¼ŒåŒ…å« increment æ–¹æ³•å’Œ result æ–¹æ³•ï¼š 12345678910111213141516171819202122232425class Difference: def __init__(self, nums): self.nums = nums self.diff = self.make_diff(self.nums) def make_diff(self, nums): diff = [0 for _ in range(len(nums))] diff[0] = nums[0] for i in range(1,len(nums)): diff[i] = nums[i] - nums[i-1] return diff # ç»™é—­åŒºé—´[i,j]å¢åŠ val # åŸç†å¾ˆç®€å•ï¼Œå›æƒ³diffæ•°ç»„åæ¨numsæ•°ç»„çš„è¿‡ç¨‹ï¼Œdiff[i] += 3æ„å‘³ç€ç»™nums[i..]æ‰€æœ‰çš„å…ƒç´ éƒ½åŠ äº† 3ï¼Œç„¶ådiff[j+1] -= 3åˆæ„å‘³ç€å¯¹äºnums[j+1..]æ‰€æœ‰å…ƒç´ å†å‡ 3ï¼Œé‚£ç»¼åˆèµ·æ¥ï¼Œæ˜¯ä¸æ˜¯å°±æ˜¯å¯¹nums[i..j]ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½åŠ  3 äº†ï¼Ÿ def increment(self, i, j, val): self.diff[i] += val if j + 1 &lt; len(self.diff): self.diff[j + 1] -= val def recover(self): rdiff = [0 for _ in range(len(self.diff))] rdiff[0] = self.diff[0] for i in range(1,len(self.nums)): rdiff[i] = rdiff[i-1] + self.diff[i] return rdiff difference = Difference([8,5,9,6,1])print(difference.diff)rdiff = difference.recover()print(rdiff)difference.increment(2,3,1)print(difference.diff)rdiff = difference.recover()print(rdiff) ã€pythonåˆ·é¢˜ã€‘å·®åˆ†æ•°ç»„https://blog.51cto.com/u_15127632/3275175"},{"title":"LeetCode15-DFS","path":"2022/08/29/LeetCode15-DFS/","text":"æˆ‘ä»¬æ‰€ç†Ÿæ‚‰çš„ DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰é—®é¢˜é€šå¸¸æ˜¯åœ¨æ ‘æˆ–è€…å›¾ç»“æ„ä¸Šè¿›è¡Œçš„ã€‚è€Œæˆ‘ä»¬ä»Šå¤©è¦è®¨è®ºçš„ DFS é—®é¢˜ï¼Œæ˜¯åœ¨ä¸€ç§ã€Œç½‘æ ¼ã€ç»“æ„ä¸­è¿›è¡Œçš„ã€‚å²›å±¿é—®é¢˜æ˜¯è¿™ç±»ç½‘æ ¼ DFS é—®é¢˜çš„å…¸å‹ä»£è¡¨ã€‚ç½‘æ ¼ç»“æ„éå†èµ·æ¥è¦æ¯”äºŒå‰æ ‘å¤æ‚ä¸€äº›ï¼Œå¦‚æœæ²¡æœ‰æŒæ¡ä¸€å®šçš„æ–¹æ³•ï¼ŒDFS ä»£ç å®¹æ˜“å†™å¾—å†—é•¿ç¹æ‚ã€‚ æœ¬æ–‡å°†ä»¥å²›å±¿é—®é¢˜ä¸ºä¾‹ï¼Œå±•ç¤ºç½‘æ ¼ç±»é—®é¢˜ DFS é€šç”¨æ€è·¯ï¼Œä»¥åŠå¦‚ä½•è®©ä»£ç å˜å¾—ç®€æ´ã€‚ åœ¨ LeetCode ä¸­ï¼Œã€Œå²›å±¿é—®é¢˜ã€æ˜¯ä¸€ä¸ªç³»åˆ—ç³»åˆ—é—®é¢˜ï¼Œæ¯”å¦‚ï¼š L200. å²›å±¿æ•°é‡ ï¼ˆEasyï¼‰463. å²›å±¿çš„å‘¨é•¿ ï¼ˆEasyï¼‰695. å²›å±¿çš„æœ€å¤§é¢ç§¯ ï¼ˆMediumï¼‰827. æœ€å¤§äººå·¥å²› ï¼ˆHardï¼‰ ä½œè€…ï¼šnetteeé“¾æ¥ï¼šhttps://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"LeetCode14-BFS","path":"2022/08/29/LeetCode14-BFS/","text":""},{"title":"5. Longest Palindromic Substring(medium)","path":"2022/08/29/5/","text":"5. Longest Palindromic Substring(medium)Given a string s, return the longest palindromic substring in s.substringå’Œsubsequenceï¼šsubstringæ˜¯å­ä¸²ã€‚ä¾‹å¦‚ï¼Œâ€˜weeâ€™ æ˜¯ â€˜helloweenâ€™çš„substringï¼Œâ€˜hwnâ€™ ä¸æ˜¯ â€˜helloweenâ€™çš„substringã€‚å–å­ä¸²çš„æ—¶å€™ä¸èƒ½éš”ç€å­—ç¬¦å–ã€‚subsequenceæ˜¯å­åºåˆ—ã€‚ä¾‹å¦‚ï¼Œâ€˜weeâ€™ å’Œ â€˜hwnâ€™ éƒ½æ˜¯ â€˜helloweenâ€™çš„subsequenceã€‚å–å­åºåˆ—çš„æ—¶å€™å¯ä»¥éš”ç€å­—ç¬¦å–ã€‚palindromic substring æ˜¯å›æ–‡å­ä¸²ï¼Œä¾‹å¦‚â€˜soebeosâ€™ æ˜¯ â€˜absoebeostgeâ€™ çš„å›æ–‡å­ä¸²ã€‚å›æ–‡çš„æ„æ€æ˜¯æ­£è¿‡æ¥å¿µå’Œåè¿‡æ¥å¿µéƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚â€œä¸Šæµ·è‡ªæ¥æ°´æ¥è‡ªæµ·ä¸Šâ€ã€‚ leetcodeé¢˜è§£æ€è·¯å¯»æ‰¾å›æ–‡ä¸²çš„é—®é¢˜æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šä»ä¸­é—´å¼€å§‹å‘ä¸¤è¾¹æ‰©æ•£æ¥åˆ¤æ–­å›æ–‡ä¸²ï¼Œå¯¹äºæœ€é•¿å›æ–‡å­ä¸²ï¼Œå°±æ˜¯è¿™ä¸ªæ„æ€ï¼š 123for 0 &lt;= i &lt; len(s): æ‰¾åˆ°ä»¥ s[i] ä¸ºä¸­å¿ƒçš„å›æ–‡ä¸² æ›´æ–°ç­”æ¡ˆ æ‰¾å›æ–‡ä¸²çš„å…³é”®æŠ€å·§æ˜¯ä¼ å…¥ä¸¤ä¸ªæŒ‡é’ˆ l å’Œ r å‘ä¸¤è¾¹æ‰©æ•£ï¼Œå› ä¸ºè¿™æ ·å®ç°å¯ä»¥åŒæ—¶å¤„ç†å›æ–‡ä¸²é•¿åº¦ä¸ºå¥‡æ•°å’Œå¶æ•°çš„æƒ…å†µã€‚ 1234567for 0 &lt;= i &lt; len(s): # æ‰¾åˆ°ä»¥ s[i] ä¸ºä¸­å¿ƒçš„å›æ–‡ä¸² palindrome(s, i, i) # æ‰¾åˆ°ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„å›æ–‡ä¸² palindrome(s, i, i + 1) æ›´æ–°ç­”æ¡ˆ 12345678910111213141516class Solution: def longestPalindrome(self, s: str) -&gt; str: def palindrome(s,l,r): while l&gt;=0 and r&lt;len(s) and s[l]==s[r]: l-=1 r+=1 return s[l+1:r] res=&quot;&quot; for i in range(len(s)): s1=palindrome(s, i, i) s2=palindrome(s, i, i+1) res=res if len(res)&gt;len(s1) else s1 res=res if len(res)&gt;len(s2) else s2 return res"},{"title":"344. Reverse String(easy)","path":"2022/08/29/344/","text":"344. Reverse String(easy)Write a function that reverses a string. The input string is given as an array of characters s.You must do this by modifying the input array in-place with O(1) extra memory.åè½¬å­—ç¬¦ä¸²ï¼Œå…¶å®è¿˜æ˜¯åè½¬æ•°ç»„ï¼ŒåŒæŒ‡é’ˆä¸€å·¦ä¸€å³æ¥å›æ›¿æ¢å°±è¡Œäº†ï¼Œè¦æ³¨æ„çš„æ˜¯åœ¨æœ¬ä½“ä¸Šå˜æ¢ class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; left = 0 right = len(s)-1 while left&lt;right: tmp =s[left] s[left]=s[right] s[right]=tmp left+=1 right-=1"},{"title":"704. Binary Search(easy)","path":"2022/08/29/704/","text":"704. Binary Search(easy)Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity.123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 äºŒåˆ†æŸ¥æ‰¾æ¨¡æ¿ 12345678910111213class Solution: def search(self, nums: List[int], target: int) -&gt; int: left =0 right=len(nums)-1 while(left&lt;=right): mid =left+(right-left)//2 if nums[mid]==target: return mid elif nums[mid]&lt;target: left=mid+1 elif nums[mid]&gt;target: right = mid-1 return -1"},{"title":"LeetCode13-Array","path":"2022/08/29/LeetCode13-Array/","text":"Python3 äºŒç»´æ•°ç»„ï¼Œä¸‰ç»´æ•°ç»„ï¼Œå¤šç»´æ•°ç»„çš„åˆ›å»ºäºŒç»´æ•°ç»„çš„åˆ›å»ºï¼š12345678910111213# 3è¡Œ10åˆ—çš„äºŒç»´æ•°ç»„çš„åˆ›å»ºï¼šm = [[0] * 3 for _ in range(10)]#æˆ–è€…m = [[0] * 3] * 10#æˆ‘ä»¬æ¥æ£€æŸ¥ä¸€ä¸‹æ•°ç»„åˆ›å»ºçš„å¯¹ä¸å¯¹for i in range(10): for j in range(3): try: if (m[i][j] != 0): print(i, j) except: print(i, j, &quot;error&quot;)#æ²¡æœ‰è¾“å‡ºerroræœ‰å…³çš„ä¸œè¥¿ï¼Œæ­£ç¡®ï¼ ä¸‰ç»´æ•°ç»„çš„åˆ›å»ºï¼š12345678910111213141516#4è¡Œ3åˆ—ï¼ŒZ = 2çš„ä¸‰ç»´æ•°ç»„çš„åˆ›å»ºï¼šm = [[[0] * 2 for _ in range(3)] for _ in range(4)]#æˆ–è€…m = [[[0] * 2] * 3] * 4#æ£€æŸ¥ï¼šfor i in range(4): for j in range(3): for k in range(2): try: if (m[i][j][k] != 0): print(i, j, k); except: print(i, j, k, &quot;error&quot;)#æ²¡æœ‰è¾“å‡ºerroræœ‰å…³çš„ä¸œè¥¿ï¼Œæ­£ç¡®ï¼#æ¥ä¸‹æ¥å¤šç»´æ•°ç»„çš„åˆ›å»ºä¹Ÿå°±å¾ˆç®€å•äº†#m = [.....[[0] * q] * w] * e]*r]*t]*y]*u]*.........] 1. å¿«æ…¢æŒ‡é’ˆ2. å·¦å³æŒ‡é’ˆäºŒåˆ†æŸ¥æ‰¾Leetcode é¢˜è§£ - äºŒåˆ†æŸ¥æ‰¾1. æ±‚å¼€æ–¹2. å¤§äºç»™å®šå…ƒç´ çš„æœ€å°å…ƒç´ 3. æœ‰åºæ•°ç»„çš„ Single Element4. ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬5. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—6. æŸ¥æ‰¾åŒºé—´äºŒåˆ†æŸ¥æ‰¾ binary search algorithm æ—¶é—´å¤æ‚åº¦äºŒåˆ†æŸ¥æ‰¾ä¹Ÿç§°ä¸ºæŠ˜åŠæŸ¥æ‰¾ï¼Œæ¯æ¬¡éƒ½èƒ½å°†æŸ¥æ‰¾åŒºé—´å‡åŠï¼Œè¿™ç§æŠ˜åŠç‰¹æ€§çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ã€‚ m è®¡ç®—æœ‰ä¸¤ç§è®¡ç®—ä¸­å€¼ m çš„æ–¹å¼ï¼š m = (l + h) / 2m = l + (h - l) / 2l + h å¯èƒ½å‡ºç°åŠ æ³•æº¢å‡ºï¼Œä¹Ÿå°±æ˜¯è¯´åŠ æ³•çš„ç»“æœå¤§äºæ•´å‹èƒ½å¤Ÿè¡¨ç¤ºçš„èŒƒå›´ã€‚ä½†æ˜¯ l å’Œ h éƒ½ä¸ºæ­£æ•°ï¼Œå› æ­¤ h - l ä¸ä¼šå‡ºç°åŠ æ³•æº¢å‡ºé—®é¢˜ã€‚æ‰€ä»¥ï¼Œæœ€å¥½ä½¿ç”¨ç¬¬äºŒç§è®¡ç®—æ³•æ–¹æ³•ã€‚ æœªæˆåŠŸæŸ¥æ‰¾çš„è¿”å›å€¼å¾ªç¯é€€å‡ºæ—¶å¦‚æœä»ç„¶æ²¡æœ‰æŸ¥æ‰¾åˆ° keyï¼Œé‚£ä¹ˆè¡¨ç¤ºæŸ¥æ‰¾å¤±è´¥ã€‚å¯ä»¥æœ‰ä¸¤ç§è¿”å›å€¼ï¼š -1ï¼šä»¥ä¸€ä¸ªé”™è¯¯ç è¡¨ç¤ºæ²¡æœ‰æŸ¥æ‰¾åˆ° keylï¼šå°† key æ’å…¥åˆ° nums ä¸­çš„æ­£ç¡®ä½ç½® æ¨¡æ¿ 1234567891011121314int binarySearch(int[] nums, int target) &#123; // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125; 1234567891011121314class Solution: def search(self, nums: List[int], target: int) -&gt; int: left =0 right=len(nums)-1 while(left&lt;=right): mid =left+(right-left)//2 if nums[mid]==target: return mid elif nums[mid]&lt;target: left=mid+1 elif nums[mid]&gt;target: right = mid-1 return -1 12345678if åˆ¤æ–­æ¡ä»¶1: æ‰§è¡Œè¯­å¥1â€¦â€¦elif åˆ¤æ–­æ¡ä»¶2: æ‰§è¡Œè¯­å¥2â€¦â€¦elif åˆ¤æ–­æ¡ä»¶3: æ‰§è¡Œè¯­å¥3â€¦â€¦else: æ‰§è¡Œè¯­å¥4â€¦â€¦ print(a[0:-1])python array:ä»ä½ç½®0åˆ°ä½ç½®-1ä¹‹å‰çš„æ•° 123456# ä¸‹é¢ä¸¤ä¸ªç»“æœä¸€æ ·a = &#x27;1234568910â€™print(a[:-1]) print(a[0:-1])#result:a = &#x27;123456891â€™#result:a = &#x27;123456891â€™"},{"title":"283. Move Zeroes(easy)","path":"2022/08/29/283/","text":"283. Move Zeroes(easy)Given an integer array nums, move all 0â€™s to the end of it while maintaining the relative order of the non-zero elements.Note that you must do this in-place without making a copy of the array.12Input: nums = [0,1,0,3,12]Output: [1,3,12,0,0] è¿™é“é¢˜å’Œ26. Remove Duplicates from Sorted Array(easy) å·®ä¸å¤šï¼Œè¿˜æ˜¯åŒæŒ‡é’ˆï¼Œé‡å¤æ•°å­—æ”¹æˆäº†0ï¼ŒæŠŠéé›¶æ•°å­—å†™å…¥æ•°ç»„å‰é¢ï¼Œç„¶åç©ºä½è¡¥0 class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; slow = 0 fast = 0 while fast&lt;len(nums): if nums[fast]!=0: nums[slow]=nums[fast] slow+=1 fast+=1 if slow&lt;len(nums): for i in range(slow,len(nums)): nums[i]=0 return nums"},{"title":"27. Remove Element(easy)","path":"2022/08/29/27/","text":"27. Remove Element(easy)Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:123456789int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; If all assertions pass, then your solution will be accepted.Example1234Input: nums = [3,2,2,3], val = 3Output: 2, nums = [2,2,_,_]Explanation: Your function should return k = 2, with the first two elements of nums being 2.It does not matter what you leave beyond the returned k (hence they are underscores). è§£æ³•ï¼šè¿™é“é¢˜å’Œ26. Remove Duplicates from Sorted Array(easy)å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œå…¶å®æ•°ç»„æ˜¯å¦æœ‰åºæ²¡æœ‰ä»»ä½•å½±å“ï¼Œæ‰€ä»¥è®¾ç½®å¿«æ…¢æŒ‡é’ˆå¯è§£å†³é—®é¢˜ï¼Œæ…¢æŒ‡é’ˆ slow èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ fast èµ°åœ¨å‰é¢æ¢è·¯ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸ç›¸åŒçš„å…ƒç´ å°±èµ‹å€¼ç»™ slow å¹¶è®© slow å‰è¿›ä¸€æ­¥ã€‚è¿™æ ·ï¼Œå°±ä¿è¯äº† nums[0..slow] éƒ½æ˜¯ä¸ç›¸åŒçš„å…ƒç´ ï¼Œå½“ fast æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ nums åï¼Œnums[0..slow] å°±æ˜¯æ•´ä¸ªæ•°ç»„ä¸ç›¸åŒvalä¹‹åçš„ç»“æœ 123456789101112class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: if len(nums)==0: return 0 slow, fast=0,0 while fast&lt;len(nums): if nums[fast]!=val: nums[slow]=nums[fast] slow+=1 fast+=1 return slow"},{"title":"26. Remove Duplicates from Sorted Array(easy)","path":"2022/08/29/26/","text":"26. Remove Duplicates from Sorted Array(easy)Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:123456789int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; If all assertions pass, then your solution will be accepted.Example1234Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). è§£æ³•ï¼šè¿™é“é¢˜å¹¶ä¸éš¾ï¼Œå› ä¸ºåªèƒ½åœ¨åŸæ•°ç»„ä¸Šæ“ä½œï¼Œæ‰€ä»¥è®¾ç½®å¿«æ…¢æŒ‡é’ˆå¯è§£å†³é—®é¢˜ï¼Œæ…¢æŒ‡é’ˆ slow èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ fast èµ°åœ¨å‰é¢æ¢è·¯ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸é‡å¤çš„å…ƒç´ å°±èµ‹å€¼ç»™ slow å¹¶è®© slow å‰è¿›ä¸€æ­¥ã€‚è¿™æ ·ï¼Œå°±ä¿è¯äº† nums[0..slow] éƒ½æ˜¯æ— é‡å¤çš„å…ƒç´ ï¼Œå½“ fast æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ nums åï¼Œnums[0..slow] å°±æ˜¯æ•´ä¸ªæ•°ç»„å»é‡ä¹‹åçš„ç»“æœ class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums)==0: return 0 slow = 0 fast = 0 while fast&lt;len(nums): if nums[fast]!=nums[slow]: slow+=1 nums[slow]=nums[fast] fast+=1 return slow+1"},{"title":"LeetCode-skill4-python-loop","path":"2022/08/28/LeetCode-skill4-python-loop/","text":"forfor i in range(n) range(n)è¾“å‡ºçš„åŒºé—´ä¸º [ 0 , n âˆ’ 1 ]ï¼Œä»£ç å¦‚ä¸‹ for i in range(5): print(i) è¾“å‡ºç»“æœä¸ºï¼š0, 1, 2, 3, 4 for i in range(m, n) range(m, n)è¾“å‡ºçš„åŒºé—´ä¸º [ m , n âˆ’ 1 ] [m, n - 1][m,nâˆ’1]ï¼Œä»£ç å¦‚ä¸‹ for i in range(2, 5): print(i) è¾“å‡ºç»“æœä¸ºï¼š 2, 3, 4 for i in range(m, n, s) å‚æ•°m,nä¸ºå·¦å³è¾¹ç•Œï¼Œsä¸ºæ­¥é•¿range(m, n, s)è¾“å‡ºçš„åŒºé—´ä¸º ( m , m + s , m + 2 s , â‹¯ , n âˆ’ k s ) (m, m + s, m + 2s, \\cdots , n - ks)(m,m+s,m+2s,â‹¯,nâˆ’ks)ï¼Œä»£ç å¦‚ä¸‹ for i in range(1,7,2): print(i) è¾“å‡ºç»“æœä¸ºï¼š1, 3ï¼Œ5 for _ in range() _æ˜¯ä¸€ä¸ªå˜é‡ï¼ˆå› ä¸ºPythonä¸­çš„å˜é‡å‘½åèƒ½å¤Ÿä»¥ä¸‹åˆ’çº¿å¼€å§‹ï¼Œå•ç‹¬çš„ä¸‹åˆ’çº¿ä¹Ÿæ˜¯ä¸€ä¸ªå˜é‡ï¼‰ï¼Œè·Ÿiä¸€æ ·ï¼Œä¸åŒç‚¹åœ¨äºï¼Œiä¼šåœ¨åç»­çš„å¾ªç¯ä½“ä¸­è¿ç”¨åˆ°ï¼Œè€Œ_åªæ˜¯ç”¨æ¥å®ç°å¾ªç¯çš„æ¬¡æ•°ã€‚ï¼ˆå› ä¸ºåŸºæœ¬ä¸Šä¸ä¼šä½¿ç”¨å•ç‹¬çš„ä¸‹åˆ’çº¿æ¥ç”¨ä½œå˜é‡ä¼ å€¼ï¼‰"},{"title":"25. Reverse Nodes in k-Group(hard)","path":"2022/08/28/25/","text":"25. Reverse Nodes in k-Group(hard)Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the listâ€™s nodes, only nodes themselves may be changed.Example 12Input: head = [1,2,3,4,5], k = 2Output: [2,1,4,3,5] æˆ‘ä»¬è¦å®ç°ä¸€ä¸ª reverse å‡½æ•°åè½¬ä¸€ä¸ªåŒºé—´ä¹‹å†…çš„å…ƒç´ ã€‚åœ¨æ­¤ä¹‹å‰æˆ‘ä»¬å†ç®€åŒ–ä¸€ä¸‹ï¼Œç»™å®šé“¾è¡¨å¤´ç»“ç‚¹ï¼Œå¦‚ä½•åè½¬æ•´ä¸ªé“¾è¡¨ï¼Ÿ 123456789101112131415// åè½¬ä»¥ a ä¸ºå¤´ç»“ç‚¹çš„é“¾è¡¨ListNode reverse(ListNode a) &#123; ListNode pre, cur, nxt; pre = null; cur = a; nxt = a; while (cur != null) &#123; nxt = cur.next; // é€ä¸ªç»“ç‚¹åè½¬ cur.next = pre; // æ›´æ–°æŒ‡é’ˆä½ç½® pre = cur; cur = nxt; &#125; // è¿”å›åè½¬åçš„å¤´ç»“ç‚¹ return pre;&#125; è¿™æ¬¡ä½¿ç”¨è¿­ä»£æ€è·¯æ¥å®ç°çš„ï¼Œå€ŸåŠ©åŠ¨ç”»ç†è§£åº”è¯¥å¾ˆå®¹æ˜“ã€‚ ã€Œåè½¬ä»¥ a ä¸ºå¤´ç»“ç‚¹çš„é“¾è¡¨ã€å…¶å®å°±æ˜¯ã€Œåè½¬ a åˆ° null ä¹‹é—´çš„ç»“ç‚¹ã€ï¼Œé‚£ä¹ˆå¦‚æœè®©ä½ ã€Œåè½¬ a åˆ° b ä¹‹é—´çš„ç»“ç‚¹ã€ï¼Œä½ ä¼šä¸ä¼šï¼Ÿ åªè¦æ›´æ”¹å‡½æ•°ç­¾åï¼Œå¹¶æŠŠä¸Šé¢çš„ä»£ç ä¸­ null æ”¹æˆ b å³å¯ï¼šJavaåŸç‰ˆ 1234567891011121314/** åè½¬åŒºé—´ [a, b) çš„å…ƒç´ ï¼Œæ³¨æ„æ˜¯å·¦é—­å³å¼€ */ListNode reverse(ListNode a, ListNode b) &#123; ListNode pre, cur, nxt; pre = null; cur = a; nxt = a; // while ç»ˆæ­¢çš„æ¡ä»¶æ”¹ä¸€ä¸‹å°±è¡Œäº† while (cur != b) &#123; nxt = cur.next; cur.next = pre; pre = cur; cur = nxt; &#125; // è¿”å›åè½¬åçš„å¤´ç»“ç‚¹ return pre;&#125; python æ”¹ç‰ˆ 1234567891011def reverse(a,b): pre= None current =a nxt=a while (current!=b): nxt = current.next current.next = pre pre = current current = nxt return pre ç°åœ¨æˆ‘ä»¬è¿­ä»£å®ç°äº†åè½¬éƒ¨åˆ†é“¾è¡¨çš„åŠŸèƒ½ï¼Œæ¥ä¸‹æ¥å°±æŒ‰ç…§ä¹‹å‰çš„é€»è¾‘ç¼–å†™ reverseKGroup å‡½æ•°å³å¯ï¼š 12345678910111213141516ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null) return null; // åŒºé—´ [a, b) åŒ…å« k ä¸ªå¾…åè½¬å…ƒç´  ListNode a, b; a = b = head; for (int i = 0; i &lt; k; i++) &#123; // ä¸è¶³ k ä¸ªï¼Œä¸éœ€è¦åè½¬ï¼Œbase case if (b == null) return head; b = b.next; &#125; // åè½¬å‰ k ä¸ªå…ƒç´  ListNode newHead = reverse(a, b); // é€’å½’åè½¬åç»­é“¾è¡¨å¹¶è¿æ¥èµ·æ¥ a.next = reverseKGroup(b, k); return newHead;&#125; python å®Œæ•´ç‰ˆ 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]: def reverse(a,b): pre= None current =a nxt=a while (current!=b): nxt = current.next current.next = pre pre = current current = nxt return pre if not head: return None a= head b = head for i in range(k): if b ==None: return head b=b.next newHead = reverse(a,b) a.next = self.reverseKGroup(b,k) return newHead"},{"title":"92. Reverse Linked List II(medium)","path":"2022/08/27/92/","text":"92. Reverse Linked List II(medium)Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.å®˜æ–¹é¢˜è§£123456789101112131415class Solution: def reverseBetween(self, head: ListNode, left: int, right: int) -&gt; ListNode: # è®¾ç½® dummyNode æ˜¯è¿™ä¸€ç±»é—®é¢˜çš„ä¸€èˆ¬åšæ³• dummy_node = ListNode(-1) dummy_node.next = head pre = dummy_node for i in range(left - 1): pre = pre.next cur = pre.next for i in range(right - left): next = cur.next cur.next = next.next next.next = pre.next pre.next = next return dummy_node.next ç¬¬ä¸€æ­¥ 12345next = cur.nextcur.next = next.nextnext.next = pre.nextpre.next = next ç¬¬äºŒæ­¥"},{"title":"142. Linked List Cycle II(medium)","path":"2022/08/27/142/","text":"142. Linked List Cycle II(medium)å¿«æ…¢æŒ‡é’ˆ-leetcodeé¢˜è§£ æ€è·¯ä¸ç®—æ³• æˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œfast ä¸ slowã€‚å®ƒä»¬èµ·å§‹éƒ½ä½äºé“¾è¡¨çš„å¤´éƒ¨ã€‚éšåï¼Œslow æŒ‡é’ˆæ¯æ¬¡å‘åç§»åŠ¨ä¸€ä¸ªä½ç½®ï¼Œè€Œ fast æŒ‡é’ˆå‘åç§»åŠ¨ä¸¤ä¸ªä½ç½®ã€‚å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯ï¼Œåˆ™ fast æŒ‡é’ˆæœ€ç»ˆå°†å†æ¬¡ä¸ slow æŒ‡é’ˆåœ¨ç¯ä¸­ç›¸é‡ã€‚ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè®¾é“¾è¡¨ä¸­ç¯å¤–éƒ¨åˆ†çš„é•¿åº¦ä¸º aã€‚slow æŒ‡é’ˆè¿›å…¥ç¯åï¼Œåˆèµ°äº† bb çš„è·ç¦»ä¸ fast ç›¸é‡ã€‚æ­¤æ—¶ï¼Œfast æŒ‡é’ˆå·²ç»èµ°å®Œäº†ç¯çš„ nn åœˆï¼Œå› æ­¤å®ƒèµ°è¿‡çš„æ€»è·ç¦»ä¸º a+n(b+c)+b=a+(n+1)b+ncã€‚ æ ¹æ®é¢˜æ„ï¼Œä»»æ„æ—¶åˆ»ï¼Œfast æŒ‡é’ˆèµ°è¿‡çš„è·ç¦»éƒ½ä¸º slow æŒ‡é’ˆçš„ 2 å€ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ a+(n+1)b+nc=2(a+b)âŸ¹a=c+(nâˆ’1)(b+c) a=c+(nâˆ’1)(b+c)æœ‰äº† a=c+(nâˆ’1)(b+c) çš„ç­‰é‡å…³ç³»ï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼šä»ç›¸é‡ç‚¹åˆ°å…¥ç¯ç‚¹çš„è·ç¦»åŠ ä¸Š nâˆ’1 åœˆçš„ç¯é•¿ï¼Œæ°å¥½ç­‰äºä»é“¾è¡¨å¤´éƒ¨åˆ°å…¥ç¯ç‚¹çš„è·ç¦»ã€‚ å› æ­¤ï¼Œå½“å‘ç° slow ä¸ fast ç›¸é‡æ—¶ï¼Œæˆ‘ä»¬å†é¢å¤–ä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆ ptrã€‚èµ·å§‹ï¼Œå®ƒæŒ‡å‘é“¾è¡¨å¤´éƒ¨ï¼›éšåï¼Œå®ƒå’Œ slow æ¯æ¬¡å‘åç§»åŠ¨ä¸€ä¸ªä½ç½®ã€‚æœ€ç»ˆï¼Œå®ƒä»¬ä¼šåœ¨å…¥ç¯ç‚¹ç›¸é‡ã€‚ 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if not head: return None fast = head slow = head while fast: slow = slow.next if fast.next: fast = fast.next.next else: return None if fast == slow: ptr = head while ptr!=slow: ptr=ptr.next slow = slow.next return ptr"},{"title":"LeetCode-skill3-python-if","path":"2022/08/27/LeetCode-skill3-python-if/","text":"ifåŸºæœ¬è¯­å¥if è¯­å¥çš„åˆ¤æ–­æ¡ä»¶å¯ä»¥ç”¨&gt;ï¼ˆå¤§äºï¼‰ã€&lt;(å°äº)ã€==ï¼ˆç­‰äºï¼‰ã€&gt;=ï¼ˆå¤§äºç­‰äºï¼‰ã€&lt;=ï¼ˆå°äºç­‰äºï¼‰æ¥è¡¨ç¤ºå…¶å…³ç³»1234567891011121314if åˆ¤æ–­æ¡ä»¶ï¼š æ‰§è¡Œè¯­å¥â€¦â€¦elseï¼š æ‰§è¡Œè¯­å¥â€¦â€¦â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™â€˜â€™if åˆ¤æ–­æ¡ä»¶1: æ‰§è¡Œè¯­å¥1â€¦â€¦elif åˆ¤æ–­æ¡ä»¶2: æ‰§è¡Œè¯­å¥2â€¦â€¦elif åˆ¤æ–­æ¡ä»¶3: æ‰§è¡Œè¯­å¥3â€¦â€¦else: æ‰§è¡Œè¯­å¥4â€¦â€¦ if or/andå¦‚æœåˆ¤æ–­éœ€è¦å¤šä¸ªæ¡ä»¶éœ€åŒæ—¶åˆ¤æ–­æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ or ï¼ˆæˆ–ï¼‰ï¼Œè¡¨ç¤ºä¸¤ä¸ªæ¡ä»¶æœ‰ä¸€ä¸ªæˆç«‹æ—¶åˆ¤æ–­æ¡ä»¶æˆåŠŸï¼›ä½¿ç”¨ and ï¼ˆä¸ï¼‰æ—¶ï¼Œè¡¨ç¤ºåªæœ‰ä¸¤ä¸ªæ¡ä»¶åŒæ—¶æˆç«‹çš„æƒ…å†µä¸‹ï¼Œåˆ¤æ–­æ¡ä»¶æ‰æˆåŠŸ12345678910111213if self.detail_image_tip.exists() or self.open_long_atlas.exists(): logger.info(&#x27;å½“å‰ä½œå“ä¸æ”¯æŒç›¸å…³æ¨èå±•ç¤º&#x27;) self.swipeByCount(&quot;up&quot;, 0.2, 1) logger.info(&#x27;ä¸Šæ»‘ä¸€ä¸ªä½œå“&#x27;)else: logger.info(&#x27;å½“å‰ä½œå“æ”¯æŒç›¸å…³æ¨èå±•ç¤º&#x27;)#or ä¸¤ä¸ªå…ƒç´ åªè¦æœ‰ä¸€ä¸ªä¸ºTrue é‚£ä¹ˆè¿™ä¸ªåˆ¤æ–­å°±ä¸ºTrue ä¸¤ä¸ªå…ƒç´ åˆ¤æ–­éƒ½ä¸ºFlaseæ‰ä¸ºFalseif self.link_icon.exists() and self.hot_live.exists(): logger.info(&#x27;å½“å‰ä½œå“ä¸æ˜¯æ™®é€šä½œå“&#x27;)else: logger.info(&#x27;å½“å‰ä½œå“æ™®é€šä½œå“&#x27;)#and å½“å‰ä¸¤ä¸ªå…ƒç´ éƒ½å­˜åœ¨ä¸ºTrueæ—¶ ifåˆ¤æ–­ä¸ºTrue ä¸€ä¸ªä¸ºFalse é‚£ä¹ˆifåˆ¤æ–­å°±ä¸ºFalse not12345678910111213141516171819202122232425if self.comment_frame.exists() is not True:#is not Trueçš„æ„æ€æ˜¯å½“å…ƒç´ åˆ¤æ–­ä¸ä¸ºTrueçš„æ—¶å€™ ifçš„åˆ¤æ–­ä¸ºTrue èµ°Trueçš„éƒ¨åˆ†ä¸èµ°elseçš„éƒ¨åˆ†if not number &gt; 6: self.swipeByCount(&quot;down&quot;, 0.2, 1) self.swipeByCount(&quot;up&quot;, 0.2, 1)#notçš„æ„æ€æ˜¯ ifåˆ¤æ–­å½“numberä¸å¤§äº6æ—¶(ä¹Ÿå°±æ˜¯&lt;=6) é‚£ä¹ˆèµ°ifçš„Trueçš„éƒ¨åˆ†#è¿™æ ·çš„å¥½å¤„å°±æ˜¯ä¸ç”¨å»ç‰¹åœ°å†™elseçš„éƒ¨åˆ†#å¦‚ä¸‹ï¼šif number &gt; 6: print(â€˜å½“å‰numberå¤§äº6â€™)elseï¼š self.swipeByCount(&quot;down&quot;, 0.2, 1) self.swipeByCount(&quot;up&quot;, 0.2, 1)#æœ‰çš„åŒå­¦å°±ä¼šè¯´é‚£æˆ‘å†™&lt;=6ä¸è¡Œå—if number &lt;= 6: self.swipeByCount(&quot;down&quot;, 0.2, 1) self.swipeByCount(&quot;up&quot;, 0.2, 1)#ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™ ä½†æ˜¯æˆ‘åœ¨å®šä¹‰è¿™ä¸ªå‡½æ•°çš„æ—¶å€™å®é™…ç›®çš„æ˜¯æ‰¾å¤§äº6æ¡çš„è¯„è®º æ‰€ä»¥not number &gt; 6ä¼šæ›´æ¸…æ™° çœ‹ä¸ªäººä¹ æƒ¯äº†def number_of_folds(self): &#x27;&#x27;&#x27; åˆ¤æ–­æŠ˜å è¯„è®ºæ•°é‡å¤§äº6æ¡ :return: &#x27;&#x27;&#x27; if ç¼©å†™1A = A.next if A else headB 1234if A: A =A.nextelse: A= headB"},{"title":"876. Middle of the Linked List(easy)","path":"2022/08/27/876/","text":"876. Middle of the Linked List(easy)Given the head of a singly linked list, return the middle node of the linked list.If there are two middle nodes, return the second middle node.æˆ‘ä»¬è®©ä¸¤ä¸ªæŒ‡é’ˆ slow å’Œ fast åˆ†åˆ«æŒ‡å‘é“¾è¡¨å¤´ç»“ç‚¹ headã€‚ æ¯å½“æ…¢æŒ‡é’ˆ slow å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ fast å°±å‰è¿›ä¸¤æ­¥ï¼Œè¿™æ ·ï¼Œå½“ fast èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œslow å°±æŒ‡å‘äº†é“¾è¡¨ä¸­ç‚¹ã€‚ # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: slow = head fast =head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"title":"86. Partition List(medium)","path":"2022/08/27/86/","text":"86. Partition List(medium)Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.é“¾è¡¨çš„åŸºæœ¬æ“ä½œï¼Œä½†æ˜¯è¿™é‡Œåˆ›ç«‹äº†ä¸¤ä¸ªé“¾è¡¨,ä¸¤ä¸ª dummy node æ¥æŒæœ‰ä¸¤ä¸ªåˆ†å‰²å‡ºæ¥çš„å­é“¾è¡¨ï¼Œåˆ†åˆ«å­˜å‚¨æ¯”xå¤§å’Œå°çš„ï¼Œæœ€ååœ¨å°†æ•°å­—å°çš„é‚£éƒ¨åˆ†é“¾æ¥åˆ°å¤§æ•°å­—ä¸Š å®˜æ–¹è¯´æ˜ ç›´è§‚æ¥è¯´æˆ‘ä»¬åªéœ€ç»´æŠ¤ä¸¤ä¸ªé“¾è¡¨ small å’Œ large å³å¯ï¼Œsmall é“¾è¡¨æŒ‰é¡ºåºå­˜å‚¨æ‰€æœ‰å°äº x çš„èŠ‚ç‚¹ï¼Œlarge é“¾è¡¨æŒ‰é¡ºåºå­˜å‚¨æ‰€æœ‰å¤§äºç­‰äº x çš„èŠ‚ç‚¹ã€‚éå†å®ŒåŸé“¾è¡¨åï¼Œæˆ‘ä»¬åªè¦å°† small é“¾è¡¨å°¾èŠ‚ç‚¹æŒ‡å‘ large é“¾è¡¨çš„å¤´èŠ‚ç‚¹å³èƒ½å®Œæˆå¯¹é“¾è¡¨çš„åˆ†éš”ã€‚ ä¸ºäº†å®ç°ä¸Šè¿°æ€è·¯ï¼Œæˆ‘ä»¬è®¾ smallHead å’Œ largeHead åˆ†åˆ«ä¸ºä¸¤ä¸ªé“¾è¡¨çš„å“‘èŠ‚ç‚¹ï¼Œå³å®ƒä»¬çš„ next æŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†æ›´æ–¹ä¾¿åœ°å¤„ç†å¤´èŠ‚ç‚¹ä¸ºç©ºçš„è¾¹ç•Œæ¡ä»¶ã€‚åŒæ—¶è®¾ small å’Œ large èŠ‚ç‚¹æŒ‡å‘å½“å‰é“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹ã€‚å¼€å§‹æ—¶ smallHead=small,largeHead=largeã€‚éšåï¼Œä»å‰å¾€åéå†é“¾è¡¨ï¼Œåˆ¤æ–­å½“å‰é“¾è¡¨çš„èŠ‚ç‚¹å€¼æ˜¯å¦å°äº xï¼Œå¦‚æœå°äºå°±å°† small çš„ next æŒ‡é’ˆæŒ‡å‘è¯¥èŠ‚ç‚¹ï¼Œå¦åˆ™å°† large çš„ next æŒ‡é’ˆæŒ‡å‘è¯¥èŠ‚ç‚¹ã€‚ éå†ç»“æŸåï¼Œæˆ‘ä»¬å°† large çš„ next æŒ‡é’ˆç½®ç©ºï¼Œè¿™æ˜¯å› ä¸ºå½“å‰èŠ‚ç‚¹å¤ç”¨çš„æ˜¯åŸé“¾è¡¨çš„èŠ‚ç‚¹ï¼Œè€Œå…¶ next æŒ‡é’ˆå¯èƒ½æŒ‡å‘ä¸€ä¸ªå°äº x çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦åˆ‡æ–­è¿™ä¸ªå¼•ç”¨ã€‚åŒæ—¶å°† small çš„ next æŒ‡é’ˆæŒ‡å‘ largeHead çš„ next æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ï¼Œå³çœŸæ­£æ„ä¹‰ä¸Šçš„ large é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚æœ€åè¿”å› smallHead çš„ next æŒ‡é’ˆå³ä¸ºæˆ‘ä»¬è¦æ±‚çš„ç­”æ¡ˆã€‚ 1234567891011121314151617class Solution: def partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]: smallhead = small =ListNode(0) largehead = large =ListNode(0) while head: if head.val&lt;x: small.next = head small = small.next else: large.next = head large = large.next head = head.next large.next = None small.next = largehead.next return smallhead.next"},{"title":"203. Remove Linked List Elements(easy)","path":"2022/08/26/203/","text":"203. Remove Linked List Elements(easy)Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.12Input: head = [1,2,6,3,4,5,6], val = 6Output: [1,2,3,4,5] è¿™é¢˜æ˜¯ä¸€ä¸ªç®€å•é¢˜ï¼Œä½†å¯ä»¥å­¦ä¹ å¦‚ä½•æ·»åŠ dummy node 1234pre = ListNode(-1)pre.next = headcurrent = pre # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]: pre = ListNode(-1) pre.next = head current = pre while current.next!=None: if current.next.val== val: current.next= current.next.next else: current = current.next return pre.next"},{"title":"LeetCode-skill2-python_funciton","path":"2022/08/24/LeetCode-skill2-python-funciton/","text":"python å¸¸ç”¨å‡½æ•°ListPython çš„åˆ—è¡¨ List åŸºæœ¬å°±æ˜¯å…¶å®ƒè¯­è¨€çš„ Array. Initialization åˆå§‹åŒ–List çš„åˆå§‹åŒ–ä¸€èˆ¬ç”¨ List comprehensionï¼Œå¾€å¾€èƒ½ä¸€è¡Œè§£å†³é—®é¢˜ 12345# 1d arrayl = [0 for _ in range(len(array)]# 2dl = [[0 for i in range(cols)] for j in range(rows)] Start from the behindä½ å¯ä»¥è½»æ¾ä»åå¾€å‰è®¿é—®ï¼š 1234567lastElement = l[-1]lastTwo = l[-2:]for i in range(0, -10, -1)# 0, -1, -2, -3, -4, -5, -6, -7, -8, -9 copy å¤åˆ¶shallow copy æµ…æ‹·è´123l2 = l1[:]# orl2 = l1.copy() æµ…å¤åˆ¶çš„é—®é¢˜åœ¨äºï¼Œå¦‚æœ l1 å†…éƒ¨è¿˜æœ‰ listï¼Œé‚£ä¹ˆè¿™ç§åµŒå¥—çš„ç´¢å¼•ä¸èƒ½è¢«å¤åˆ¶ï¼Œæ¯”å¦‚ï¼š 12345a = [1, 2, [3, 4]]b = a[:]a[2].append(5)print(b)# [1, 2, [3, 4, 5]] deep copy æ·±æ‹·è´æ‰€ä»¥å¦‚æœè¦åšæ·±æ‹·è´ï¼Œè¦èŠ‚åˆ¶è‡ªå¸¦åº“ copy 123import copycopy.deepcopy() enumerate æšä¸¾å½“æˆ‘ä»¬éœ€è¦æšä¸¾ä¸€ä¸ªæ•°ç»„å¹¶åŒæ—¶è·å¾—å€¼ä¸ index çš„æ—¶å€™å¯ä»¥ä½¿ç”¨ï¼š 12345678l = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for i, v in enumerate(l): print(i, v)# 0 a# 1 b# 2 c zipzip æœ¬æ„å°±æ˜¯æ‹‰é“¾ï¼Œå¯ä»¥æƒ³è±¡æˆå°†ä¸¤ä¸ªæ•°ç»„åƒæ‹‰é“¾ä¸€æ ·æŒ¨ä¸ªèšåˆï¼š 12345&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = [4, 5, 6]&gt;&gt;&gt; zipped = zip(x, y)&gt;&gt;&gt; list(zipped)[(1, 4), (2, 5), (3, 6)] reducereduce å¯ä»¥åˆ†åˆ«å¯¹ç›¸é‚»å…ƒç´ ä½¿ç”¨åŒä¸€ç§è®¡ç®—è§„åˆ™ï¼ŒåŒæ—¶æ¯ä¸€æ­¥ç»“æœä½œä¸ºä¸‹ä¸€æ­¥çš„å‚æ•°ï¼Œå¾ˆå…¸å‹çš„å‡½æ•°å¼ç¼–ç¨‹ç”¨æ³•ã€‚ 12345678910# importing functools for reduce()import functools# initializing listlis = [ 1, 3, 5, 6, 2, ]# using reduce to compute sum of listprint (&quot;The sum of the list elements is : &quot;,end=&quot;&quot;)print (functools.reduce(lambda a,b : a+b,lis))# The sum of the list elements is : 17 mapå¯ä»¥å°†å‚æ•°ä¸€ä¸€æ˜ å°„æ¥è®¡ç®—ï¼Œ æ¯”å¦‚map() ä¼šæ ¹æ®æä¾›çš„å‡½æ•°å¯¹æŒ‡å®šåºåˆ—åšæ˜ å°„ã€‚ ç¬¬ä¸€ä¸ªå‚æ•° function ä»¥å‚æ•°åºåˆ—ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ è°ƒç”¨ function å‡½æ•°ï¼Œè¿”å›åŒ…å«æ¯æ¬¡ function å‡½æ•°è¿”å›å€¼çš„æ–°åˆ—è¡¨ã€‚map(function, iterable, â€¦) 12345678910&gt;&gt;&gt; def square(x) : # è®¡ç®—å¹³æ–¹æ•°... return x ** 2...&gt;&gt;&gt; map(square, [1,2,3,4,5]) # è®¡ç®—åˆ—è¡¨å„ä¸ªå…ƒç´ çš„å¹³æ–¹&gt;&gt;&gt; list(map(square, [1,2,3,4,5])) # ä½¿ç”¨ list() è½¬æ¢ä¸ºåˆ—è¡¨[1, 4, 9, 16, 25]&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # ä½¿ç”¨ lambda åŒ¿åå‡½æ•°[1, 4, 9, 16, 25]&gt;&gt;&gt; 1234date = &quot;2019-8-15&quot;Y, M, D = map(int, date.split(&#x27;-&#x27;))# Y = 2019, M = 8, D = 15 dequelist åˆ é™¤æœ«å°¾çš„æ“ä½œæ˜¯O(1)çš„ï¼Œä½†æ˜¯åˆ é™¤å¤´æ“ä½œå°±æ˜¯O(n)ï¼Œè¿™æ—¶å€™æˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªåŒç«¯é˜Ÿåˆ— dequeã€‚é¦–å°¾çš„å¸¸è§„æ“ä½œä¸ºï¼š appendï¼Œæ·»åŠ åˆ°æœ«å°¾appendleft, æ·»åŠ åˆ°å¼€å¤´pop, å‰”é™¤æœ«å°¾popleftï¼Œç§»é™¤å¼€å¤´ sortlist è‡ªèº«æœ‰è‡ªå¸¦çš„ sort(), ä½†æ˜¯å®ƒä¸è¿”å›æ–°çš„ list.å¯ä»¥åŠ reverseä½¿ç»“æœå€’åº 1234# vowels lista= [6, 2, 3, 8]a.sort(reverse=True)print(a)#[8, 6, 3, 2] sortedlist è‡ªèº«æœ‰è‡ªå¸¦çš„ sort(), ä½†æ˜¯å®ƒä¸è¿”å›æ–°çš„ list. sorted èƒ½è¿”å›ä¸€ä¸ªæ–°çš„ list, å¹¶ä¸”æ”¯æŒä¼ å…¥å‚æ•°reverseã€‚ æ¯”å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ª tuple çš„æ•°ç»„ï¼Œæˆ‘ä»¬æƒ³æŒ‰ç…§ tuple çš„ç¬¬ä¸€ä¸ªå…ƒç´ è¿›è¡Œæ’åºï¼š 12345l1 = [(1,2), (0,1), (3,10) ]l2 = sorted(l1, key=lambda x: x[0])# l2 = [(0, 1), (1, 2), (3, 10)] è¿™é‡Œçš„ key å…è®¸ä¼ å…¥ä¸€ä¸ªè‡ªå®šä¹‰å‚æ•°ï¼Œä¹Ÿå¯ä»¥ç”¨è‡ªå¸¦å‡½æ•°è¿›è¡Œæ¯”è¾ƒï¼Œæ¯”å¦‚åœ¨ä¸€ä¸ª string æ•°ç»„é‡Œåªæƒ³æ¯”è¾ƒå°å†™ï¼Œå¯ä»¥ä¼ å…¥key=str.lower 123456l1 = [&quot;banana&quot;,&quot;APPLE&quot;, &quot;Watermelon&quot;]l2 = sorted(l1, key=str.lower)print(l2)# [&#x27;APPLE&#x27;, &#x27;banana&#x27;, &#x27;Watermelon&#x27;] 123456&gt;&gt;&gt; word = &#x27;paper&#x27;&gt;&gt;&gt; len(word)5&gt;&gt;&gt; words = [&#x27;banana&#x27;, &#x27;pie&#x27;, &#x27;Washington&#x27;, &#x27;book&#x27;]&gt;&gt;&gt; sorted(words, key=len)[&#x27;pie&#x27;, &#x27;book&#x27;, &#x27;banana&#x27;, &#x27;Washington&#x27;] 1234tree=sorted([x for x in a if x!=-1])# è¿™ä¸ªå¾ˆç¥å¥‡ï¼ŒæŠŠé™¤äº†-1ä»¥å¤–çš„æ•°æ’åº#tree=[150, 160, 170, 180, 190] lambdaä½ æ³¨æ„åˆ°æˆ‘ä»¬åœ¨ä¸Šé¢ä½¿ç”¨äº† lambda æ¥å®šä¹‰ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œååˆ†æ–¹ä¾¿ã€‚å¦‚æœä½ ç†Ÿæ‚‰å…¶å®ƒè¯­è¨€ç±»ä¼¼ JS çš„è¯ï¼Œå¯ä»¥æŠŠå®ƒç†è§£æˆä¸€ä¸ª callback å‡½æ•°ï¼Œå‚æ•°åä¸€ä¸€å¯¹åº”å°±è¡Œã€‚ cmp_to_keyåœ¨ python3 ä¸­ï¼Œsorted å‡½æ•°å–æ¶ˆäº†è‡ªå¸¦çš„cmpå‡½æ•°ï¼Œéœ€è¦å€ŸåŠ©functools åº“ä¸­çš„ cmp_to_keyæ¥åšæ¯”è¾ƒã€‚æ¯”å¦‚å¦‚æœè¦æŒ‰ç…§æ•°ç»„å…ƒç´ çš„ç»å¯¹å€¼æ¥æ’åºï¼š 1234567891011from functools import cmp_to_keydef absSort(arr): newarr = sorted(arr, key = cmp_to_key(sortfunc)) return newarrdef sortfunc(a, b): if abs(a) &lt; abs(b): return -1 elif abs(a) &gt; abs(b): return 1 else: return a - b setset çš„æŸ¥æ‰¾æ“ä½œå¤æ‚åº¦ä¸ºO(1)ï¼Œæœ‰æ—¶å€™å¯ä»¥æ›¿ä»£dict æ¥å­˜å‚¨ä¸­é—´è¿‡ç¨‹ã€‚ add : set çš„æ·»åŠ æ˜¯ add ä¸æ˜¯append remove vs discard: éƒ½æ˜¯åˆ é™¤æ“ä½œï¼ŒåŒºåˆ«åœ¨äºremoveä¸å­˜åœ¨çš„å…ƒç´ ä¼šæŠ¥é”™ï¼Œdiscardä¸ä¼šã€‚ union, intersection: å¿«é€Ÿè·å¾—å¹¶é›†å’Œäº¤é›†ï¼Œæ–¹ä¾¿ä¸€äº›å»é‡æ“ä½œã€‚ dictå­—å…¸ï¼Œç›¸å½“äºå…¶å®ƒè¯­è¨€ä¸­çš„map, hashtable, hashmapä¹‹ç±»çš„ï¼Œè¯»å–æ“ä½œä¹Ÿæ˜¯O(1) å¤æ‚åº¦ keys(), values(), items()è¿™ä¸‰ä¸ªæ–¹æ³•å¯ä»¥åˆ†åˆ«è·å¾—key, value, {key: value}çš„æ•°ç»„ã€‚ setdefaultè¿™ä¸ªå‡½æ•°ç»å¸¸åœ¨åˆå§‹åŒ–å­—å…¸æ—¶å€™ä½¿ç”¨ï¼Œå¦‚æœæŸä¸ªkeyåœ¨å­—å…¸ä¸­å­˜åœ¨ï¼Œè¿”å›å®ƒçš„value, å¦åˆ™è¿”å›ä½ ç»™çš„ default å€¼ã€‚æ¯”å¦‚åœ¨å»ºä¸€ä¸ª trie æ ‘çš„æ—¶å€™ OrderedDictOrderedDict èƒ½è®°å½•ä½  key å’Œ value æ’å…¥çš„é¡ºåºï¼Œåº•å±‚å…¶å®æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨åŠ å“ˆå¸Œè¡¨çš„å®ç°ã€‚æˆ‘ä»¬ç”šè‡³å¯ä»¥ä½¿ç”¨move_to_endè¿™æ ·çš„å‡½æ•°ï¼š 12345678&gt;&gt;&gt; d = OrderedDict.fromkeys(&#x27;abcde&#x27;)&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;)&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())&#x27;acdeb&#x27;# æ”¾å¼€å¤´&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;, last=False)&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())&#x27;bacde&#x27; defaultdictdefaultdictå¯ä»¥å¾ˆå¥½åœ°æ¥è§£å†³ä¸€äº›åˆå§‹åŒ–çš„é—®é¢˜ï¼Œæ¯”å¦‚ value æ˜¯ä¸€ä¸ª listï¼Œæ¯æ¬¡éœ€è¦åˆ¤æ–­ key æ˜¯å¦å­˜åœ¨çš„æƒ…å†µã€‚è¿™æ—¶æˆ‘ä»¬å¯ä»¥ç›´æ¥å®šä¹‰ 1234567d = defaultdict(list)s = [(&#x27;yellow&#x27;, 1), (&#x27;blue&#x27;, 2), (&#x27;yellow&#x27;, 3), (&#x27;blue&#x27;, 4), (&#x27;red&#x27;, 1)]for k, v in s: d[k].append(v)sorted(d.items())# [(&#x27;blue&#x27;, [2, 4]), (&#x27;red&#x27;, [1]), (&#x27;yellow&#x27;, [1, 3])] heapqheapq å°±æ˜¯ python çš„ priority queueï¼Œheapq[0]å³ä¸ºå †é¡¶å…ƒç´ ã€‚ heapq çš„å®ç°æ˜¯å°é¡¶å †ï¼Œå¦‚æœéœ€è¦ä¸€ä¸ªå¤§é¡¶å †ï¼Œå¸¸è§„çš„ä¸€ä¸ªåšæ³•æ˜¯æŠŠå€¼å–è´Ÿå­˜å…¥ï¼Œå–å‡ºæ—¶å†åè½¬ã€‚ä»¥ä¸‹æ˜¯å€ŸåŠ© heapq æ¥å®ç° heapsort çš„ä¾‹å­ï¼š 12345678&gt;&gt;&gt; def heapsort(iterable):... h = []... for value in iterable:... heappush(h, value)... return [heappop(h) for i in range(len(h))]...&gt;&gt;&gt; heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] bisectpython è‡ªå¸¦äºŒåˆ†æŸ¥æ‰¾çš„åº“ï¼Œåœ¨ä¸€äº›ä¸è¦æ±‚å®ç° binary searchï¼Œä½†æ˜¯å€ŸåŠ©å®ƒèƒ½åŠ é€Ÿçš„åœºæ™¯ä¸‹å¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚ 12bisect.bisect(a, x, lo=0, hi=len(a))è¿™é‡Œçš„å‚æ•°åˆ†åˆ«ä¸º æ•°ç»„ï¼Œè¦æŸ¥æ‰¾çš„æ•°ï¼ŒèŒƒå›´èµ·å§‹ç‚¹ï¼ŒèŒƒå›´ç»“æŸç‚¹ ç›¸ä¼¼å‡½æ•°è¿˜æœ‰ 12bisect.bisect_leftbisect.bisect_right åˆ†åˆ«è¿”å›å¯ä»¥æ’å…¥ x çš„æœ€å·¦å’Œæœ€å³ index CounterCounter æ¥å—çš„å‚æ•°å¯ä»¥æ˜¯ä¸€ä¸ª string, æˆ–è€…ä¸€ä¸ª list, mapping 1234&gt;&gt;&gt; c = Counter() # a new, empty counter&gt;&gt;&gt; c = Counter(&#x27;gallahad&#x27;) # a new counter from an iterable&gt;&gt;&gt; c = Counter(&#123;&#x27;red&#x27;: 4, &#x27;blue&#x27;: 2&#125;) # a new counter from a mapping&gt;&gt;&gt; c = Counter(cats=4, dogs=8) # a new counter from keyword args most_common(n)å¯ä»¥å¾—åˆ°å‡ºç°æ¬¡æ•°æœ€å¤šçš„ n ä¸ªæ•°ï¼š 12&gt;&gt;&gt; Counter(&#x27;abracadabra&#x27;).most_common(3) # doctest: +SKIP[(&#x27;a&#x27;, 5), (&#x27;r&#x27;, 2), (&#x27;b&#x27;, 2)] stringsord, charord è¿”å›å•ä¸ªå­—ç¬¦çš„ unicode: 12&gt;&gt;&gt; ord(&#x27;a&#x27;)97 char åˆ™æ˜¯åå‘æ“ä½œï¼š 12&gt;&gt;&gt; chr(100)&#x27;d&#x27; stripç§»é™¤ string å‰åçš„å­—ç¬¦ä¸²ï¼Œé»˜è®¤æ¥ç§»é™¤ç©ºæ ¼ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥ç»™ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åä¼šç§»é™¤å«æœ‰è¿™ä¸ªå­—ç¬¦ä¸²çš„éƒ¨åˆ†ï¼š `` â€˜ spacious â€˜.strip()â€˜spaciousâ€™â€˜www.example.com&#39;.strip(&#39;cmowz.&#39;)â€˜exampleâ€™`` splitæŒ‰ç…§æŸä¸ªå­—ç¬¦ä¸²æ¥åˆ‡åˆ†ï¼Œè¿”å›ä¸€ä¸ª list, å¯ä»¥ä¼ å…¥ä¸€ä¸ªå‚æ•°maxsplitæ¥é™å®šåˆ†ç¦»æ•°ã€‚ 123456&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;, maxsplit=1)[&#x27;1&#x27;, &#x27;2,3&#x27;]&gt;&gt;&gt; &#x27;1,2,,3,&#x27;.split(&#x27;,&#x27;)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;&#x27;] int/ floatæœ€å¤§, æœ€å° numberæœ‰æ—¶å€™åˆå§‹åŒ–æˆ‘ä»¬éœ€è¦è®¾å®š Math.max() å’Œ Math.min(), åœ¨ python ä¸­åˆ†åˆ«ä»¥ float(â€˜infâ€™) å’Œ float(â€˜-infâ€™)è¡¨ç¤º æˆ–è€…ä¹Ÿå¯ä»¥ç”¨mathåº“é‡Œçš„ math.inf å’Œ math.inf åœ¨ python2 ä¸­æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™ä¹ˆåšï¼š 1234import sys#maxintMax = sys.maxint é™¤æ³•åœ¨ python3 ä¸­ï¼Œ / ä¼šä¿ç•™æµ®ç‚¹ï¼Œç›¸å½“äº float ç›¸é™¤ï¼Œå¦‚æœéœ€è¦åšåˆ°åƒ pyhton2 ä¸­çš„ int ç›¸é™¤ï¼Œéœ€è¦ //ï¼š 1234&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 3 // 21 æ¬¡æ–¹åœ¨ python ä¸­ä¸º **: 12&gt;&gt;&gt; 2 ** 101024 conditionsåœ¨ python çš„ä¸‰é¡¹è¡¨è¾¾å¼(ternary operation) ä¸å…¶å®ƒè¯­è¨€ä¸å¤ªä¸€æ ·ï¼š 1res = a if condition else b å®ƒè¡¨ç¤ºå¦‚æœ condition æ»¡è¶³ï¼Œé‚£ä¹ˆ res = a, ä¸ç„¶ res = bï¼Œåœ¨ç±» c çš„è¯­è¨€é‡Œå³ä¸ºï¼š 1res = condition ? a : b; strip()1231. strip():- This method is used to delete all the leading and trailing characters mentioned in its argument.2. lstrip():- This method is used to delete all the leading characters mentioned in its argument.3. rstrip():- This method is used to delete all the trailing characters mentioned in its argument. 123456789101112131415161718# Python code to demonstrate working of# strip(), lstrip() and rstrip()str = &quot;---geeksforgeeks---&quot;# using strip() to delete all &#x27;-&#x27;print ( &quot; String after stripping all &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.strip(&#x27;-&#x27;) )# String after stripping all &#x27;-&#x27; is : geeksforgeeks# using lstrip() to delete all trailing &#x27;-&#x27;print ( &quot; String after stripping all leading &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.lstrip(&#x27;-&#x27;) )# String after stripping all leading &#x27;-&#x27; is : geeksforgeeks---# using rstrip() to delete all leading &#x27;-&#x27;print ( &quot; String after stripping all trailing &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.rstrip(&#x27;-&#x27;) )# String after stripping all trailing &#x27;-&#x27; is : ---geeksforgeeks join()join()Python join() æ–¹æ³•ç”¨äºå°†åºåˆ—ä¸­çš„å…ƒç´ ä»¥æŒ‡å®šçš„å­—ç¬¦è¿æ¥ç”Ÿæˆä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ã€‚str.join(sequence) sequence â€“ è¦è¿æ¥çš„å…ƒç´ åºåˆ—ã€‚ 12345s1 = &quot;-&quot;s2 = &quot;&quot;seq = (&quot;r&quot;, &quot;u&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;b&quot;) # å­—ç¬¦ä¸²åºåˆ—print (s1.join( seq )) #r-u-n-o-o-bprint (s2.join( seq )) #runoob isalnum()isalnum()ç”¨æ¥åˆ¤æ–­æ˜¯ä¸æ˜¯å­—æ¯ 123456789# string contains either alphabet or number name1 = &quot;Python3&quot;print(name1.isalnum()) #True# string contains whitespacename2 = &quot;Python 3&quot;print(name2.isalnum()) #False å‚è€ƒï¼šhttps://hzhao.me/2019/08/16/python-leetcode-trick/#heapq https://xdren69.github.io/2021/03/31/leetcode-python/"},{"title":"304. Range Sum Query 2D - Immutable(medium)","path":"2022/08/24/304/","text":"304. Range Sum Query 2D - Immutable(medium)Given a 2D matrix matrix, handle multiple queries of the following type:Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).Implement the NumMatrix class:NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).You must design an algorithm where sumRegion works on O(1) time complexity.å®˜æ–¹é¢˜è§£è¿™é“é¢˜æ˜¯303é¢˜çš„å‡çº§ç‰ˆï¼Œä»ä¸€ç»´æ•°ç»„å‡çº§æˆäºŒç»´çŸ©é˜µï¼ŒåŒæ ·æ˜¯å‰ç¼€å’Œæ•°ç»„ 123456789101112131415class NumMatrix: def __init__(self, matrix: List[List[int]]): m, n = len(matrix), (len(matrix[0]) if matrix else 0) self.sums = [[0] * (n + 1) for _ in range(m + 1)] _sums = self.sums for i in range(m): for j in range(n): _sums[i + 1][j + 1] = _sums[i][j + 1] + _sums[i + 1][j] - _sums[i][j] + matrix[i][j] def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int: _sums = self.sums return _sums[row2 + 1][col2 + 1] - _sums[row1][col2 + 1] - _sums[row2 + 1][col1] + _sums[row1][col1] ä½œè€…ï¼šLeetCode-Solutioné“¾æ¥ï¼šæ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"303. Range Sum Query - Immutable(easy)","path":"2022/08/24/303/","text":"303. Range Sum Query - Immutable(easy)Given an integer array nums, handle multiple queries of the following type:Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.Implement the NumArray class:NumArray(int[] nums) Initializes the object with the integer array nums.int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive(i.e. nums[left] + nums[left + 1] + â€¦ + nums[right]).æœ€åŸºç¡€çš„å‰ç¼€å’Œé—®é¢˜å®˜æ–¹é¢˜è§£ 12345678910111213141516class NumArray: def __init__(self, nums: List[int]): self.sums = [0] _sums = self.sums for num in nums: _sums.append(_sums[-1] + num) def sumRange(self, i: int, j: int) -&gt; int: _sums = self.sums return _sums[j + 1] - _sums[i]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(left,right) 1234567891011class NumArray: # 68 ms, faster than 97.72% def __init__(self, nums: List[int]): self.preSum = nums # pass by pointer! for i in range(len(nums)-1): self.preSum[i+1] += self.preSum[i] def sumRange(self, left: int, right: int) -&gt; int: if left == 0: return self.preSum[right] return self.preSum[right] - self.preSum[left-1]"},{"title":"LeetCode-skill1-prefix_sum","path":"2022/08/24/LeetCode-skill1-prefix-sum/","text":"å‰ç¼€å’Œï¼ˆprefix sumï¼‰æ˜¯ç®—æ³•é¢˜ä¸­æ¯”è¾ƒå®ç”¨çš„ä¸€ç§æŠ€å·§ï¼Œå½“ç®—æ³•é¢˜çš„èƒŒæ™¯æ˜¯æ•´æ•°å‹æ•°ç»„ä¸”å‡ºç° â€œå­æ•°ç»„å’Œâ€ æˆ–è€… â€œè¿ç»­çš„å­æ•°ç»„â€ æ—¢å¯ä»¥è€ƒè™‘ä½¿ç”¨å‰ç¼€å’Œæ¥æ±‚è§£ä¼šå¾—åˆ°ä¸é”™çš„æ•ˆæœã€‚303é¢˜ 304é¢˜"},{"title":"518. Coin Change 2(medium)","path":"2022/08/23/518/","text":"518. Coin Change 2(medium)You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.You may assume that you have an infinite number of each kind of coin.The answer is guaranteed to fit into a signed 32-bit integer.leetcodeé¢˜è§£12345678910111213141516class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: n = len(coins) dp = [[0]*(amount+1) for _ in range(n+1)] # åˆå§‹åŒ– dp[0][0] = 1 # åˆæ³•çš„åˆå§‹åŒ– # å®Œå…¨èƒŒåŒ…ï¼šä¼˜åŒ–åçš„çŠ¶æ€è½¬ç§» for i in range(1, n+1): # ç¬¬ä¸€å±‚å¾ªç¯ï¼šéå†ç¡¬å¸ for j in range(amount+1): # ç¬¬äºŒå±‚å¾ªç¯ï¼šéå†èƒŒåŒ… if j &lt; coins[i-1]: # å®¹é‡æœ‰é™ï¼Œæ— æ³•é€‰æ‹©ç¬¬iä¸ªç¡¬å¸ dp[i][j] = dp[i-1][j] else: # å¯é€‰æ‹©ç¬¬iä¸ªç¡¬å¸ dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]] return dp[n][amount] ä½œè€…ï¼šflixé“¾æ¥ï¼šhttps://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"322. Coin Change(medium)","path":"2022/08/23/322/","text":"322. Coin Change(medium)You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.You may assume that you have an infinite number of each kind of coin."},{"title":"253. Meeting Rooms II","path":"2022/08/23/253/","text":"253. Meeting Rooms IIGiven an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.æ€æƒ³ï¼šçº¢è‰²çš„ç‚¹ä»£è¡¨æ¯ä¸ªä¼šè®®çš„å¼€å§‹æ—¶é—´ç‚¹ï¼Œç»¿è‰²çš„ç‚¹ä»£è¡¨æ¯ä¸ªä¼šè®®çš„ç»“æŸæ—¶é—´ç‚¹ã€‚ç°åœ¨å‡æƒ³æœ‰ä¸€æ¡å¸¦ç€è®¡æ•°å™¨çš„çº¿ï¼Œåœ¨æ—¶é—´çº¿ä¸Šä»å·¦è‡³å³è¿›è¡Œæ‰«æï¼Œæ¯é‡åˆ°çº¢è‰²çš„ç‚¹ï¼Œè®¡æ•°å™¨ count åŠ ä¸€ï¼Œæ¯é‡åˆ°ç»¿è‰²çš„ç‚¹ï¼Œè®¡æ•°å™¨ count å‡ä¸€ï¼šè¿™æ ·ä¸€æ¥ï¼Œæ¯ä¸ªæ—¶åˆ»æœ‰å¤šå°‘ä¸ªä¼šè®®åœ¨åŒæ—¶è¿›è¡Œï¼Œå°±æ˜¯è®¡æ•°å™¨ count çš„å€¼ï¼Œcount çš„æœ€å¤§å€¼ï¼Œå°±æ˜¯éœ€è¦ç”³è¯·çš„ä¼šè®®å®¤æ•°é‡ã€‚ å¯¹å·®åˆ†æ•°ç»„æŠ€å·§ç†Ÿæ‚‰çš„è¯»è€…ä¸€çœ¼å°±èƒ½çœ‹å‡ºæ¥äº†ï¼Œè¿™ä¸ªæ‰«æçº¿å…¶å®å°±æ˜¯å·®åˆ†æ•°ç»„çš„éå†è¿‡ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬è¯´è¿™æ˜¯å·®åˆ†æ•°ç»„æŠ€å·§è¡ç”Ÿå‡ºæ¥çš„è§£æ³•ã€‚ ä»£ç å®ç°é‚£ä¹ˆï¼Œå¦‚ä½•å†™ä»£ç å®ç°è¿™ä¸ªæ‰«æçš„è¿‡ç¨‹å‘¢ï¼Ÿ é¦–å…ˆï¼Œå¯¹åŒºé—´è¿›è¡ŒæŠ•å½±ï¼Œå°±ç›¸å½“äºå¯¹æ¯ä¸ªåŒºé—´çš„èµ·ç‚¹å’Œç»ˆç‚¹åˆ†åˆ«è¿›è¡Œæ’åºç„¶åå°±ç®€å•äº†ï¼Œæ‰«æçº¿ä»å·¦å‘å³å‰è¿›ï¼Œé‡åˆ°çº¢ç‚¹å°±å¯¹è®¡æ•°å™¨åŠ ä¸€ï¼Œé‡åˆ°ç»¿ç‚¹å°±å¯¹è®¡æ•°å™¨å‡ä¸€ï¼Œè®¡æ•°å™¨ count çš„æœ€å¤§å€¼å°±æ˜¯ç­”æ¡ˆï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯ åŒæŒ‡é’ˆæŠ€å·§ï¼Œæ ¹æ® i, j çš„ç›¸å¯¹ä½ç½®æ¨¡æ‹Ÿæ‰«æçº¿å‰è¿›çš„è¿‡ç¨‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution: def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int: n= len(intervals) begin =[] end = [] count = 0 res,c,j=0,0,0 for i in range(n): begin.append(intervals[i][0]) end.append(intervals[i][1]) begin.sort() end.sort() while (c&lt;n and j&lt;n): if begin[c]&lt;end[j]: count+=1 c+=1 else: count-=1 j+=1 res = max(res,count) return res``` ```javaint minMeetingRooms(int[][] meetings) &#123; int n = meetings.length; int[] begin = new int[n]; int[] end = new int[n]; for(int i = 0; i &lt; n; i++) &#123; begin[i] = meetings[i][0]; end[i] = meetings[i][1]; &#125; Arrays.sort(begin); Arrays.sort(end); // æ‰«æè¿‡ç¨‹ä¸­çš„è®¡æ•°å™¨ int count = 0; // åŒæŒ‡é’ˆæŠ€å·§ int res = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; if (begin[i] &lt; end[j]) &#123; // æ‰«æåˆ°ä¸€ä¸ªçº¢ç‚¹ count++; i++; &#125; else &#123; // æ‰«æåˆ°ä¸€ä¸ªç»¿ç‚¹ count--; j++; &#125; // è®°å½•æ‰«æè¿‡ç¨‹ä¸­çš„æœ€å¤§å€¼ res = Math.max(res, count); &#125; return res;&#125;"},{"title":"1207. Unique Number of Occurrences(easy)","path":"2022/08/22/1207/","text":"1207. Unique Number of Occurrences(easy)Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.123Input: arr = [1,2,2,1,1,3]Output: trueExplanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. è¿™é“é¢˜ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œåˆ¤æ–­hashmapçš„valueæ˜¯å¦éƒ½æ˜¯uniqueçš„ï¼Œé€šè¿‡setçš„æ— é‡å¤æ€§å¾ˆå®¹æ˜“å°±èƒ½åˆ¤æ–­ 123456789101112class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: hashmap=&#123;&#125; res=[] for i in arr: if i not in hashmap: hashmap[i]=1 else: hashmap[i]+=1 for i in hashmap.keys(): res.append(hashmap[i]) return len(set(res))==len(res)"},{"title":"146. LRU Cache(medium)","path":"2022/08/22/146/","text":"146. LRU Cache(medium)Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.Implement the LRUCache class:LRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.The functions get and put must each run in O(1) average time complexity.å®˜æ–¹ç­”æ¡ˆè¿™é“é¢˜æ˜¯hashmapé¢‘ç‡ç¬¬ä¸€ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class DLinkedNode: def __init__(self, key=0, value=0): self.key = key self.value = value self.prev = None self.next = Noneclass LRUCache: def __init__(self, capacity: int): self.cache = dict() # ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹ self.head = DLinkedNode() self.tail = DLinkedNode() self.head.next = self.tail self.tail.prev = self.head self.capacity = capacity self.size = 0 def get(self, key: int) -&gt; int: if key not in self.cache: return -1 # å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ç§»åˆ°å¤´éƒ¨ node = self.cache[key] self.moveToHead(node) return node.value def put(self, key: int, value: int) -&gt; None: if key not in self.cache: # å¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ node = DLinkedNode(key, value) # æ·»åŠ è¿›å“ˆå¸Œè¡¨ self.cache[key] = node # æ·»åŠ è‡³åŒå‘é“¾è¡¨çš„å¤´éƒ¨ self.addToHead(node) self.size += 1 if self.size &gt; self.capacity: # å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹ removed = self.removeTail() # åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹ self.cache.pop(removed.key) self.size -= 1 else: # å¦‚æœ key å­˜åœ¨ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†ä¿®æ”¹ valueï¼Œå¹¶ç§»åˆ°å¤´éƒ¨ node = self.cache[key] node.value = value self.moveToHead(node) def addToHead(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def removeNode(self, node): node.prev.next = node.next node.next.prev = node.prev def moveToHead(self, node): self.removeNode(node) self.addToHead(node) def removeTail(self): node = self.tail.prev self.removeNode(node) return node"},{"title":"290. Word Pattern(easy)","path":"2022/08/21/290/","text":"290. Word Pattern(easy)Given a pattern and a string s, find if s follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.12Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;Output: true è¿™é“é¢˜ä¸205.åŒæ„å­—ç¬¦ä¸²å‡ ä¹ä¸€æ ·ï¼ŒåŒºåˆ«åœ¨äºï¼š1.205é¢˜å‡è®¾sä¸té•¿åº¦ç›¸ç­‰ï¼Œè¿™é“é¢˜éœ€è¦å¤„ç†patternå’Œsé•¿åº¦ä¸ä¸€æ ·çš„æƒ…å†µ 2.æœ¬é¢˜éœ€è¦å°†såˆ†éš”æˆå•ä¸ªå•è¯ å¸¸è§„åšæ³•æ˜¯ï¼Œæ ¹æ®patternå’Œsçš„å¯¹åº”å…³ç³»å»ºç«‹ä¸€ä¸ªhashmapï¼Œç„¶åå†éå†sä¸hashmapçš„æ˜ å°„åšæ¯”è¾ƒï¼Œæœ‰ä¸ä¸€æ ·å°±è¿”å›false 12345678910111213141516class Solution: def wordPattern(self, pattern: str, s: str) -&gt; bool: s=s.split() if len(s)!=len(pattern): return False if len(set(pattern))!=len(set(s)): return False hashmap=&#123;&#125; for i in range(len(s)): if pattern[i] not in hashmap: hashmap[pattern[i]]=s[i] for i in range(len(pattern)): if hashmap[pattern[i]]!=s[i]: return False return True ä¼˜é›…çš„pythonè§£æ³•æ˜¯ï¼š 12345678class Solution: def wordPattern(self, pattern: str, s: str) -&gt; bool: s = s.split() if len(pattern) != len(s): return False return len(set(pattern)) == len(set(s)) == len(set(zip(pattern,s)))"},{"title":"350. Intersection of Two Arrays II(easy)","path":"2022/08/21/350/","text":"350. Intersection of Two Arrays II(easy)Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.ç»™ä½ ä¸¤ä¸ªæ•´æ•°æ•°ç»„ nums1 å’Œ nums2 ï¼Œè¯·ä½ ä»¥æ•°ç»„å½¢å¼è¿”å›ä¸¤æ•°ç»„çš„äº¤é›†ã€‚è¿”å›ç»“æœä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œåº”ä¸å…ƒç´ åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å‡ºç°çš„æ¬¡æ•°ä¸€è‡´ï¼ˆå¦‚æœå‡ºç°æ¬¡æ•°ä¸ä¸€è‡´ï¼Œåˆ™è€ƒè™‘å–è¾ƒå°å€¼ï¼‰ã€‚å¯ä»¥ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåºã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode.cn/problems/intersection-of-two-arrays-iiè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚å®˜æ–¹é¢˜è§£ç”¨çš„æ˜¯heap åŠ hashmap 123456789101112131415161718class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: if len(nums1) &gt; len(nums2): return self.intersect(nums2, nums1) m = collections.Counter() for num in nums1: m[num] += 1 intersection = list() for num in nums2: if (count := m.get(num, 0)) &gt; 0: intersection.append(num) m[num] -= 1 if m[num] == 0: m.pop(num) return intersection è¿™ä¸ªæ–¹æ³•ç”¨çš„æ˜¯pythonä¸€äº›ç‹¬ç‰¹çš„å‡½æ•° Counter 123456class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: num1 = collections.Counter(nums1) num2 = collections.Counter(nums2) num = num1 &amp; num2 return num.elements() é“¾æ¥ï¼šæ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"349. Intersection of Two Arrays(easy)","path":"2022/08/21/349/","text":"349. Intersection of Two Arrays(easy)Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2] è¿™é¢˜ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æ‰¾åˆ°nums1 å’Œnums2ç›¸åŒçš„æ•°å­—ï¼Œå¹¶ä¸”è¾“å‡ºhashsetï¼ˆä¸èƒ½è¾“å‡ºé‡å¤æ•°å­—ï¼‰ 1234567891011121314class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: hashmap=&#123;&#125; res = [] for i in nums1: if i not in hashmap: hashmap[i]=1 else: hashmap[i]+=1 for i in nums2: if i in hashmap: res.append(i) return set(res)"},{"title":"299. Bulls and Cows","path":"2022/08/21/299/","text":"299. Bulls and CowsYou are playing the Bulls and Cows game with your friend.You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:The number of â€œbullsâ€, which are digits in the guess that are in the correct position.The number of â€œcowsâ€, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.Given the secret number secret and your friendâ€™s guess guess, return the hint for your friendâ€™s guess.The hint should be formatted as â€œxAyBâ€, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.åŸç†ï¼šçŒœæµ‹æ•°å­—ä¸­æœ‰å¤šå°‘ä½å±äºæ•°å­—å’Œç¡®åˆ‡ä½ç½®éƒ½çŒœå¯¹äº†ï¼ˆç§°ä¸º â€œBullsâ€ï¼Œå…¬ç‰›ï¼‰ï¼Œæœ‰å¤šå°‘ä½å±äºæ•°å­—çŒœå¯¹äº†ä½†æ˜¯ä½ç½®ä¸å¯¹ï¼ˆç§°ä¸º â€œCowsâ€ï¼Œå¥¶ç‰›ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ¬¡çŒœæµ‹ä¸­æœ‰å¤šå°‘ä½éå…¬ç‰›æ•°å­—å¯ä»¥é€šè¿‡é‡æ–°æ’åˆ—è½¬æ¢æˆå…¬ç‰›æ•°å­—ã€‚"},{"title":"264. Ugly Number II(medium)","path":"2022/08/20/264/","text":"264. Ugly Number II(medium)An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.Given an integer n, return the nth ugly number.è¿™æ˜¯ä¸€ä¸ªç³»åˆ—é¢˜263. ä¸‘æ•°ï¼ˆç®€å•ï¼‰ ä¸‘æ•° IIï¼ˆä¸­ç­‰ï¼‰ ä¸‘æ•° IIIï¼ˆä¸­ç­‰ï¼‰ è¶…çº§ä¸‘æ•°ï¼ˆä¸­ç­‰ï¼‰ â€œprime factorâ€æ˜¯è´¨å› å­ï¼Œè´¨å› å­æ˜¯æ‰€æœ‰å› å­ä¸­æ˜¯è´¨æ•°çš„ å®˜æ–¹é¢˜è§£1234567891011121314class Solution: def nthUglyNumber(self, n: int) -&gt; int: factors = [2, 3, 5] seen = &#123;1&#125; heap = [1] for i in range(n - 1): curr = heapq.heappop(heap) for factor in factors: if (nxt := curr * factor) not in seen: seen.add(nxt) heapq.heappush(heap, nxt) return heapq.heappop(heap) https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution 12345678910111213141516171819202122232425262728class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; ugly = [1] p2, p3, p5 = 0, 0, 0 # pointers that point to the last element 2, 3 or 5 was multiplied to while len(ugly) &lt; n: u2 = 2 * ugly[p2] u3 = 3 * ugly[p3] u5 = 5 * ugly[p5] u = min(u2, u3, u5) if u == u2: # if the minimum result was result of multiplying the element(ugly[p2]) by 2 p2 += 1 if u == u3: # if minimum was result of multiplying the element(ugly[p3]) by 3 p3 += 1 if u == u5: # if minimus was result of multiplying the element(ugly[p5]) by 5 p5 += 1 ugly.append(u) return ugly[-1] # return the last element of ugly list"},{"title":"268. Missing Number","path":"2022/08/20/268/","text":"268. Missing NumberGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.é¢˜ç›®æ˜¯è¯´ç»™äº†nä¸ªæ•°ï¼Œæ‰¾åˆ°0-nä¹‹é—´ç¼ºçš„é‚£ä¸ªæ•° 123Input: nums = [9,6,4,2,3,5,7,0,1]Output: 8Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. æ€è·¯ï¼šæœ¬è´¨ä¸Šä¸242. Valid AnagramZ(easy) æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œç›¸å½“äºæ˜¯ä¸¤ä¸ªhashmapçš„æ¯”è¾ƒï¼Œè¿™é‡Œæœ‰ä¸ªéšæ€§çš„æ¯”è¾ƒï¼Œåˆ†åˆ«æ˜¯numså»ºæˆçš„hashmapï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯å®Œæ•´çš„0-nè¿™æ ·çš„listå»ºæˆçš„hashmapï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥æ˜¯å»ºé€ ä¸€ä¸ªåŒ…å«0-næ•°å­—çš„listï¼Œç„¶åä»¥numså»ºæˆçš„hasmapä¸ºåŸºç¡€ï¼Œæ‹¿å®Œæ•´ç‰ˆè¿›è¡Œæ¯”è¾ƒï¼Œè¿™æ ·å¯ä»¥å¾—åˆ°ç¼ºå¤±çš„æ•°å­— class Solution: def missingNumber(self, nums: List[int]) -&gt; int: hashmap=&#123;&#125; n=len(nums) list = [] for i in nums: if i not in hashmap: hashmap[i]=1 else: hashmap[i]+=1 for i in range(n+1): list.append(i) for i in list: if i not in hashmap: a = i return a"},{"title":"242. Valid Anagram(easy)","path":"2022/08/20/242/","text":"242. Valid Anagram(easy)Given two strings s and t, return true if t is an anagram of s, and false otherwise.An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once.è¿™é“é¢˜å’Œ 205. Isomorphic Strings æœ‰ç‚¹åƒï¼Œä½†è¿™é“é¢˜æ›´ç®€å•ã€‚è¿™é“é¢˜æœ€å®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•å°±æ˜¯ç›´æ¥å¯¹å­—ç¬¦ä¸²æ’åºæ¯”è¾ƒå¾—åˆ°ç»“æœï¼Œé¦–å…ˆå­—ç¬¦ä¸²é•¿åº¦ä¸åŒè‚¯å®šè¾“å‡ºfalseï¼Œæ¥ä¸‹æ¥å†å¯¹å­—ç¬¦ä¸²æ’åºï¼Œå¦‚æœæ’åºåç›¸åŒå°±è¾“å‡ºtrue 12345678910111213141516171819202122232425clas Solution: def isAnagram(self, s: str, t: str) -&gt; bool: if len(s)!=len(t): return False return sorted(s)==sorted(t)``` ### [ä½†æ˜¯ï¼](htps://leetcode.cn/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/)å¤æ‚åº¦åˆ†ææ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ï¼Œå…¶ä¸­ n ä¸º s çš„é•¿åº¦ã€‚æ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸º O(nlogn)ï¼Œæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰æ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå› æ­¤æ€»ä½“æ—¶é—´å¤æ‚åº¦ä¸º O(nlogn+n)=O(nlogn)ã€‚ç©ºé—´å¤æ‚åº¦ï¼šO(logn)ã€‚æ’åºéœ€è¦ O(logn) çš„ç©ºé—´å¤æ‚åº¦ã€‚æ³¨æ„ï¼Œåœ¨æŸäº›è¯­è¨€ï¼ˆæ¯”å¦‚ Java &amp; JavaScriptï¼‰ä¸­å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é¢å¤–çš„ O(n) çš„ç©ºé—´æ¥æ‹·è´å­—ç¬¦ä¸²ã€‚ä½†æ˜¯æˆ‘ä»¬å¿½ç•¥è¿™ä¸€å¤æ‚åº¦åˆ†æï¼Œå› ä¸ºï¼šè¿™ä¾èµ–äºè¯­è¨€çš„ç»†èŠ‚ï¼›è¿™å–å†³äºå‡½æ•°çš„è®¾è®¡æ–¹å¼ï¼Œä¾‹å¦‚ï¼Œå¯ä»¥å°†å‡½æ•°å‚æ•°ç±»å‹æ›´æ”¹ä¸º char[]ã€‚æ‰€ä»¥ï¼Œæœ‰ç¬¬äºŒç§æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯hashmapï¼šä»å¦ä¸€ä¸ªè§’åº¦è€ƒè™‘ï¼Œt æ˜¯ s çš„å¼‚ä½è¯ç­‰ä»·äºã€Œä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­å­—ç¬¦å‡ºç°çš„ç§ç±»å’Œæ¬¡æ•°å‡ç›¸ç­‰ã€ã€‚ç”±äºå­—ç¬¦ä¸²åªåŒ…å« 26 ä¸ªå°å†™å­—æ¯ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º 26 çš„é¢‘æ¬¡æ•°ç»„ tableï¼Œå…ˆéå†è®°å½•å­—ç¬¦ä¸² s ä¸­å­—ç¬¦å‡ºç°çš„é¢‘æ¬¡ï¼Œç„¶åéå†å­—ç¬¦ä¸² tï¼Œå‡å» table ä¸­å¯¹åº”çš„é¢‘æ¬¡ï¼Œå¦‚æœå‡ºç° table[i]&lt;0ï¼Œåˆ™è¯´æ˜ t åŒ…å«ä¸€ä¸ªä¸åœ¨ s ä¸­çš„é¢å¤–å­—ç¬¦ï¼Œè¿”å› false å³å¯ã€‚å…¶å®ç®€å•ç‚¹æƒ³ï¼Œå°±æ˜¯å»ºä¸¤ä¸ªhashmapï¼Œæœ€åæ¯”è¾ƒæ˜¯å¦ç›¸åŒå°±å®Œäº‹äº†ã€‚æ¯”è¾ƒçš„å‡½æ•°```pythonoperator.eq(hashmap1,hashmap2) 123456789101112131415161718class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: if len(s)!=len(t): return False hashmap1=&#123;&#125; hashmap2=&#123;&#125; for c1 in s: if c1 not in hashmap1: hashmap1[c1]=1 else: hashmap1[c1]+=1 for c2 in t: if c2 not in hashmap2: hashmap2[c2]=1 else: hashmap2[c2]+=1 return operator.eq(hashmap1,hashmap2) Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?å¯¹äºè¿›é˜¶é—®é¢˜ï¼ŒUnicode æ˜¯ä¸ºäº†è§£å†³ä¼ ç»Ÿå­—ç¬¦ç¼–ç çš„å±€é™æ€§è€Œäº§ç”Ÿçš„æ–¹æ¡ˆï¼Œå®ƒä¸ºæ¯ä¸ªè¯­è¨€ä¸­çš„å­—ç¬¦è§„å®šäº†ä¸€ä¸ªå”¯ä¸€çš„äºŒè¿›åˆ¶ç¼–ç ã€‚è€Œ Unicode ä¸­å¯èƒ½å­˜åœ¨ä¸€ä¸ªå­—ç¬¦å¯¹åº”å¤šä¸ªå­—èŠ‚çš„é—®é¢˜ï¼Œä¸ºäº†è®©è®¡ç®—æœºçŸ¥é“å¤šå°‘å­—èŠ‚è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ï¼Œé¢å‘ä¼ è¾“çš„ç¼–ç æ–¹å¼çš„ UTFâˆ’8 å’Œ UTFâˆ’16 ä¹Ÿéšä¹‹è¯ç”Ÿé€æ¸å¹¿æ³›ä½¿ç”¨ï¼Œå…·ä½“ç›¸å…³çš„çŸ¥è¯†è¯»è€…å¯ä»¥ç»§ç»­æŸ¥é˜…ç›¸å…³èµ„æ–™æ‹“å±•è§†é‡ï¼Œè¿™é‡Œä¸å†å±•å¼€ã€‚ å›åˆ°æœ¬é¢˜ï¼Œè¿›é˜¶é—®é¢˜çš„æ ¸å¿ƒç‚¹åœ¨äºã€Œå­—ç¬¦æ˜¯ç¦»æ•£æœªçŸ¥çš„ã€ï¼Œå› æ­¤æˆ‘ä»¬ç”¨å“ˆå¸Œè¡¨ç»´æŠ¤å¯¹åº”å­—ç¬¦çš„é¢‘æ¬¡å³å¯ã€‚åŒæ—¶è¯»è€…éœ€è¦æ³¨æ„ Unicode ä¸€ä¸ªå­—ç¬¦å¯èƒ½å¯¹åº”å¤šä¸ªå­—èŠ‚çš„é—®é¢˜ï¼Œä¸åŒè¯­è¨€å¯¹äºå­—ç¬¦ä¸²è¯»å–å¤„ç†çš„æ–¹å¼æ˜¯ä¸åŒçš„ã€‚ 12345678910111213clas Solution: def isAnagram(self, s: str, t: str) -&gt; bool: #Using Hashmaps: (O(s+t) time and space) s_map = &#123;&#125; t_map = &#123;&#125; for leter in s: s_map[leter] = s_map.setdefault(leter, 0) + 1 for leter in t: t_map[leter] = t_map.setdefault(leter, 0) + 1 return s_map == t_map"},{"title":"229. Majority Element II(easy)","path":"2022/08/20/229/","text":"229. Majority Element II(easy)Given an integer array of size n, find all elements that appear more than âŒŠ n/3 âŒ‹ times.è¿™é“é¢˜æœ‰ç‚¹åƒTOP Ké—®é¢˜ï¼Œçœ‹åˆ°all elementsé‡Œçš„éå†æƒ³åˆ°hashmap æŠŠtop K çš„ä»£ç å’ŒMajority Element Içš„æ”¾åœ¨ä¸€èµ·å°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜äº† 12345678910111213141516171819202122232425262728293031323334class Solution: def majorityElement(self, nums: List[int]) -&gt; List[int]: hashmap = &#123;&#125; n=len(nums) for ans in nums: if ans not in hashmap: hashmap[ans]=1 else: hashmap[ans]+=1 res=[] for i in hashmap.keys(): if hashmap[i]&gt; len(nums)//3: res.append(i) return res``` è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¾“å‡ºæ‰€æœ‰æœ‰å¯èƒ½çš„æ•°ç»„æ—¶ï¼ŒTOP K é—®é¢˜ç”¨çš„æ˜¯extendï¼Œè€Œè¿™é‡Œç”¨çš„æ˜¯appendappendå¯ä»¥è¿½åŠ ä¸€ä¸ªlistï¼Œä¸€ä¸ªå¯¹è±¡ï¼›extendåˆ™æ˜¯æŠŠä¸¤ä¸ªlistè¿æ¥èµ·æ¥ï¼Œç±»ä¼¼matlabçš„catå‡½æ•° ```pythonNumList1 = [1,2,3]NumList2 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]NumList1.append(NumList2)print(&quot;åˆ—è¡¨2appendåˆ°åˆ—è¡¨1ï¼š&quot;,NumList1)#[1, 2, 3, [â€˜aâ€™, â€˜bâ€™, â€˜câ€™]]print(&#x27;ç¬¬å››ä¸ªå…ƒç´ ä¸º&#x27;,NumList1[3]) #[â€˜aâ€™, â€˜bâ€™, â€˜câ€™]NumList1 = [1,2,3]NumList1.extend(NumList2)print(&quot;åˆ—è¡¨2extendåˆ°åˆ—è¡¨1ï¼š&quot;,NumList1)#[1, 2, 3, â€˜aâ€™, â€˜bâ€™, â€˜câ€™]è¾“å‡ºç»“æœä¸ºï¼šåˆ—è¡¨2appendåˆ°åˆ—è¡¨1ï¼š [1, 2, 3, [â€˜aâ€™, â€˜bâ€™, â€˜câ€™]]ç¬¬å››ä¸ªå…ƒç´ ä¸º [â€˜aâ€™, â€˜bâ€™, â€˜câ€™]åˆ—è¡¨2extendåˆ°åˆ—è¡¨1ï¼š [1, 2, 3, â€˜aâ€™, â€˜bâ€™, â€˜câ€™]"},{"title":"219. Contains Duplicate II(easy)","path":"2022/08/20/219/","text":"219. Contains Duplicate II(easy)Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.12Input: nums = [1,2,3,1], k = 3Output: true å®˜æ–¹é¢˜è§£å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªå…ƒç´ çš„æœ€å¤§ä¸‹æ ‡ã€‚ä»å·¦åˆ°å³éå†æ•°ç»„ numsï¼Œå½“éå†åˆ°ä¸‹æ ‡ i æ—¶ï¼Œè¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š å¦‚æœå“ˆå¸Œè¡¨ä¸­å·²ç»å­˜åœ¨å’Œ nums[i] ç›¸ç­‰çš„å…ƒç´ ä¸”è¯¥å…ƒç´ åœ¨å“ˆå¸Œè¡¨ä¸­è®°å½•çš„ä¸‹æ ‡ j æ»¡è¶³ iâˆ’jâ‰¤kï¼Œè¿”å› trueï¼› å°† nums[i] å’Œä¸‹æ ‡ i å­˜å…¥å“ˆå¸Œè¡¨ï¼Œæ­¤æ—¶ i æ˜¯ nums[i] çš„æœ€å¤§ä¸‹æ ‡ã€‚ 123456789class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: pos = &#123;&#125; for i, num in enumerate(nums): if num in pos and i - pos[num] &lt;= k: return True pos[num] = i return False"},{"title":"205. Isomorphic Strings(easy)","path":"2022/08/20/205/","text":"205. Isomorphic Strings(easy)Given two strings s and t, determine if they are isomorphic.Two strings s and t are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.å®˜æ–¹é¢˜è§£æ­¤é¢˜æ˜¯ã€Œ290. å•è¯è§„å¾‹ã€çš„ç®€åŒ–ç‰ˆï¼Œéœ€è¦æˆ‘ä»¬åˆ¤æ–­ s å’Œ t æ¯ä¸ªä½ç½®ä¸Šçš„å­—ç¬¦æ˜¯å¦éƒ½ä¸€ä¸€å¯¹åº”ï¼Œå³ s çš„ä»»æ„ä¸€ä¸ªå­—ç¬¦è¢« t ä¸­å”¯ä¸€çš„å­—ç¬¦å¯¹åº”ï¼ŒåŒæ—¶ t çš„ä»»æ„ä¸€ä¸ªå­—ç¬¦è¢« s ä¸­å”¯ä¸€çš„å­—ç¬¦å¯¹åº”ã€‚è¿™ä¹Ÿè¢«ç§°ä¸ºã€ŒåŒå°„ã€çš„å…³ç³»ã€‚ æ€»ç»“ä¸€ä¸‹å°±æ˜¯å¾—ä¸€ä¸€å¯¹åº”ï¼Œå¹¶ä¸”æ˜¯äº’ç›¸å¯¹åº”ã€‚æ‰€ä»¥ç¬¬ä¸€ç§æ–¹æ³•å¯ä»¥ç”¨ä¸¤ä¸ªhashmapäº’ç›¸å­˜å‚¨å¯¹åº”å…³ç³»ï¼Œå†å¾€åè¿›è¡Œåˆ¤æ–­ 12345678910111213class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: hashmap1 = &#123;&#125; hashmap2 = &#123;&#125; for c1, c2 in zip(s, t): #The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it. if hashmap1.get(c1, c2) != c2 or hashmap2.get(c2, c1) != c1: #The get() method returns the value for the specified key if the key is in the dictionary. return False hashmap1[c1] = c2 hashmap2[c2] = c1 return True ç¬¬äºŒç§æ–¹æ³•ä¹Ÿæ˜¯è¯„è®ºé‡Œçš„å¾ˆæœ‰æ„æ€çš„æ–¹æ³•ï¼Œåˆ©ç”¨setçš„æ— é‡å¤ç‰¹æ€§æ¥åˆ¤æ–­ 123class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: return len(set(s)) == len(set(t)) == len(set(zip(s, t))) zip å‡½æ•° 1234567a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) # è¿”å›ä¸€ä¸ªå¯¹è±¡list(zipped) # list() è½¬æ¢ä¸ºåˆ—è¡¨ [(1, 4), (2, 5), (3, 6)]list(zip(a,c)) # å…ƒç´ ä¸ªæ•°ä¸æœ€çŸ­çš„åˆ—è¡¨ä¸€è‡´ [(1, 4), (2, 5), (3, 6)]"},{"title":"202. Happy Number(easy)","path":"2022/08/19/202/","text":"202. Happy Number(easy)Write an algorithm to determine if a number n is happy.A happy number is a number defined by the following process:Starting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.Those numbers for which this process ends in 1 are happy.Return true if n is a happy number, and false if not.åˆæ˜¯ä¸€ä¸ªå¥‡æ€ªçš„æ•°ï¼Œå«åšhappy number å®˜æ–¹é¢˜è§£æ€»ç»“ä¸€ä¸‹ï¼Œæ•°å­—æ¯ä¸€ä½çš„å¹³æ–¹å’Œåçš„ç»“æœæœ‰ä¸¤ç§å¯èƒ½æ€§ å˜æˆ1 å˜æˆå¾ªç¯ å¯¹äº 3 ä½æ•°çš„æ•°å­—ï¼Œå®ƒä¸å¯èƒ½å¤§äº 243ã€‚è¿™æ„å‘³ç€å®ƒè¦ä¹ˆè¢«å›°åœ¨ 243 ä»¥ä¸‹çš„å¾ªç¯å†…ï¼Œè¦ä¹ˆè·Œåˆ° 1ã€‚4 ä½æˆ– 4 ä½ä»¥ä¸Šçš„æ•°å­—åœ¨æ¯ä¸€æ­¥éƒ½ä¼šä¸¢å¤±ä¸€ä½ï¼Œç›´åˆ°é™åˆ° 3 ä½ä¸ºæ­¢ã€‚æ‰€ä»¥æˆ‘ä»¬çŸ¥é“ï¼Œæœ€åçš„æƒ…å†µä¸‹ï¼Œç®—æ³•å¯èƒ½ä¼šåœ¨ 243 ä»¥ä¸‹çš„æ‰€æœ‰æ•°å­—ä¸Šå¾ªç¯ï¼Œç„¶åå›åˆ°å®ƒå·²ç»åˆ°è¿‡çš„ä¸€ä¸ªå¾ªç¯æˆ–è€…å›åˆ° 1ã€‚ä½†å®ƒä¸ä¼šæ— é™æœŸåœ°è¿›è¡Œä¸‹å»ï¼Œæ‰€ä»¥æˆ‘ä»¬æ’é™¤æ— é™å¢å¤§çš„é€‰æ‹©ã€‚ ç®—æ³• ç®—æ³•åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæˆ‘ä»¬éœ€è¦è®¾è®¡å’Œç¼–å†™ä»£ç ã€‚ ç»™ä¸€ä¸ªæ•°å­— nnï¼Œå®ƒçš„ä¸‹ä¸€ä¸ªæ•°å­—æ˜¯ä»€ä¹ˆï¼ŸæŒ‰ç…§ä¸€ç³»åˆ—çš„æ•°å­—æ¥åˆ¤æ–­æˆ‘ä»¬æ˜¯å¦è¿›å…¥äº†ä¸€ä¸ªå¾ªç¯ã€‚ æˆ‘ä»¬æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚åšæ•°ä½åˆ†ç¦»ï¼Œæ±‚å¹³æ–¹å’Œã€‚ å¯ä»¥ä½¿ç”¨å“ˆå¸Œé›†åˆå®Œæˆã€‚æ¯æ¬¡ç”Ÿæˆé“¾ä¸­çš„ä¸‹ä¸€ä¸ªæ•°å­—æ—¶ï¼Œæˆ‘ä»¬éƒ½ä¼šæ£€æŸ¥å®ƒæ˜¯å¦å·²ç»åœ¨å“ˆå¸Œé›†åˆä¸­ã€‚ å¦‚æœå®ƒä¸åœ¨å“ˆå¸Œé›†åˆä¸­ï¼Œæˆ‘ä»¬åº”è¯¥æ·»åŠ å®ƒã€‚å¦‚æœå®ƒåœ¨å“ˆå¸Œé›†åˆä¸­ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¤„äºä¸€ä¸ªå¾ªç¯ä¸­ï¼Œå› æ­¤åº”è¯¥è¿”å› falseã€‚ æˆ‘ä»¬ä½¿ç”¨å“ˆå¸Œé›†åˆè€Œä¸æ˜¯å‘é‡ã€åˆ—è¡¨æˆ–æ•°ç»„çš„åŸå› æ˜¯å› ä¸ºæˆ‘ä»¬åå¤æ£€æŸ¥å…¶ä¸­æ˜¯å¦å­˜åœ¨æŸæ•°å­—ã€‚æ£€æŸ¥æ•°å­—æ˜¯å¦åœ¨å“ˆå¸Œé›†åˆä¸­éœ€è¦ O(1) çš„æ—¶é—´ï¼Œè€Œå¯¹äºå…¶ä»–æ•°æ®ç»“æ„ï¼Œåˆ™éœ€è¦ O(n) çš„æ—¶é—´ã€‚é€‰æ‹©æ­£ç¡®çš„æ•°æ®ç»“æ„æ˜¯è§£å†³è¿™äº›é—®é¢˜çš„å…³é”®éƒ¨åˆ†ã€‚ Hashmapè§£æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution: def isHappy(self, n: int) -&gt; bool: n_history=&#123;&#125; while True: try: n_history[n]+=1 return False except: n_history[n]=0 digit_li=[str(n)[i] for i in range(len(str(n)))] n=sum(list(map(lambda x:(int(x))**2,digit_li))) if n==1: return True``` ç›¸å½“äºæŠŠæ•°å­—nè½¬æ¢æˆå­—ç¬¦ä¸²ï¼Œå†è¿›è¡Œå¹³æ–¹å’Œè¿ç®— ```python class Solution: def isHappy(self, n: int) -&gt; bool: seen = set() while n != 1: if n in seen: return False seen.add(n) num = str(n) temp = 0 for ch in num: temp += int(ch)**2 n = temp return True ``` hashsetè§£æ³•```pythonclass Solution: def isHappy(self, n: int) -&gt; bool: def get_next(n): total_sum = 0 while n &gt; 0: n, digit = divmod(n, 10) #divmodæ±‚ä½™æ•° total_sum += digit ** 2 return total_sum seen = set() # pythoné‡Œhashsetçš„æœ¬è´¨å°±æ˜¯set while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"title":"169. Majority Element(easy)","path":"2022/08/19/169/","text":"169. Majority Element(easy)Given an array nums of size n, return the majority element.The majority element is the element that appears more than âŒŠn / 2âŒ‹ times. You may assume that the majority element always exists in the array.1234Example 1:Input: nums = [3,2,3]Output: 3 å ªç§°hashampæœ€åŸºç¡€é¢˜ç›®ï¼Œçº¯ç²¹æ˜¯è€ƒhashmapçš„æ€§è´¨ï¼Œå‰é¢æ˜¯æŠŠæ•°å­—éƒ½å½•å…¥hashmapï¼Œåé¢å†è¿›è¡Œä¸€ä¸ªç®€å•çš„åˆ¤æ–­ã€‚class Solution: def majorityElement(self, nums: List[int]) -&gt; int: hashmap = &#123;&#125; n=len(nums) for ans in nums: if ans not in hashmap: hashmap[ans]=1 else: hashmap[ans]+=1 for ans in hashmap: if hashmap[ans]&gt;n//2: return ans"},{"title":"101. Symmetric Tree (Easy)","path":"2022/08/17/101/","text":"101. Symmetric Tree (Easy)Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).123456789101112131415161718192021class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True def dfs(left,right): # é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºç©º # æˆ–è€…ä¸¤ä¸ªèŠ‚ç‚¹ä¸­æœ‰ä¸€ä¸ªä¸ºç©º # æˆ–è€…ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ä¸ç›¸ç­‰ if not (left or right): return True if not (left and right): return False if left.val!=right.val: return False return dfs(left.left,right.right) and dfs(left.right,right.left) # ç”¨é€’å½’å‡½æ•°ï¼Œæ¯”è¾ƒå·¦èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹ return dfs(root.left,root.right)"},{"title":"572. Subtree of Another Tree (Easy)","path":"2022/08/17/572/","text":"572. Subtree of Another Tree (Easy)Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.A subtree of a binary tree tree is a tree that consists of a node in tree and all of this nodeâ€™s descendants. The tree tree could also be considered as a subtree of itself.12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isSubtree(self, root, subRoot) : queue = [root] while len(queue) &gt; 0: curr = queue.pop(0) if curr.val == subRoot.val : if self.compare(curr,subRoot): return True if curr.right: queue.append(curr.right) if curr.left: queue.append(curr.left) return False def compare(self,curr,subRoot): if curr is None and subRoot is None: return True elif not curr is None and subRoot is None : return False elif curr is None and not subRoot is None : return False elif curr.val == subRoot.val : r_flag = self.compare(curr.right,subRoot.right) l_flag = self.compare(curr.left,subRoot.left) if r_flag and l_flag: return True"},{"title":"437. Path Sum III (Easy)","path":"2022/08/17/437/","text":"437. Path Sum III (Easy)Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).å‰ç¼€å’Œæ€è·¯ä¸ç®—æ³•æˆ‘ä»¬ä»”ç»†æ€è€ƒä¸€ä¸‹ï¼Œè§£æ³•ä¸€ä¸­åº”è¯¥å­˜åœ¨è®¸å¤šé‡å¤è®¡ç®—ã€‚æˆ‘ä»¬å®šä¹‰èŠ‚ç‚¹çš„å‰ç¼€å’Œä¸ºï¼šç”±æ ¹ç»“ç‚¹åˆ°å½“å‰ç»“ç‚¹çš„è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å’Œã€‚æˆ‘ä»¬åˆ©ç”¨å…ˆåºéå†äºŒå‰æ ‘ï¼Œè®°å½•ä¸‹æ ¹èŠ‚ç‚¹ root åˆ°å½“å‰èŠ‚ç‚¹ pp çš„è·¯å¾„ä¸Šé™¤å½“å‰èŠ‚ç‚¹ä»¥å¤–æ‰€æœ‰èŠ‚ç‚¹çš„å‰ç¼€å’Œï¼Œåœ¨å·²ä¿å­˜çš„è·¯å¾„å‰ç¼€å’Œä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å‰ç¼€å’Œåˆšå¥½ç­‰äºå½“å‰èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„å‰ç¼€å’Œ currcurr å‡å» targetSumã€‚å¯¹äºç©ºè·¯å¾„æˆ‘ä»¬ä¹Ÿéœ€è¦ä¿å­˜é¢„å…ˆå¤„ç†ä¸€ä¸‹ï¼Œæ­¤æ—¶å› ä¸ºç©ºè·¯å¾„ä¸ç»è¿‡ä»»ä½•èŠ‚ç‚¹ï¼Œå› æ­¤å®ƒçš„å‰ç¼€å’Œä¸º 00ã€‚å‡è®¾æ ¹èŠ‚ç‚¹ä¸º rootï¼Œæˆ‘ä»¬å½“å‰åˆšå¥½è®¿é—®èŠ‚ç‚¹ nodeï¼Œåˆ™æ­¤æ—¶ä»æ ¹èŠ‚ç‚¹ root åˆ°èŠ‚ç‚¹ node çš„è·¯å¾„ï¼ˆæ— é‡å¤èŠ‚ç‚¹ï¼‰åˆšå¥½ä¸º \\rightarrow p_1 \\rightarrow p_2 \\rightarrow \\ldots \\rightarrow p_k \\rightarrow rootâ†’p1â€‹ â†’p2â€‹ â†’â€¦â†’pkâ€‹ â†’nodeï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å·²ç»ä¿å­˜äº†èŠ‚ç‚¹ p_1, p_2, p_3, \\ldots, p_kp1â€‹ ,p2â€‹ ,p3â€‹ ,â€¦,pkâ€‹ çš„å‰ç¼€å’Œï¼Œå¹¶ä¸”è®¡ç®—å‡ºäº†èŠ‚ç‚¹ node çš„å‰ç¼€å’Œã€‚ å‡è®¾å½“å‰ä»æ ¹èŠ‚ç‚¹ root åˆ°èŠ‚ç‚¹ node çš„å‰ç¼€å’Œä¸º \\textit{curr}currï¼Œåˆ™æ­¤æ—¶æˆ‘ä»¬åœ¨å·²ä¿å­˜çš„å‰ç¼€å’ŒæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨å‰ç¼€å’Œåˆšå¥½ç­‰äº \\textit{curr} - currâˆ’targetSumã€‚å‡è®¾ä»æ ¹èŠ‚ç‚¹ root åˆ°èŠ‚ç‚¹ node çš„è·¯å¾„ä¸­å­˜åœ¨èŠ‚ç‚¹ p_ipiâ€‹ åˆ°æ ¹èŠ‚ç‚¹ root çš„å‰ç¼€å’Œä¸º \\textit{curr} - currâˆ’targetSumï¼Œåˆ™èŠ‚ç‚¹ p_{i+1}pi+1â€‹ åˆ° node çš„è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å’Œä¸€å®šä¸º targetSumã€‚ æˆ‘ä»¬åˆ©ç”¨æ·±åº¦æœç´¢éå†æ ‘ï¼Œå½“æˆ‘ä»¬é€€å‡ºå½“å‰èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬éœ€è¦åŠæ—¶æ›´æ–°å·²ç»ä¿å­˜çš„å‰ç¼€å’Œã€‚ ä½œè€…ï¼šLeetCode-Solutioné“¾æ¥ï¼šhttps://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"},{"title":"112. Path Sum (Easy)","path":"2022/08/16/112/","text":"112. Path Sum (Easy)Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.A leaf is a node with no children.å®˜æ–¹é¢˜è§£ è§‚å¯Ÿè¦æ±‚æˆ‘ä»¬å®Œæˆçš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å½’çº³å‡ºå®ƒçš„åŠŸèƒ½ï¼šè¯¢é—®æ˜¯å¦å­˜åœ¨ä»å½“å‰èŠ‚ç‚¹ root åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ»¡è¶³å…¶è·¯å¾„å’Œä¸º sumã€‚ å‡å®šä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å€¼ä¹‹å’Œä¸º valï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå¤§é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªå°é—®é¢˜ï¼šæ˜¯å¦å­˜åœ¨ä»å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ°å¶å­çš„è·¯å¾„ï¼Œæ»¡è¶³å…¶è·¯å¾„å’Œä¸º sum - valã€‚ ä¸éš¾å‘ç°è¿™æ»¡è¶³é€’å½’çš„æ€§è´¨ï¼Œè‹¥å½“å‰èŠ‚ç‚¹å°±æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥åˆ¤æ–­ sum æ˜¯å¦ç­‰äº val å³å¯ï¼ˆå› ä¸ºè·¯å¾„å’Œå·²ç»ç¡®å®šï¼Œå°±æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­è¯¥è·¯å¾„å’Œæ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼‰ã€‚è‹¥å½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦é€’å½’åœ°è¯¢é—®å®ƒçš„å­èŠ‚ç‚¹æ˜¯å¦èƒ½æ»¡è¶³æ¡ä»¶å³å¯ã€‚ å¤æ‚åº¦åˆ†æ æ—¶é—´å¤æ‚åº¦ï¼šO(N)ï¼Œå…¶ä¸­ N æ˜¯æ ‘çš„èŠ‚ç‚¹æ•°ã€‚å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(H)ï¼Œå…¶ä¸­ H æ˜¯æ ‘çš„é«˜åº¦ã€‚ç©ºé—´å¤æ‚åº¦ä¸»è¦å–å†³äºé€’å½’æ—¶æ ˆç©ºé—´çš„å¼€é”€ï¼Œæœ€åæƒ…å†µä¸‹ï¼Œæ ‘å‘ˆç°é“¾çŠ¶ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(N)ã€‚å¹³å‡æƒ…å†µä¸‹æ ‘çš„é«˜åº¦ä¸èŠ‚ç‚¹æ•°çš„å¯¹æ•°æ­£ç›¸å…³ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(logN)ã€‚ 12345678910111213141516 # Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool: if not root: return False if not root.left and not root.right: return targetSum == root.val return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)"},{"title":"617. Merge Two Binary Trees (Easy)","path":"2022/08/15/617/","text":"617. Merge Two Binary Trees (Easy)You are given two binary trees root1 and root2.Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.Return the merged tree.Note: The merging process must start from the root nodes of both trees.å‚è€ƒè§£æå¯¹äºäºŒå‰æ ‘æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬åƒéå†æ•°ç»„é‚£æ ·ï¼ŒæŒ¨ä¸ªéå†ä¸¤é¢—äºŒå‰æ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå†æŠŠä»–ä»¬ç›¸åŠ ï¼Œé‚£é—®é¢˜å°±æ¯”è¾ƒå®¹æ˜“è§£å†³äº†ã€‚ éå†äºŒå‰æ ‘å¾ˆç®€å•ï¼Œç”¨ å‰åº éå†å°±å¯ä»¥äº†ï¼Œå†ä¾æ¬¡æŠŠè®¿é—®åˆ°çš„èŠ‚ç‚¹å€¼ç›¸åŠ ï¼Œå› ä¸ºé¢˜ç›®æ²¡æœ‰è¯´ä¸èƒ½æ”¹å˜æ ‘çš„å€¼å’Œç»“æ„ï¼Œæˆ‘ä»¬ä¸ç”¨å†åˆ›å»ºæ–°çš„èŠ‚ç‚¹äº†ï¼Œç›´æ¥å°†æ ‘2åˆå¹¶åˆ°æ ‘1ä¸Šå†è¿”å›å°±å¯ä»¥äº†ã€‚éœ€è¦æ³¨æ„ï¼šè¿™ä¸¤é¢—æ ‘å¹¶ä¸æ˜¯é•¿å¾—å®Œå…¨ä¸€æ ·ï¼Œæœ‰çš„æ ‘å¯èƒ½æœ‰å·¦èŠ‚ç‚¹ï¼Œä½†æœ‰çš„æ ‘æ²¡æœ‰ã€‚ æ€»ç»“ä¸‹é€’å½’çš„æ¡ä»¶ï¼š ç»ˆæ­¢æ¡ä»¶ï¼šæ ‘ 1 çš„èŠ‚ç‚¹ä¸º nullï¼Œæˆ–è€…æ ‘ 2 çš„èŠ‚ç‚¹ä¸º nullé€’å½’å‡½æ•°å†…ï¼šå°†ä¸¤ä¸ªæ ‘çš„èŠ‚ç‚¹ç›¸åŠ åï¼Œå†èµ‹ç»™æ ‘ 1 çš„èŠ‚ç‚¹ã€‚å†é€’å½’çš„æ‰§è¡Œä¸¤ä¸ªæ ‘çš„å·¦èŠ‚ç‚¹ï¼Œé€’å½’æ‰§è¡Œä¸¤ä¸ªæ ‘çš„å³èŠ‚ç‚¹ æ€»ç»“ä¸€ä¸‹å°±æ˜¯æŠŠroot2çš„å€¼å¤åˆ¶åˆ°root1ä¸Š 12345678910111213141516171819 # Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]: def dfs(root1,root2): if not (root1 and root2): return root1 if root1 else root2 root1.val += root2.val root1.left = dfs(root1.left,root2.left) root1.right = dfs(root1.right,root2.right) return root1 return dfs(root1,root2)"},{"title":"226. Invert Binary Tree (Easy)","path":"2022/08/15/226/","text":"226. Invert Binary Tree (Easy)Given the root of a binary tree, invert the tree, and return its root.å®˜æ–¹é¢˜è§£è¿™æ˜¯ä¸€é“å¾ˆç»å…¸çš„äºŒå‰æ ‘é—®é¢˜ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé€’å½’åœ°å¯¹æ ‘è¿›è¡Œéå†ï¼Œå¹¶ä»å¶å­èŠ‚ç‚¹å…ˆå¼€å§‹ç¿»è½¬ã€‚å¦‚æœå½“å‰éå†åˆ°çš„èŠ‚ç‚¹ root çš„å·¦å³ä¸¤æ£µå­æ ‘éƒ½å·²ç»ç¿»è½¬ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦äº¤æ¢ä¸¤æ£µå­æ ‘çš„ä½ç½®ï¼Œå³å¯å®Œæˆä»¥ root ä¸ºæ ¹èŠ‚ç‚¹çš„æ•´æ£µå­æ ‘çš„ç¿»è½¬ã€‚ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]: if not root: return root left = self.invertTree(root.left) right = self.invertTree(root.right) root.left = right root.right = left return root"},{"title":"543. Diameter of Binary Tree (Easy)","path":"2022/08/14/543/","text":"543. Diameter of Binary Tree (Easy)Given the root of a binary tree, return the length of the diameter of the tree.The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.The length of a path between two nodes is represented by the number of edges between them.ç»å…¸é‡ç° å®˜æ–¹é¢˜è§£æ·±åº¦ä¼˜å…ˆæœç´¢å…¶å®æˆ‘çœ‹åˆ°è¿™é“é¢˜æ„Ÿè§‰å’Œ110. Balanced Binary Tree (Easy)å¾ˆåƒï¼Œå¯ä»¥åœ¨æ±‚é«˜åº¦çš„åŸºç¡€ä¸Šç¨å¾®æ”¹ä¸€ä¸‹é¦–å…ˆæˆ‘ä»¬çŸ¥é“ä¸€æ¡è·¯å¾„çš„é•¿åº¦ä¸ºè¯¥è·¯å¾„ç»è¿‡çš„èŠ‚ç‚¹æ•°å‡ä¸€ï¼Œæ‰€ä»¥æ±‚ç›´å¾„ï¼ˆå³æ±‚è·¯å¾„é•¿åº¦çš„æœ€å¤§å€¼ï¼‰ç­‰æ•ˆäºæ±‚è·¯å¾„ç»è¿‡èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼å‡ä¸€ã€‚ è€Œä»»æ„ä¸€æ¡è·¯å¾„å‡å¯ä»¥è¢«çœ‹ä½œç”±æŸä¸ªèŠ‚ç‚¹ä¸ºèµ·ç‚¹ï¼Œä»å…¶å·¦å„¿å­å’Œå³å„¿å­å‘ä¸‹éå†çš„è·¯å¾„æ‹¼æ¥å¾—åˆ°ã€‚ å‡è®¾æˆ‘ä»¬çŸ¥é“å¯¹äºè¯¥èŠ‚ç‚¹çš„å·¦å„¿å­å‘ä¸‹éå†ç»è¿‡æœ€å¤šçš„èŠ‚ç‚¹æ•° L ï¼ˆå³ä»¥å·¦å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ï¼‰ å’Œå…¶å³å„¿å­å‘ä¸‹éå†ç»è¿‡æœ€å¤šçš„èŠ‚ç‚¹æ•° R ï¼ˆå³ä»¥å³å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ï¼‰ï¼Œé‚£ä¹ˆä»¥è¯¥èŠ‚ç‚¹ä¸ºèµ·ç‚¹çš„è·¯å¾„ç»è¿‡èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼å³ä¸º L+R+1 ã€‚ æˆ‘ä»¬è®°èŠ‚ç‚¹node ä¸ºèµ·ç‚¹çš„è·¯å¾„ç»è¿‡èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼ä¸º dnodeï¼Œé‚£ä¹ˆäºŒå‰æ ‘çš„ç›´å¾„å°±æ˜¯æ‰€æœ‰èŠ‚ç‚¹ dnodeçš„æœ€å¤§å€¼å‡ä¸€ã€‚ æœ€åçš„ç®—æ³•æµç¨‹ä¸ºï¼šæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•° depth(node) è®¡ç®— dnodeï¼Œå‡½æ•°è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ã€‚å…ˆé€’å½’è°ƒç”¨å·¦å„¿å­å’Œå³å„¿å­æ±‚å¾—å®ƒä»¬ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ L å’Œ R ï¼Œåˆ™è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦å³ä¸ºmax(L,R)+1 è¯¥èŠ‚ç‚¹çš„ dnode å€¼ä¸ºL+R+1 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int: self.ans = 1 def depth(root): # è®¿é—®åˆ°ç©ºèŠ‚ç‚¹äº†ï¼Œè¿”å›0 if not root: return 0 # å·¦å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ L = depth(root.left) # å³å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ R = depth(root.right) # è®¡ç®—d_nodeå³L+R+1 å¹¶æ›´æ–°ans self.ans = max(self.ans, L + R + 1) # è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ return max(L, R) + 1 depth(root) return self.ans - 1"},{"title":"110. Balanced Binary Tree (Easy)","path":"2022/08/14/110/","text":"110. Balanced Binary Tree (Easy)Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as:a binary tree in which the left and right subtrees of every node differ in height by no more than 1.ç»å…¸é‡ç° å¹³è¡¡äºŒå‰æ ‘ä¸¤ç§åŠæ³• æ–¹æ³•ä¸€ï¼šè‡ªé¡¶å‘ä¸‹çš„é€’å½’å®šä¹‰å‡½æ•° heightï¼Œç”¨äºè®¡ç®—äºŒå‰æ ‘ä¸­çš„ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ p çš„é«˜åº¦ï¼šheight(p)=max(height(p.left),height(p.right))+1 Pæ˜¯éç©ºèŠ‚ç‚¹ æœ‰äº†è®¡ç®—èŠ‚ç‚¹é«˜åº¦çš„å‡½æ•°ï¼Œå³å¯åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦å¹³è¡¡ã€‚å…·ä½“åšæ³•ç±»ä¼¼äºäºŒå‰æ ‘çš„å‰åºéå†ï¼Œå³å¯¹äºå½“å‰éå†åˆ°çš„èŠ‚ç‚¹ï¼Œé¦–å…ˆè®¡ç®—å·¦å³å­æ ‘çš„é«˜åº¦ï¼Œå¦‚æœå·¦å³å­æ ‘çš„é«˜åº¦å·®æ˜¯å¦ä¸è¶…è¿‡ 1ï¼Œå†åˆ†åˆ«é€’å½’åœ°éå†å·¦å³å­èŠ‚ç‚¹ï¼Œå¹¶åˆ¤æ–­å·¦å­æ ‘å’Œå³å­æ ‘æ˜¯å¦å¹³è¡¡ã€‚è¿™æ˜¯ä¸€ä¸ªè‡ªé¡¶å‘ä¸‹çš„é€’å½’çš„è¿‡ç¨‹ã€‚ 12345678910class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def height(root: TreeNode) -&gt; int: if not root: return 0 return max(height(root.left), height(root.right)) + 1 if not root: return True return abs(height(root.left) - height(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right) æ–¹æ³•äºŒï¼šè‡ªåº•å‘ä¸Šçš„é€’å½’æ–¹æ³•ä¸€ç”±äºæ˜¯è‡ªé¡¶å‘ä¸‹é€’å½’ï¼Œå› æ­¤å¯¹äºåŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‡½æ•° height ä¼šè¢«é‡å¤è°ƒç”¨ï¼Œå¯¼è‡´æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ã€‚å¦‚æœä½¿ç”¨è‡ªåº•å‘ä¸Šçš„åšæ³•ï¼Œåˆ™å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œå‡½æ•° height åªä¼šè¢«è°ƒç”¨ä¸€æ¬¡ã€‚ è‡ªåº•å‘ä¸Šé€’å½’çš„åšæ³•ç±»ä¼¼äºååºéå†ï¼Œå¯¹äºå½“å‰éå†åˆ°çš„èŠ‚ç‚¹ï¼Œå…ˆé€’å½’åœ°åˆ¤æ–­å…¶å·¦å³å­æ ‘æ˜¯å¦å¹³è¡¡ï¼Œå†åˆ¤æ–­ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘æ˜¯å¦å¹³è¡¡ã€‚å¦‚æœä¸€æ£µå­æ ‘æ˜¯å¹³è¡¡çš„ï¼Œåˆ™è¿”å›å…¶é«˜åº¦ï¼ˆé«˜åº¦ä¸€å®šæ˜¯éè´Ÿæ•´æ•°ï¼‰ï¼Œå¦åˆ™è¿”å› -1ã€‚å¦‚æœå­˜åœ¨ä¸€æ£µå­æ ‘ä¸å¹³è¡¡ï¼Œåˆ™æ•´ä¸ªäºŒå‰æ ‘ä¸€å®šä¸å¹³è¡¡ã€‚ 1234567891011121314class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def height(root: TreeNode) -&gt; int: if not root: return 0 leftHeight = height(root.left) rightHeight = height(root.right) if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) &gt; 1: return -1 else: return max(leftHeight, rightHeight) + 1 return height(root) &gt;= 0 ä¼˜åŒ– 123456789101112class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def helper(node): if not node: return 0 left_depth = helper(node.left) right_depth = helper(node.right) if abs(left_depth - right_depth) &gt; 1: flag[0] = False return max(left_depth, right_depth) + 1 flag = [True] helper(root) return flag[0] è¿™é‡Œä¸ºä»€ä¹ˆè¦ç”¨flag[0]è€Œä¸æ˜¯ä¸€ä¸ªå˜é‡å‘¢ï¼Ÿç›´æ¥ä¸€ä¸ªå˜é‡éœ€è¦åŠ selfå…³é”®å­—ï¼Œå¦åˆ™ä¼ ä¸è¿›é€’å½’å‡½æ•°é‡Œï¼Œå› ä¸ºå˜é‡çš„èµ‹å€¼å’Œåˆå§‹åŒ–éƒ½æ˜¯ä¸€ä¸ªè¯­æ³•ä¼šå¯¼è‡´æ­§ä¹‰ï¼Œæ‰€ä»¥é€’å½’é‡Œä¿®æ”¹flagçš„å€¼ä¼šå½“æˆå®šä¹‰ä¸€ä¸ªæ–°çš„flagå˜é‡ï¼Œè€Œè¿™ä¸ªå˜é‡åªåœ¨é€’å½’é‡Œç”Ÿæ•ˆï¼Œæ‰€ä»¥é€’å½’å¤–éƒ¨å®šä¹‰çš„flagæ— æ³•è¢«ä¿®æ”¹ï¼Œå¤§æ¦‚ç±»ä¼¼å±€éƒ¨å˜é‡å’Œå…¨å±€å˜é‡çš„åŒºåˆ«ï¼Œè€Œåˆ—è¡¨ã€å­—å…¸ç­‰ï¼Œåˆå§‹åŒ–å’Œèµ‹å€¼çš„æ–¹æ³•ä¸åŒï¼Œå› æ­¤ä¸ä¼šå¯¼è‡´æ­§ä¹‰ï¼Œæ‰€ä»¥å‡½æ•°å¯¹å…¶ä¿®æ”¹ä¹Ÿä¼šæ”¹å˜è°ƒç”¨ä»£ç ä¸­çš„å€¼ï¼Œç»“è®ºå¦‚ä¸‹: åˆ—è¡¨ã€å­—å…¸ã€é›†åˆï¼šæ€»æ˜¯ä¼šæŒ‰å¼•ç”¨ä¼ å…¥å‡½æ•°ï¼Œå‡½æ•°ä»£ç ç»„ä¸­å¯¹å˜é‡æ•°æ®ç»“æ„çš„ä»»ä½•æ”¹å˜éƒ½ä¼šåæ˜ åˆ°è°ƒç”¨ä»£ç ä¸­ã€‚å­—ç¬¦ä¸²ã€æ•´æ•° ã€å…ƒç»„ï¼šæ€»æ˜¯ä¼šæŒ‰å€¼ä¼ å…¥å‡½æ•°ï¼Œå‡½æ•°ä¸­å¯¹å˜é‡çš„ä»»ä½•ä¿®æ”¹æ˜¯è¿™ä¸ªå‡½æ•°ç§æœ‰çš„ï¼Œä¸ä¼šåæ˜ åˆ°è°ƒç”¨ä»£ç ä¸­ã€‚"},{"title":"104. Maximum Depth of Binary Tree (Easy)","path":"2022/08/14/104/","text":"104. Maximum Depth of Binary Tree (Easy)Given the root of a binary tree, return its maximum depth.A binary treeâ€™s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.ç»å…¸é‡ç° è¿™é“é¢˜æ˜¯æ±‚äºŒå‰æ ‘çš„æ·±åº¦ï¼Œå¯ä»¥ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚ç®—æ³•æ€æƒ³ï¼š ä¸€ä¸ªèŠ‚ç‚¹çš„é«˜åº¦=max(å·¦å­©å­çš„é«˜åº¦,å³å­©å­çš„é«˜åº¦)+1ã€‚ è¿›è¡Œå…ˆåºéå†æœç´¢ï¼Œæ¯æ¬¡é€’å½’è¿”å›çš„æ—¶å€™ç»Ÿè®¡å…¶å·¦å³å­©å­ä¸­æœ€å¤§çš„æ·±åº¦ã€‚ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if root is None: return 0 else: left_height = self.maxDepth(root.left) right_height = self.maxDepth(root.right) return max(left_height,right_height)+1"},{"title":"328. Odd Even Linked List (Medium)","path":"2022/08/06/328/","text":"328. Odd Even Linked List (Medium)Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.The first node is considered odd, and the second node is even, and so on.Note that the relative order inside both the even and odd groups should remain as it was in the input.You must solve the problem in O(1) extra space complexity and O(n) time complexity.æ€»ç»“æ˜¯æŠŠå¥‡æ•°èŠ‚ç‚¹ä¸²ä¸€å—å„¿ï¼Œå†æŠŠå¶æ•°èŠ‚ç‚¹ä¸²ä¸€èµ·ï¼Œç„¶åæŠŠä¸¤ä¸ªè¿æˆä¸€æ¡é“¾è¡¨ å®˜æ–¹é¢˜è§£ 12345678910111213141516class Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head: return head evenHead = head.next #æ–°å»ºä¸€ä¸ªé“¾è¡¨å¤´ odd, even = head, evenHead while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head"},{"title":"725. Split Linked List in Parts(Medium)","path":"2022/08/06/725/","text":"725. Split Linked List in Parts(Medium)Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.Return an array of the k parts.é¢˜ç›®æè¿°ï¼šæŠŠé“¾è¡¨åˆ†éš”æˆ k éƒ¨åˆ†ï¼Œæ¯éƒ¨åˆ†çš„é•¿åº¦éƒ½åº”è¯¥å°½å¯èƒ½ç›¸åŒï¼Œæ’åœ¨å‰é¢çš„é•¿åº¦åº”è¯¥å¤§äºç­‰äºåé¢çš„ã€‚å…¶å®å°±æ˜¯nä¸ªæ•°åˆ†æˆmç»„ï¼Œå‰é¢ä¸€äº›ç»„å¤šä¸€ä¸ªï¼Œn/m+1ï¼Œåé¢çš„ç»„æ•°é‡æ˜¯n/m ä»£ç  1234567891011121314151617181920212223242526class Solution: def splitListToParts(self, head: ListNode, k: int) -&gt; List[ListNode]: L = 0 node = head while node: #ä¸€æ¬¡éå†å¾—åˆ°é•¿åº¦ L += 1 node = node.next quotient, remainder = L // k, L % k parts = [None for _ in range(k)] #create lists of size n and initialize with None i, curr = 0, head while i &lt; k and curr: parts[i] = curr if i&lt;remainder: part_size = quotient + 1 else: part_size = quotient for _ in range(part_size - 1): #for _ in range:When you are not interested in some values returned by a function we use underscore in place of variable name . Basically it means you are not interested in how many times the loop is run till now just that it should run some specific number of times overall. curr = curr.next next = curr.next curr.next = None curr = next i += 1 return parts"},{"title":"234. Palindrome Linked List (Easy)","path":"2022/08/04/234/","text":"234. Palindrome Linked List (Easy)Given the head of a singly linked list, return true if it is a palindrome.è¿™é“é¢˜çš„å…³é”®åœ¨äºå¦‚ä½•æ§åˆ¶ç©ºé—´å¤æ‚åº¦ã€‚ å®˜æ–¹é¢˜è§£O(n):ç®€å•æ¥è¯´å°±æ˜¯æŠŠé“¾è¡¨çš„æ•°å€¼å…¨éƒ½å­˜åˆ°æ•°ç»„é‡Œï¼Œç„¶åå†è¿›è¡Œåˆ¤æ–­ 123456789class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: vals = [] current_node = head while current_node is not None: vals.append(current_node.val) current_node = current_node.next return vals == vals[::-1] O(1):é¿å…ä½¿ç”¨ O(n)é¢å¤–ç©ºé—´çš„æ–¹æ³•å°±æ˜¯æ”¹å˜è¾“å…¥ã€‚ æˆ‘ä»¬å¯ä»¥å°†é“¾è¡¨çš„ååŠéƒ¨åˆ†åè½¬ï¼ˆä¿®æ”¹é“¾è¡¨ç»“æ„ï¼‰ï¼Œç„¶åå°†å‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†è¿›è¡Œæ¯”è¾ƒã€‚æ¯”è¾ƒå®Œæˆåæˆ‘ä»¬åº”è¯¥å°†é“¾è¡¨æ¢å¤åŸæ ·ã€‚è™½ç„¶ä¸éœ€è¦æ¢å¤ä¹Ÿèƒ½é€šè¿‡æµ‹è¯•ç”¨ä¾‹ï¼Œä½†æ˜¯ä½¿ç”¨è¯¥å‡½æ•°çš„äººé€šå¸¸ä¸å¸Œæœ›é“¾è¡¨ç»“æ„è¢«æ›´æ”¹ã€‚ è¯¥æ–¹æ³•è™½ç„¶å¯ä»¥å°†ç©ºé—´å¤æ‚åº¦é™åˆ° O(1)ï¼Œä½†æ˜¯åœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œè¯¥æ–¹æ³•ä¹Ÿæœ‰ç¼ºç‚¹ã€‚åœ¨å¹¶å‘ç¯å¢ƒä¸‹ï¼Œå‡½æ•°è¿è¡Œæ—¶éœ€è¦é”å®šå…¶ä»–çº¿ç¨‹æˆ–è¿›ç¨‹å¯¹é“¾è¡¨çš„è®¿é—®ï¼Œå› ä¸ºåœ¨å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­é“¾è¡¨ä¼šè¢«ä¿®æ”¹ã€‚ ç®—æ³• æ•´ä¸ªæµç¨‹å¯ä»¥åˆ†ä¸ºä»¥ä¸‹äº”ä¸ªæ­¥éª¤ï¼š æ‰¾åˆ°å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹ã€‚ åè½¬ååŠéƒ¨åˆ†é“¾è¡¨ã€‚ åˆ¤æ–­æ˜¯å¦å›æ–‡ã€‚ æ¢å¤é“¾è¡¨ã€‚ è¿”å›ç»“æœã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head is None: return True # æ‰¾åˆ°å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹å¹¶åè½¬ååŠéƒ¨åˆ†é“¾è¡¨ first_half_end = self.end_of_first_half(head) second_half_start = self.reverse_list(first_half_end.next) # åˆ¤æ–­æ˜¯å¦å›æ–‡ result = True first_position = head second_position = second_half_start while result and second_position is not None: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # è¿˜åŸé“¾è¡¨å¹¶è¿”å›ç»“æœ first_half_end.next = self.reverse_list(second_half_start) return result def end_of_first_half(self, head): fast = head slow = head while fast.next is not None and fast.next.next is not None: fast = fast.next.next slow = slow.next return slow def reverse_list(self, head): previous = None current = head while current is not None: next_node = current.next current.next = previous previous = current current = next_node return previous å›æ–‡é“¾è¡¨è¿™é‡Œè¿ç”¨åˆ°ä¸€ä¸ªéå¸¸æœ‰è¶£çš„æ–¹æ³•ï¼Œå€ŸåŠ©äºŒå‰æ ‘ååºéå†çš„æ€è·¯ï¼Œä¸éœ€è¦æ˜¾å¼åè½¬åŸå§‹é“¾è¡¨ä¹Ÿå¯ä»¥å€’åºéå†é“¾è¡¨ å®é™…ä¸Šå°±æ˜¯æŠŠé“¾è¡¨èŠ‚ç‚¹æ”¾å…¥ä¸€ä¸ªæ ˆï¼Œç„¶åå†æ‹¿å‡ºæ¥ï¼Œè¿™æ—¶å€™å…ƒç´ é¡ºåºå°±æ˜¯åçš„ï¼Œåªä¸è¿‡æˆ‘ä»¬åˆ©ç”¨çš„æ˜¯é€’å½’å‡½æ•°çš„å †æ ˆè€Œå·² é¦–å…ˆï¼Œå¯»æ‰¾å›æ–‡ä¸²æ˜¯ä»ä¸­é—´å‘ä¸¤ç«¯æ‰©å±•ï¼Œåˆ¤æ–­å›æ–‡ä¸²æ˜¯ä»ä¸¤ç«¯å‘ä¸­é—´æ”¶ç¼©ã€‚å¯¹äºå•é“¾è¡¨ï¼Œæ— æ³•ç›´æ¥å€’åºéå†ï¼Œå¯ä»¥é€ ä¸€æ¡æ–°çš„åè½¬é“¾è¡¨ï¼Œå¯ä»¥åˆ©ç”¨é“¾è¡¨çš„ååºéå†ï¼Œä¹Ÿå¯ä»¥ç”¨æ ˆç»“æ„å€’åºå¤„ç†å•é“¾è¡¨ã€‚ å…·ä½“åˆ°å›æ–‡é“¾è¡¨çš„åˆ¤æ–­é—®é¢˜ï¼Œç”±äºå›æ–‡çš„ç‰¹æ®Šæ€§ï¼Œå¯ä»¥ä¸å®Œå…¨åè½¬é“¾è¡¨ï¼Œè€Œæ˜¯ä»…ä»…åè½¬éƒ¨åˆ†é“¾è¡¨ï¼Œå°†ç©ºé—´å¤æ‚åº¦é™åˆ° O(1)ã€‚ ä¼˜åŒ–1. å…ˆé€šè¿‡ åŒæŒ‡é’ˆæŠ€å·§ ä¸­çš„å¿«æ…¢æŒ‡é’ˆæ¥æ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹ï¼š1234567ListNode slow, fast;slow = fast = head;while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next;&#125;// slow æŒ‡é’ˆç°åœ¨æŒ‡å‘é“¾è¡¨ä¸­ç‚¹ 2. å¦‚æœfastæŒ‡é’ˆæ²¡æœ‰æŒ‡å‘nullï¼Œè¯´æ˜é“¾è¡¨é•¿åº¦ä¸ºå¥‡æ•°ï¼Œslowè¿˜è¦å†å‰è¿›ä¸€æ­¥ï¼š12if (fast != null) slow = slow.next; 3. ä»slowå¼€å§‹åè½¬åé¢çš„é“¾è¡¨ï¼Œç°åœ¨å°±å¯ä»¥å¼€å§‹æ¯”è¾ƒå›æ–‡ä¸²äº†ï¼š12345678910ListNode left = head;ListNode right = reverse(slow);while (right != null) &#123; if (left.val != right.val) return false; left = left.next; right = right.next;&#125;return true; 4. æ€»ä»£ç java åŸç‰ˆ 123456789101112131415161718192021222324252627282930313233boolean isPalindrome(ListNode head) &#123; ListNode slow, fast; slow = fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; if (fast != null) slow = slow.next; ListNode left = head; ListNode right = reverse(slow); while (right != null) &#123; if (left.val != right.val) return false; left = left.next; right = right.next; &#125; return true;&#125;ListNode reverse(ListNode head) &#123; ListNode pre = null, cur = head; while (cur != null) &#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre;&#125; python æ”¹ç‰ˆ 12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def isPalindrome(self, head: Optional[ListNode]) -&gt; bool: def reverse(head): pre = None current = head while current: nxt = current.next current.next = pre pre = current current = nxt return pre slow =head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if fast: slow = slow.next left = head right = reverse(slow) while right: if left.val!=right.val: return False left= left.next right = right.next return True"},{"title":"445. Add Two Numbers II (Medium)","path":"2022/08/04/445/","text":"445. Add Two Numbers II (Medium)You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example: 12Input: l1 = [7,2,4,3], l2 = [5,6,4]Output: [7,8,0,7] è¿™ä¸ªä¾‹å­æƒ³è®²çš„å…¶å®å°±æ˜¯7243+564=7807 å®˜æ–¹é¢˜è§£æœ¬é¢˜çš„ä¸»è¦éš¾ç‚¹åœ¨äºé“¾è¡¨ä¸­æ•°ä½çš„é¡ºåºä¸æˆ‘ä»¬åšåŠ æ³•çš„é¡ºåºæ˜¯ç›¸åçš„ï¼Œä¸ºäº†é€†åºå¤„ç†æ‰€æœ‰æ•°ä½ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ˆï¼šæŠŠæ‰€æœ‰æ•°å­—å‹å…¥æ ˆä¸­ï¼Œå†ä¾æ¬¡å–å‡ºç›¸åŠ ã€‚è®¡ç®—è¿‡ç¨‹ä¸­éœ€è¦æ³¨æ„è¿›ä½çš„æƒ…å†µã€‚ å¯¹äºé€†åºå¤„ç†åº”è¯¥é¦–å…ˆæƒ³åˆ°æ ˆä»£ç  123456789101112131415161718192021class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: s1, s2 = [], [] while l1: s1.append(l1.val) l1 = l1.next while l2: s2.append(l2.val) l2 = l2.next ans = None carry = 0 while s1 or s2 or carry != 0: a = 0 if not s1 else s1.pop() b = 0 if not s2 else s2.pop() cur = a + b + carry carry = cur // 10 cur %= 10 curnode = ListNode(cur) curnode.next = ans ans = curnode return ans"},{"title":"24. Swap Nodes in Pairs (Medium)","path":"2022/08/04/24/","text":"24. Swap Nodes in Pairs (Medium)Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the listâ€™s nodes (i.e., only nodes themselves may be changed.)å®˜æ–¹é¢˜è§£12345678class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head newHead = head.next head.next = self.swapPairs(newHead.next) newHead.next = head return newHead"},{"title":"19. Remove Nth Node From End of List (medium)","path":"2022/08/01/19/","text":"19. Remove Nth Node From End of List (medium)Given the head of a linked list, remove the nth node from the end of the list and return its head.ç§»é™¤å€’åºçš„ç¬¬nä¸ªèŠ‚ç‚¹ ç¬¬ä¸€ååº”æ˜¯ä¸¤æ¬¡éå†ï¼Œç¬¬ä¸€æ¬¡éå†å…ˆåˆ¤æ–­é“¾è¡¨é•¿åº¦Lï¼Œç„¶åå†éå†ç¬¬äºŒæ¬¡ç®—å‡ºåº”è¯¥åˆ é™¤çš„Lâˆ’n+1èŠ‚ç‚¹ 1234567891011121314151617class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def getLength(head: ListNode) -&gt; int: length = 0 while head: length += 1 head = head.next return length # æ·»åŠ å“‘ç»“ç‚¹dummy dummy = ListNode(0, head) length = getLength(head) current = dummy for i in range(1, length - n + 1): current = current.next current.next = current.next.next return dummy.next æ–¹æ³•äºŒ åŒæŒ‡é’ˆè§£å†³é—®é¢˜æ€è·¯ï¼šæˆ‘ä»¬å¯ä»¥è®¾æƒ³å‡è®¾è®¾å®šäº†åŒæŒ‡é’ˆ p å’Œ q çš„è¯ï¼Œå½“ q æŒ‡å‘æœ«å°¾çš„ NULLï¼Œp ä¸ q ä¹‹é—´ç›¸éš”çš„å…ƒç´ ä¸ªæ•°ä¸º n æ—¶ï¼Œé‚£ä¹ˆåˆ é™¤æ‰ p çš„ä¸‹ä¸€ä¸ªæŒ‡é’ˆå°±å®Œæˆäº†è¦æ±‚ã€‚ è®¾ç½®è™šæ‹ŸèŠ‚ç‚¹ dummyHead æŒ‡å‘ head è®¾å®šåŒæŒ‡é’ˆ p å’Œ qï¼Œåˆå§‹éƒ½æŒ‡å‘è™šæ‹ŸèŠ‚ç‚¹ dummyHead ç§»åŠ¨ qï¼Œç›´åˆ° p ä¸ q ä¹‹é—´ç›¸éš”çš„å…ƒç´ ä¸ªæ•°ä¸º n åŒæ—¶ç§»åŠ¨ p ä¸ qï¼Œç›´åˆ° q æŒ‡å‘çš„ä¸º NULL å°† p çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘ä¸‹ä¸‹ä¸ªèŠ‚ç‚¹ ä»£ç ï¼š123456789101112131415class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dummy = ListNode(0, head) first = head second = dummy for i in range(n): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next æ·»åŠ å“‘èŠ‚ç‚¹ï¼šæ·»åŠ ä¸€ä¸ªå“‘èŠ‚ç‚¹ï¼ˆdummy nodeï¼‰ï¼Œè®©å®ƒçš„next æŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚è¿™æ ·ä¸€æ¥ï¼Œå¤´èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹å°±æ˜¯å“‘èŠ‚ç‚¹æœ¬èº«ã€‚ 1dummy = ListNode(0,head) 1234567891011121314151617class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def findNth(head,n): p1=head for i in range(n): p1 = p1.next p2 = head while p1: p2 = p2.next p1= p1.next return p2 dummy = ListNode(-1) dummy.next = head x = findNth(dummy,n+1) x.next = x.next.next return dummy.next"},{"title":"83. Remove Duplicates from Sorted List (Easy)","path":"2022/08/01/83/","text":"83. Remove Duplicates from Sorted List (Easy)Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.åˆ é™¤é‡å¤èŠ‚ç‚¹å› ä¸ºæ˜¯æœ‰åºèŠ‚ç‚¹ï¼Œç»è¿‡ä¸€ééå†ï¼ŒæŠŠé‡å¤çš„åˆ é™¤å°±å¯ä»¥äº† 123456789101112class Solution: def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if not head: return head current = head while current.next: if current.val== current.next.val: current.next = current.next.next else: current = current.next return head"},{"title":"206. Reverse Linked List(easy)","path":"2022/07/20/206/","text":"206. Reverse Linked List(easy)Given the head of a singly linked list, reverse the list, and return the reversed list. åè½¬æ•°ç»„ï¼Œè¿˜æ˜¯ç”¨åŒæŒ‡é’ˆï¼Œå¦å¤–è®¾ç½®äº†ä¸€ä¸ªä¸´æ—¶å˜é‡tmpè®°å½•currentçš„ä¸‹ä¸€ä¸ªå€¼å›¾ä¾‹å¯ä»¥çœ‹è¿™ä¸ªå›ç­” 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: pre = None current = head while current !=None: tmp = current.next current.next = pre pre = current current = tmp return pre"},{"title":"160. Intersection of Two Linked Lists (Easy)","path":"2022/07/20/160/","text":"160. Intersection of Two Linked Lists (Easy)Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure.Note that the linked lists must retain their original structure after the function returns.Custom Judge:The inputs to the judge are given as follows (your program is not given these inputs):intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.è§£æ³•ï¼šè¿™é“é¢˜å¯ä»¥é€šè¿‡åŒæŒ‡é’ˆçš„æ–¹æ³•è§£å†³ï¼Œä¸€å¼€å§‹æƒ³çš„æ˜¯é€šè¿‡ä¸¤ä¸ªé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†ä»åå¾€å‰ï¼Œä½†æ˜¯è¯¥é¢˜é¢˜è§£é‡Œæœ‰ä¸ªæ€è·¯å¾ˆå¥½ï¼š160. ç›¸äº¤é“¾è¡¨ï¼ˆåŒæŒ‡é’ˆï¼Œæ¸…æ™°å›¾è§£ï¼‰ ListA å¤´èŠ‚ç‚¹ headA åˆ° å…¬å…±node å‰ï¼Œå…±æœ‰ a - c ä¸ªèŠ‚ç‚¹ï¼›ListB å¤´èŠ‚ç‚¹ headB åˆ° å…¬å…±node å‰ï¼Œå…±æœ‰ b - c ä¸ªèŠ‚ç‚¹ï¼› è€ƒè™‘æ„å»ºä¸¤ä¸ªèŠ‚ç‚¹æŒ‡é’ˆ Aâ€‹ , B åˆ†åˆ«æŒ‡å‘ä¸¤é“¾è¡¨å¤´èŠ‚ç‚¹ headA , headB ï¼Œåšå¦‚ä¸‹æ“ä½œï¼š æŒ‡é’ˆ A å…ˆéå†å®Œé“¾è¡¨ headA ï¼Œå†å¼€å§‹éå†é“¾è¡¨ headB ï¼Œå½“èµ°åˆ° å…¬å…±node æ—¶ï¼Œå…±èµ°æ­¥æ•°ä¸ºï¼ša + (b - c) = a + b - c æŒ‡é’ˆ B å…ˆéå†å®Œé“¾è¡¨ headB ï¼Œå†å¼€å§‹éå†é“¾è¡¨ headA ï¼Œå½“èµ°åˆ° å…¬å…±node æ—¶ï¼Œå…±èµ°æ­¥æ•°ä¸ºï¼šb + (a - c) = a + b - c æ‰€ä»¥è¿™å°±æœ‰å¯ä»¥æ“ä½œçš„åœ°æ–¹äº† å¦‚ä¸‹å¼æ‰€ç¤ºï¼Œæ­¤æ—¶æŒ‡é’ˆ A , B é‡åˆï¼Œå¹¶æœ‰ä¸¤ç§æƒ…å†µï¼š a + (b - c) = b + (a - c) è‹¥ä¸¤é“¾è¡¨ æœ‰ å…¬å…±å°¾éƒ¨ (å³ c &gt; 0 ) ï¼šæŒ‡é’ˆ A , B åŒæ—¶æŒ‡å‘ã€Œç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€node ã€‚è‹¥ä¸¤é“¾è¡¨ æ—  å…¬å…±å°¾éƒ¨ (å³ c = 0 ) ï¼šæŒ‡é’ˆ A , B åŒæ—¶æŒ‡å‘ null ã€‚ å…¶å®å°±æ˜¯ä¸¤è¾¹äº’ç›¸æ¢å®¶èµ°ä¸€éï¼Œç›¸å½“äºä»ä¸€å¼€å§‹çš„å¤´ç»“ç‚¹å¼€å§‹ï¼ŒæŒ‡é’ˆA,Béƒ½èµ°ä¸€élist Aå’Œlist B 12345678class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A, B = headA, headB while A != B: A = A.next if A else headB B = B.next if B else headA return A è¿™è¡Œä»£ç  1A = A.next if A else headB å…¶å®æ²¡çœ‹æ‡‚å®ç°é€»è¾‘ï¼ˆåŸºç¡€ä¸ç‰¢å›ºï¼‰ï¼Œåæ¥æœäº†ä¸€ä¸‹æ˜¯pythonçš„ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼ 123456789It&#x27;s a conditional expression:A if PREDICATE else BA is yielded if PREDICATE is true, otherwise B is yielded.&gt;&gt;&gt; &#x27;A&#x27; if 1 &lt; 2 else &#x27;B&#x27;&#x27;A&#x27;&gt;&gt;&gt; &#x27;A&#x27; if 1 &gt; 2 else &#x27;B&#x27;&#x27;B&#x27; æ¢æˆå®Œæ•´ç‰ˆå°±æ˜¯ 123if 1 &lt; 2: &#x27;A&#x27;else: &#x27;B&#x27; æ‰€ä»¥é¢˜è§£é‡Œçš„å†™æ³•å…¶å®å¯ä»¥å†™æˆ 12345678910111213class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]: a,b= headA,headB while a!=b: if a: a =a.next else: a= headB if b: b =b.next else: b = headA return a"},{"title":"LeetCode12-Tree","path":"2022/07/20/LeetCode12-Tree/","text":"å‚è€ƒï¼š Leetcode é¢˜è§£ - é“¾è¡¨leetcode tagå¦‚æœè¯´æ•°æ®ç»“æ„æ˜¯ç®—æ³•çš„åŸºç¡€ï¼Œé‚£ä¹ˆæ•°ç»„å’Œé“¾è¡¨å°±æ˜¯æ•°æ®ç»“æ„çš„åŸºç¡€ã€‚å› ä¸ºåƒå †ï¼Œæ ˆï¼Œæ ‘ï¼Œå›¾ç­‰æ¯”è¾ƒå¤æ‚çš„æ•°ç»„ç»“åŸºæœ¬ä¸Šéƒ½å¯ä»¥ç”±æ•°ç»„å’Œé“¾è¡¨æ¥è¡¨ç¤ºï¼Œæ‰€ä»¥æŒæ¡æ•°ç»„å’Œé“¾è¡¨çš„åŸºæœ¬æ“ä½œååˆ†é‡è¦ã€‚ ä¸€æ£µæ ‘è¦ä¹ˆæ˜¯ç©ºæ ‘ï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ¯ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€æ£µæ ‘ã€‚æ ‘æ˜¯ä¸€ç§é€’å½’ç»“æ„ï¼Œå¾ˆå¤šæ ‘çš„é—®é¢˜å¯ä»¥ä½¿ç”¨é€’å½’æ¥å¤„ç†ã€‚"},{"title":"2. Add Two Numbers(medium)","path":"2022/07/15/2/","text":"2. Add Two Numbers(medium)You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.123Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807. 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: pre = ListNode(-1) current = pre carry = 0 while l1!=None or l2!= None or carry!=0: l1val= l1.val if l1 else 0 l2val= l2.val if l2 else 0 columnSum = l1val+l2val+carry carry = columnSum //10 newNode = ListNode(columnSum%10) current.next = newNode current = newNode l1 = l1.next if l1 else None l2 = l2.next if l2 else None return pre.next"},{"title":"LeetCode11-Linked list","path":"2022/07/15/LeetCode11-Linked list/","text":"é“¾è¡¨æ˜¯ç©ºèŠ‚ç‚¹ï¼Œæˆ–è€…æœ‰ä¸€ä¸ªå€¼å’Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªé“¾è¡¨çš„æŒ‡é’ˆï¼Œå› æ­¤å¾ˆå¤šé“¾è¡¨é—®é¢˜å¯ä»¥ç”¨é€’å½’æ¥å¤„ç†ã€‚ å‚è€ƒï¼š Leetcode é¢˜è§£ - é“¾è¡¨leetcode tagå¦‚æœè¯´æ•°æ®ç»“æ„æ˜¯ç®—æ³•çš„åŸºç¡€ï¼Œé‚£ä¹ˆæ•°ç»„å’Œé“¾è¡¨å°±æ˜¯æ•°æ®ç»“æ„çš„åŸºç¡€ã€‚å› ä¸ºåƒå †ï¼Œæ ˆï¼Œæ ‘ï¼Œå›¾ç­‰æ¯”è¾ƒå¤æ‚çš„æ•°ç»„ç»“åŸºæœ¬ä¸Šéƒ½å¯ä»¥ç”±æ•°ç»„å’Œé“¾è¡¨æ¥è¡¨ç¤ºï¼Œæ‰€ä»¥æŒæ¡æ•°ç»„å’Œé“¾è¡¨çš„åŸºæœ¬æ“ä½œååˆ†é‡è¦ã€‚ Labuladongæœ¬æ–‡å°±æ€»ç»“ä¸€ä¸‹å•é“¾è¡¨çš„åŸºæœ¬æŠ€å·§ï¼Œæ¯ä¸ªæŠ€å·§éƒ½å¯¹åº”ç€è‡³å°‘ä¸€é“ç®—æ³•é¢˜ï¼š 1ã€åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ 2ã€é“¾è¡¨çš„åˆ†è§£ 3ã€åˆå¹¶ k ä¸ªæœ‰åºé“¾è¡¨ 4ã€å¯»æ‰¾å•é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ 5ã€å¯»æ‰¾å•é“¾è¡¨çš„ä¸­ç‚¹ 6ã€åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦åŒ…å«ç¯å¹¶æ‰¾å‡ºç¯èµ·ç‚¹ 7ã€åˆ¤æ–­ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦ç›¸äº¤å¹¶æ‰¾å‡ºäº¤ç‚¹ è¿™äº›è§£æ³•éƒ½ç”¨åˆ°äº†åŒæŒ‡é’ˆæŠ€å·§ï¼Œæ‰€ä»¥è¯´å¯¹äºå•é“¾è¡¨ç›¸å…³çš„é¢˜ç›®ï¼ŒåŒæŒ‡é’ˆçš„è¿ç”¨æ˜¯éå¸¸å¹¿æ³›çš„ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥ä¸€ä¸ªä¸€ä¸ªçœ‹ã€‚ å­¦ä¹ å¦‚ä½•æ·»åŠ dummy node 1234pre = ListNode(-1)pre.next = headcurrent = pre Linked List Cycle Linked List Cycle II(medium) Intersection of Two Linked Lists (Easy) Remove Nth Node From End of List 1234567891011121314151617class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def findNth(head,n): p1=head for i in range(n): p1 = p1.next p2 = head while p1: p2 = p2.next p1= p1.next return p2 dummy = ListNode(-1) dummy.next = head x = findNth(dummy,n+1) x.next = x.next.next return dummy.next Merge Two Sorted Lists(easy) 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: current = pre =ListNode() while list1 and list2: if list1.val&lt;list2.val: current.next = list1 list1, current = list1.next, list1 #list1 = list1.next #current = list1 else: current.next = list2 list2, current = list2.next, list2 #list2=list2.next #current = list2 if list1 or list2: current.next=list1 if list1 else list2 return pre.next``` 23. Merge k Sorted Lists(hard)```python# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]: temp = [] for i in range(len(lists)): while lists[i]: temp.append(lists[i].val) lists[i] = lists[i].next temp.sort() head = current = ListNode() for i in range(len(temp)): Node = ListNode(temp[i]) current.next = Node current = current.next return head.next Partition List(medium) 1 Middle of the Linked List(easy) Palindrome Linked Listå›æ–‡é“¾è¡¨è¿™é‡Œè¿ç”¨åˆ°ä¸€ä¸ªéå¸¸æœ‰è¶£çš„æ–¹æ³•ï¼Œå€ŸåŠ©äºŒå‰æ ‘ååºéå†çš„æ€è·¯ï¼Œä¸éœ€è¦æ˜¾å¼åè½¬åŸå§‹é“¾è¡¨ä¹Ÿå¯ä»¥å€’åºéå†é“¾è¡¨"},{"title":"LeetCode10-Backtracking","path":"2022/07/14/LeetCode10-Backtracking/","text":"å›æº¯é¢˜ç›®æ€»ç»“ï¼šBacktracking Python problems+ solutions- interview prepleetcode tag"},{"title":"17. Letter Combinations of a Phone Number(medium)","path":"2022/07/14/17/","text":"17. Letter Combinations of a Phone Number(medium)Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.123456789phone = &#123;&#x27;2&#x27;:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;], &#x27;3&#x27;:[&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;], &#x27;4&#x27;:[&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;], &#x27;5&#x27;:[&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;], &#x27;6&#x27;:[&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;], &#x27;7&#x27;:[&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;], &#x27;8&#x27;:[&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;], &#x27;9&#x27;:[&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]&#125; ç‰¹ç‚¹è¿™é¢˜å±äºæ˜¯hashmapè®°å½•æ•°å­—å’Œå­—æ¯çš„å¯¹åº”å…³ç³»ï¼Œç„¶åå†ç”¨å›æº¯çš„æ–¹æ³•è§£å†³ leetcodeé¢˜è§£è§£æ³•ï¼š1234567891011121314151617181920212223242526class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if not digits: return [] phone = &#123;&#x27;2&#x27;:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;], &#x27;3&#x27;:[&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;], &#x27;4&#x27;:[&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;], &#x27;5&#x27;:[&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;], &#x27;6&#x27;:[&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;], &#x27;7&#x27;:[&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;], &#x27;8&#x27;:[&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;], &#x27;9&#x27;:[&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]&#125; def backtrack(conbination,nextdigit): if len(nextdigit) == 0: res.append(conbination) else: for letter in phone[nextdigit[0]]: backtrack(conbination + letter,nextdigit[1:]) res = [] backtrack(&#x27;&#x27;,digits) return res"},{"title":"12. Integer to Roman(medium)","path":"2022/07/13/12/","text":"12. Integer to Roman(medium)Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, 2 is written as II in Roman numeral, just two oneâ€™s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:1234I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. ç‰¹ç‚¹è¿™é¢˜å’Œæ¥ä¸‹æ¥çš„13é¢˜æ˜¯å®Œå…¨ç›¸åçš„æ€è·¯ï¼Œæœ¬é¢˜ï¼ˆ12é¢˜ï¼‰æ˜¯æ•´æ•°è½¬ç½—é©¬æ•°å­—ï¼Œ13é¢˜æ˜¯ç½—é©¬æ•°å­—è½¬æ•´æ•° 12345Example 1:Input: num = 3Output: &quot;III&quot;Explanation: 3 is represented as 3 ones. 12345Example 2:Input: num = 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. 12345Example 3:Input: num = 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. ç½—é©¬æ•°å­—ç”± 77 ä¸ªä¸åŒçš„å•å­—æ¯ç¬¦å·ç»„æˆï¼Œæ¯ä¸ªç¬¦å·å¯¹åº”ä¸€ä¸ªå…·ä½“çš„æ•°å€¼ã€‚æ­¤å¤–ï¼Œå‡æ³•è§„åˆ™ï¼ˆå¦‚é—®é¢˜æè¿°ä¸­æ‰€è¿°ï¼‰ç»™å‡ºäº†é¢å¤–çš„ 66 ä¸ªå¤åˆç¬¦å·ã€‚è¿™ç»™äº†æˆ‘ä»¬æ€»å…± 1313 ä¸ªç‹¬ç‰¹çš„ç¬¦å·ï¼ˆæ¯ä¸ªç¬¦å·ç”± 11 ä¸ªæˆ– 22 ä¸ªå­—æ¯ç»„æˆï¼‰ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ å®˜æ–¹é¢˜è§£ ç½—é©¬æ•°å­—çš„è§„åˆ™æ˜¯ï¼šå¯¹äºç½—é©¬æ•°å­—ä»å·¦åˆ°å³çš„æ¯ä¸€ä½ï¼Œé€‰æ‹©å°½å¯èƒ½å¤§çš„ç¬¦å·å€¼ã€‚ è§£æ³•ï¼šæ ¹æ®ç½—é©¬æ•°å­—çš„å”¯ä¸€è¡¨ç¤ºæ³•ï¼Œä¸ºäº†è¡¨ç¤ºä¸€ä¸ªç»™å®šçš„æ•´æ•° numï¼Œæˆ‘ä»¬å¯»æ‰¾ä¸è¶…è¿‡ num çš„æœ€å¤§ç¬¦å·å€¼ï¼Œå°† num å‡å»è¯¥ç¬¦å·å€¼ï¼Œç„¶åç»§ç»­å¯»æ‰¾ä¸è¶…è¿‡ num çš„æœ€å¤§ç¬¦å·å€¼ï¼Œå°†è¯¥ç¬¦å·æ‹¼æ¥åœ¨ä¸Šä¸€ä¸ªæ‰¾åˆ°çš„ç¬¦å·ä¹‹åï¼Œå¾ªç¯ç›´è‡³ num ä¸º 0ã€‚æœ€åå¾—åˆ°çš„å­—ç¬¦ä¸²å³ä¸º num çš„ç½—é©¬æ•°å­—è¡¨ç¤ºã€‚ ç¼–ç¨‹æ—¶ï¼Œå¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°å€¼-ç¬¦å·å¯¹çš„åˆ—è¡¨ valueSymbolsï¼ŒæŒ‰æ•°å€¼ä»å¤§åˆ°å°æ’åˆ—ã€‚éå† valueSymbols ä¸­çš„æ¯ä¸ªæ•°å€¼-ç¬¦å·å¯¹ï¼Œè‹¥å½“å‰æ•°å€¼ value ä¸è¶…è¿‡ numï¼Œåˆ™ä» num ä¸­ä¸æ–­å‡å» valueï¼Œç›´è‡³ num å°äº valueï¼Œç„¶åéå†ä¸‹ä¸€ä¸ªæ•°å€¼-ç¬¦å·å¯¹ã€‚è‹¥éå†ä¸­ num ä¸º 0 åˆ™è·³å‡ºå¾ªç¯ã€‚ 12345678910111213141516171819202122232425262728class Solution: VALUE_SYMBOLS = [ (1000, &quot;M&quot;), (900, &quot;CM&quot;), (500, &quot;D&quot;), (400, &quot;CD&quot;), (100, &quot;C&quot;), (90, &quot;XC&quot;), (50, &quot;L&quot;), (40, &quot;XL&quot;), (10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;), ] def intToRoman(self, num: int) -&gt; str: roman = list() for value, symbol in Solution.VALUE_SYMBOLS: while num &gt;= value: num -= value roman.append(symbol) if num == 0: break return &quot;&quot;.join(roman) 123456789101112class Solution: def intToRoman(self, num: int) -&gt; str: # ä½¿ç”¨å“ˆå¸Œè¡¨ï¼ŒæŒ‰ç…§ä»å¤§åˆ°å°é¡ºåºæ’åˆ— hashmap = &#123;1000:&#x27;M&#x27;, 900:&#x27;CM&#x27;, 500:&#x27;D&#x27;, 400:&#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50:&#x27;L&#x27;, 40:&#x27;XL&#x27;, 10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125; res = &#x27;&#x27; for key in hashmap: if num // key != 0: count = num // key # æ¯”å¦‚è¾“å…¥4000ï¼Œcount ä¸º 4 res += hashmap[key] * count num %= key return res"},{"title":"21. Merge Two Sorted Lists(easy)","path":"2022/07/04/21/","text":"21. Merge Two Sorted Lists(easy)You are given the heads of two sorted linked lists list1 and list2.Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.Return the head of the merged linked list.æˆ‘ä»¬åˆ¤æ–­ list1 å’Œ list2 å¤´ç»“ç‚¹å“ªä¸ªæ›´å°ï¼Œç„¶åè¾ƒå°ç»“ç‚¹çš„ next æŒ‡é’ˆæŒ‡å‘å…¶ä½™ç»“ç‚¹çš„åˆå¹¶ç»“æœã€‚ï¼ˆè°ƒç”¨é€’å½’ï¼‰ leetcodeé¢˜è§£é€’å½’çš„æ–¹æ³•ï¼š 1234567891011class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: if not list1: return list2 # ç»ˆæ­¢æ¡ä»¶ï¼Œç›´åˆ°ä¸¤ä¸ªé“¾è¡¨éƒ½ç©º if not list2: return list1 if list1.val &lt;= list2.val: # é€’å½’è°ƒç”¨ list1.next = self.mergeTwoLists(list1.next,list2) return list1 else: list2.next = self.mergeTwoLists(list1,list2.next) return list2 leetcodeé¢˜è§£è¿™ä¸ªæ›´å¥½ç†è§£ä¸€äº› 12345678910111213141516class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: cur = dummy = ListNode() while list1 and list2: if list1.val &lt; list2.val: cur.next = list1 list1, cur = list1.next, list1 else: cur.next = list2 list2, cur = list2.next, list2 if list1 or list2: cur.next = list1 if list1 else list2 return dummy.next"},{"title":"13. Roman to Integer(easy)","path":"2022/07/01/13/","text":"13. Roman to Integer(easy)Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 å®˜æ–¹é¢˜è§£ è¿™é¢˜çš„ç‰¹ç‚¹é€šå¸¸æƒ…å†µä¸‹ï¼Œç½—é©¬æ•°å­—ä¸­å°çš„æ•°å­—åœ¨å¤§çš„æ•°å­—çš„å³è¾¹ã€‚è‹¥è¾“å…¥çš„å­—ç¬¦ä¸²æ»¡è¶³è¯¥æƒ…å†µï¼Œé‚£ä¹ˆå¯ä»¥å°†æ¯ä¸ªå­—ç¬¦è§†ä½œä¸€ä¸ªå•ç‹¬çš„å€¼ï¼Œç´¯åŠ æ¯ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å€¼å³å¯ã€‚ ä¾‹å¦‚ XXVII å¯è§†ä½œ X+X+V+I+I=10+10+5+1+1=27ã€‚ è‹¥å­˜åœ¨å°çš„æ•°å­—åœ¨å¤§çš„æ•°å­—çš„å·¦è¾¹çš„æƒ…å†µï¼Œæ ¹æ®è§„åˆ™éœ€è¦å‡å»å°çš„æ•°å­—ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†æ¯ä¸ªå­—ç¬¦è§†ä½œä¸€ä¸ªå•ç‹¬çš„å€¼ï¼Œè‹¥ä¸€ä¸ªæ•°å­—å³ä¾§çš„æ•°å­—æ¯”å®ƒå¤§ï¼Œåˆ™å°†è¯¥æ•°å­—çš„ç¬¦å·å–åã€‚ ä¾‹å¦‚ XIV å¯è§†ä½œ Xâˆ’I+V=10âˆ’1+5=14ã€‚ ä½†æ˜¯è¯„è®ºé‡Œæœ‰è¶…ç¥æ€è·¯ï¼šä»å³åˆ°å·¦éå†ï¼Œè®°å½•å½“å‰é‡åˆ°çš„æœ€å¤§çš„æ•°å­—ï¼Œé‡åˆ°æ›´å¤§çš„å°±åŠ ï¼Œå¹¶ä¸”æ›´æ–°æœ€å¤§æ•°ï¼Œé‡åˆ°å°çš„å°±å‡ï¼Œæ›´å¥½ç†è§£å§ 12345678910111213141516class Solution: def romanToInt(self, s: str) -&gt; int: mapping = &#123; &#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000 &#125; highestLevel = 1 result = 0 for ch in s[::-1]: level = mapping[ch] if level &gt;= highestLevel: result += level highestLevel = level else: result -= level return result"},{"title":"9. Palindrome Number(easy)","path":"2022/07/01/9/","text":"9. Palindrome Number(easy)Given an integer x, return true if x is palindrome integer.An integer is a palindrome when it reads the same backward as forward.For example, 121 is a palindrome while 123 is not.æ‰¾åˆ°å›æ–‡æ•° å®˜æ–¹é¢˜è§£åè½¬ä¸€åŠæ•°å­—æ€è·¯ æ˜ å…¥è„‘æµ·çš„ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯å°†æ•°å­—è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡ã€‚ä½†æ˜¯ï¼Œè¿™éœ€è¦é¢å¤–çš„éå¸¸é‡ç©ºé—´æ¥åˆ›å»ºé—®é¢˜æè¿°ä¸­æ‰€ä¸å…è®¸çš„å­—ç¬¦ä¸²ã€‚ ç¬¬äºŒä¸ªæƒ³æ³•æ˜¯å°†æ•°å­—æœ¬èº«åè½¬ï¼Œç„¶åå°†åè½¬åçš„æ•°å­—ä¸åŸå§‹æ•°å­—è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå®ƒä»¬æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—å°±æ˜¯å›æ–‡ã€‚ä½†æ˜¯ï¼Œå¦‚æœåè½¬åçš„æ•°å­—å¤§äº int.MAXï¼Œæˆ‘ä»¬å°†é‡åˆ°æ•´æ•°æº¢å‡ºé—®é¢˜ã€‚ æŒ‰ç…§ç¬¬äºŒä¸ªæƒ³æ³•ï¼Œä¸ºäº†é¿å…æ•°å­—åè½¬å¯èƒ½å¯¼è‡´çš„æº¢å‡ºé—®é¢˜ï¼Œä¸ºä»€ä¹ˆä¸è€ƒè™‘åªåè½¬ int æ•°å­—çš„ä¸€åŠï¼Ÿæ¯•ç«Ÿï¼Œå¦‚æœè¯¥æ•°å­—æ˜¯å›æ–‡ï¼Œå…¶ååŠéƒ¨åˆ†åè½¬ååº”è¯¥ä¸åŸå§‹æ•°å­—çš„å‰åŠéƒ¨åˆ†ç›¸åŒã€‚ ä¾‹å¦‚ï¼Œè¾“å…¥ 1221ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ•°å­— â€œ1221â€ çš„ååŠéƒ¨åˆ†ä» â€œ21â€ åè½¬ä¸º â€œ12â€ï¼Œå¹¶å°†å…¶ä¸å‰åŠéƒ¨åˆ† â€œ12â€ è¿›è¡Œæ¯”è¾ƒï¼Œå› ä¸ºäºŒè€…ç›¸åŒï¼Œæˆ‘ä»¬å¾—çŸ¥æ•°å­— 1221 æ˜¯å›æ–‡ã€‚ ç®—æ³•é¦–å…ˆï¼Œæˆ‘ä»¬åº”è¯¥å¤„ç†ä¸€äº›ä¸´ç•Œæƒ…å†µã€‚æ‰€æœ‰è´Ÿæ•°éƒ½ä¸å¯èƒ½æ˜¯å›æ–‡ï¼Œä¾‹å¦‚ï¼š-123 ä¸æ˜¯å›æ–‡ï¼Œå› ä¸º - ä¸ç­‰äº 3ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹æ‰€æœ‰è´Ÿæ•°è¿”å› falseã€‚é™¤äº† 0 ä»¥å¤–ï¼Œæ‰€æœ‰ä¸ªä½æ˜¯ 0 çš„æ•°å­—ä¸å¯èƒ½æ˜¯å›æ–‡ï¼Œå› ä¸ºæœ€é«˜ä½ä¸ç­‰äº 0ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹æ‰€æœ‰å¤§äº 0 ä¸”ä¸ªä½æ˜¯ 0 çš„æ•°å­—è¿”å› falseã€‚ ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥è€ƒè™‘å¦‚ä½•åè½¬ååŠéƒ¨åˆ†çš„æ•°å­—ã€‚ å¯¹äºæ•°å­— 1221ï¼Œå¦‚æœæ‰§è¡Œ 1221 % 10ï¼Œæˆ‘ä»¬å°†å¾—åˆ°æœ€åä¸€ä½æ•°å­— 1ï¼Œè¦å¾—åˆ°å€’æ•°ç¬¬äºŒä½æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆé€šè¿‡é™¤ä»¥ 10 æŠŠæœ€åä¸€ä½æ•°å­—ä» 1221 ä¸­ç§»é™¤ï¼Œ1221 / 10 = 122ï¼Œå†æ±‚å‡ºä¸Šä¸€æ­¥ç»“æœé™¤ä»¥ 10 çš„ä½™æ•°ï¼Œ122 % 10 = 2ï¼Œå°±å¯ä»¥å¾—åˆ°å€’æ•°ç¬¬äºŒä½æ•°å­—ã€‚å¦‚æœæˆ‘ä»¬æŠŠæœ€åä¸€ä½æ•°å­—ä¹˜ä»¥ 10ï¼Œå†åŠ ä¸Šå€’æ•°ç¬¬äºŒä½æ•°å­—ï¼Œ1 * 10 + 2 = 12ï¼Œå°±å¾—åˆ°äº†æˆ‘ä»¬æƒ³è¦çš„åè½¬åçš„æ•°å­—ã€‚å¦‚æœç»§ç»­è¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬å°†å¾—åˆ°æ›´å¤šä½æ•°çš„åè½¬æ•°å­—ã€‚ ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•çŸ¥é“åè½¬æ•°å­—çš„ä½æ•°å·²ç»è¾¾åˆ°åŸå§‹æ•°å­—ä½æ•°çš„ä¸€åŠï¼Ÿ ç”±äºæ•´ä¸ªè¿‡ç¨‹æˆ‘ä»¬ä¸æ–­å°†åŸå§‹æ•°å­—é™¤ä»¥ 10ï¼Œç„¶åç»™åè½¬åçš„æ•°å­—ä¹˜ä¸Š 10ï¼Œæ‰€ä»¥ï¼Œå½“åŸå§‹æ•°å­—å°äºæˆ–ç­‰äºåè½¬åçš„æ•°å­—æ—¶ï¼Œå°±æ„å‘³ç€æˆ‘ä»¬å·²ç»å¤„ç†äº†ä¸€åŠä½æ•°çš„æ•°å­—äº†ã€‚ æ ¹æ®å®˜æ–¹é¢˜è§£æ”¹çš„pythonä»£ç  12345678910class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0 or (x % 10 == 0 and x != 0): return False revertedNumber = 0 while x &gt; revertedNumber: revertedNumber = revertedNumber * 10 + x % 10 x //= 10 return x == revertedNumber or x == revertedNumber // 10"},{"title":"15. 3Sum(medium)","path":"2022/07/01/15/","text":"15. 3Sum(medium)Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets.ä¸‰æ•°ä¹‹å’Œï¼Œç»å…¸é¢˜ç›® é¢˜è§£ç®—æ³•æµç¨‹ï¼š ç‰¹åˆ¤ï¼Œå¯¹äºæ•°ç»„é•¿åº¦ nï¼Œå¦‚æœæ•°ç»„ä¸º null æˆ–è€…æ•°ç»„é•¿åº¦å°äº 3ï¼Œè¿”å› []ã€‚ å¯¹æ•°ç»„è¿›è¡Œæ’åºã€‚ éå†æ’åºåæ•°ç»„ï¼ša. è‹¥ nums[i]&gt;0ï¼šå› ä¸ºå·²ç»æ’åºå¥½ï¼Œæ‰€ä»¥åé¢ä¸å¯èƒ½æœ‰ä¸‰ä¸ªæ•°åŠ å’Œç­‰äº 0ï¼Œç›´æ¥è¿”å›ç»“æœã€‚b. å¯¹äºé‡å¤å…ƒç´ ï¼šè·³è¿‡ï¼Œé¿å…å‡ºç°é‡å¤è§£c. ä»¤å·¦æŒ‡é’ˆ L=i+1ï¼Œå³æŒ‡é’ˆ R=n-1ï¼Œå½“ L&lt;R æ—¶ï¼Œæ‰§è¡Œå¾ªç¯ï¼šå½“ nums[i]+nums[L]+nums[R]==0ï¼Œæ‰§è¡Œå¾ªç¯ï¼Œåˆ¤æ–­å·¦ç•Œå’Œå³ç•Œæ˜¯å¦å’Œä¸‹ä¸€ä½ç½®é‡å¤ï¼Œå»é™¤é‡å¤è§£ã€‚å¹¶åŒæ—¶å°† L,R ç§»åˆ°ä¸‹ä¸€ä½ç½®ï¼Œå¯»æ‰¾æ–°çš„è§£è‹¥å’Œå¤§äº 0ï¼Œè¯´æ˜ nums[R] å¤ªå¤§ï¼ŒR å·¦ç§»è‹¥å’Œå°äº 0ï¼Œè¯´æ˜ nums[L] å¤ªå°ï¼ŒL å³ç§» 1234567891011121314151617181920212223242526272829class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if(not nums or n&lt;3): return [] nums.sort() res=[] for i in range(n): if(nums[i]&gt;0): return res if(i&gt;0 and nums[i]==nums[i-1]): continue L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while(L&lt;R and nums[R]==nums[R-1]): R=R-1 L=L+1 R=R-1 elif(nums[i]+nums[L]+nums[R]&gt;0): R=R-1 else: L=L+1 return res 123456789101112131415161718192021222324def threeSum(self, nums): nums.sort() result = [] for left in range(len(nums) - 2): # renamed this to left because this will always be the leftmost pointer in the triplet if left &gt; 0 and nums[left] == nums[left - 1]: # this step makes sure that we do not have any duplicates in our result output continue mid = left + 1 # renamed this to mid because this is the pointer that is between the left and right pointers right = len(nums) - 1 while mid &lt; right: curr_sum = nums[left] + nums[mid] + nums[right] if curr_sum &lt; 0: mid += 1 elif curr_sum &gt; 0: right -= 1 else: result.append([nums[left], nums[mid], nums[right]]) while mid &lt; right and nums[mid] == nums[mid + 1]: # Another conditional for not calculating duplicates mid += 1 while mid &lt; right and nums[right] == nums[right - 1]: # Avoiding duplicates check right -= 1 mid += 1 right -= 1 return result"},{"title":"11. Container With Most Water(medium)","path":"2022/07/01/11/","text":"11. Container With Most Water(medium)You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container.çœ‹äº†é¢˜è§£ï¼ŒåŒæŒ‡é’ˆï¼Œä»ä¸¤å¤´å¼€å§‹å†…å·ï¼Œå…ˆå·çŸ®çš„é‚£å¤´ 123456789101112131415class Solution: def maxArea(self, height: List[int]) -&gt; int: l = 0 r = len(height)-1 ans = 0 while l&lt;r: area = min(height[l],height[r])*(r-l) ans = max(ans,area) l= if height[l]&lt;height[r]: l+=1 else: r-=1 return ans 12345678910class Solution: def maxArea(self, height): L, R, width, res = 0, len(height) - 1, len(height) - 1, 0 for w in range(width, 0, -1): #range(start, stop, step) if height[L] &lt; height[R]: res, L = max(res, height[L] * w), L + 1 else: res, R = max(res, height[R] * w), R - 1 return res"},{"title":"3. Longest Substring Without Repeating Characters(medium)","path":"2022/07/01/3/","text":"3. Longest Substring Without Repeating Characters(medium)Given a string s, find the length of the longest substring without repeating characters.123Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. è¿™é“é¢˜ç¬¬ä¸€ååº”æ˜¯åŒæŒ‡é’ˆï¼Œé€šè¿‡æ»‘åŠ¨çª—å£æ¥è§£å†³ï¼Œä½†æœ‰ä¸ªéœ€è¦è§£å†³çš„é—®é¢˜æ˜¯å¦‚æœåˆ¤æ–­substringçš„å­—æ¯æœ‰é‡å¤çš„ã€‚ åˆ©ç”¨hashmapæŸ¥æ‰¾é‡å¤å­—æ¯leetcodeè¯„è®º 123456789101112class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: k, res, c_dict = -1, 0, &#123;&#125; for i, c in enumerate(s): if c in c_dict and c_dict[c] &gt; k: # å­—ç¬¦cåœ¨å­—å…¸ä¸­ ä¸” ä¸Šæ¬¡å‡ºç°çš„ä¸‹æ ‡å¤§äºå½“å‰é•¿åº¦çš„èµ·å§‹ä¸‹æ ‡ k = c_dict[c] c_dict[c] = i else: c_dict[c] = i res = max(res, i-k) return res åˆ©ç”¨é˜Ÿåˆ—æŸ¥æ‰¾å­—æ¯ 1234567891011class Solution(object): def lengthOfLongestSubstring(self, s): lst = [] n = len(s) ans = 0 for i in range(n): while s[i] in lst: del lst[0] # é˜Ÿé¦–å…ƒç´ å‡ºé˜Ÿ lst.append(s[i]) # æ’é™¤é‡å¤å…ƒç´ å æ–°å…ƒç´ å…¥é˜Ÿ ans = max(ans, len(lst)) return ans"},{"title":"LeetCode09-hashmap","path":"2022/06/28/LeetCode09-hashmap/","text":"å‚è€ƒï¼š Leetcode é¢˜è§£ - ç›®å½•.mdhashmap å®˜æ–¹hashmaptag 451. Sort Characters By Frequency (Medium)hashmapå¯¹valueæ’åºï¼š1.å»ºå“ˆå¸Œè¡¨ï¼Œå°†å­—ç¬¦ä¸²sä¸­çš„æ¯ä¸ªå­—ç¬¦è®¡æ•°2.æ ¹æ®å“ˆå¸Œè¡¨ä¸­çš„å€¼è¿›è¡Œé™åºæ’åºå³å¯(è¿™ä¸ªæ–¹æ³•å¾ˆé‡è¦)3.ç›´æ¥å­—ç¬¦ä¹˜ä»¥æ•°ç›® 123456789101112131415161718class Solution(object): def frequencySort(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; hashmap = &#123;&#125; for ans in s: if ans not in hashmap: hashmap[ans] = 1 else: hashmap[ans] += 1 result = sorted(hashmap.items(),key=lambda hashmap:hashmap[1],reverse=True) s = &#x27;&#x27; for i in range(len(result)): res = result[i][0] * result[i][1] s += res return s Integer to Roman(medium)123456789101112class Solution: def intToRoman(self, num: int) -&gt; str: # ä½¿ç”¨å“ˆå¸Œè¡¨ï¼ŒæŒ‰ç…§ä»å¤§åˆ°å°é¡ºåºæ’åˆ— hashmap = &#123;1000:&#x27;M&#x27;, 900:&#x27;CM&#x27;, 500:&#x27;D&#x27;, 400:&#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50:&#x27;L&#x27;, 40:&#x27;XL&#x27;, 10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125; res = &#x27;&#x27; for key in hashmap: if num // key != 0: count = num // key # æ¯”å¦‚è¾“å…¥4000ï¼Œcount ä¸º 4 res += hashmap[key] * count num %= key return res 123456789101112131415161718192021222324252627class Solution: VALUE_SYMBOLS = [ (1000, &quot;M&quot;), (900, &quot;CM&quot;), (500, &quot;D&quot;), (400, &quot;CD&quot;), (100, &quot;C&quot;), (90, &quot;XC&quot;), (50, &quot;L&quot;), (40, &quot;XL&quot;), (10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;), ] def intToRoman(self, num: int) -&gt; str: roman = list() for value, symbol in Solution.VALUE_SYMBOLS: while num &gt;= value: num -= value roman.append(symbol) if num == 0: break return &quot;&quot;.join(roman) Roman to Integer(easy)12345678910111213141516class Solution: def romanToInt(self, s: str) -&gt; int: mapping = &#123; &#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000 &#125; highestLevel = 1 result = 0 for ch in s[::-1]: level = mapping[ch] if level &gt;= highestLevel: result += level highestLevel = level else: result -= level return result ä»è¿™ä¸¤é¢˜æˆ‘ä»¬å¯ä»¥çœ‹å‡ºhashmapçš„åŸºç¡€å†™æ³•ï¼š 12345678910111213141516171819202122mapping = &#123; &#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000 &#125;VALUE_SYMBOLS = [ (1000, &quot;M&quot;), (900, &quot;CM&quot;), (500, &quot;D&quot;), (400, &quot;CD&quot;), (100, &quot;C&quot;), (90, &quot;XC&quot;), (50, &quot;L&quot;), (40, &quot;XL&quot;), (10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;), ]hashmap = &#123;1000:&#x27;M&#x27;, 900:&#x27;CM&#x27;, 500:&#x27;D&#x27;, 400:&#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50:&#x27;L&#x27;, 40:&#x27;XL&#x27;, 10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125; 1"},{"title":"LeetCode08-åŠ¨æ€è§„åˆ’","path":"2022/06/28/LeetCode08-åŠ¨æ€è§„åˆ’/","text":"å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - åŠ¨æ€è§„åˆ’ç´ æ•°åˆ†è§£æ¯ä¸€ä¸ªæ•°éƒ½å¯ä»¥åˆ†è§£æˆç´ æ•°çš„ä¹˜ç§¯ æ•´é™¤ä»¤ x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * â€¦ ä»¤ y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * â€¦ å¦‚æœ x æ•´é™¤ yï¼ˆy mod x == 0ï¼‰ï¼Œåˆ™å¯¹äºæ‰€æœ‰ iï¼Œmi &lt;= niã€‚ æœ€å¤§å…¬çº¦æ•°æœ€å°å…¬å€æ•°x å’Œ y çš„æœ€å¤§å…¬çº¦æ•°ä¸ºï¼šgcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * â€¦ x å’Œ y çš„æœ€å°å…¬å€æ•°ä¸ºï¼šlcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * â€¦ Fibonacci Number(easy) Climbing Stairs Min Cost Climbing Stairs(easy)"},{"title":"914. X of a Kind in a Deck of Cards","path":"2022/06/27/914/","text":"914. X of a Kind in a Deck of CardsIn a deck of cards, each card has an integer written on it.Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:Each group has exactly X cards.All the cards in each group have the same integer."},{"title":"204. Count Primes (Easy)","path":"2022/06/27/204/","text":"204. Count Primes (Easy)Given an integer n, return the number of prime numbers that are strictly less than n.å®˜æ–¹é¢˜è§£æ–¹æ³•ä¸€ï¼šæšä¸¾å¾ˆç›´è§‚çš„æ€è·¯æ˜¯æˆ‘ä»¬æšä¸¾æ¯ä¸ªæ•°åˆ¤æ–­å…¶æ˜¯ä¸æ˜¯è´¨æ•°ã€‚ è€ƒè™‘è´¨æ•°çš„å®šä¹‰ï¼šåœ¨å¤§äº 1 çš„è‡ªç„¶æ•°ä¸­ï¼Œé™¤äº† 1 å’Œå®ƒæœ¬èº«ä»¥å¤–ä¸å†æœ‰å…¶ä»–å› æ•°çš„è‡ªç„¶æ•°ã€‚å› æ­¤å¯¹äºæ¯ä¸ªæ•° xï¼Œæˆ‘ä»¬å¯ä»¥ä»å°åˆ°å¤§æšä¸¾ [2,xâˆ’1] ä¸­çš„æ¯ä¸ªæ•° yï¼Œåˆ¤æ–­ y æ˜¯å¦ä¸º x çš„å› æ•°ã€‚ä½†è¿™æ ·åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°çš„æ—¶é—´å¤æ‚åº¦æœ€å·®æƒ…å†µä¸‹ä¼šåˆ° O(n)ï¼Œæ— æ³•é€šè¿‡æ‰€æœ‰æµ‹è¯•æ•°æ®ã€‚ æ–¹æ³•äºŒï¼šåŸƒæ°ç­›æšä¸¾æ²¡æœ‰è€ƒè™‘åˆ°æ•°ä¸æ•°çš„å…³è”æ€§ï¼Œå› æ­¤éš¾ä»¥å†ç»§ç»­ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä»‹ç»ä¸€ä¸ªå¸¸è§çš„ç®—æ³•ï¼Œè¯¥ç®—æ³•ç”±å¸Œè…Šæ•°å­¦å®¶å„æ‹‰å¤šå¡ï¼ˆEratosthenesï¼‰æå‡ºï¼Œç§°ä¸ºå„æ‹‰å¤šå¡ç­›æ³•ï¼Œç®€ç§°åŸƒæ°ç­›ã€‚ æˆ‘ä»¬è€ƒè™‘è¿™æ ·ä¸€ä¸ªäº‹å®ï¼šå¦‚æœ x æ˜¯è´¨æ•°ï¼Œé‚£ä¹ˆå¤§äº x çš„ x çš„å€æ•° 2x,3x,â€¦ ä¸€å®šä¸æ˜¯è´¨æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä»è¿™é‡Œå…¥æ‰‹ã€‚ æˆ‘ä»¬è®¾ isPrime[i] è¡¨ç¤ºæ•° i æ˜¯ä¸æ˜¯è´¨æ•°ï¼Œå¦‚æœæ˜¯è´¨æ•°åˆ™ä¸º 1ï¼Œå¦åˆ™ä¸º 0ã€‚ä»å°åˆ°å¤§éå†æ¯ä¸ªæ•°ï¼Œå¦‚æœè¿™ä¸ªæ•°ä¸ºè´¨æ•°ï¼Œåˆ™å°†å…¶æ‰€æœ‰çš„å€æ•°éƒ½æ ‡è®°ä¸ºåˆæ•°ï¼ˆé™¤äº†è¯¥è´¨æ•°æœ¬èº«ï¼‰ï¼Œå³ 0ï¼Œè¿™æ ·åœ¨è¿è¡Œç»“æŸçš„æ—¶å€™æˆ‘ä»¬å³èƒ½çŸ¥é“è´¨æ•°çš„ä¸ªæ•°ã€‚ è¿™ç§æ–¹æ³•çš„æ­£ç¡®æ€§æ˜¯æ¯”è¾ƒæ˜¾ç„¶çš„ï¼šè¿™ç§æ–¹æ³•æ˜¾ç„¶ä¸ä¼šå°†è´¨æ•°æ ‡è®°æˆåˆæ•°ï¼›å¦ä¸€æ–¹é¢ï¼Œå½“ä»å°åˆ°å¤§éå†åˆ°æ•° x æ—¶ï¼Œå€˜è‹¥å®ƒæ˜¯åˆæ•°ï¼Œåˆ™å®ƒä¸€å®šæ˜¯æŸä¸ªå°äº x çš„è´¨æ•° yy çš„æ•´æ•°å€ï¼Œæ•…æ ¹æ®æ­¤æ–¹æ³•çš„æ­¥éª¤ï¼Œæˆ‘ä»¬åœ¨éå†åˆ° y æ—¶ï¼Œå°±ä¸€å®šä¼šåœ¨æ­¤æ—¶å°† xx æ ‡è®°ä¸º isPrime[x]=0ã€‚å› æ­¤ï¼Œè¿™ç§æ–¹æ³•ä¹Ÿä¸ä¼šå°†åˆæ•°æ ‡è®°ä¸ºè´¨æ•°ã€‚ å½“ç„¶è¿™é‡Œè¿˜å¯ä»¥ç»§ç»­ä¼˜åŒ–ï¼Œå¯¹äºä¸€ä¸ªè´¨æ•° xï¼Œå¦‚æœæŒ‰ä¸Šæ–‡è¯´çš„æˆ‘ä»¬ä» 2x å¼€å§‹æ ‡è®°å…¶å®æ˜¯å†—ä½™çš„ï¼Œåº”è¯¥ç›´æ¥ä» xâ‹…x å¼€å§‹æ ‡è®°ï¼Œå› ä¸º 2x,3x,â€¦ è¿™äº›æ•°ä¸€å®šåœ¨ x ä¹‹å‰å°±è¢«å…¶ä»–æ•°çš„å€æ•°æ ‡è®°è¿‡äº†ï¼Œä¾‹å¦‚ 2 çš„æ‰€æœ‰å€æ•°ï¼Œ3 çš„æ‰€æœ‰å€æ•°ç­‰ã€‚ leetcodeé¢˜è§£12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution(object): def countPrimes(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; # Sieve of EratosthenesåŸƒæ°ç­› # We are only interested in numbers LESS than the input number # exit early for numbers LESS than 2; (two is prime) if n &lt; 2: return 0 # create strike list for the input range, initializing all indices to # prime (1). strikes = [1] * n # we know that 0 and 2 are not prime strikes[0] = 0 strikes[1] = 0 # Now set multiples of remaining numbers that are marked as prime to # not prime. It is safe ignore numbers alreay marked as not prime # because there are factor(s) that divide evenly into this number and # all its multiples. Use upper limit of (n**0.5)+1, because: # (a) the smallest factor of a non-prime number will not be &gt; sqrt(n). # Ex. non-prime = 100, # 5*20 # 10*10, # 20*5 # !! we have seen 5 before. for i in range(2, int(n**0.5)+1): if strikes[i] != 0: # slow: #for j in range(i*i, n, i): # strikes[j] = 0 # 3x faster: # strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1) # n = 11 # i = 2 # (n-1-i*i)//i + 1 # (n-1) # get total # of indicies for n (non-inclusive) # -i*i # shift to get # of slots in range of interest # //i # get number of groups # + 1 # get number of slots # strikes[2*2:11:2] = [0] * ((11-1-2*2)//2 + 1 # strikes[4:11:2] = [0] * 4 # s[4], s[6], s[8], s10] = 0, 0, 0, 0 strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1) return sum(strikes) 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def countPrimes(self, n: int) -&gt; int: &quot;&quot;&quot; ç”¨æ•°ç»„primes[i]è¡¨ç¤ºæ•°å­—iæ˜¯å¦æ˜¯ç´ æ•°ï¼Œå¦‚æœå€¼ä¸ºTrueåˆ™ä¸ºç´ æ•°ï¼Œ å¦‚æœå€¼ä¸ºFalseåˆ™ä¸ºåˆæ•° &quot;&quot;&quot; primes = [True] * n primes[0]=primes[1]=False result = 0 for i in range(2, n): # å¦‚æœå½“å‰å€¼æ˜¯ç´ æ•°ï¼Œå°±å°†å®ƒå€æ•°æ ‡è®°ä¸ºåˆæ•° if primes[i]: result += 1 _power = i * i if _power &lt; n : for j in range(_power, n, i): primes[j] = False return resultclass Solution: def countPrimes(self, n: int) -&gt; int: &quot;&quot;&quot; ç”¨æ•°ç»„primes[i]è¡¨ç¤ºæ•°å­—iæ˜¯å¦æ˜¯ç´ æ•°ï¼Œå¦‚æœå€¼ä¸ºTrueåˆ™ä¸ºç´ æ•°ï¼Œ å¦‚æœå€¼ä¸ºFalseåˆ™ä¸ºåˆæ•° &quot;&quot;&quot; if n&lt;3: return 0 primes = [True] * n primes[0]= primes[1] = False result = 0 for i in range(2, n): # å¦‚æœå½“å‰å€¼æ˜¯ç´ æ•°ï¼Œå°±å°†å®ƒå€æ•°æ ‡è®°ä¸ºåˆæ•° if primes[i]: result += 1 _power = i * i if _power &lt; n : for j in range(_power, n, i): primes[j] = False return result"},{"title":"LeetCode07-æ•°å­¦","path":"2022/06/26/LeetCode07-æ•°å­¦/","text":"å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - æ•°å­¦ç´ æ•°åˆ†è§£æ¯ä¸€ä¸ªæ•°éƒ½å¯ä»¥åˆ†è§£æˆç´ æ•°çš„ä¹˜ç§¯ æ•´é™¤ä»¤ x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * â€¦ ä»¤ y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * â€¦ å¦‚æœ x æ•´é™¤ yï¼ˆy mod x == 0ï¼‰ï¼Œåˆ™å¯¹äºæ‰€æœ‰ iï¼Œmi &lt;= niã€‚ æœ€å¤§å…¬çº¦æ•°æœ€å°å…¬å€æ•°x å’Œ y çš„æœ€å¤§å…¬çº¦æ•°ä¸ºï¼šgcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * â€¦ x å’Œ y çš„æœ€å°å…¬å€æ•°ä¸ºï¼šlcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * â€¦ 1. ç”Ÿæˆç´ æ•°åºåˆ—2. æœ€å¤§å…¬çº¦æ•°3. ä½¿ç”¨ä½æ“ä½œå’Œå‡æ³•æ±‚è§£æœ€å¤§å…¬çº¦æ•°è¿›åˆ¶è½¬æ¢1. 7 è¿›åˆ¶2. 16 è¿›åˆ¶3. 26 è¿›åˆ¶é˜¶ä¹˜1. ç»Ÿè®¡é˜¶ä¹˜å°¾éƒ¨æœ‰å¤šå°‘ä¸ª 0å­—ç¬¦ä¸²åŠ æ³•å‡æ³•1. äºŒè¿›åˆ¶åŠ æ³•2. å­—ç¬¦ä¸²åŠ æ³•ç›¸é‡é—®é¢˜1. æ”¹å˜æ•°ç»„å…ƒç´ ä½¿æ‰€æœ‰çš„æ•°ç»„å…ƒç´ éƒ½ç›¸ç­‰å¤šæ•°æŠ•ç¥¨é—®é¢˜1. æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°å¤šäº n / 2 çš„å…ƒç´ å…¶å®ƒ1. å¹³æ–¹æ•°2. 3 çš„ n æ¬¡æ–¹3. ä¹˜ç§¯æ•°ç»„4. æ‰¾å‡ºæ•°ç»„ä¸­çš„ä¹˜ç§¯æœ€å¤§çš„ä¸‰ä¸ªæ•°"},{"title":"LeetCode06-æœç´¢","path":"2022/06/23/LeetCode06-æœç´¢/","text":"å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - æœç´¢BFS1. è®¡ç®—åœ¨ç½‘æ ¼ä¸­ä»åŸç‚¹åˆ°ç‰¹å®šç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦2. ç»„æˆæ•´æ•°çš„æœ€å°å¹³æ–¹æ•°æ•°é‡3. æœ€çŸ­å•è¯è·¯å¾„DFS1. æŸ¥æ‰¾æœ€å¤§çš„è¿é€šé¢ç§¯2. çŸ©é˜µä¸­çš„è¿é€šåˆ†é‡æ•°ç›®3. å¥½å‹å…³ç³»çš„è¿é€šåˆ†é‡æ•°ç›®4. å¡«å……å°é—­åŒºåŸŸ5. èƒ½åˆ°è¾¾çš„å¤ªå¹³æ´‹å’Œå¤§è¥¿æ´‹çš„åŒºåŸŸBacktracking1. æ•°å­—é”®ç›˜ç»„åˆ2. IP åœ°å€åˆ’åˆ†3. åœ¨çŸ©é˜µä¸­å¯»æ‰¾å­—ç¬¦ä¸²4. è¾“å‡ºäºŒå‰æ ‘ä¸­æ‰€æœ‰ä»æ ¹åˆ°å¶å­çš„è·¯å¾„5. æ’åˆ—6. å«æœ‰ç›¸åŒå…ƒç´ æ±‚æ’åˆ—7. ç»„åˆ8. ç»„åˆæ±‚å’Œ9. å«æœ‰ç›¸åŒå…ƒç´ çš„ç»„åˆæ±‚å’Œ10. 1-9 æ•°å­—çš„ç»„åˆæ±‚å’Œ11. å­é›†12. å«æœ‰ç›¸åŒå…ƒç´ æ±‚å­é›†13. åˆ†å‰²å­—ç¬¦ä¸²ä½¿å¾—æ¯ä¸ªéƒ¨åˆ†éƒ½æ˜¯å›æ–‡æ•°14. æ•°ç‹¬15. N çš‡åBFSå®½åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼ˆåˆç§°å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰æ˜¯æœ€ç®€ä¾¿çš„å›¾çš„æœç´¢ç®—æ³•ä¹‹ä¸€ï¼Œè¿™ä¸€ç®—æ³•ä¹Ÿæ˜¯å¾ˆå¤šé‡è¦çš„å›¾çš„ç®—æ³•çš„åŸå‹ã€‚Dijkstraå•æºæœ€çŸ­è·¯å¾„ç®—æ³•å’ŒPrimæœ€å°ç”Ÿæˆæ ‘ç®—æ³•éƒ½é‡‡ç”¨äº†å’Œå®½åº¦ä¼˜å…ˆæœç´¢ç±»ä¼¼çš„æ€æƒ³ã€‚å…¶åˆ«ååˆå«BFSï¼Œå±äºä¸€ç§ç›²ç›®æœå¯»æ³•ï¼Œç›®çš„æ˜¯ç³»ç»Ÿåœ°å±•å¼€å¹¶æ£€æŸ¥å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œä»¥æ‰¾å¯»ç»“æœã€‚æ¢å¥è¯è¯´ï¼Œå®ƒå¹¶ä¸è€ƒè™‘ç»“æœçš„å¯èƒ½ä½ç½®ï¼Œå½»åº•åœ°æœç´¢æ•´å¼ å›¾ï¼Œç›´åˆ°æ‰¾åˆ°ç»“æœä¸ºæ­¢ã€‚ bfsæ˜¯æŒ‰ä¸€å±‚ä¸€å±‚æ¥è®¿é—®çš„ï¼Œæ‰€ä»¥é€‚åˆæœ‰ç›®æ ‡æ±‚æœ€çŸ­è·¯çš„æ­¥æ•°ï¼Œä½ æƒ³æƒ³å±‚å±‚æœç´¢æ¯æ¬¡å±‚å°±ä»£è¡¨äº†ä¸€æ­¥ã€‚bfsä¼˜å…ˆè®¿é—®çš„æ˜¯å…„å¼ŸèŠ‚ç‚¹ï¼Œåªæœ‰è¿™ä¸€å±‚å…¨éƒ¨è®¿é—®å®Œæ‰èƒ½è®¿é—®ä¸‹ä¸€å±‚ï¼Œä¹Ÿå°±æ˜¯è¯´bfsç¬¬å‡ å±‚å°±ä»£è¡¨å½“å‰å¯ä»¥èµ°åˆ°çš„ä½ç½®(ç»“ç‚¹).è€Œdfsæ˜¯æŒ‰é€’å½’æ¥å®ç°çš„ï¼Œå®ƒä¼˜å…ˆæœç´¢æ·±åº¦ï¼Œå†å›æº¯ï¼Œä¼˜å…ˆè®¿é—®çš„æ˜¯æ²¡æœ‰è®¿é—®è¿‡çš„å­èŠ‚ç‚¹DFSå¤šç”¨äºè¿é€šæ€§é—®é¢˜å› ä¸ºå…¶è¿è¡Œæ€æƒ³ä¸äººè„‘çš„æ€ç»´å¾ˆç›¸ä¼¼ï¼Œæ•…è§£å†³è¿é€šæ€§é—®é¢˜æ›´è‡ªç„¶ã€‚BFSå¤šç”¨äºè§£å†³æœ€çŸ­è·¯é—®é¢˜ï¼Œå…¶è¿è¡Œè¿‡ç¨‹ä¸­éœ€è¦å‚¨å­˜æ¯ä¸€å±‚çš„ä¿¡æ¯ï¼Œæ‰€ä»¥å…¶è¿è¡Œæ—¶éœ€è¦å‚¨å­˜çš„ä¿¡æ¯é‡è¾ƒå¤§ï¼Œå¦‚æœäººè„‘ä¹Ÿå¯å‚¨å­˜å¤§é‡ä¿¡æ¯çš„è¯ï¼Œç†è®ºä¸Šäººè„‘ä¹Ÿå¯è¿è¡ŒBFSã€‚æ€»çš„æ¥è¯´å¤šæ•°æƒ…å†µä¸‹è¿è¡ŒBFSæ‰€éœ€çš„å†…å­˜ä¼šå¤§äºDFSéœ€è¦çš„å†…å­˜(DFSä¸€æ¬¡è®¿é—®ä¸€æ¡è·¯ï¼ŒBFSä¸€æ¬¡è®¿é—®å¤šæ¡è·¯)ï¼ŒDFSå®¹æ˜“çˆ†æ ˆ(æ ˆä¸æ˜“â€æ§åˆ¶â€)ï¼ŒBFSé€šè¿‡æ§åˆ¶é˜Ÿåˆ—å¯ä»¥å¾ˆå¥½è§£å†³â€çˆ†é˜Ÿåˆ—â€é£é™©ã€‚å®ƒä»¬ä¸¤è€…é—´å„è‡ªçš„ä¼˜åŠ¿éœ€è¦é€šè¿‡å®é™…çš„é—®é¢˜æ¥å…·ä½“åˆ†æï¼Œæ ¹æ®å®ƒä»¬å„è‡ªçš„ç‰¹ç‚¹æ¥åº”ç”¨äºä¸åŒçš„é—®é¢˜ä¸­æ‰èƒ½è·å¾—æœ€ä¼˜çš„æ€§èƒ½ã€‚"},{"title":"95. Unique Binary Search Trees II (Medium)","path":"2022/06/21/95/","text":"95. Unique Binary Search Trees II (Medium)Given an integer n, return all the structurally unique BSTâ€™s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.12Input: n = 3Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] å®˜æ–¹leetcode é¢˜è§£12345678910111213141516171819202122232425class Solution: def generateTrees(self, n: int) -&gt; List[TreeNode]: def generateTrees(start, end): if start &gt; end: return [None,] allTrees = [] for i in range(start, end + 1): # æšä¸¾å¯è¡Œæ ¹èŠ‚ç‚¹ # è·å¾—æ‰€æœ‰å¯è¡Œçš„å·¦å­æ ‘é›†åˆ leftTrees = generateTrees(start, i - 1) # è·å¾—æ‰€æœ‰å¯è¡Œçš„å³å­æ ‘é›†åˆ rightTrees = generateTrees(i + 1, end) # ä»å·¦å­æ ‘é›†åˆä¸­é€‰å‡ºä¸€æ£µå·¦å­æ ‘ï¼Œä»å³å­æ ‘é›†åˆä¸­é€‰å‡ºä¸€æ£µå³å­æ ‘ï¼Œæ‹¼æ¥åˆ°æ ¹èŠ‚ç‚¹ä¸Š for l in leftTrees: for r in rightTrees: currTree = TreeNode(i) currTree.left = l currTree.right = r allTrees.append(currTree) return allTrees return generateTrees(1, n) if n else []"},{"title":"241. Different Ways to Add Parentheses (Medium)","path":"2022/06/21/241/","text":"241. Different Ways to Add Parentheses (Medium)Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.12345Input: expression = &quot;2-1-1&quot;Output: [0,2]Explanation:((2-1)-1) = 0 (2-(1-1)) = 2 åˆ†æ²»ç®—æ³•(divide and conquer)çš„åŸºæœ¬æ€æƒ³æ˜¯å°†ä¸€ä¸ªè§„æ¨¡ä¸ºNçš„é—®é¢˜åˆ†è§£ä¸ºKä¸ªè§„æ¨¡è¾ƒå°çš„å­é—®é¢˜ï¼Œè¿™äº›å­é—®é¢˜ç›¸äº’ç‹¬ç«‹ä¸”ä¸åŸé—®é¢˜æ€§è´¨ç›¸åŒã€‚æ±‚å‡ºå­é—®é¢˜çš„è§£ï¼Œå°±å¯å¾—åˆ°åŸé—®é¢˜çš„è§£ã€‚å³ä¸€ç§åˆ†ç›®æ ‡å®Œæˆç¨‹åºç®—æ³•ï¼Œç®€å•é—®é¢˜å¯ç”¨äºŒåˆ†æ³•å®Œæˆã€‚åˆ†æ²»æ³•è§£é¢˜çš„ä¸€èˆ¬æ­¥éª¤ï¼ˆå¦‚å›¾1ï¼‰ï¼šï¼ˆ1ï¼‰åˆ†è§£ï¼Œå°†è¦è§£å†³çš„é—®é¢˜åˆ’åˆ†æˆè‹¥å¹²è§„æ¨¡è¾ƒå°çš„åŒç±»é—®é¢˜ï¼›ï¼ˆ2ï¼‰æ±‚è§£ï¼Œå½“å­é—®é¢˜åˆ’åˆ†å¾—è¶³å¤Ÿå°æ—¶ï¼Œç”¨è¾ƒç®€å•çš„æ–¹æ³•è§£å†³ï¼›ï¼ˆ3ï¼‰åˆå¹¶ï¼ŒæŒ‰åŸé—®é¢˜çš„è¦æ±‚ï¼Œå°†å­é—®é¢˜çš„è§£é€å±‚åˆå¹¶æ„æˆåŸé—®é¢˜çš„è§£ã€‚leetcode é¢˜è§£1234567891011121314151617181920212223class Solution: def diffWaysToCompute(self, input: str) -&gt; List[int]: # å¦‚æœåªæœ‰æ•°å­—ï¼Œç›´æ¥è¿”å› if input.isdigit(): return [int(input)] res = [] for i, char in enumerate(input): if char in [&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;]: # 1.åˆ†è§£ï¼šé‡åˆ°è¿ç®—ç¬¦ï¼Œè®¡ç®—å·¦å³ä¸¤ä¾§çš„ç»“æœé›† # 2.è§£å†³ï¼šdiffWaysToCompute é€’å½’å‡½æ•°æ±‚å‡ºå­é—®é¢˜çš„è§£ left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) # 3.åˆå¹¶ï¼šæ ¹æ®è¿ç®—ç¬¦åˆå¹¶å­é—®é¢˜çš„è§£ for l in left: for r in right: if char == &#x27;+&#x27;: res.append(l + r) elif char == &#x27;-&#x27;: res.append(l - r) else: res.append(l * r) return res"},{"title":"34. Find First and Last Position of Element in Sorted Array","path":"2022/06/20/34/","text":"34. Find First and Last Position of Element in Sorted Array (Medium)Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].You must write an algorithm with O(log n) runtime complexity.12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] è¿™ä¸ªæ˜¯äºŒåˆ†æŸ¥æ‰¾çš„æ¨¡æ¿123456def lower_bound(array, first, last, value): # æ±‚éé™åºèŒƒå›´[first, last)å†…ç¬¬ä¸€ä¸ªä¸å°äºvalueçš„å€¼çš„ä½ç½® while first &lt; last: # æœç´¢åŒºé—´[first, last)ä¸ä¸ºç©º mid = first + (last - first) // 2 # é˜²æº¢å‡º if array[mid] &lt; value: first = mid + 1 else: last = mid return first # lastä¹Ÿè¡Œï¼Œå› ä¸º[first, last)ä¸ºç©ºçš„æ—¶å€™å®ƒä»¬é‡åˆ Solution:123456789101112131415161718class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: def binarysearchleft(nums, target): left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right)//2 if nums[mid] &gt;= target: right = mid -1 else: left = mid + 1 return left start = binarysearchleft(nums, target) end = binarysearchleft(nums, target + 1) - 1 if start == len(nums) or nums[start] != target: return [-1, -1] else: return [start, end]"},{"title":"153. Find Minimum in Rotated Sorted Array (Medium)","path":"2022/06/20/153/","text":"153. Find Minimum in Rotated Sorted Array (Medium)Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:[4,5,6,7,0,1,2] if it was rotated 4 times.[0,1,2,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], â€¦, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], â€¦, a[n-2]].Given the sorted rotated array nums of unique elements, return the minimum element of this array.You must write an algorithm that runs in O(log n) time.è¿™ä¸ªæ˜¯äºŒåˆ†æŸ¥æ‰¾çš„æ¨¡æ¿123456def lower_bound(array, first, last, value): # æ±‚éé™åºèŒƒå›´[first, last)å†…ç¬¬ä¸€ä¸ªä¸å°äºvalueçš„å€¼çš„ä½ç½® while first &lt; last: # æœç´¢åŒºé—´[first, last)ä¸ä¸ºç©º mid = first + (last - first) // 2 # é˜²æº¢å‡º if array[mid] &lt; value: first = mid + 1 else: last = mid return first # lastä¹Ÿè¡Œï¼Œå› ä¸º[first, last)ä¸ºç©ºçš„æ—¶å€™å®ƒä»¬é‡åˆ Solution:123456789101112class Solution: def findMin(self, nums: List[int]) -&gt; int: first,last = 0,len(nums)-1 while first&lt;last: mid = first+(last-first)//2 if nums[mid]&lt;nums[last] : last = mid else: first = mid +1 return nums[first]"},{"title":"278. First Bad Version (Easy)","path":"2022/06/20/278/","text":"278. First Bad Version (Easy)You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, â€¦, n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.12345678Input: n = 5, bad = 4Output: 4Explanation:call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. å®˜æ–¹é¢˜è§£å› ä¸ºé¢˜ç›®è¦æ±‚å°½é‡å‡å°‘è°ƒç”¨æ£€æŸ¥æ¥å£çš„æ¬¡æ•°ï¼Œæ‰€ä»¥ä¸èƒ½å¯¹æ¯ä¸ªç‰ˆæœ¬éƒ½è°ƒç”¨æ£€æŸ¥æ¥å£ï¼Œè€Œæ˜¯åº”è¯¥å°†è°ƒç”¨æ£€æŸ¥æ¥å£çš„æ¬¡æ•°é™åˆ°æœ€ä½ã€‚ æ³¨æ„åˆ°ä¸€ä¸ªæ€§è´¨ï¼šå½“ä¸€ä¸ªç‰ˆæœ¬ä¸ºæ­£ç¡®ç‰ˆæœ¬ï¼Œåˆ™è¯¥ç‰ˆæœ¬ä¹‹å‰çš„æ‰€æœ‰ç‰ˆæœ¬å‡ä¸ºæ­£ç¡®ç‰ˆæœ¬ï¼›å½“ä¸€ä¸ªç‰ˆæœ¬ä¸ºé”™è¯¯ç‰ˆæœ¬ï¼Œåˆ™è¯¥ç‰ˆæœ¬ä¹‹åçš„æ‰€æœ‰ç‰ˆæœ¬å‡ä¸ºé”™è¯¯ç‰ˆæœ¬ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ€§è´¨è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ã€‚ å…·ä½“åœ°ï¼Œå°†å·¦å³è¾¹ç•Œåˆ†åˆ«åˆå§‹åŒ–ä¸º 1 å’Œ nï¼Œå…¶ä¸­ n æ˜¯ç»™å®šçš„ç‰ˆæœ¬æ•°é‡ã€‚è®¾å®šå·¦å³è¾¹ç•Œä¹‹åï¼Œæ¯æ¬¡æˆ‘ä»¬éƒ½ä¾æ®å·¦å³è¾¹ç•Œæ‰¾åˆ°å…¶ä¸­é—´çš„ç‰ˆæœ¬ï¼Œæ£€æŸ¥å…¶æ˜¯å¦ä¸ºæ­£ç¡®ç‰ˆæœ¬ã€‚å¦‚æœè¯¥ç‰ˆæœ¬ä¸ºæ­£ç¡®ç‰ˆæœ¬ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬å¿…ç„¶ä½äºè¯¥ç‰ˆæœ¬çš„å³ä¾§ï¼Œæˆ‘ä»¬ç¼©ç´§å·¦è¾¹ç•Œï¼›å¦åˆ™ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬å¿…ç„¶ä½äºè¯¥ç‰ˆæœ¬åŠè¯¥ç‰ˆæœ¬çš„å·¦ä¾§ï¼Œæˆ‘ä»¬ç¼©ç´§å³è¾¹ç•Œã€‚ è¿™æ ·æˆ‘ä»¬æ¯åˆ¤æ–­ä¸€æ¬¡éƒ½å¯ä»¥ç¼©ç´§ä¸€æ¬¡è¾¹ç•Œï¼Œè€Œæ¯æ¬¡ç¼©ç´§æ—¶ä¸¤è¾¹ç•Œè·ç¦»å°†å˜ä¸ºåŸæ¥çš„ä¸€åŠï¼Œå› æ­¤æˆ‘ä»¬è‡³å¤šåªéœ€è¦ç¼©ç´§ O(logn) æ¬¡ã€‚ è¿™ä¸ªæ˜¯äºŒåˆ†æŸ¥æ‰¾çš„æ¨¡æ¿123456def lower_bound(array, first, last, value): # æ±‚éé™åºèŒƒå›´[first, last)å†…ç¬¬ä¸€ä¸ªä¸å°äºvalueçš„å€¼çš„ä½ç½® while first &lt; last: # æœç´¢åŒºé—´[first, last)ä¸ä¸ºç©º mid = first + (last - first) // 2 # é˜²æº¢å‡º if array[mid] &lt; value: first = mid + 1 else: last = mid return first # lastä¹Ÿè¡Œï¼Œå› ä¸º[first, last)ä¸ºç©ºçš„æ—¶å€™å®ƒä»¬é‡åˆ solution 123456789101112131415161718# The isBadVersion API is already defined for you.# @param version, an integer# @return an integer# def isBadVersion(version):class Solution: def firstBadVersion(self, n: int) -&gt; int: first,last=1,n while first&lt;last: mid = first+(last-first)//2 if isBadVersion(mid): last= mid else: first = mid +1 return first"},{"title":"540. Single Element in a Sorted Array (Medium)","path":"2022/06/20/540/","text":"540. Single Element in a Sorted Array (Medium)You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.Return the single element that appears only once.Your solution must run in O(log n) time and O(1) space.é¢˜ç›®æè¿°ï¼šä¸€ä¸ªæœ‰åºæ•°ç»„åªæœ‰ä¸€ä¸ªæ•°ä¸å‡ºç°ä¸¤æ¬¡ï¼Œæ‰¾å‡ºè¿™ä¸ªæ•°ã€‚ä½ è®¾è®¡çš„è§£å†³æ–¹æ¡ˆå¿…é¡»æ»¡è¶³ O(log n) æ—¶é—´å¤æ‚åº¦å’Œ O(1) ç©ºé—´å¤æ‚åº¦ã€‚ 1.äºŒåˆ†æŸ¥æ‰¾å®˜æ–¹é¢˜è§£åˆ©ç”¨åˆ—è¡¨æœ‰åºçš„ç‰¹ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾é™ä½æ—¶é—´å¤æ‚åº¦ã€‚ è¿™é“é¢˜çš„ç‰¹ç‚¹åœ¨äºæ¯”è¾ƒçš„ä¸æ˜¯æ•°å­—æœ¬èº«çš„å¤§å°ï¼Œè€Œæ˜¯ä¸‹æ ‡çš„å¥‡å¶æ€§ã€‚å› ä¸ºåªæœ‰ä¸€ä¸ªæ•°åªå‡ºç°ä¸€æ¬¡ï¼Œæ‰€ä»¥è¿™ä¸ªæ•°å­—çš„ä¸‹æ ‡å°±åªèƒ½æ˜¯å¶æ•°ã€‚ ç”±äºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œå› æ­¤æ•°ç»„ä¸­ç›¸åŒçš„å…ƒç´ ä¸€å®šç›¸é‚»ã€‚å¯¹äºä¸‹æ ‡ x å·¦è¾¹çš„ä¸‹æ ‡ yï¼Œå¦‚æœ nums[y]=nums[y+1]ï¼Œåˆ™ y ä¸€å®šæ˜¯å¶æ•°ï¼›å¯¹äºä¸‹æ ‡ x å³è¾¹çš„ä¸‹æ ‡ zï¼Œå¦‚æœ nums[z]=nums[z+1]ï¼Œåˆ™ z ä¸€å®šæ˜¯å¥‡æ•°ã€‚ç”±äºä¸‹æ ‡ x æ˜¯ç›¸åŒå…ƒç´ çš„å¼€å§‹ä¸‹æ ‡çš„å¥‡å¶æ€§çš„åˆ†ç•Œï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•å¯»æ‰¾ä¸‹æ ‡ xã€‚ åˆå§‹æ—¶ï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„å·¦è¾¹ç•Œæ˜¯ 0ï¼Œå³è¾¹ç•Œæ˜¯æ•°ç»„çš„æœ€å¤§ä¸‹æ ‡ã€‚æ¯æ¬¡å–å·¦å³è¾¹ç•Œçš„å¹³å‡å€¼ mid ä½œä¸ºå¾…åˆ¤æ–­çš„ä¸‹æ ‡ï¼Œæ ¹æ® mid çš„å¥‡å¶æ€§å†³å®šå’Œå·¦è¾¹æˆ–å³è¾¹çš„ç›¸é‚»å…ƒç´ æ¯”è¾ƒï¼š å¦‚æœ mid æ˜¯å¶æ•°ï¼Œåˆ™æ¯”è¾ƒ nums[mid] å’Œ nums[mid+1] æ˜¯å¦ç›¸ç­‰ï¼› å¦‚æœ mid æ˜¯å¥‡æ•°ï¼Œåˆ™æ¯”è¾ƒ nums[midâˆ’1] å’Œ nums[mid] æ˜¯å¦ç›¸ç­‰ã€‚ å¦‚æœä¸Šè¿°æ¯”è¾ƒç›¸é‚»å…ƒç´ çš„ç»“æœæ˜¯ç›¸ç­‰ï¼Œåˆ™ mid&lt;x, è°ƒæ•´å·¦è¾¹ç•Œã€‚å¦åˆ™ midâ‰¥xï¼Œè°ƒæ•´å³è¾¹ç•Œã€‚è°ƒæ•´è¾¹ç•Œä¹‹åç»§ç»­äºŒåˆ†æŸ¥æ‰¾ï¼Œç›´åˆ°ç¡®å®šä¸‹æ ‡ x çš„å€¼ã€‚ å¾—åˆ°ä¸‹æ ‡ x çš„å€¼ä¹‹åï¼Œnums[x] å³ä¸ºåªå‡ºç°ä¸€æ¬¡çš„å…ƒç´ ã€‚ âŠ• æ˜¯æŒ‰ä½å¼‚æˆ–è¿ç®—ç¬¦ å½“ mid æ˜¯å¶æ•°æ—¶ï¼Œ mid+1=midâŠ•1ï¼› å½“ mid æ˜¯å¥‡æ•°æ—¶ï¼Œ midâˆ’1=midâŠ•1ã€‚ æ³¨ï¼šæŒ‰ä½å¼‚æˆ– ^ ,æŒ‰ä½æˆ– | ,æŒ‰ä½ä¸ &amp;ä¹Ÿå°±æ˜¯è¯´åˆ¤æ–­å¥‡å¶æ€§æ˜¯é å¼‚æˆ–è¿ç®— è¿™ä¸ªæ˜¯äºŒåˆ†æŸ¥æ‰¾çš„æ¨¡æ¿123456def lower_bound(array, first, last, value): # æ±‚éé™åºèŒƒå›´[first, last)å†…ç¬¬ä¸€ä¸ªä¸å°äºvalueçš„å€¼çš„ä½ç½® while first &lt; last: # æœç´¢åŒºé—´[first, last)ä¸ä¸ºç©º mid = first + (last - first) // 2 # é˜²æº¢å‡º if array[mid] &lt; value: first = mid + 1 else: last = mid return first # lastä¹Ÿè¡Œï¼Œå› ä¸º[first, last)ä¸ºç©ºçš„æ—¶å€™å®ƒä»¬é‡åˆ 1234567891011class Solution: def singleNonDuplicate(self, nums: List[int]) -&gt; int: low, high = 0, len(nums) - 1 while low &lt; high: mid = (low + high) // 2 if nums[mid] == nums[mid ^ 1]: low = mid + 1 else: high = mid return nums[low]"},{"title":"16. 3Sum Closest(medium)","path":"2022/06/16/16/","text":"16. 3Sum Closest(medium)Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.Return the sum of the three integers.You may assume that each input would have exactly one solution.æ’åº + åŒæŒ‡é’ˆè¿™é¢˜å’Œä¸‰æ•°ä¹‹å’Œæ¥è¿‘ï¼Œå°±æ˜¯æ’åºç„¶åå†ä½¿ç”¨åŒæŒ‡é’ˆã€‚å¯»æ‰¾æœ€æ¥è¿‘çš„æ•°ï¼Œåˆšå¥½åŸæ¥çš„ä¸‰æ•°ä¹‹å’Œå°±æ˜¯ä½¿ç”¨æ…¢æ…¢æ¥è¿‘çš„æ–¹æ³•å¯»æ‰¾targetçš„ï¼Œæ‰€ä»¥å°±å¯ä»¥åœ¨å¯»æ‰¾targetçš„è¿‡ç¨‹ä¸­æ¯ä¸€æ¬¡éƒ½åˆ¤æ–­æ˜¯å¦æ˜¯æœ€æ¥è¿‘çš„ã€‚ ä¼˜åŒ–çš„ç»†èŠ‚æ˜¯åœ¨åŒæŒ‡é’ˆå‰åŠ å…¥å½“å‰è¿™ä¸€è½®ï¼Œä¹Ÿå°±æ˜¯firstå›ºå®šä¸‹æ¥åï¼Œçš„æœ€å¤§å€¼å’Œæœ€å°å€¼ä¸targetçš„å…³ç³»ã€‚å¦‚æœæœ€å¤§çš„æ•°éƒ½å°äºç­‰äºtargetï¼Œé‚£ç›´æ¥ä¸‹ä¸€è½®ï¼Œfirstå¾€å³ä¹Ÿè®¸èƒ½æ›´å¤§ï¼›å¦‚æœæœ€å°çš„æ•°éƒ½å¤§äºç­‰äºtargetï¼Œé‚£å‹æ ¹åˆ«æ‰¾äº†ï¼Œå› ä¸ºä¸å¯èƒ½å†æœ‰æ›´å°çš„æ•°äº†ï¼Œç›´æ¥Breakæ‰è¿”å›ç»“æœå³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def threeSumClosest(self, nums, target): n = len(nums) nums.sort() # æ’åº ans = float(&#x27;inf&#x27;) for first in range(n-2): # æšä¸¾ç¬¬ä¸€ä¸ªå…ƒç´  if first &gt; 0 and nums[first] == nums[first-1]: continue # ä¿è¯firstä¸ä¼šæœ‰é‡å¤ second, third = first + 1, n - 1 max_sum = nums[first] + nums[-2] + nums[-1] min_sum = nums[first] + nums[first + 1] + nums[first + 2] if max_sum &lt;= target: # æœ€å¤§çš„æ•° if abs(max_sum - target) &lt; abs(ans - target): ans = max_sum continue elif min_sum &gt;= target: # æœ€å°çš„æ•° if abs(min_sum - target) &lt; abs(ans - target): ans = min_sum break while second &lt; third: two_sum_target = target - nums[first] s = nums[second] + nums[third] if abs(s + nums[first] - target) &lt; abs(ans - target): ans = s + nums[first] if s &gt; two_sum_target: # å½“å‰æ•°å€¼å¤ªå¤§ å³æŒ‡é’ˆå·¦ç§» third -= 1 while third &gt; second and nums[third] == nums[third + 1]: third -= 1 elif s &lt; two_sum_target: # å½“å‰æ•°å€¼å¤ªå° å·¦æŒ‡é’ˆå³ç§» second += 1 while third &gt; second and nums[second] == nums[second - 1]: second += 1 else: # åˆšå¥½ç­‰äº ç›´æ¥è¿”å›targetå³å¯ return target return ans"},{"title":"744. Find Smallest Letter Greater Than Target (Easy)","path":"2022/06/16/744/","text":"744. Find Smallest Letter Greater Than Target (Easy)Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.123456789Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;Output: &quot;f&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;Output: &quot;c&quot; é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªæœ‰åºçš„å­—ç¬¦æ•°ç»„ letters å’Œä¸€ä¸ªå­—ç¬¦ targetï¼Œè¦æ±‚æ‰¾å‡º letters ä¸­å¤§äº target çš„æœ€å°å­—ç¬¦ï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±è¿”å›ç¬¬ 1 ä¸ªå­—ç¬¦ã€‚ å®˜æ–¹é¢˜è§£1.çº¿æ€§æŸ¥æ‰¾ç”±äºç»™å®šçš„åˆ—è¡¨å·²ç»æŒ‰ç…§é€’å¢é¡ºåºæ’åºï¼Œå› æ­¤å¯ä»¥ä»å·¦åˆ°å³éå†åˆ—è¡¨ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”ç›®æ ‡å­—æ¯å¤§çš„å­—æ¯ï¼Œå³ä¸ºæ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ã€‚ å¦‚æœç›®æ ‡å­—æ¯å°äºåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå­—æ¯ï¼Œåˆ™ä¸€å®šå¯ä»¥åœ¨åˆ—è¡¨ä¸­æ‰¾åˆ°æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ã€‚å¦‚æœç›®æ ‡å­—æ¯å¤§äºæˆ–ç­‰äºåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå­—æ¯ï¼Œåˆ™åˆ—è¡¨ä¸­ä¸å­˜åœ¨æ¯”ç›®æ ‡å­—æ¯å¤§çš„å­—æ¯ï¼Œæ ¹æ®å¾ªç¯å‡ºç°çš„é¡ºåºï¼Œåˆ—è¡¨çš„é¦–ä¸ªå­—æ¯æ˜¯æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ã€‚ 1234class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: return next((letter for letter in letters if letter &gt; target), letters[0]) 2.äºŒåˆ†æŸ¥æ‰¾åˆ©ç”¨åˆ—è¡¨æœ‰åºçš„ç‰¹ç‚¹ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾é™ä½æ—¶é—´å¤æ‚åº¦ã€‚ é¦–å…ˆæ¯”è¾ƒç›®æ ‡å­—æ¯å’Œåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå­—æ¯ï¼Œå½“ç›®æ ‡å­—æ¯å¤§äºæˆ–ç­‰äºåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå­—æ¯æ—¶ï¼Œç­”æ¡ˆæ˜¯åˆ—è¡¨çš„é¦–ä¸ªå­—æ¯ã€‚å½“ç›®æ ‡å­—æ¯å°äºåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå­—æ¯æ—¶ï¼Œåˆ—è¡¨ä¸­ä¸€å®šå­˜åœ¨æ¯”ç›®æ ‡å­—æ¯å¤§çš„å­—æ¯ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å¾—åˆ°æ¯”ç›®æ ‡å­—æ¯å¤§çš„æœ€å°å­—æ¯ã€‚ åˆå§‹æ—¶ï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„èŒƒå›´æ˜¯æ•´ä¸ªåˆ—è¡¨çš„ä¸‹æ ‡èŒƒå›´ã€‚æ¯æ¬¡æ¯”è¾ƒå½“å‰ä¸‹æ ‡å¤„çš„å­—æ¯å’Œç›®æ ‡å­—æ¯ï¼Œå¦‚æœå½“å‰ä¸‹æ ‡å¤„çš„å­—æ¯å¤§äºç›®æ ‡å­—æ¯ï¼Œåˆ™åœ¨å½“å‰ä¸‹æ ‡ä»¥åŠå½“å‰ä¸‹æ ‡çš„å·¦ä¾§ç»§ç»­æŸ¥æ‰¾ï¼Œå¦åˆ™åœ¨å½“å‰ä¸‹æ ‡çš„å³ä¾§ç»§ç»­æŸ¥æ‰¾ã€‚ 1234class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: return letters[bisect_right(letters, target)] if target &lt; letters[-1] else letters[0] è¿™ä¸ªæ˜¯äºŒåˆ†æŸ¥æ‰¾çš„æ¨¡æ¿123456def lower_bound(array, first, last, value): # æ±‚éé™åºèŒƒå›´[first, last)å†…ç¬¬ä¸€ä¸ªä¸å°äºvalueçš„å€¼çš„ä½ç½® while first &lt; last: # æœç´¢åŒºé—´[first, last)ä¸ä¸ºç©º mid = first + (last - first) // 2 # é˜²æº¢å‡º if array[mid] &lt; value: first = mid + 1 else: last = mid return first # lastä¹Ÿè¡Œï¼Œå› ä¸º[first, last)ä¸ºç©ºçš„æ—¶å€™å®ƒä»¬é‡åˆ è‡ªå·±å†™çš„å®Œå…¨ç‰ˆ123456789101112131415class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: first,last=0,len(letters)-1 # æ³¨æ„å¦‚æœç›®æ ‡å€¼å¤§äºæˆ–ç­‰äºæœ‰åºåˆ—è¡¨çš„æœ€åä¸€é¡¹ï¼Œè¿”å›å€¼ä¸ºé¦–å…ƒç´  #letters[-1]æ˜¯åˆ—è¡¨æœ€åä¸€ä¸ªå…ƒç´  if target&gt;=letters[-1]: return letters[0] while first&lt;last: mid = first+ (last-first)//2 #1//2=0,å‘ä¸‹å–æ•´ if letters[mid]&lt;=target: first=mid+1 else: last = mid return letters[first]"},{"title":"69. Sqrt(x) (Easy)","path":"2022/06/16/69/","text":"69. Sqrt(x) (Easy)Given a non-negative integer x, compute and return the square root of x.Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5æ–¹æ³•ä¸€ï¼šäºŒåˆ†æŸ¥æ‰¾123456789def lower_bound(array, first, last, value): # æ±‚éé™åºèŒƒå›´[first, last)å†…ç¬¬ä¸€ä¸ªä¸å°äºvalueçš„å€¼çš„ä½ç½® while first &lt; last: # æœç´¢åŒºé—´[first, last)ä¸ä¸ºç©º mid = first + (last - first) // 2 # é˜²æº¢å‡º if array[mid] &lt; value: first = mid + 1 else: last = mid return first # lastä¹Ÿè¡Œï¼Œå› ä¸º[first, last)ä¸ºç©ºçš„æ—¶å€™å®ƒä»¬é‡åˆ 123456789101112class Solution: def mySqrt(self, x: int) -&gt; int: left, right, ans = 0, x, -1 while left &lt;= right: mid = left+(left-right)//2 # é˜²æº¢å‡º if mid * mid &lt;= x: ans = mid left = mid + 1 else: right = mid - 1 return ans 123456789101112class Solution: def mySqrt(self, x: int) -&gt; int: left, right, ans = 0, x, -1 while left &lt;= right: mid = left+(right-left)//2 # é˜²æº¢å‡º #mid = (left + right) // 2 if mid * mid &lt;= x: ans = mid left = mid + 1 else: right = mid - 1 return ans æ–¹æ³•äºŒï¼šç‰›é¡¿è¿­ä»£"},{"title":"Leetcode05- äºŒåˆ†æŸ¥æ‰¾","path":"2022/06/16/Leetcode05-äºŒåˆ†æŸ¥æ‰¾/","text":"å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - äºŒåˆ†æŸ¥æ‰¾1. æ±‚å¼€æ–¹2. å¤§äºç»™å®šå…ƒç´ çš„æœ€å°å…ƒç´ 3. æœ‰åºæ•°ç»„çš„ Single Element4. ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬5. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—6. æŸ¥æ‰¾åŒºé—´äºŒåˆ†æŸ¥æ‰¾ binary search algorithm æ—¶é—´å¤æ‚åº¦äºŒåˆ†æŸ¥æ‰¾ä¹Ÿç§°ä¸ºæŠ˜åŠæŸ¥æ‰¾ï¼Œæ¯æ¬¡éƒ½èƒ½å°†æŸ¥æ‰¾åŒºé—´å‡åŠï¼Œè¿™ç§æŠ˜åŠç‰¹æ€§çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ã€‚ m è®¡ç®—æœ‰ä¸¤ç§è®¡ç®—ä¸­å€¼ m çš„æ–¹å¼ï¼š m = (l + h) / 2m = l + (h - l) / 2l + h å¯èƒ½å‡ºç°åŠ æ³•æº¢å‡ºï¼Œä¹Ÿå°±æ˜¯è¯´åŠ æ³•çš„ç»“æœå¤§äºæ•´å‹èƒ½å¤Ÿè¡¨ç¤ºçš„èŒƒå›´ã€‚ä½†æ˜¯ l å’Œ h éƒ½ä¸ºæ­£æ•°ï¼Œå› æ­¤ h - l ä¸ä¼šå‡ºç°åŠ æ³•æº¢å‡ºé—®é¢˜ã€‚æ‰€ä»¥ï¼Œæœ€å¥½ä½¿ç”¨ç¬¬äºŒç§è®¡ç®—æ³•æ–¹æ³•ã€‚ æœªæˆåŠŸæŸ¥æ‰¾çš„è¿”å›å€¼å¾ªç¯é€€å‡ºæ—¶å¦‚æœä»ç„¶æ²¡æœ‰æŸ¥æ‰¾åˆ° keyï¼Œé‚£ä¹ˆè¡¨ç¤ºæŸ¥æ‰¾å¤±è´¥ã€‚å¯ä»¥æœ‰ä¸¤ç§è¿”å›å€¼ï¼š -1ï¼šä»¥ä¸€ä¸ªé”™è¯¯ç è¡¨ç¤ºæ²¡æœ‰æŸ¥æ‰¾åˆ° keylï¼šå°† key æ’å…¥åˆ° nums ä¸­çš„æ­£ç¡®ä½ç½® æ¨¡æ¿ 1234567891011121314int binarySearch(int[] nums, int target) &#123; // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125;"},{"title":"763. Partition Labels (Medium)","path":"2022/06/13/763/","text":"763. Partition Labels (Medium)You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.Return a list of integers representing the size of these parts.Example: 123456Input: s = &quot;ababcbacadefegdehijhklij&quot;Output: [9,7,8]Explanation:The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.This is a partition so that each letter appears in at most one part.A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts. æ€è·¯:å…¶å®æ€è·¯å¾ˆç®€å•ï¼Œ1ï¼Œ é¦–å…ˆçœ‹ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œæ‰¾åˆ°å®ƒåœ¨ä¸²é‡Œæœ€åçš„ä¸€ä¸ªä½ç½®ï¼Œè®°ä½œlastæˆ–ä¸€æ®µçš„æœ€åä½ç½®ã€‚2ï¼Œ åœ¨ä»0~lastè¿™ä¸ªèŒƒå›´é‡Œï¼ŒæŒ¨ä¸ªæŸ¥å…¶ä»–å­—æ¯ï¼Œçœ‹ä»–ä»¬çš„æœ€åä½ç½®æ˜¯ä¸æ˜¯æ¯”åˆšæ‰çš„lastæˆ–ä¸€æ®µçš„æœ€åä½ç½®å¤§ã€‚å¦‚æœæ²¡æœ‰åˆšæ‰çš„lastæˆ–ä¸€æ®µçš„æœ€åä½ç½®å¤§ï¼Œæ— è§†å®ƒç»§ç»­å¾€åæ‰¾ã€‚å¦‚æœæ¯”åˆšæ‰çš„å¤§ï¼Œè¯´æ˜è¿™ä¸€æ®µçš„åˆ†éš”ä½ç½®å¿…é¡»å¾€åç§»åŠ¨ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠlastæˆ–ä¸€æ®µçš„æœ€åä½ç½®æ›´æ–°ä¸ºå½“å‰çš„å­—æ¯çš„æœ€åä½ç½®ã€‚3ï¼Œè‚¯å®šåˆ°æœ‰ä¸€ä¸ªæ—¶é—´ï¼Œè¿™ä¸ªlastå°±æ›´æ–°ä¸äº†äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™è¿™ä¸ªä½ç½®å°±æ˜¯æˆ‘ä»¬çš„åˆ†éš”ä½ç½®ã€‚æ³¨æ„é¢˜ç›®è¦åˆ†éš”åçš„é•¿åº¦ï¼Œæˆ‘ä»¬å°±ç”¨last - startindex + 1ã€‚4ï¼Œæ‰¾åˆ°ä¸€ä¸ªåˆ†å‰²ä½ï¼Œæ›´æ–°ä¸€ä¸‹èµ·å§‹ä½ç½®ï¼ŒåŒç†æœç´¢å°±è¡Œäº†ã€‚ ç”¨å­—å…¸çš„å¥½å¤„å°±æ˜¯ä¸ç”¨æ¯æ¬¡éƒ½æœç´¢ä½ç½®äº†ã€‚ç›´æ¥ç”¨å­—å…¸å­˜æ‰€æœ‰å­—ç¬¦çš„æœ€åä½ç½®å°±å¥½äº†ã€‚ 1234567891011121314151617class Solution: def partitionLabels(self, S: &quot;str&quot;) -&gt; &quot;list[int]&quot;: maxIndex = dict() # è®°å½•æ¯ä¸ªå­—ç¬¦æœ€åçš„ä½ç½® for i in range(len(S)): maxIndex[S[i]] = i ans = list() # å½“å‰ç‰‡æ®µå¼€å§‹ä½ç½®å’Œç»“æŸä½ç½® start = 0 end = 0 # éå†æ•´ä¸ªå­—ç¬¦ä¸²Sï¼Œå¯»æ‰¾æ‰€æœ‰åˆé€‚çš„è§£ for i in range(len(S)): end = max(maxIndex[S[i]], end) #å¦‚æœæœ€åä½ç½®æ¯”åˆšæ‰çš„å¤§ï¼Œå°±æ›´æ–°æœ€åä½ç½® if i == end: #è¿™é‡Œå°±æ˜¯æ‰¾åˆ°è¿™ä¸€æ®µçš„ç»“æŸäº†ï¼Œå°±è¯´æ˜å½“å‰ä½ç½®çš„indexå’Œè¿™ä¸ªå­—æ¯åœ¨å­—å…¸é‡Œçš„æœ€åä½ç½®åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚ ans.append(end - start + 1) # åŠ å…¥result start = end + 1 return ans"},{"title":"53. Maximum Subarray (Easy)","path":"2022/06/13/53/","text":"53. Maximum Subarray (Easy)Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.A subarray is a contiguous part of an array.Example: 123Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. è¿™é¢˜ç¬¬ä¸€çœ¼éå¸¸åƒä¹°è‚¡ç¥¨ç¬¬ä¸€å¼¹ 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: minprice = float(&#x27;inf&#x27;) #float(&#x27;inf&#x27;)è¡¨ç¤ºæ­£æ— ç©·å¤§ maxprofit = 0 #ä¿å­˜å½“å‰æœ€å¤§çš„åˆ©æ¶¦ for price in prices: #ä¸€æ¬¡éå† maxprofit = max(price - minprice, maxprofit)#å½“å‰åˆ©æ¶¦ä¸æœ€å¤§çš„åˆ©æ¶¦ç›¸æ¯” minprice = min(price, minprice) #ä¿å­˜å½“å‰æœ€å°çš„ä»·æ ¼ return maxprofit æœ¬è´¨ä¸Šæ˜¯åŠ¨æ€è§„åˆ’é—®é¢˜ï¼šleetcodeé¢˜è§£ æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’ã€ŒåŠ›æ‰£ã€ç¬¬ 53 é¢˜ï¼ˆæœ€å¤§å­åºå’Œï¼‰æ˜¯ã€ŒåŠ›æ‰£ã€ç¬¬ 124 é¢˜ï¼ˆäºŒå‰æ ‘çš„æœ€å¤§è·¯å¾„å’Œï¼‰çš„çº¿æ€§ç‰ˆæœ¬ï¼Œå®ƒä»¬çš„çŠ¶æ€è®¾è®¡æ€æƒ³å’ŒçŠ¶æ€è½¬ç§»æ˜¯ç±»ä¼¼çš„ï¼Œå¸Œæœ›å¤§å®¶èƒ½å¤Ÿé€šè¿‡æœ¬é¢˜é¢˜è§£è¿›ä¸€æ­¥ä½“ä¼šçŠ¶æ€æ˜¯å¦‚ä½•æƒ³åˆ°çš„ï¼ˆå³å­é—®é¢˜çš„å®šä¹‰éœ€è¦ä»å“ªäº›æ–¹é¢è€ƒè™‘ï¼‰ã€‚ æœ¬é¢˜æ¥çš„é‡ç‚¹åœ¨ã€Œå…³é”® 1ï¼šç†è§£é¢˜æ„ã€å’Œã€Œå…³é”® 2ï¼šå¦‚ä½•å®šä¹‰å­é—®é¢˜ï¼ˆå¦‚ä½•å®šä¹‰çŠ¶æ€ï¼‰ã€å’Œã€Œæœ€åå†è°ˆè°ˆã€Œæ— åæ•ˆæ€§ã€ã€‚ å…³é”® 1ï¼šç†è§£é¢˜æ„é¢˜ç›®è¦æˆ‘ä»¬æ‰¾å‡ºå’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„çš„å€¼æ˜¯å¤šå°‘ï¼Œã€Œè¿ç»­ã€æ˜¯å…³é”®å­—ï¼Œè¿ç»­å¾ˆé‡è¦ï¼Œä¸æ˜¯å­åºåˆ—ã€‚ é¢˜ç›®åªè¦æ±‚è¿”å›ç»“æœï¼Œä¸è¦æ±‚å¾—åˆ°æœ€å¤§çš„è¿ç»­å­æ•°ç»„æ˜¯å“ªä¸€ä¸ªã€‚è¿™æ ·çš„é—®é¢˜é€šå¸¸å¯ä»¥ä½¿ç”¨ã€ŒåŠ¨æ€è§„åˆ’ã€è§£å†³ã€‚ å…³é”® 2ï¼šå¦‚ä½•å®šä¹‰å­é—®é¢˜ï¼ˆå¦‚ä½•å®šä¹‰çŠ¶æ€ï¼‰è®¾è®¡çŠ¶æ€æ€è·¯ï¼šæŠŠä¸ç¡®å®šçš„å› ç´ ç¡®å®šä¸‹æ¥ï¼Œè¿›è€ŒæŠŠå­é—®é¢˜å®šä¹‰æ¸…æ¥šï¼ŒæŠŠå­é—®é¢˜å®šä¹‰å¾—ç®€å•ã€‚åŠ¨æ€è§„åˆ’çš„æ€æƒ³é€šè¿‡è§£å†³äº†ä¸€ä¸ªä¸€ä¸ªç®€å•çš„é—®é¢˜ï¼Œè¿›è€ŒæŠŠç®€å•çš„é—®é¢˜çš„è§£ç»„æˆäº†å¤æ‚çš„é—®é¢˜çš„è§£ã€‚ å‹æƒ…æç¤ºï¼šä¸Šé¢è¿™å¥è¯å¤§å®¶å§‘ä¸”è¿™ä¹ˆä¸€çœ‹ï¼Œè„‘å­é‡Œæœ‰ä¸ªå°è±¡ï¼Œæ²¡æœ‰é‚£ä¹ˆç»å¯¹ã€‚å¯èƒ½ä¸åŒçš„äººçœ‹ä¼šæœ‰ä¸åŒçš„ç†è§£ã€‚å¦‚æœæˆ‘ä»¥åè®²è§£çš„åŠ¨æ€è§„åˆ’çš„è®¾è®¡æ€æƒ³ä¸è¿™é‡Œè®²è§£çš„ã€Œè®¾è®¡çŠ¶æ€æ€è·¯ã€ä¸ä¸€æ ·çš„ï¼Œæˆ‘ä¼šå†å’Œå¤§å®¶è¯´æ˜ã€‚å¦‚æœè®²è§£æœ‰è¯¯å¯¼çš„åœ°æ–¹ï¼Œè¿˜è¯·å¤§å®¶æŒ‡å‡ºã€‚ï¼Œ æˆ‘ä»¬ ä¸çŸ¥é“å’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„ä¸€å®šä¼šé€‰å“ªä¸€ä¸ªæ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ±‚å‡º æ‰€æœ‰ ç»è¿‡è¾“å…¥æ•°ç»„çš„æŸä¸€ä¸ªæ•°çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œã€‚ ä¾‹å¦‚ï¼Œç¤ºä¾‹ 1 è¾“å…¥æ•°ç»„æ˜¯ [-2,1,-3,4,-1,2,1,-5,4] ï¼Œæˆ‘ä»¬å¯ä»¥æ±‚å‡ºä»¥ä¸‹å­é—®é¢˜ï¼š å­é—®é¢˜ 1ï¼šç»è¿‡ -2 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 2ï¼šç»è¿‡ 1 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 3ï¼šç»è¿‡ -3 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 4ï¼šç»è¿‡ 4 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 5ï¼šç»è¿‡ -1 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 6ï¼šç»è¿‡ 2 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 7ï¼šç»è¿‡ 1 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 8ï¼šç»è¿‡ -5 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 9ï¼šç»è¿‡ 4 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ã€‚ä¸€å…± 9 ä¸ªå­é—®é¢˜ï¼Œè¿™äº›å­é—®é¢˜ä¹‹é—´çš„è”ç³»å¹¶æ²¡æœ‰é‚£ä¹ˆå¥½çœ‹å‡ºæ¥ï¼Œè¿™æ˜¯å› ä¸ºå­é—®é¢˜çš„æè¿°è¿˜æœ‰ä¸ç¡®å®šçš„åœ°æ–¹ï¼ˆè¿™ä»¶äº‹æƒ…å«åšã€Œæœ‰åæ•ˆæ€§ã€ï¼Œæˆ‘ä»¬åœ¨æœ¬æ–‡çš„æœ€åä¼šè®²è§£ä»€ä¹ˆæ˜¯ã€Œæ— åæ•ˆæ€§ã€ï¼‰ã€‚ ä¾‹å¦‚ã€Œå­é—®é¢˜ 3ã€ï¼šç»è¿‡ -3 çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ã€‚ ã€Œç»è¿‡ -3 çš„è¿ç»­å­æ•°ç»„ã€æˆ‘ä»¬ä»»æ„ä¸¾å‡ºå‡ ä¸ªï¼š [-2,1,-3,4] ï¼Œ-3 æ˜¯è¿™ä¸ªè¿ç»­å­æ•°ç»„çš„ç¬¬ 3 ä¸ªå…ƒç´ ï¼›[1,-3,4,-1] ï¼Œ-3 æ˜¯è¿™ä¸ªè¿ç»­å­æ•°ç»„çš„ç¬¬ 2 ä¸ªå…ƒç´ ï¼›â€¦â€¦æˆ‘ä»¬ä¸ç¡®å®šçš„æ˜¯ï¼š-3 æ˜¯è¿ç»­å­æ•°ç»„çš„ç¬¬å‡ ä¸ªå…ƒç´ ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±æŠŠ -3 å®šä¹‰æˆè¿ç»­å­æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚åœ¨æ–°çš„å®šä¹‰ä¸‹ï¼Œæˆ‘ä»¬åˆ—å‡ºå­é—®é¢˜å¦‚ä¸‹ï¼š å­é—®é¢˜ 1ï¼šä»¥ -2 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 2ï¼šä»¥ 1 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 3ï¼šä»¥ -3 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 4ï¼šä»¥ 4 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 5ï¼šä»¥ -1 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 6ï¼šä»¥ 2 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 7ï¼šä»¥ 1 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 8ï¼šä»¥ -5 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›å­é—®é¢˜ 9ï¼šä»¥ 4 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ã€‚æˆ‘ä»¬åŠ ä¸Šäº†ã€Œç»“å°¾çš„ã€ï¼Œè¿™äº›å­é—®é¢˜ä¹‹é—´å°±æœ‰äº†è”ç³»ã€‚æˆ‘ä»¬å•ç‹¬çœ‹å­é—®é¢˜ 1 å’Œå­é—®é¢˜ 2ï¼š å­é—®é¢˜ 1ï¼šä»¥ -2 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›ä»¥ -2 ç»“å°¾çš„è¿ç»­å­æ•°ç»„æ˜¯ [-2]ï¼Œå› æ­¤æœ€å¤§å’Œå°±æ˜¯ -2ã€‚ å­é—®é¢˜ 2ï¼šä»¥ 1 ç»“å°¾çš„è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ï¼›ä»¥ 1 ç»“å°¾çš„è¿ç»­å­æ•°ç»„æœ‰ [-2,1] å’Œ [1] ï¼Œå…¶ä¸­ [-2,1] å°±æ˜¯åœ¨ã€Œå­é—®é¢˜ 1ã€çš„åé¢åŠ ä¸Š 1 å¾—åˆ°ã€‚-2 + 1 = -1 &lt; 1âˆ’2+1=âˆ’1&lt;1 ï¼Œå› æ­¤ã€Œå­é—®é¢˜ 2ã€ çš„ç­”æ¡ˆæ˜¯ 1ã€‚ å¤§å®¶å‘ç°äº†å—ï¼Œå¦‚æœç¼–å·ä¸º i çš„å­é—®é¢˜çš„ç»“æœæ˜¯è´Ÿæ•°æˆ–è€… 0 ï¼Œé‚£ä¹ˆç¼–å·ä¸º i + 1 çš„å­é—®é¢˜å°±å¯ä»¥æŠŠç¼–å·ä¸º i çš„å­é—®é¢˜çš„ç»“æœèˆå¼ƒæ‰ï¼ˆè¿™é‡Œ i ä¸ºæ•´æ•°ï¼Œæœ€å°å€¼ä¸º 1 ï¼Œæœ€å¤§å€¼ä¸º 8ï¼‰ï¼Œè¿™æ˜¯å› ä¸ºï¼š ä¸€ä¸ªæ•° a åŠ ä¸Šè´Ÿæ•°çš„ç»“æœæ¯” a æ›´å°ï¼›ä¸€ä¸ªæ•° a åŠ ä¸Š 0 çš„ç»“æœä¸ä¼šæ¯” a æ›´å¤§ï¼›è€Œå­é—®é¢˜çš„å®šä¹‰å¿…é¡»ä»¥ä¸€ä¸ªæ•°ç»“å°¾ï¼Œå› æ­¤å¦‚æœå­é—®é¢˜ i çš„ç»“æœæ˜¯è´Ÿæ•°æˆ–è€… 0ï¼Œé‚£ä¹ˆå­é—®é¢˜ i + 1 çš„ç­”æ¡ˆå°±æ˜¯ä»¥ nums[i] ç»“å°¾çš„é‚£ä¸ªæ•°ã€‚å› ä¸ºæˆ‘ä»¬æŠŠå­é—®é¢˜å®šä¹‰çš„æ›´æ¸…æ¥šï¼Œå­é—®é¢˜ä¹‹é—´çš„è”ç³»å°±å®¹æ˜“è§‚å¯Ÿåˆ°ã€‚è¿™æ˜¯æˆ‘ä»¬å®šä¹‰å­é—®é¢˜ã€å®šä¹‰çŠ¶æ€çš„ç»éªŒã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬æŒ‰ç…§ç¼–å†™åŠ¨æ€è§„åˆ’é¢˜è§£çš„æ­¥éª¤ï¼ŒæŠŠã€ŒçŠ¶æ€å®šä¹‰ã€ã€ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€ã€Œåˆå§‹åŒ–ã€ã€Œè¾“å‡ºã€ã€Œæ˜¯å¦å¯ä»¥ç©ºé—´ä¼˜åŒ–ã€å…¨éƒ½å†™å‡ºæ¥ã€‚ å®šä¹‰çŠ¶æ€ï¼ˆå®šä¹‰å­é—®é¢˜ï¼‰dp[i]ï¼šè¡¨ç¤ºä»¥ nums[i] ç»“å°¾ çš„ è¿ç»­ å­æ•°ç»„çš„æœ€å¤§å’Œã€‚ è¯´æ˜ï¼šã€Œç»“å°¾ã€å’Œã€Œè¿ç»­ã€æ˜¯å…³é”®å­—ã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼ˆæè¿°å­é—®é¢˜ä¹‹é—´çš„è”ç³»ï¼‰æ ¹æ®çŠ¶æ€çš„å®šä¹‰ï¼Œç”±äº nums[i] ä¸€å®šä¼šè¢«é€‰å–ï¼Œå¹¶ä¸”ä»¥ nums[i] ç»“å°¾çš„è¿ç»­å­æ•°ç»„ä¸ä»¥ nums[i - 1] ç»“å°¾çš„è¿ç»­å­æ•°ç»„åªç›¸å·®ä¸€ä¸ªå…ƒç´  nums[i] ã€‚ å‡è®¾æ•°ç»„ nums çš„å€¼å…¨éƒ½ä¸¥æ ¼å¤§äº 0ï¼Œé‚£ä¹ˆä¸€å®šæœ‰ dp[i] = dp[i - 1] + nums[i]ã€‚ å¯æ˜¯ dp[i - 1] æœ‰å¯èƒ½æ˜¯è´Ÿæ•°ï¼Œäºæ˜¯åˆ†ç±»è®¨è®ºï¼š å¦‚æœ dp[i - 1] &gt; 0ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠ nums[i] ç›´æ¥æ¥åœ¨ dp[i - 1] è¡¨ç¤ºçš„é‚£ä¸ªæ•°ç»„çš„åé¢ï¼Œå¾—åˆ°å’Œæ›´å¤§çš„è¿ç»­å­æ•°ç»„ï¼›å¦‚æœ dp[i - 1] &lt;= 0ï¼Œé‚£ä¹ˆ nums[i] åŠ ä¸Šå‰é¢çš„æ•° dp[i - 1] ä»¥åå€¼ä¸ä¼šå˜å¤§ã€‚äºæ˜¯ dp[i] ã€Œå¦èµ·ç‚‰ç¶ã€ï¼Œæ­¤æ—¶å•ç‹¬çš„ä¸€ä¸ª nums[i] çš„å€¼ï¼Œå°±æ˜¯ dp[i]ã€‚ æ€è€ƒåˆå§‹å€¼dp[0] æ ¹æ®å®šä¹‰ï¼Œåªæœ‰ 1 ä¸ªæ•°ï¼Œä¸€å®šä»¥ nums[0] ç»“å°¾ï¼Œå› æ­¤ dp[0] = nums[0]ã€‚ æ€è€ƒè¾“å‡ºæ³¨æ„ï¼š è¿™é‡ŒçŠ¶æ€çš„å®šä¹‰ä¸æ˜¯é¢˜ç›®ä¸­çš„é—®é¢˜çš„å®šä¹‰ï¼Œä¸èƒ½ç›´æ¥å°†æœ€åä¸€ä¸ªçŠ¶æ€è¿”å›å›å»ï¼›123456789101112131415class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: size = len(nums) if size == 0: return 0 dp = [0 for _ in range(size)] dp[0] = nums[0] for i in range(1, size): if dp[i - 1] &gt;= 0: dp[i] = dp[i - 1] + nums[i] else: dp[i] = nums[i] return max(dp)"},{"title":"665. Non-decreasing Array(medium)","path":"2022/06/13/665/","text":"665. Non-decreasing Array(medium)Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).é¢˜ç›®æè¿°ï¼šåˆ¤æ–­ä¸€ä¸ªæ•°ç»„æ˜¯å¦èƒ½åªä¿®æ”¹ä¸€ä¸ªæ•°å°±æˆä¸ºéé€’å‡æ•°ç»„ã€‚ 123Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. è¿™é“é¢˜çš„å…³é”®åœ¨äºä¿®æ”¹å“ªä¸ªæ•°ï¼Œæœ¬é¢˜åœ¨å‡ºç° nums[i] &lt; nums[i - 1] æ—¶ï¼Œéœ€è¦è€ƒè™‘çš„æ˜¯åº”è¯¥ä¿®æ”¹æ•°ç»„çš„å“ªä¸ªæ•°ï¼Œä½¿å¾—æœ¬æ¬¡ä¿®æ”¹èƒ½ä½¿ i ä¹‹å‰çš„æ•°ç»„æˆä¸ºéé€’å‡æ•°ç»„ï¼Œå¹¶ä¸” ä¸å½±å“åç»­çš„æ“ä½œ ã€‚ä¼˜å…ˆè€ƒè™‘ä»¤ nums[i - 1] = nums[i]ï¼Œå› ä¸ºå¦‚æœä¿®æ”¹ nums[i] = nums[i - 1] çš„è¯ï¼Œé‚£ä¹ˆ nums[i] è¿™ä¸ªæ•°ä¼šå˜å¤§ï¼Œå°±æœ‰å¯èƒ½æ¯” nums[i + 1] å¤§ï¼Œä»è€Œå½±å“äº†åç»­æ“ä½œã€‚è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒç‰¹åˆ«çš„æƒ…å†µå°±æ˜¯ nums[i] &lt; nums[i - 2]ï¼Œä¿®æ”¹ nums[i - 1] = nums[i] ä¸èƒ½ä½¿æ•°ç»„æˆä¸ºéé€’å‡æ•°ç»„ï¼Œåªèƒ½ä¿®æ”¹ nums[i] = nums[i - 1]ã€‚ æ€è·¯:nums[i] &lt; nums[i - 1]: nums[i - 1] = nums[i]nums[i] &lt; nums[i - 2]: nums[i] = nums[i - 1] 1234567891011121314class Solution: def checkPossibility(self, nums: List[int]) -&gt; bool: cnt = 0 for i in range(1,len(nums)): if nums[i]&lt;nums[i-2] and i-2&gt;=0 : nums[i]=nums[i-1] cnt+=1 if nums[i]&lt;nums[i-1]: nums[i-1]= nums[i] cnt+=1 if cnt&lt;=1: return True"},{"title":"392. Is Subsequence (Medium)","path":"2022/06/13/392/","text":"392. Is Subsequence (Medium)Given two strings s and t, return true if s is a subsequence of t, or false otherwise.A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., â€œaceâ€ is a subsequence of â€œabcdeâ€ while â€œaecâ€ is not).æœ¬é¢˜è¯¢é—®çš„æ˜¯ï¼Œs æ˜¯å¦æ˜¯ t çš„å­åºåˆ—ï¼Œå› æ­¤åªè¦èƒ½æ‰¾åˆ°ä»»æ„ä¸€ç§ s åœ¨ t ä¸­å‡ºç°çš„æ–¹å¼ï¼Œå³å¯è®¤ä¸º s æ˜¯ t çš„å­åºåˆ—ã€‚ è€Œå½“æˆ‘ä»¬ä»å‰å¾€ååŒ¹é…ï¼Œå¯ä»¥å‘ç°æ¯æ¬¡è´ªå¿ƒåœ°åŒ¹é…é å‰çš„å­—ç¬¦æ˜¯æœ€ä¼˜å†³ç­–ã€‚ è¿™æ ·ï¼Œæˆ‘ä»¬åˆå§‹åŒ–ä¸¤ä¸ªæŒ‡é’ˆ i å’Œ jï¼Œåˆ†åˆ«æŒ‡å‘ s å’Œ t çš„åˆå§‹ä½ç½®ã€‚æ¯æ¬¡è´ªå¿ƒåœ°åŒ¹é…ï¼ŒåŒ¹é…æˆåŠŸåˆ™ i å’Œ j åŒæ—¶å³ç§»ï¼ŒåŒ¹é… s çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼ŒåŒ¹é…å¤±è´¥åˆ™ j å³ç§»ï¼Œi ä¸å˜ï¼Œå°è¯•ç”¨ t çš„ä¸‹ä¸€ä¸ªå­—ç¬¦åŒ¹é… sã€‚ æœ€ç»ˆå¦‚æœ i ç§»åŠ¨åˆ° s çš„æœ«å°¾ï¼Œå°±è¯´æ˜ s æ˜¯ t çš„å­åºåˆ—ã€‚ Example 12Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;Output: true 12345678910111213class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: i=j=0 while i&lt;len(s) and j&lt;len(t): if s[i]==t[j]: i+=1 j+=1 else: j+=1 if i==len(s): return True è‡ªå·±å†™çš„åŒæŒ‡é’ˆ 12345678910111213class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: if len(s)&gt;len(t): return False if len(s)==0: return True resultword= 0 for i in range(0,len(t)): if resultword&lt;= len(s)-1: if s[resultword] == t[i]: resultword+=1 return resultword == len(s)"},{"title":"605. Can Place Flowers (Easy)","path":"2022/06/11/605/","text":"605. Can Place Flowers (Easy)You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.Given an integer array flowerbed containing 0â€™s and 1â€™s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.leetcodeå®˜è§£è¯„è®º éå¸¸å·§å¦™çš„æ–¹æ³•ï¼Œç”¨æ•°å­¦å½’çº³æ³•å¾ˆå®¹æ˜“æ¨å‡ºæ¥å…¬å¼ ç»Ÿè®¡è¿ç»­çš„0çš„åŒºé—´ï¼Œåˆ†åˆ«æœ‰å¤šå°‘ä¸ªè¿ç»­çš„0å³å¯ã€‚å¯¹äºæ¯ä¸€æ®µ0åŒºé—´ï¼Œéƒ½å¯ä»¥æ ¹æ®å…¬å¼ç›´æ¥ç®—å‡ºå¯ä»¥ç§å‡ æœµèŠ±ã€‚ å…¬å¼å¯ä»¥é€šè¿‡æ•°å­¦å½’çº³æ³•æ¨å‡ºæ¥ï¼Œå¾ˆç®€å•ï¼š å¯¹äºä¸­é—´çš„0åŒºé—´ï¼š 1~2ä¸ª0ï¼šå¯ç§0æœµï¼› 3~4ä¸ªï¼šå¯ç§1æœµï¼› 5~6ä¸ªï¼šå¯ç§2æœµï¼› â€¦ countä¸ªï¼šå¯ç§ (count-1)/2 æœµ å¯¹äºä¸¤å¤´çš„0åŒºé—´ï¼Œç”±äºå·¦è¾¹ã€å³è¾¹åˆ†åˆ«æ²¡æœ‰1çš„é™åˆ¶ï¼Œå¯ç§èŠ±æœµæ•°ç¨æœ‰ä¸åŒã€‚ ä¸ºäº†ä»£ç æµç¨‹çš„ç»Ÿä¸€ï¼Œå¯ä»¥åœ¨æ•°ç»„æœ€å·¦è¾¹ã€æ•°ç»„æœ€å³è¾¹åˆ†åˆ«è¡¥1ä¸ª0ï¼Œæ„å‘³ç€èŠ±å›å·¦è¾¹ã€å³è¾¹æ²¡æœ‰èŠ±ã€‚ è¿™æ ·å…¬å¼å°±è·Ÿ1ç›¸åŒäº†ã€‚ 1234567891011121314151617181920class Solution: def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool: if not flowerbed: return 0 countofZero = 1 # å½“å‰å…¨0åŒºæ®µä¸­è¿ç»­0çš„æ•°é‡ï¼Œåˆšå¼€å§‹é¢„è®¾1ä¸ª0ï¼Œå› ä¸ºå¼€å¤´èŠ±å›çš„æœ€å·¦è¾¹æ²¡æœ‰èŠ±ï¼Œå¯ä»¥è®¤ä¸ºå­˜åœ¨ä¸€ä¸ªè™šæ— çš„0 canPlace = 0 # å¯ä»¥ç§çš„èŠ±çš„æ•°é‡ for bed in flowerbed: if bed == 0: # é‡åˆ°0ï¼Œè¿ç»­0çš„æ•°é‡+1 countofZero += 1 else: #é‡åˆ°1ï¼Œç»“ç®—ä¸Šä¸€æ®µè¿ç»­çš„0åŒºé—´ï¼Œçœ‹èƒ½ç§ä¸‹å‡ ç›†èŠ±ï¼š(countofZero-1)/2 canPlace += int((countofZero-1)/2) if canPlace &gt;= n: return True countofZero = 0; # 0çš„æ•°é‡æ¸…é›¶ï¼Œå¼€å§‹ç»Ÿè®¡ä¸‹ä¸€ä¸ªå…¨0åˆ†åŒº #æœ€åä¸€æ®µ0åŒºè¿˜æœªç»“ç®—ï¼š countofZero += 1# æœ€åå†é¢„è®¾1ä¸ª0ï¼Œå› ä¸ºæœ€åèŠ±å›çš„æœ€å³è¾¹æ²¡æœ‰èŠ±ï¼Œå¯ä»¥è®¤ä¸ºå­˜åœ¨ä¸€ä¸ªè™šæ— çš„0 canPlace += (countofZero-1)/2 if canPlace &gt;= n: return True"},{"title":"123. Best Time to Buy and Sell Stock III(hard)","path":"2022/06/11/123/","text":"123. Best Time to Buy and Sell Stock III(hard)You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).1234Input: prices = [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. å–è‚¡ç¥¨ç¬¬ä¸‰å¼¹ï¼ˆhardé¢˜äº†ï¼‰ å–è‚¡ç¥¨ä¸€å…±å…­é¢˜ï¼Œåˆ†åˆ«æ˜¯122,123,188,309,714 å’Œç¬¬äºŒé¢˜å·®ä¸å¤šï¼Œä½†æ˜¯é™åˆ¶äº†æœ€å¤šä¸¤æ¬¡äº¤æ˜“ï¼Œä¹‹å‰çš„å°æŠ€å·§æœ‰äº›ç”¨ä¸ä¸Šäº†ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—èµ°åŠ¨æ€è§„åˆ’çš„è·¯å­ã€‚ å®˜æ–¹é¢˜è§£æ€è·¯ä¸ç®—æ³• ç”±äºæˆ‘ä»¬æœ€å¤šå¯ä»¥å®Œæˆä¸¤ç¬”äº¤æ˜“ï¼Œå› æ­¤åœ¨ä»»æ„ä¸€å¤©ç»“æŸä¹‹åï¼Œæˆ‘ä»¬ä¼šå¤„äºä»¥ä¸‹äº”ä¸ªçŠ¶æ€ä¸­çš„ä¸€ç§ï¼š æœªè¿›è¡Œè¿‡ä»»ä½•æ“ä½œï¼› åªè¿›è¡Œè¿‡ä¸€æ¬¡ä¹°æ“ä½œï¼› è¿›è¡Œäº†ä¸€æ¬¡ä¹°æ“ä½œå’Œä¸€æ¬¡å–æ“ä½œï¼Œå³å®Œæˆäº†ä¸€ç¬”äº¤æ˜“ï¼› åœ¨å®Œæˆäº†ä¸€ç¬”äº¤æ˜“çš„å‰æä¸‹ï¼Œè¿›è¡Œäº†ç¬¬äºŒæ¬¡ä¹°æ“ä½œï¼› å®Œæˆäº†å…¨éƒ¨ä¸¤ç¬”äº¤æ˜“ã€‚ ç”±äºç¬¬ä¸€ä¸ªçŠ¶æ€çš„åˆ©æ¶¦æ˜¾ç„¶ä¸º 0ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ç”¨å°†å…¶è®°å½•ã€‚å¯¹äºå‰©ä¸‹çš„å››ä¸ªçŠ¶æ€ï¼Œæˆ‘ä»¬åˆ†åˆ«å°†å®ƒä»¬çš„æœ€å¤§åˆ©æ¶¦è®°ä¸º buy1,sell1,,buy2,sell2 12345678910111213class Solution: def maxProfit(self, prices: List[int]) -&gt; int: n = len(prices) buy1 = buy2 = -prices[0] sell1 = sell2 = 0 for i in range(1, n): buy1 = max(buy1, -prices[i]) sell1 = max(sell1, buy1 + prices[i]) buy2 = max(buy2, sell1 - prices[i]) sell2 = max(sell2, buy2 + prices[i]) return sell2"},{"title":"122. Best Time to Buy and Sell Stock II (Easy)","path":"2022/06/11/122/","text":"122. Best Time to Buy and Sell Stock II (Easy)You are given an integer array prices where prices[i] is the price of a given stock on the ith day.On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.Find and return the maximum profit you can achieve.å–è‚¡ç¥¨ç¬¬äºŒå¼¹ å–è‚¡ç¥¨ä¸€å…±å…­é¢˜ï¼Œåˆ†åˆ«æ˜¯122,123,188,309,714 ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ prices ï¼Œå…¶ä¸­ prices[i] è¡¨ç¤ºæŸæ”¯è‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ åœ¨æ¯ä¸€å¤©ï¼Œä½ å¯ä»¥å†³å®šæ˜¯å¦è´­ä¹°å’Œ/æˆ–å‡ºå”®è‚¡ç¥¨ã€‚ä½ åœ¨ä»»ä½•æ—¶å€™æœ€å¤šåªèƒ½æŒæœ‰ä¸€è‚¡è‚¡ç¥¨ã€‚ä½ ä¹Ÿå¯ä»¥å…ˆè´­ä¹°ï¼Œç„¶ååœ¨ åŒä¸€å¤© å‡ºå”®ã€‚ è¿”å› ä½ èƒ½è·å¾—çš„ æœ€å¤§åˆ©æ¶¦ ã€‚ è¿™ä¸€é¢˜ä¸€æ ·æ˜¯å¯ä»¥ç”¨è´ªå¿ƒç®—æ³•æˆ–è€…åŠ¨æ€è§„åˆ’å†™çš„ï¼Œä½†æ˜¯æˆ‘åœ¨å®˜æ–¹é¢˜è§£è¯„è®ºåŒºå‘ç°ä¸€ä¸ªæå…¶ç®€å•çš„å°æŠ€å·§ã€‚åœ¨æœ¬é¢˜ä¸­ä¹°å–éƒ½æ˜¯æ— é™æ¬¡çš„ï¼Œæ‰€ä»¥åªè¦æŠŠç›ˆåˆ©ï¼ˆä¹Ÿå°±æ˜¯ä¸Šå‡æ®µï¼‰å…¨éƒ¨åŠ åœ¨ä¸€èµ·å°±å¯ä»¥äº†ï¼Œç›¸å½“äºæ¯éš”ä¸€å¤©ç®—ä¸€æ¬¡ç›ˆåˆ©ï¼Œç›ˆåˆ©ä¸ºæ­£ç®—åœ¨æ€»åˆ©æ¶¦é‡Œï¼Œç›ˆåˆ©ä¸ºè´Ÿå°±ä¸¢æ‰ã€‚ ç®€å•æ¥è¯´å°±æ˜¯åªè¦æŠŠæ‰€æœ‰çš„ç›ˆåˆ©åŠ åœ¨ä¸€èµ·ã€‚ 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: res = 0 i = 1 for i in range(1,len(prices)): if prices[i]-prices[i-1]&gt;0: res += prices[i]-prices[i-1] return res"},{"title":"121. Best Time to Buy and Sell Stock (Easy)","path":"2022/06/11/121/","text":"121. Best Time to Buy and Sell Stock (Easy)You are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.å…¶å®è¿™é¢˜æ˜¯åŠ¨æ€è§„åˆ’çš„é—®é¢˜.å–è‚¡ç¥¨ä¸€å…±å…­é¢˜ï¼Œåˆ†åˆ«æ˜¯121,122,123,188,309,714 å®˜æ–¹é¢˜è§£ 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: minprice = float(&#x27;inf&#x27;) #float(&#x27;inf&#x27;)è¡¨ç¤ºæ­£æ— ç©·å¤§ maxprofit = 0 #ä¿å­˜å½“å‰æœ€å¤§çš„åˆ©æ¶¦ for price in prices: #ä¸€æ¬¡éå† maxprofit = max(price - minprice, maxprofit)#å½“å‰åˆ©æ¶¦ä¸æœ€å¤§çš„åˆ©æ¶¦ç›¸æ¯” minprice = min(price, minprice) #ä¿å­˜å½“å‰æœ€å°çš„ä»·æ ¼ return maxprofit"},{"title":"406. Queue Reconstruction by Height(Medium)","path":"2022/06/11/406/","text":"406. Queue Reconstruction by Height(Medium)You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).Example123456Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] é¢˜ç›®æè¿°ï¼šæ•´æ•°å¯¹ (h, k) è¡¨ç¤ºï¼Œå…¶ä¸­ h æ˜¯è¿™ä¸ªäººçš„èº«é«˜ï¼Œk æ˜¯æ’åœ¨è¿™ä¸ªäººå‰é¢ä¸”èº«é«˜å¤§äºæˆ–ç­‰äº h çš„äººæ•°ã€‚ æ¸”ï¼ˆå¥—è·¯ï¼‰ï¼šä¸€èˆ¬è¿™ç§æ•°å¯¹ï¼Œè¿˜æ¶‰åŠæ’åºçš„ï¼Œæ ¹æ®ç¬¬ä¸€ä¸ªå…ƒç´ æ­£å‘æ’åºï¼Œæ ¹æ®ç¬¬äºŒä¸ªå…ƒç´ åå‘æ’åºï¼Œæˆ–è€…æ ¹æ®ç¬¬ä¸€ä¸ªå…ƒç´ åå‘æ’åºï¼Œæ ¹æ®ç¬¬äºŒä¸ªå…ƒç´ æ­£å‘æ’åºï¼Œå¾€å¾€èƒ½å¤Ÿç®€åŒ–è§£é¢˜è¿‡ç¨‹ã€‚ åœ¨æœ¬é¢˜ç›®ä¸­ï¼Œé¦–å…ˆå¯¹æ•°å¯¹è¿›è¡Œæ’åºï¼ŒæŒ‰ç…§æ•°å¯¹çš„å…ƒç´  1(èº«é«˜) é™åºæ’åºï¼ŒæŒ‰ç…§æ•°å¯¹çš„å…ƒç´  2 (äººæ•°)å‡åºæ’åºã€‚åŸå› æ˜¯ï¼ŒæŒ‰ç…§å…ƒç´  1 è¿›è¡Œé™åºæ’åºï¼Œå¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œåœ¨å…¶ä¹‹å‰çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œå°±æ˜¯å¤§äºç­‰äºä»–çš„å…ƒç´ çš„æ•°é‡ï¼Œè€ŒæŒ‰ç…§ç¬¬äºŒä¸ªå…ƒç´ æ­£å‘æ’åºï¼Œæˆ‘ä»¬å¸Œæœ› k å¤§çš„å°½é‡åœ¨åé¢ï¼Œå‡å°‘æ’å…¥æ“ä½œçš„æ¬¡æ•°ã€‚ leetcodeé¢˜è§£ æ³¨ï¼š 1key = lambda x: (-x[0], x[1])) ç¬¬ä¸€ä¸ªå…ƒç´ é™åºï¼Œç¬¬äºŒä¸ªå…ƒç´ å‡åºæ’åˆ—ï¼Œä»¥ç¬¬ä¸€ä¸ªå…ƒç´ çš„é™åºæ’åˆ—ä¼˜å…ˆ ä¾‹å­12345678A = [[1,4],[2,3],[3,4],[1,3],[1,2]]print(sorted(A,key=lambda x:x[1]))print(sorted(A,key = lambda x: (-x[0], x[1])))print(sorted(A,key = lambda x: (-x[0]))) ç»“æœ1234[[1, 2], [2, 3], [1, 3], [1, 4], [3, 4]][[3, 4], [2, 3], [1, 2], [1, 3], [1, 4]][[3, 4], [2, 3], [1, 4], [1, 3], [1, 2]] æœ¬é¢˜ä¾‹å­1[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] æ‰€ä»¥æ’åºå®Œï¼š 1[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]] 1234567891011class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: res = [] people = sorted(people, key = lambda x: (-x[0], x[1])) #æ’åº for p in people: if len(res) &lt;= p[1]: #æ¯”è¾ƒçš„å˜é‡æ˜¯å½“å‰æ•°ç»„çš„é•¿åº¦ res.append(p) elif len(res) &gt; p[1]: res.insert(p[1], p) # p is inserted at index p[1]ï¼ˆå‚ä¸è¿™æ¬¡æ’åºçš„P[1]) return res 123456789101112131415class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: if not people: return 0 people.sort(key=lambda balloon: balloon[1]) pos = people[0][1] ans = 1 for balloon in people: if balloon[0] &gt; pos: pos = balloon[1] ans += 1 return ans"},{"title":"452. Minimum Number of Arrows to Burst Balloons (Medium)","path":"2022/06/10/452/","text":"452. Minimum Number of Arrows to Burst Balloons (Medium)There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.Given the array points, return the minimum number of arrows that must be shot to burst all balloons.é¢˜ç›®æè¿°ï¼šæ°”çƒåœ¨ä¸€ä¸ªæ°´å¹³æ•°è½´ä¸Šæ‘†æ”¾ï¼Œå¯ä»¥é‡å ï¼Œé£é•–å‚ç›´æŠ•å‘åæ ‡è½´ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ°”çƒéƒ½è¢«åˆºç ´ã€‚æ±‚è§£æœ€å°çš„æŠ•é£é•–æ¬¡æ•°ä½¿æ‰€æœ‰æ°”çƒéƒ½è¢«åˆºç ´ã€‚ ä¹Ÿæ˜¯è®¡ç®—ä¸é‡å çš„åŒºé—´ä¸ªæ•°ï¼Œä¸è¿‡å’Œ Non-overlapping points çš„åŒºåˆ«åœ¨äºï¼Œ[1, 2] å’Œ [2, 3] åœ¨æœ¬é¢˜ä¸­ç®—æ˜¯é‡å åŒºé—´ã€‚ Example 12345Input:[[10,16], [2,8], [1,6], [7,12]]Output:2 æ’åº + è´ªå¿ƒè¿™é“é¢˜å’Œ 435. Non-overlapping Intervals (Medium) æœ‰äº›ç±»ä¼¼ï¼Œéƒ½æ˜¯å¯»æ‰¾é‡åˆåŒºé—´ è´ªå¿ƒï¼šæ—¢ç„¶æ¯ä¸ªæ°”çƒéƒ½éœ€è¦è¢«å¼•çˆ†ï¼Œé‚£ä¹ˆåœ¨æ»¡è¶³å¼•çˆ†å¯¹ç®­é™åˆ¶æœ€å¤§çš„é‚£ä¸ªæ°”çƒï¼ˆå› ä¸ºå®ƒä¸€å®šè¦è¢«å¼•çˆ†ï¼Œè€Œç®­å’Œå…¶å®ƒåŒæ—¶è¢«å¼•çˆ†çš„æ°”çƒ éƒ½å¯ä»¥è¿å°±å®ƒï¼Œæ‰€ä»¥æ»¡è¶³å®ƒæ˜¯å¿…é¡»çš„ï¼‰ çš„åŒæ—¶ï¼Œå¼•çˆ†å°½å¯èƒ½å¤šå…¶ä»–çš„æ°”çƒã€‚ åœ¨ä»˜å‡ºä¸å˜çš„çš„å‰æä¸‹ï¼Œè·å¾—å°½å¯èƒ½å¤šã€‚ ç®€å•æ¥è¯´å°±æ˜¯å…ˆæŒ‰ç…§åŒºé—´å³è¾¹è¾¹ç•Œä»å°åˆ°å¤§æ’åºï¼Œä¸ºäº†å°½å¯èƒ½çš„å¤šå¼•çˆ†æ°”çƒï¼Œç¬¬ä¸€æ”¯ç®­å°„åœ¨ç¬¬ä¸€ä¸ªåŒºé—´çš„æœ€å³è¾¹ï¼Œæ ¹æ®åé¢åŒºé—´çš„å·¦ç«¯ç‚¹åˆ¤æ–­ä¸€å…±å¼•çˆ†äº†å“ªäº›åŒºé—´ï¼Œå¹¶ä»å‰©ä¸‹æœªè¢«å¼•çˆ†çš„æ°”çƒä¸­ï¼Œå†é€‰æ‹©å³è¾¹ç•Œä½ç½®æœ€é å·¦çš„é‚£ä¸€ä¸ªï¼Œç¡®å®šä¸‹ä¸€æ”¯ç®­ï¼Œç›´åˆ°æ‰€æœ‰çš„æ°”çƒéƒ½è¢«å¼•çˆ†ã€‚ æœ‰ä¸ªé—®é¢˜æ˜¯è¿™ nn ä¸ªæ°”çƒå¯¹åº”çš„åŒºé—´äº’ä¸é‡å ï¼Œwhile å¾ªç¯éœ€è¦æ‰§è¡Œ n æ¬¡ã€‚æ‰€ä»¥å½“é‡åˆ°x(j) â‰¤ y(i)æ—¶ æˆ‘ä»¬å¯ä»¥ç›´æ¥è·³å‡ºå¾ªç¯ï¼Œy(j)å°±æ˜¯ä¸‹ä¸€ä¸ªç®­çš„ä½ç½®ã€‚ å®˜æ–¹é¢˜è§£ 1234567891011121314class Solution: def findMinArrowShots(self, points: List[List[int]]) -&gt; int: if not points: return 0 points.sort(key=lambda balloon: balloon[1]) pos = points[0][1] ans = 1 for balloon in points: if balloon[0] &gt; pos: pos = balloon[1] ans += 1 return ans"},{"title":"435. Non-overlapping Intervals (Medium)","path":"2022/06/09/435/","text":"435. Non-overlapping Intervals (Medium)Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.ç»™å®šä¸€ä¸ªåŒºé—´çš„é›†åˆ intervals ï¼Œå…¶ä¸­ intervals[i] = [starti, endi] ã€‚è¿”å› éœ€è¦ç§»é™¤åŒºé—´çš„æœ€å°æ•°é‡ï¼Œä½¿å‰©ä½™åŒºé—´äº’ä¸é‡å  ã€‚ è¾“å…¥: intervals = [[1,2],[2,3],[3,4],[1,3]]è¾“å‡º: 1è§£é‡Š: ç§»é™¤ [1,3] åï¼Œå‰©ä¸‹çš„åŒºé—´æ²¡æœ‰é‡å ã€‚ é¢˜ç›®æè¿°ï¼šè®¡ç®—è®©ä¸€ç»„åŒºé—´ä¸é‡å æ‰€éœ€è¦ç§»é™¤çš„åŒºé—´ä¸ªæ•°ã€‚ å…ˆè®¡ç®—æœ€å¤šèƒ½ç»„æˆçš„ä¸é‡å åŒºé—´ä¸ªæ•°ï¼Œç„¶åç”¨åŒºé—´æ€»ä¸ªæ•°å‡å»ä¸é‡å åŒºé—´çš„ä¸ªæ•°ã€‚ åœ¨æ¯æ¬¡é€‰æ‹©ä¸­ï¼ŒåŒºé—´çš„ç»“å°¾æœ€ä¸ºé‡è¦ï¼Œé€‰æ‹©çš„åŒºé—´ç»“å°¾è¶Šå°ï¼Œç•™ç»™åé¢çš„åŒºé—´çš„ç©ºé—´è¶Šå¤§ï¼Œé‚£ä¹ˆåé¢èƒ½å¤Ÿé€‰æ‹©çš„åŒºé—´ä¸ªæ•°ä¹Ÿå°±è¶Šå¤§ã€‚ æŒ‰åŒºé—´çš„ç»“å°¾è¿›è¡Œæ’åºï¼Œæ¯æ¬¡é€‰æ‹©ç»“å°¾æœ€å°ï¼Œå¹¶ä¸”å’Œå‰ä¸€ä¸ªåŒºé—´ä¸é‡å çš„åŒºé—´ã€‚ å®˜æ–¹é¢˜è§£ 12345678910111213141516class Solution: def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int: if not intervals: return 0 intervals.sort(key=lambda x: x[1]) n = len(intervals) right = intervals[0][1] ans = 1 for i in range(1, n): if intervals[i][0] &gt;= right: ans += 1 right = intervals[i][1] return n - ans æ³¨é‡Šï¼škey=lambda å…ƒç´ : å…ƒç´ [å­—æ®µç´¢å¼•] æ¯”å¦‚ print(sorted(C, key=lambda x: x[2])) x:x[]å­—æ¯å¯ä»¥éšæ„ä¿®æ”¹ï¼Œæ’åºæ–¹å¼æŒ‰ç…§ä¸­æ‹¬å·[]é‡Œé¢çš„ç»´åº¦è¿›è¡Œæ’åºï¼Œ[0]æŒ‰ç…§ç¬¬ä¸€ç»´æ’åºï¼Œ[2]æŒ‰ç…§ç¬¬ä¸‰ç»´æ’åº ä¾‹å­ 1234567C = [(&#x27;e&#x27;, 4, 2), (&#x27;a&#x27;, 2, 1), (&#x27;c&#x27;, 5, 4), (&#x27;b&#x27;, 3, 3), (&#x27;d&#x27;, 1, 5)]print(sorted(C, key=lambda y: y[0]))#è¾“å‡º[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]print(sorted(C, key=lambda x: x[0]))#[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]print(sorted(C, key=lambda x: x[2]))[(&#x27;a&#x27;, 2, 1), (&#x27;e&#x27;, 4, 2), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5)]"},{"title":"455. Assign Cookies (Easy)","path":"2022/06/09/455/","text":"455. Assign Cookies (Easy)Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.é¢˜ç›®æè¿°ï¼šæ¯ä¸ªå­©å­éƒ½æœ‰ä¸€ä¸ªæ»¡è¶³åº¦ gridï¼Œæ¯ä¸ªé¥¼å¹²éƒ½æœ‰ä¸€ä¸ªå¤§å° sizeï¼Œåªæœ‰é¥¼å¹²çš„å¤§å°å¤§äºç­‰äºä¸€ä¸ªå­©å­çš„æ»¡è¶³åº¦ï¼Œè¯¥å­©å­æ‰ä¼šè·å¾—æ»¡è¶³ã€‚æ±‚è§£æœ€å¤šå¯ä»¥è·å¾—æ»¡è¶³çš„å­©å­æ•°é‡ã€‚ ç»™ä¸€ä¸ªå­©å­çš„é¥¼å¹²åº”å½“å°½é‡å°å¹¶ä¸”åˆèƒ½æ»¡è¶³è¯¥å­©å­ï¼Œè¿™æ ·å¤§é¥¼å¹²æ‰èƒ½æ‹¿æ¥ç»™æ»¡è¶³åº¦æ¯”è¾ƒå¤§çš„å­©å­ã€‚å› ä¸ºæ»¡è¶³åº¦æœ€å°çš„å­©å­æœ€å®¹æ˜“å¾—åˆ°æ»¡è¶³ï¼Œæ‰€ä»¥å…ˆæ»¡è¶³æ»¡è¶³åº¦æœ€å°çš„å­©å­ã€‚åœ¨ä»¥ä¸Šçš„è§£æ³•ä¸­ï¼Œæˆ‘ä»¬åªåœ¨æ¯æ¬¡åˆ†é…æ—¶é¥¼å¹²æ—¶é€‰æ‹©ä¸€ç§çœ‹èµ·æ¥æ˜¯å½“å‰æœ€ä¼˜çš„åˆ†é…æ–¹æ³•ï¼Œä½†æ— æ³•ä¿è¯è¿™ç§å±€éƒ¨æœ€ä¼˜çš„åˆ†é…æ–¹æ³•æœ€åèƒ½å¾—åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚æˆ‘ä»¬å‡è®¾èƒ½å¾—åˆ°å…¨å±€æœ€ä¼˜è§£ï¼Œå¹¶ä½¿ç”¨åè¯æ³•è¿›è¡Œè¯æ˜ï¼Œå³å‡è®¾å­˜åœ¨ä¸€ç§æ¯”æˆ‘ä»¬ä½¿ç”¨çš„è´ªå¿ƒç­–ç•¥æ›´ä¼˜çš„æœ€ä¼˜ç­–ç•¥ã€‚å¦‚æœä¸å­˜åœ¨è¿™ç§æœ€ä¼˜ç­–ç•¥ï¼Œè¡¨ç¤ºè´ªå¿ƒç­–ç•¥å°±æ˜¯æœ€ä¼˜ç­–ç•¥ï¼Œå¾—åˆ°çš„è§£ä¹Ÿå°±æ˜¯å…¨å±€æœ€ä¼˜è§£ã€‚ è¯æ˜ï¼šå‡è®¾åœ¨æŸæ¬¡é€‰æ‹©ä¸­ï¼Œè´ªå¿ƒç­–ç•¥é€‰æ‹©ç»™å½“å‰æ»¡è¶³åº¦æœ€å°çš„å­©å­åˆ†é…ç¬¬ m ä¸ªé¥¼å¹²ï¼Œç¬¬ m ä¸ªé¥¼å¹²ä¸ºå¯ä»¥æ»¡è¶³è¯¥å­©å­çš„æœ€å°é¥¼å¹²ã€‚å‡è®¾å­˜åœ¨ä¸€ç§æœ€ä¼˜ç­–ç•¥ï¼Œå¯ä»¥ç»™è¯¥å­©å­åˆ†é…ç¬¬ n ä¸ªé¥¼å¹²ï¼Œå¹¶ä¸” m &lt; nã€‚æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œç»è¿‡è¿™ä¸€è½®åˆ†é…ï¼Œè´ªå¿ƒç­–ç•¥åˆ†é…åå‰©ä¸‹çš„é¥¼å¹²ä¸€å®šæœ‰ä¸€ä¸ªæ¯”æœ€ä¼˜ç­–ç•¥æ¥å¾—å¤§ã€‚å› æ­¤åœ¨åç»­çš„åˆ†é…ä¸­ï¼Œè´ªå¿ƒç­–ç•¥ä¸€å®šèƒ½æ»¡è¶³æ›´å¤šçš„å­©å­ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸å­˜åœ¨æ¯”è´ªå¿ƒç­–ç•¥æ›´ä¼˜çš„ç­–ç•¥ï¼Œå³è´ªå¿ƒç­–ç•¥å°±æ˜¯æœ€ä¼˜ç­–ç•¥ã€‚ ä¸ªäººç†è§£å°±æ˜¯å°½åŠ›æŠŠå°çš„å­©å­å–‚é¥±ï¼Œæ¯è½®éƒ½æŒ‰ç…§è¿™æ ·å–‚é¥±å°±æ˜¯æœ€ä¼˜è§£ è‡ªå·±å†™çš„ï¼ŒæŒ‰ç…§é¢˜ç›®é€»è¾‘s[j]&gt;=g[i]åˆ¤æ–­ 123456789101112131415class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() n, m = len(g), len(s) i = j = count = 0 # greed factor g[i] # cookie size s[j] while i &lt; n and j &lt; m: if s[j]&gt;=g[i]: count +=1 i +=1 j+=1 return count å®˜æ–¹é¢˜è§£ 123456789101112131415161718class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() n, m = len(g), len(s) i = j = count = 0 # greed factor g[i] # cookie size s[j] while i &lt; n and j &lt; m: while j &lt; m and g[i] &gt; s[j]: j += 1 if j &lt; m: count += 1 i += 1 j += 1 return count"},{"title":"LeetCode04-è´ªå¿ƒæ€æƒ³","path":"2022/06/09/LeetCode04-è´ªå¿ƒæ€æƒ³/","text":"å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - è´ªå¿ƒæ€æƒ³1. åˆ†é…é¥¼å¹²2. ä¸é‡å çš„åŒºé—´ä¸ªæ•°3. æŠ•é£é•–åˆºç ´æ°”çƒ4. æ ¹æ®èº«é«˜å’Œåºå·é‡ç»„é˜Ÿåˆ—5. ä¹°å–è‚¡ç¥¨æœ€å¤§çš„æ”¶ç›Š6. ä¹°å–è‚¡ç¥¨çš„æœ€å¤§æ”¶ç›Š II7. ç§æ¤èŠ±æœµ8. åˆ¤æ–­æ˜¯å¦ä¸ºå­åºåˆ—9. ä¿®æ”¹ä¸€ä¸ªæ•°æˆä¸ºéé€’å‡æ•°ç»„10. å­æ•°ç»„æœ€å¤§çš„å’Œ11. åˆ†éš”å­—ç¬¦ä¸²ä½¿åŒç§å­—ç¬¦å‡ºç°åœ¨ä¸€èµ·ä¿è¯æ¯æ¬¡æ“ä½œéƒ½æ˜¯å±€éƒ¨æœ€ä¼˜çš„ï¼Œå¹¶ä¸”æœ€åå¾—åˆ°çš„ç»“æœæ˜¯å…¨å±€æœ€ä¼˜çš„ã€‚"},{"title":"75. Sort Colors (Medium)","path":"2022/06/09/75/","text":"75. Sort Colors (Medium)Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.You must solve this problem without using the libraryâ€™s sort function.æœ‰ä¸‰ç§é¢œè‰²çš„çƒï¼Œç®—æ³•çš„ç›®æ ‡æ˜¯å°†è¿™ä¸‰ç§çƒæŒ‰é¢œè‰²é¡ºåºæ­£ç¡®åœ°æ’åˆ—ã€‚å®ƒå…¶å®æ˜¯ä¸‰å‘åˆ‡åˆ†å¿«é€Ÿæ’åºçš„ä¸€ç§å˜ç§ï¼Œåœ¨ä¸‰å‘åˆ‡åˆ†å¿«é€Ÿæ’åºä¸­ï¼Œæ¯æ¬¡åˆ‡åˆ†éƒ½å°†æ•°ç»„åˆ†æˆä¸‰ä¸ªåŒºé—´ï¼šå°äºåˆ‡åˆ†å…ƒç´ ã€ç­‰äºåˆ‡åˆ†å…ƒç´ ã€å¤§äºåˆ‡åˆ†å…ƒç´ ï¼Œè€Œè¯¥ç®—æ³•æ˜¯å°†æ•°ç»„åˆ†æˆä¸‰ä¸ªåŒºé—´ï¼šç­‰äºçº¢è‰²ã€ç­‰äºç™½è‰²ã€ç­‰äºè“è‰²ã€‚ä¸ªäººç†è§£å°±æ˜¯ä¸‰æŒ‡é’ˆï¼Œè·Ÿä¹‹å‰çš„åŒæŒ‡é’ˆå·®ä¸å¤šï¼Œå’Œä¹‹å‰ä¸åŒçš„æ˜¯å› ä¸ºæœ‰ä¸‰ä¸ªåŒºé—´æ‰€ä»¥è¦ä¸‰ä¸ªæŒ‡é’ˆè·å…°å›½æ——é—®é¢˜å‚è€ƒ 123456789101112131415class Solution: def sortColors(self, nums: List[int]) -&gt; None: a = c = 0 b = len(nums) - 1 while c &lt;= b: if nums[c] == 0: nums[a], nums[c] = nums[c], nums[a] a += 1 c += 1 elif nums[c] == 2: nums[c], nums[b] = nums[b], nums[c] b -= 1 else: c += 1"},{"title":"451. Sort Characters By Frequency (Medium)","path":"2022/06/09/451/","text":"Sort Characters By Frequency (Medium) Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.Return the sorted string. If there are multiple answers, return any of them.Leetcode é¢˜è§£ è¿™é“é¢˜å’Œ 347. Top K Frequent Elements (Medium) å‡ ä¹ä¸€æ ·ï¼Œä¸€ä¸ªæ˜¯æ•°å­—ä¸€ä¸ªæ˜¯å­—ç¬¦ä¸²ï¼Œæ–¹æ³•ä¹Ÿç±»ä¼¼ 1.å»ºå“ˆå¸Œè¡¨ï¼Œå°†å­—ç¬¦ä¸²sä¸­çš„æ¯ä¸ªå­—ç¬¦è®¡æ•°2.æ ¹æ®å“ˆå¸Œè¡¨ä¸­çš„å€¼è¿›è¡Œé™åºæ’åºå³å¯(è¿™ä¸ªæ–¹æ³•å¾ˆé‡è¦)3.ç›´æ¥å­—ç¬¦ä¹˜ä»¥æ•°ç›® 123456789101112131415161718class Solution(object): def frequencySort(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; hashmap = &#123;&#125; for ans in s: if ans not in hashmap: hashmap[ans] = 1 else: hashmap[ans] += 1 result = sorted(hashmap.items(),key=lambda hashmap:hashmap[1],reverse=True) s = &#x27;&#x27; for i in range(len(result)): res = result[i][0] * result[i][1] s += res return s"},{"title":"347. Top K Frequent Elements (Medium)","path":"2022/06/09/347/","text":"347. Top K Frequent Elements (Medium)Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.Top K é—®é¢˜hashmap1.å»ºå“ˆå¸Œè¡¨ï¼Œå°†æ•°ç»„ä¸­çš„æ¯ä¸ªæ•°å­—è®¡æ•°2.æ ¹æ®å“ˆå¸Œè¡¨ä¸­çš„å€¼è¿›è¡Œé™åºæ’åºå³å¯ 12345678910111213141516171819class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: dic = &#123;&#125; for val in nums: if val not in dic: dic[val] = 1 else: dic[val] += 1 result = [] count = 0 for num in sorted(dic, key=dic.get, reverse=True): result.append(num) count += 1 if count == k: break return result é¢˜è§£è¯„è®º ç”¨å­—å…¸å»ä»£æ›¿æ•°ç»„ä¼šä¸ä¼šå¥½ä¸€äº›ï¼›å€’åºéå†é¢‘æ¬¡æ—¶ï¼Œæœ€å¤§ä¸è¶…è¿‡ n-k+1 ï¼›python3ç‰ˆæœ¬: 12345678910111213141516171819class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: hashMap = dict() for num in nums: hashMap[num] = hashMap.get(num, 0) + 1 bucket = dict() for x, v in hashMap.items(): if v not in bucket: bucket[v] = [x] else: bucket[v].append(x) res = [] for v in range(len(nums) - k + 1, -1, -1): if len(res) &gt;= k: break if v in bucket: res.extend(bucket[v]) return res python dict.get(key, default=None)è¿”å›æŒ‡å®šé”®çš„å€¼ï¼Œå¦‚æœå€¼ä¸åœ¨å­—å…¸ä¸­è¿”å›defaultå€¼ leetcodeé¢˜è§£ å¯¹äº topk é—®é¢˜ï¼šæœ€å¤§å †æ±‚topkå°ï¼Œæœ€å°å †æ±‚ topk å¤§ã€‚ topkå°ï¼šæ„å»ºä¸€ä¸ª k ä¸ªæ•°çš„æœ€å¤§å †ï¼Œå½“è¯»å–çš„æ•°å°äºæ ¹èŠ‚ç‚¹æ—¶ï¼Œæ›¿æ¢æ ¹èŠ‚ç‚¹ï¼Œé‡æ–°å¡‘é€ æœ€å¤§å †topkå¤§ï¼šæ„å»ºä¸€ä¸ª k ä¸ªæ•°çš„æœ€å°å †ï¼Œå½“è¯»å–çš„æ•°å¤§äºæ ¹èŠ‚ç‚¹æ—¶ï¼Œæ›¿æ¢æ ¹èŠ‚ç‚¹ï¼Œé‡æ–°å¡‘é€ æœ€å°å †è¿™ä¸€é¢˜çš„æ€»ä½“æ€è·¯ æ€»ä½“æ—¶é—´å¤æ‚åº¦ O(nlogk)å‰kä¸ªæ•°æ„é€  è§„æ¨¡ä¸º k+1 çš„æœ€å°å † minheapï¼Œ O(k)ï¼Œ æ³¨æ„ +1 æ˜¯å› ä¸ºå ä½èŠ‚ç‚¹ã€‚éå†è§„æ¨¡kä¹‹å¤–çš„æ•°æ®ï¼Œå¤§äºå †é¡¶åˆ™å…¥å †ï¼Œä¸‹æ²‰ç»´æŠ¤è§„æ¨¡ä¸ºkçš„æœ€å°å † minheap. O(nlogk)(å¦‚éœ€æŒ‰é¢‘ç‡è¾“å‡ºï¼Œå¯¹è§„æ¨¡ä¸ºkçš„å †è¿›è¡Œæ’åº) 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: def sift_down(arr, root, k): &quot;&quot;&quot;ä¸‹æ²‰log(k),å¦‚æœæ–°çš„æ ¹èŠ‚ç‚¹&gt;å­èŠ‚ç‚¹å°±ä¸€ç›´ä¸‹æ²‰&quot;&quot;&quot; val = arr[root] # ç”¨ç±»ä¼¼æ’å…¥æ’åºçš„èµ‹å€¼äº¤æ¢ while root&lt;&lt;1 &lt; k: child = root &lt;&lt; 1 # é€‰å–å·¦å³å­©å­ä¸­å°çš„ä¸çˆ¶èŠ‚ç‚¹äº¤æ¢ if child|1 &lt; k and arr[child|1][1] &lt; arr[child][1]: child |= 1 # å¦‚æœå­èŠ‚ç‚¹&lt;æ–°èŠ‚ç‚¹,äº¤æ¢,å¦‚æœå·²ç»æœ‰åºbreak if arr[child][1] &lt; val[1]: arr[root] = arr[child] root = child else: break arr[root] = val def sift_up(arr, child): &quot;&quot;&quot;ä¸Šæµ®log(k),å¦‚æœæ–°åŠ å…¥çš„èŠ‚ç‚¹&lt;çˆ¶èŠ‚ç‚¹å°±ä¸€ç›´ä¸Šæµ®&quot;&quot;&quot; val = arr[child] while child&gt;&gt;1 &gt; 0 and val[1] &lt; arr[child&gt;&gt;1][1]: arr[child] = arr[child&gt;&gt;1] child &gt;&gt;= 1 arr[child] = val stat = collections.Counter(nums) stat = list(stat.items()) heap = [(0,0)] # æ„å»ºè§„æ¨¡ä¸ºk+1çš„å †,æ–°å…ƒç´ åŠ å…¥å †å°¾,ä¸Šæµ® for i in range(k): heap.append(stat[i]) sift_up(heap, len(heap)-1) # ç»´æŠ¤è§„æ¨¡ä¸ºk+1çš„å †,å¦‚æœæ–°å…ƒç´ å¤§äºå †é¡¶,å…¥å †,å¹¶ä¸‹æ²‰ for i in range(k, len(stat)): if stat[i][1] &gt; heap[1][1]: heap[1] = stat[i] sift_down(heap, 1, k+1) return [item[0] for item in heap[1:]] 12"},{"title":"215. Kth Largest Element in an Array (Medium)","path":"2022/06/09/215/","text":"215. Kth Largest Element in an Array (Medium)Given an integer array nums and an integer k, return the kth largest element in the array.Note that it is the kth largest element in the sorted order, not the kth distinct element.leetcodeé¢˜è§£ æ–¹æ³•ä¸€. å¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰å¿«é€Ÿæ’åºï¼ˆè‹±è¯­ï¼šQuicksortï¼‰ï¼Œåˆç§°åˆ†åŒºäº¤æ¢æ’åºï¼ˆpartition-exchange sortï¼‰ï¼Œç®€ç§°å¿«æ’ï¼Œä¸€ç§æ’åºç®—æ³•ï¼Œæœ€æ—©ç”±ä¸œå°¼Â·éœå°”ï¼ˆTony Hoare ï¼‰æå‡ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def partition(arr: List[int], low: int, high: int) -&gt; int: pivot = arr[low] # é€‰å–æœ€å·¦è¾¹ä¸ºpivot left, right = low, high # åŒæŒ‡é’ˆ while left &lt; right: while left&lt;right and arr[right] &gt;= pivot: # æ‰¾åˆ°å³è¾¹ç¬¬ä¸€ä¸ª&lt;pivotçš„å…ƒç´  right -= 1 arr[left] = arr[right] # å¹¶å°†å…¶ç§»åŠ¨åˆ°leftå¤„ while left&lt;right and arr[left] &lt;= pivot: # æ‰¾åˆ°å·¦è¾¹ç¬¬ä¸€ä¸ª&gt;pivotçš„å…ƒç´  left += 1 arr[right] = arr[left] # å¹¶å°†å…¶ç§»åŠ¨åˆ°rightå¤„ arr[left] = pivot # pivotæ”¾ç½®åˆ°ä¸­é—´left=rightå¤„ return left def randomPartition(arr: List[int], low: int, high: int) -&gt; int: pivot_idx = random.randint(low, high) # éšæœºé€‰æ‹©pivot arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low] # pivotæ”¾ç½®åˆ°æœ€å·¦è¾¹ return partition(arr, low, high) # è°ƒç”¨partitionå‡½æ•° def topKSplit(arr: List[int], low: int, high: int, k: int) -&gt; int: # mid = partition(arr, low, high) # ä»¥midä¸ºåˆ†å‰²ç‚¹ã€ééšæœºé€‰æ‹©pivotã€‘ mid = randomPartition(arr, low, high) # ä»¥midä¸ºåˆ†å‰²ç‚¹ã€éšæœºé€‰æ‹©pivotã€‘ if mid == k-1: # ç¬¬kå°å…ƒç´ çš„ä¸‹æ ‡ä¸ºk-1 return arr[mid] #ã€æ‰¾åˆ°å³è¿”å›ã€‘ elif mid &lt; k-1: return topKSplit(arr, mid+1, high, k) # é€’å½’å¯¹midå³ä¾§å…ƒç´ è¿›è¡Œæ’åº else: return topKSplit(arr, low, mid-1, k) # é€’å½’å¯¹midå·¦ä¾§å…ƒç´ è¿›è¡Œæ’åº n = len(nums) return topKSplit(nums, 0, n-1, n-k+1) # ç¬¬kå¤§å…ƒç´ å³ä¸ºç¬¬n-k+1å°å…ƒç´  æ–¹æ³•äºŒ. å †æ’åºï¼ˆHeap Sortï¼‰å †æ’åºï¼ˆè‹±è¯­ï¼šHeapsortï¼‰æ˜¯æŒ‡åˆ©ç”¨å †ï¼ˆheapï¼‰è¿™ç§æ•°æ®ç»“æ„æ‰€è®¾è®¡çš„ä¸€ç§æ’åºç®—æ³•ã€‚å †æ˜¯ä¸€ä¸ªè¿‘ä¼¼å®Œå…¨äºŒå‰æ ‘çš„ç»“æ„ï¼Œå¹¶åŒæ—¶æ»¡è¶³å †ç§¯çš„æ€§è´¨ï¼šå³å­èŠ‚ç‚¹çš„é”®å€¼æˆ–ç´¢å¼•æ€»æ˜¯å°äºï¼ˆæˆ–è€…å¤§äºï¼‰å®ƒçš„çˆ¶èŠ‚ç‚¹ã€‚[æ‘˜è‡ª@ç»´åŸºç™¾ç§‘] leetcodeé¢˜è§£ å †ä¸æ’åºï¼š å¯¹äºä¸€ä¸ªå¾…æ’åºçš„åŒ…å« nn ä¸ªå…ƒç´ çš„æ•°ç»„ numsnumsï¼Œå †æ’åº é€šå¸¸åŒ…å«ä»¥ä¸‹å‡ ä¸ªåŸºæœ¬æ­¥éª¤ï¼š å»ºå †ï¼šå°†å¾…æ’åºçš„æ•°ç»„åˆå§‹åŒ–ä¸ºå¤§æ ¹å †ï¼ˆå°æ ¹å †ï¼‰ã€‚æ­¤æ—¶ï¼Œå †é¡¶çš„å…ƒç´ ï¼ˆå³æ ¹èŠ‚ç‚¹ï¼‰å³ä¸ºæ•´ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼ï¼ˆæœ€å°å€¼ï¼‰ã€‚ äº¤æ¢å’Œè°ƒæ•´ï¼šå°†å †é¡¶å…ƒç´ ä¸æœ«å°¾å…ƒç´ è¿›è¡Œäº¤æ¢ï¼Œæ­¤æ—¶æœ«å°¾å³ä¸ºæœ€å¤§å€¼ï¼ˆæœ€å°å€¼ï¼‰ã€‚é™¤å»æœ«å°¾å…ƒç´ åï¼Œå°†å…¶ä»– n-1nâˆ’1 ä¸ªå…ƒç´ é‡æ–°æ„é€ æˆä¸€ä¸ªå¤§æ ¹å †ï¼ˆå°æ ¹å †ï¼‰ï¼Œå¦‚æ­¤ä¾¿å¯å¾—åˆ°åŸæ•°ç»„ nn ä¸ªå…ƒç´ ä¸­çš„æ¬¡å¤§å€¼ï¼ˆæ¬¡å°å€¼ï¼‰ã€‚ é‡å¤æ­¥éª¤äºŒï¼Œç›´è‡³å †ä¸­ä»…å‰©ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æ­¤ä¾¿å¯å¾—åˆ°ä¸€ä¸ªæœ‰åºåºåˆ—äº† 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def maxHeapify(arr, i, end): j = 2*i + 1 while j &lt;= end: if j+1 &lt;= end and arr[j+1] &gt; arr[j]: j += 1 if arr[i] &lt; arr[j]: arr[i], arr[j] = arr[j], arr[i] i = j j = 2*i + 1 else: break def maxHepify(arr, i, end): # å¤§é¡¶å † j = 2*i + 1 # jä¸ºiçš„å·¦å­èŠ‚ç‚¹ã€å»ºå †æ—¶ä¸‹æ ‡0è¡¨ç¤ºå †é¡¶ã€‘ while j &lt;= end: # è‡ªä¸Šè€Œä¸‹è¿›è¡Œè°ƒæ•´ if j+1 &lt;= end and arr[j+1] &gt; arr[j]: # içš„å·¦å³å­èŠ‚ç‚¹åˆ†åˆ«ä¸ºjå’Œj+1 j += 1 # å–ä¸¤è€…ä¹‹é—´çš„è¾ƒå¤§è€… if arr[i] &lt; arr[j]: # è‹¥iæŒ‡ç¤ºçš„å…ƒç´ å°äºå…¶å­èŠ‚ç‚¹ä¸­çš„è¾ƒå¤§è€… arr[i], arr[j] = arr[j], arr[i] # äº¤æ¢iå’Œjçš„å…ƒç´ ï¼Œå¹¶ç»§ç»­å¾€ä¸‹åˆ¤æ–­ i = j # å¾€ä¸‹èµ°ï¼šiè°ƒæ•´ä¸ºå…¶å­èŠ‚ç‚¹j j = 2*i + 1 # jè°ƒæ•´ä¸ºiçš„å·¦å­èŠ‚ç‚¹ else: # å¦åˆ™ï¼Œç»“æŸè°ƒæ•´ break n = len(nums) # å»ºå †ã€å¤§é¡¶å †ã€‘ for i in range(n//2-1, -1, -1): # ä»ç¬¬ä¸€ä¸ªéå¶å­èŠ‚ç‚¹n//2-1å¼€å§‹ä¾æ¬¡å¾€ä¸Šè¿›è¡Œå»ºå †çš„è°ƒæ•´ maxHepify(nums, i, n-1) # æ’åºï¼šä¾æ¬¡å°†å †é¡¶å…ƒç´ ï¼ˆå½“å‰æœ€å¤§å€¼ï¼‰æ”¾ç½®åˆ°å°¾éƒ¨ï¼Œå¹¶è°ƒæ•´å † # k-1æ¬¡é‡å»ºå †ï¼ˆå †é¡¶å…ƒç´ ï¼‰ï¼Œæˆ– kæ¬¡äº¤æ¢åˆ°å°¾éƒ¨ï¼ˆå€’æ•°ç¬¬kä¸ªå…ƒç´ ï¼‰ for j in range(n-1, n-k-1, -1): nums[0], nums[j] = nums[j], nums[0] # å †é¡¶å…ƒç´ ï¼ˆå½“å‰æœ€å¤§å€¼ï¼‰æ”¾ç½®åˆ°å°¾éƒ¨j maxHepify(nums, 0, j-1) # j-1å˜æˆå°¾éƒ¨ï¼Œå¹¶ä»å †é¡¶0å¼€å§‹è°ƒæ•´å † return nums[-k] åŸºäºå¿«æ’çš„æ‰€æœ‰TopKé—®é¢˜ç®€å•pythonæ¨¡æ¿"},{"title":"LeetCode03-æ’åº","path":"2022/06/03/LeetCode03-æ’åº/","text":"å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - æ’åº1. å¿«é€Ÿé€‰æ‹©2. å †-Kth Element3. æ¡¶æ’åº4. è·å…°å›½æ——é—®é¢˜ å¿«é€Ÿé€‰æ‹©ï¼ˆå¿«é€Ÿæ’åºï¼‰ ç”¨äºæ±‚è§£ Kth Element é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ç¬¬ K ä¸ªå…ƒç´ çš„é—®é¢˜ã€‚ å¿«é€Ÿé€‰æ‹©ç®—æ³•æ˜¯åŸºäºå¿«é€Ÿæ’åºç®—æ³•æ€æƒ³çš„ç”¨äºè§£å†³Top K é—®é¢˜çš„ç®—æ³• å¯ä»¥ä½¿ç”¨å¿«é€Ÿæ’åºçš„ partition() è¿›è¡Œå®ç°ã€‚éœ€è¦å…ˆæ‰“ä¹±æ•°ç»„ï¼Œå¦åˆ™æœ€åæƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ä¸º O(N2)ã€‚ æ­¥éª¤ï¼ša. ä»æ•°åˆ—ä¸­æŒ‘å‡ºä¸€ä¸ªå…ƒç´ ï¼Œç§°ä¸º â€œåŸºå‡†â€ï¼ˆpivotï¼‰; b. é‡æ–°æ’åºæ•°åˆ—ï¼Œæ‰€æœ‰å…ƒç´ æ¯”åŸºå‡†å€¼å°çš„æ‘†æ”¾åœ¨åŸºå‡†å‰é¢ï¼Œæ‰€æœ‰å…ƒç´ æ¯”åŸºå‡†å€¼å¤§çš„æ‘†åœ¨åŸºå‡†çš„åé¢ï¼ˆç›¸åŒçš„æ•°å¯ä»¥åˆ°ä»»ä¸€è¾¹ï¼‰ã€‚åœ¨è¿™ä¸ªåˆ†åŒºé€€å‡ºä¹‹åï¼Œè¯¥åŸºå‡†å°±å¤„äºæ•°åˆ—çš„ä¸­é—´ä½ç½®ã€‚è¿™ä¸ªç§°ä¸ºåˆ†åŒºï¼ˆpartitionï¼‰æ“ä½œï¼› c. é€’å½’åœ°ï¼ˆrecursiveï¼‰æŠŠå°äºåŸºå‡†å€¼å…ƒç´ çš„å­æ•°åˆ—å’Œå¤§äºåŸºå‡†å€¼å…ƒç´ çš„å­æ•°åˆ—æ’åºï¼› å †æ’åº ç”¨äºæ±‚è§£ TopK Elements é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ K ä¸ªæœ€å°å…ƒç´ çš„é—®é¢˜ã€‚ä½¿ç”¨æœ€å°å †æ¥å®ç° TopK é—®é¢˜ï¼Œæœ€å°å †ä½¿ç”¨å¤§é¡¶å †æ¥å®ç°ï¼Œå¤§é¡¶å †çš„å †é¡¶å…ƒç´ ä¸ºå½“å‰å †çš„æœ€å¤§å…ƒç´ ã€‚å®ç°è¿‡ç¨‹ï¼šä¸æ–­åœ°å¾€å¤§é¡¶å †ä¸­æ’å…¥æ–°å…ƒç´ ï¼Œå½“å †ä¸­å…ƒç´ çš„æ•°é‡å¤§äº k æ—¶ï¼Œç§»é™¤å †é¡¶å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯å½“å‰å †ä¸­æœ€å¤§çš„å…ƒç´ ï¼Œå‰©ä¸‹çš„å…ƒç´ éƒ½ä¸ºå½“å‰æ·»åŠ è¿‡çš„å…ƒç´ ä¸­æœ€å°çš„ K ä¸ªå…ƒç´ ã€‚æ’å…¥å’Œç§»é™¤å †é¡¶å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦éƒ½ä¸º log2Nã€‚ å †ä¹Ÿå¯ä»¥ç”¨äºæ±‚è§£ Kth Element é—®é¢˜ï¼Œå¾—åˆ°äº†å¤§å°ä¸º K çš„æœ€å°å †ä¹‹åï¼Œå› ä¸ºä½¿ç”¨äº†å¤§é¡¶å †æ¥å®ç°ï¼Œå› æ­¤å †é¡¶å…ƒç´ å°±æ˜¯ç¬¬ K å¤§çš„å…ƒç´ ã€‚ å¿«é€Ÿé€‰æ‹©ä¹Ÿå¯ä»¥æ±‚è§£ TopK Elements é—®é¢˜ï¼Œå› ä¸ºæ‰¾åˆ° Kth Element ä¹‹åï¼Œå†éå†ä¸€æ¬¡æ•°ç»„ï¼Œæ‰€æœ‰å°äºç­‰äº Kth Element çš„å…ƒç´ éƒ½æ˜¯ TopK Elementsã€‚ å¯ä»¥çœ‹åˆ°ï¼Œå¿«é€Ÿé€‰æ‹©å’Œå †æ’åºéƒ½å¯ä»¥æ±‚è§£ Kth Element å’Œ TopK Elements é—®é¢˜ã€‚ æ¡¶æ’åºæ¡¶æ’åºï¼Œç®€å•æ¥è¯´å°±æ˜¯å°†å¾…æ’åºåºåˆ—ï¼ŒæŒ‰ç…§åºåˆ—å€¼çš„å¤§å°åˆ’åˆ†æˆå‡ ä¸ªæ¡¶ï¼Œåˆ†åˆ«å¯¹æ¯ç»„è¿›è¡Œæ’åºï¼Œæ’å®Œåºä¹‹åå†æŒ‰ç…§ä¸€å®šçš„é¡ºåºåˆå¹¶æ‰€æœ‰çš„æ¡¶ï¼Œå³æ’åºå®Œæˆã€‚ å¯¹è¿™é“é¢˜è€Œè¨€ï¼Œè®¾ç½®è‹¥å¹²ä¸ªæ¡¶ï¼Œæ¯ä¸ªæ¡¶å­˜å‚¨å‡ºç°é¢‘ç‡ç›¸åŒçš„æ•°ã€‚æ¡¶çš„ä¸‹æ ‡è¡¨ç¤ºæ•°å‡ºç°çš„é¢‘ç‡ï¼Œå³ç¬¬ i ä¸ªæ¡¶ä¸­å­˜å‚¨çš„æ•°å‡ºç°çš„é¢‘ç‡ä¸º iã€‚ æŠŠæ•°éƒ½æ”¾åˆ°æ¡¶ä¹‹åï¼Œä»åå‘å‰éå†æ¡¶ï¼Œæœ€å…ˆå¾—åˆ°çš„ k ä¸ªæ•°å°±æ˜¯å‡ºç°é¢‘ç‡æœ€å¤šçš„çš„ k ä¸ªæ•°ã€‚ è·å…°å›½æ——é—®é¢˜ â€œè·å…°å›½æ——é—®é¢˜â€ æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªç»å…¸é¢˜ç›®ï¼Œå®ƒæ˜¯ç”±Edsger Dijkstraæå‡ºçš„ã€‚è·å…°å›½æ——ç”±çº¢ã€ç™½ã€è“ä¸‰è‰²ç»„æˆã€‚ è·å…°å›½æ——é—®é¢˜ï¼šç°åœ¨æœ‰è‹¥å¹²ä¸ªçº¢ã€ç™½ã€è“ä¸‰ç§é¢œè‰²çš„çƒéšæœºæ’åˆ—æˆä¸€æ¡ç›´çº¿ã€‚ç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯æŠŠè¿™äº›çƒæŒ‰ç…§çº¢ã€ç™½ã€è“æ’åºã€‚ è¿™ä¸ªé—®é¢˜ä¹‹æ‰€ä»¥å«è·å…°å›½æ——ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¯ä»¥å°†çº¢ç™½è“ä¸‰è‰²å°çƒæƒ³è±¡æˆæ¡çŠ¶ç‰©ï¼Œæœ‰åºæ’åˆ—åæ­£å¥½ç»„æˆè·å…°å›½æ——ã€‚"},{"title":"524. Longest Word in Dictionary through Deleting (Medium)","path":"2022/05/31/524/","text":"524. Longest Word in Dictionary through Deleting (Medium)Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.é¢˜ç›®æè¿°ï¼šåˆ é™¤ s ä¸­çš„ä¸€äº›å­—ç¬¦ï¼Œä½¿å¾—å®ƒæ„æˆå­—ç¬¦ä¸²åˆ—è¡¨ d ä¸­çš„ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºèƒ½æ„æˆçš„æœ€é•¿å­—ç¬¦ä¸²ã€‚å¦‚æœæœ‰å¤šä¸ªç›¸åŒé•¿åº¦çš„ç»“æœï¼Œè¿”å›å­—å…¸åºçš„æœ€å°å­—ç¬¦ä¸²ã€‚é€šè¿‡åˆ é™¤å­—ç¬¦ä¸² s ä¸­çš„ä¸€ä¸ªå­—ç¬¦èƒ½å¾—åˆ°å­—ç¬¦ä¸² tï¼Œå¯ä»¥è®¤ä¸º t æ˜¯ s çš„å­åºåˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ¥åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºå¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—ã€‚ å®˜æ–¹é¢˜è§£1.åªæœ‰åŒæŒ‡é’ˆè¿™é¢˜è¿˜çœŸæœ‰äº›éš¾åº¦ï¼Œä¸»è¦æ˜¯æœ‰äº›é—®é¢˜ä¸èƒ½ä¸€çœ¼çœ‹åˆ°é€»è¾‘å’Œç»“æœã€‚ æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬éœ€è¦è§£å†³ä¸‰ä¸ªé—®é¢˜ï¼š ç»™å®šå­—ç¬¦ä¸²såˆ é™¤ä¸€äº›å­—ç¬¦åèƒ½å¾—åˆ°æ•°ç»„çš„å­—ç¬¦ä¸² æ‰¾æœ€é•¿çš„å­—ç¬¦ä¸² å¦‚æœé•¿åº¦ç›¸åŒï¼Œé€‰å­—å…¸é¡ºåºæœ€å°çš„å­—ç¬¦ä¸²å®˜æ–¹ä¾‹å­ï¼šInput: s = â€œabpcpleaâ€, dictionary = [â€œaleâ€,â€appleâ€,â€monkeyâ€,â€pleaâ€]Output: â€œappleâ€ ç¬¬ä¸€ç‚¹å¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯åœ¨sè¿™ä¸ªå­—ç¬¦ä¸²é‡Œæ‰¾åˆ°å­ä¸²ã€‚å°±åƒåœ¨ä¸€ä¸ªé›†åˆé‡Œæ‰¾åˆ°å­é›†ä¸€æ ·ï¼Œå¯ä»¥å‘ç°[â€œaleâ€,â€appleâ€,â€pleaâ€]ç¬¦åˆ æœ€é•¿çš„å­—ç¬¦ä¸²å°±æ˜¯æ¯”è¾ƒå­ä¸²é•¿åº¦äº†ï¼Œ[â€œappleâ€] å°±æ¯” [â€œaleâ€] å’Œ [â€œpleaâ€]é•¿åº¦è¦é•¿ å­—å…¸é¡ºåºæœ€å°ï¼Œè¿™ä¸ªå°±æ˜¯æ¯”è¾ƒåœ¨å­—æ¯è¡¨ä¸Šçš„é¡ºåºäº†ï¼Œä»¥ aã€bã€câ€¦â€¦z çš„é¡ºåºæ’åˆ—ï¼Œaæœ€å°ï¼Œå‡å¦‚è¿˜æœ‰ä¸ªæ–°å•è¯ [â€œapplaâ€],é‚£å’Œ[â€œappleâ€]æ¯”è¾ƒï¼Œè™½ç„¶é•¿åº¦ä¸€æ ·ï¼Œä½†æ˜¯açš„å­—å…¸é¡ºåºåœ¨eå‰ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—é€‰æ‹©[â€œapplaâ€] 12345678910111213class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: res = &quot;&quot; for t in dictionary: i = j = 0 while i &lt; len(t) and j &lt; len(s): if t[i] == s[j]: i += 1 j += 1 if i == len(t): if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res æ’åº+åŒæŒ‡é’ˆ 123456789101112131415161718192021222324252627class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: m = len(s) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): if ord(s[i]) == j + 97: f[i][j] = i else: f[i][j] = f[i + 1][j] res = &quot;&quot; for t in dictionary: match = True j = 0 for i in range(len(t)): if f[j][ord(t[i]) - 97] == m: match = False break j = f[j][ord(t[i]) - 97] + 1 if match: if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res"},{"title":"141. Linked List Cycle (Easy)","path":"2022/05/31/141/","text":"141. Linked List Cycle(Easy)Given head, the head of a linked list, determine if the linked list has a cycle in it.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tailâ€™s next pointer is connected to. Note that pos is not passed as a parameter.Return true if there is a cycle in the linked list. Otherwise, return false.å¿«æ…¢æŒ‡é’ˆ å®˜æ–¹é¢˜è§£ï¼šã€ŒFloyd åˆ¤åœˆç®—æ³•ã€ï¼ˆåˆç§°é¾Ÿå…”èµ›è·‘ç®—æ³•ï¼‰å‡æƒ³ã€Œä¹Œé¾Ÿã€å’Œã€Œå…”å­ã€åœ¨é“¾è¡¨ä¸Šç§»åŠ¨ï¼Œã€Œå…”å­ã€è·‘å¾—å¿«ï¼Œã€Œä¹Œé¾Ÿã€è·‘å¾—æ…¢ã€‚å½“ã€Œä¹Œé¾Ÿã€å’Œã€Œå…”å­ã€ä»é“¾è¡¨ä¸Šçš„åŒä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ç§»åŠ¨æ—¶ï¼Œå¦‚æœè¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ï¼Œé‚£ä¹ˆã€Œå…”å­ã€å°†ä¸€ç›´å¤„äºã€Œä¹Œé¾Ÿã€çš„å‰æ–¹ï¼›å¦‚æœè¯¥é“¾è¡¨ä¸­æœ‰ç¯ï¼Œé‚£ä¹ˆã€Œå…”å­ã€ä¼šå…ˆäºã€Œä¹Œé¾Ÿã€è¿›å…¥ç¯ï¼Œå¹¶ä¸”ä¸€ç›´åœ¨ç¯å†…ç§»åŠ¨ã€‚ç­‰åˆ°ã€Œä¹Œé¾Ÿã€è¿›å…¥ç¯æ—¶ï¼Œç”±äºã€Œå…”å­ã€çš„é€Ÿåº¦å¿«ï¼Œå®ƒä¸€å®šä¼šåœ¨æŸä¸ªæ—¶åˆ»ä¸ä¹Œé¾Ÿç›¸é‡ï¼Œå³å¥—äº†ã€Œä¹Œé¾Ÿã€è‹¥å¹²åœˆã€‚ æˆ‘ä»¬å¯ä»¥æ ¹æ®ä¸Šè¿°æ€è·¯æ¥è§£å†³æœ¬é¢˜ã€‚å…·ä½“åœ°ï¼Œæˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€å¿«ä¸€æ»¡ã€‚æ…¢æŒ‡é’ˆæ¯æ¬¡åªç§»åŠ¨ä¸€æ­¥ï¼Œè€Œå¿«æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ã€‚åˆå§‹æ—¶ï¼Œæ…¢æŒ‡é’ˆåœ¨ä½ç½® headï¼Œè€Œå¿«æŒ‡é’ˆåœ¨ä½ç½® head.nextã€‚è¿™æ ·ä¸€æ¥ï¼Œå¦‚æœåœ¨ç§»åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œå¿«æŒ‡é’ˆåè¿‡æ¥è¿½ä¸Šæ…¢æŒ‡é’ˆï¼Œå°±è¯´æ˜è¯¥é“¾è¡¨ä¸ºç¯å½¢é“¾è¡¨ã€‚å¦åˆ™å¿«æŒ‡é’ˆå°†åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œè¯¥é“¾è¡¨ä¸ä¸ºç¯å½¢é“¾è¡¨ã€‚ ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå­˜åœ¨ç¯ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šç›¸é‡ã€‚ å®˜æ–¹è§£æ³• 123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True leetcode discussionï¼ˆé€Ÿåº¦æ›´å¿«ï¼Œä½†é€»è¾‘æ˜¯ç±»ä¼¼çš„ï¼‰ 1234567891011class Solution: def hasCycle(self, head): try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False è¿™é‡Œæœ‰ä¸€ç‚¹å°ä¸åŒ 1while slow is not fast: 1while slow != fast: è¿™ä¸¤ä¸ªçš„ç¼–è¯‘é€Ÿåº¦åœ¨æˆ‘å¤šæ¬¡å°è¯•åå‘ç°æ²¡ä»€ä¹ˆä¸åŒï¼Œåº”è¯¥æ²¡æœ‰ä»€ä¹ˆå½±å“"},{"title":"88. Merge Sorted Array (Easy)","path":"2022/05/29/88/","text":"88. Merge Sorted Array (Easy)You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.Merge nums1 and nums2 into a single array sorted in non-decreasing order.The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.python æ•°ç»„æŠ€å·§array[n:]ï¼šæ‰“å°ä»ç¬¬nä¸ªå…ƒç´ ï¼ˆä¸‹æ ‡ä¸ºn-1ï¼‰åˆ°æœ€åä¸€ä¸ªå…ƒç´ (åŒ…æ‹¬ç¬¬nä¸ªå…ƒç´ )array[:n]ï¼šæ‰“å°ä»ç¬¬ä¸€ä¸ªå…ƒç´ åˆ°ç¬¬nä¸ªå…ƒç´ ï¼ˆä¸‹æ ‡ä¸ºn-1ï¼‰ï¼ˆåŒ…æ‹¬ç¬¬nä¸ªå…ƒç´ ï¼‰ Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6]Explanation: The arrays we are merging are [1,2,3] and [2,5,6].The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. 12345678910111213141516171819202122class Solution: def merge(self, nums1, m, nums2, n): while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] def merge(self, nums1, m, nums2, n): while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n]"},{"title":"680. Valid Palindrome II (Easy)","path":"2022/05/28/680/","text":"680. Valid Palindrome II(Easy)Given a string s, return true if the s can be palindrome after deleting at most one character from it.å®˜æ–¹é¢˜è§£ï¼šlist+åŒæŒ‡é’ˆå®˜æ–¹é¢˜è§£ 12345678910111213141516171819202122232425class Solution: def validPalindrome(self, s: str) -&gt; bool: def checkPalindrome(low, high): i, j = low, high while i &lt; j: if s[i] != s[j]: return False i += 1 j -= 1 return True low, high = 0, len(s) - 1 while low &lt; high: if s[low] == s[high]: low += 1 high -= 1 else: return checkPalindrome(low + 1, high) or checkPalindrome(low, high - 1) return Trueä½œè€…ï¼šLeetCode-Solutioné“¾æ¥ï¼šæ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ 123456789101112class Solution(object): def validPalindrome(self, s): # Time: O(n) # Space: O(n) left, right = 0, len(s) - 1 while left &lt; right: if s[left] != s[right]: one, two = s[left:right], s[left + 1:right + 1] return one == one[::-1] or two == two[::-1] left, right = left + 1, right - 1 return True 123456789101112131415class Solution: def validPalindrome(self, s: str) -&gt; bool: i = 0 j = len(s)-1 while i &lt; j: if s[i] != s[j]: delete_i = s[i+1:j+1] delete_j = s[i:j] return self._isPalindrome(delete_i) or self._isPalindrome(delete_j) i += 1 j -= 1 return True def _isPalindrome(self, s): return s == s[::-1]"},{"title":"345. Reverse Vowels of a String (Easy)","path":"2022/05/28/345/","text":"345. Reverse Vowels of a StringGiven a string s, reverse only all the vowels in the string and return it.The vowels are â€˜aâ€™, â€˜eâ€™, â€˜iâ€™, â€˜oâ€™, and â€˜uâ€™, and they can appear in both cases.å®˜æ–¹é¢˜è§£ï¼šlist+åŒæŒ‡é’ˆ1234567891011121314151617181920class Solution: def reverseVowels(self, s: str) -&gt; str: def isVowel(ch: str) -&gt; bool: return ch in &quot;aeiouAEIOU&quot; n = len(s) s = list(s) left, right = 0, n - 1 while left &lt; right: while left &lt; n and not isVowel(s[i]): left += 1 while right &gt; 0 and not isVowel(s[j]): right -= 1 if left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return &quot;&quot;.join(s) 1234567891011121314151617class Solution(object): def reverseVowels(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; temp=[]#å­˜å‚¨é‡åˆ°çš„å…ƒéŸ³ for i in range(len(s)): if s[i] in [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;]: temp.append(s[i]) k=len(temp) s=list(s) for i in range(len(s)): if s[i] in [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;]: s[i]=temp[k-1]#tempä»åå¾€å‰å–å€¼å»è¦†ç›– k-=1 return &#x27;&#x27;.join(s) list+åŒæŒ‡é’ˆ 123456789101112131415class Solution: def reverseVowels(self, s): vowels = [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;A&quot;, &quot;E&quot;, &quot;I&quot;, &quot;O&quot;, &quot;U&quot;] # å…ƒéŸ³å­—æ¯åˆ—è¡¨ s = list(s) # åˆ—è¡¨åŒ–è¾“å…¥å­—ç¬¦ä¸² left, right = 0, len(s) - 1 # åˆå§‹åŒ–å·¦å³æŒ‡é’ˆä½ç½® while left &lt; right: # å¦‚æœæŒ‡é’ˆä½ç½®åˆæ³• if s[left] not in vowels: # å¦‚æœå·¦æŒ‡é’ˆå¤„å­—ç¬¦ä¸æ˜¯å…ƒéŸ³å­—æ¯ left += 1 # å·¦æŒ‡é’ˆå³ç§» elif s[right] not in vowels: # å¦‚æœå³æŒ‡é’ˆå¤„å­—ç¬¦ä¸æ˜¯å…ƒéŸ³å­—æ¯ right -= 1 # å³æŒ‡é’ˆå·¦ç§» else: # å¦‚æœå·¦å³æŒ‡é’ˆå¤„å­—ç¬¦éƒ½æ˜¯å…ƒéŸ³å­—æ¯ s[left], s[right] = s[right], s[left] # äº¤æ¢ä½ç½® left += 1 # å·¦æŒ‡é’ˆå³ç§» right -= 1 # å³æŒ‡é’ˆå·¦ç§» return &#x27;&#x27;.join(s) # å°†åˆ—è¡¨ä¸­çš„å­—ç¬¦è¿æ¥èµ·æ¥"},{"title":"633. Sum of Square Numbers (Medium)","path":"2022/05/28/633-Sum of Square Numbers/","text":"633. Sum of Square NumbersGiven a non-negative integer c, decide whether thereâ€™re two integers a and b such that a2 + b2 = c.åŒæ ·æ˜¯åŒæŒ‡é’ˆ æœ¬é¢˜çš„å…³é”®æ˜¯å³æŒ‡é’ˆçš„åˆå§‹åŒ–ï¼Œå®ç°å‰ªæï¼Œä»è€Œé™ä½æ—¶é—´å¤æ‚åº¦ã€‚è®¾å³æŒ‡é’ˆä¸º xï¼Œå·¦æŒ‡é’ˆå›ºå®šä¸º 0ï¼Œä¸ºäº†ä½¿ 02 + x2 çš„å€¼å°½å¯èƒ½æ¥è¿‘ targetï¼Œæˆ‘ä»¬å¯ä»¥å°† x å–ä¸º sqrt(target)ã€‚ å› ä¸ºæœ€å¤šåªéœ€è¦éå†ä¸€æ¬¡ 0~sqrt(target)ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º O(sqrt(target))ã€‚åˆå› ä¸ºåªä½¿ç”¨äº†ä¸¤ä¸ªé¢å¤–çš„å˜é‡ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚ 123456789101112class Solution(object): def judgeSquareSum(self, c): l, r = 0, int(c**0.5) while l &lt;= r: sum = l*l+r*r if sum &lt; c: l +=1 elif sum&gt;c: r -=1 else: return True return False"},{"title":"167. Two Sum II - Input array is sorted (Easy)","path":"2022/05/28/167-twosum-sorted/","text":"167. Two Sum II - Input Array Is SortedGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.The tests are generated such that there is exactly one solution. You may not use the same element twice.Your solution must use only constant extra space.å’Œç¬¬ä¸€é¢˜å‡ ä¹å¯ä»¥ç”¨åŒæ ·çš„æ€è·¯ï¼Œåªä¸è¿‡è¿™é‡Œçš„indexä»1å¼€å§‹ï¼Œè€Œä¸”æœ‰åºæ•°ç»„æ¯”ç¬¬ä¸€é¢˜æ›´ç®€å• æ ¹æ®ç¬¬ä¸€é¢˜æ”¹çš„hashmap123456789class Solution(object): def twoSum(self, numbers, target): Hashmap = &#123;&#125; for index, value in enumerate(numbers): key = target - value if key in Hashmap: return [Hashmap[key]+1, index+1] else: Hashmap[value] = index Two pointers: O(n) time and O(1) spaceDictionary: O(n) time and O(n) spaceBinary search: O(nlogn) time and O(1) space two-pointer1234567891011class Solution(object): def twoSum(self, numbers, target): l, r = 0, len(numbers)-1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: return [l+1, r+1] elif s &lt; target: l += 1 else: r -= 1 dictionary123456789101112131415161718192021222324class Solution(object): def twoSum(self, numbers, target): dic = &#123;&#125; for i, num in enumerate(numbers): if target-num in dic: return [dic[target-num]+1, i+1] dic[num] = i``` ### binary search ```pythondef twoSum(self, numbers, target): for i in xrange(len(numbers)): l, r = i+1, len(numbers)-1 tmp = target - numbers[i] while l &lt;= r: mid = l + (r-l)//2 if numbers[mid] == tmp: return [i+1, mid+1] elif numbers[mid] &lt; tmp: l = mid+1 else: r = mid-1 binary search æ”¹è¿›ç‰ˆ123456789101112131415161718class Solution(object): def twoSum(self, numbers, target): investigatedSoFar = [] for i in range(len(numbers)): if not numbers[i] in investigatedSoFar: investigatedSoFar.append(numbers[i]) l, r = i + 1, len(numbers) - 1 tmp = target - numbers[i] while l &lt;= r: mid = l + (r-l) // 2 if numbers[mid] == tmp: return([i + 1, mid + 1]) elif numbers[mid] &lt; tmp: l = mid + 1 else: r = mid - 1"},{"title":"1. Two Sum","path":"2022/05/28/1-twosum/","text":"1. Two SumGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.ï¼ˆæ— åºï¼‰ hashmapenumerate()(å•è¯æ„æ€æ˜¯æšä¸¾çš„æ„æ€)æ˜¯pythonä¸­çš„å†…ç½®å‡½æ•°enumerate(X,[start=0])å‡½æ•°ä¸­çš„å‚æ•°Xå¯ä»¥æ˜¯ä¸€ä¸ªè¿­ä»£å™¨(iterator)æˆ–è€…æ˜¯ä¸€ä¸ªåºåˆ—ï¼Œstartæ˜¯èµ·å§‹è®¡æ•°å€¼ï¼Œé»˜è®¤ä»0å¼€å§‹ã€‚Xå¯ä»¥æ˜¯ä¸€ä¸ªå­—å…¸ã€‚ 12345678910class Solution(object): def twoSum(self, nums, target): Hashmap = &#123;&#125; for index, value in enumerate(nums): key = target - value if key in Hashmap: return [Hashmap[key], index] else: Hashmap[value] = index"},{"title":"LeetCode02-æŒ‡é’ˆ","path":"2022/05/25/LeetCode02-æŒ‡é’ˆ/","text":"ç¬¬äºŒç¯‡å­¦ä¹ ç¬”è®°ï¼Œæ¢ä¸€ä¸ªæ€è·¯å°è¯•å­¦ä¹  å…·ä½“å­¦ä¹ é“¾æ¥:Leetcode é¢˜è§£ - ç›®å½•.mdLeetcode é¢˜è§£ - åŒæŒ‡é’ˆ1. æœ‰åºæ•°ç»„çš„ Two Sum2. ä¸¤æ•°å¹³æ–¹å’Œ3. åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—ç¬¦4. å›æ–‡å­—ç¬¦ä¸²5. å½’å¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„6. åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯7. æœ€é•¿å­åºåˆ—åŒæŒ‡é’ˆç±»å‹å¯¹æ’æŒ‡é’ˆï¼šä¸¤ä¸ªæŒ‡é’ˆæ–¹å‘ç›¸åã€‚é€‚åˆè§£å†³æŸ¥æ‰¾æœ‰åºæ•°ç»„ä¸­æ»¡è¶³æŸäº›çº¦æŸæ¡ä»¶çš„ä¸€ç»„å…ƒç´ é—®é¢˜ã€å­—ç¬¦ä¸²åè½¬é—®é¢˜ã€‚å¿«æ…¢æŒ‡é’ˆï¼šä¸¤ä¸ªæŒ‡é’ˆæ–¹å‘ç›¸åŒã€‚é€‚åˆè§£å†³æ•°ç»„ä¸­çš„ç§»åŠ¨ã€åˆ é™¤å…ƒç´ é—®é¢˜ï¼Œæˆ–è€…é“¾è¡¨ä¸­çš„åˆ¤æ–­æ˜¯å¦æœ‰ç¯ã€é•¿åº¦é—®é¢˜ã€‚åˆ†ç¦»åŒæŒ‡é’ˆï¼šä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«å±äºä¸åŒçš„æ•°ç»„ / é“¾è¡¨ã€‚é€‚åˆè§£å†³æœ‰åºæ•°ç»„åˆå¹¶ï¼Œæ±‚äº¤é›†ã€å¹¶é›†é—®é¢˜ã€‚ åŒæŒ‡é’ˆä¸»è¦ç”¨äºéå†æ•°ç»„ï¼Œä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸åŒçš„å…ƒç´ ï¼Œä»è€ŒååŒå®Œæˆä»»åŠ¡ã€‚ å¯¹æ’æŒ‡é’ˆï¼šä¸¤ä¸ªæŒ‡é’ˆæ–¹å‘ç›¸åã€‚é€‚åˆè§£å†³æŸ¥æ‰¾æœ‰åºæ•°ç»„ä¸­æ»¡è¶³æŸäº›çº¦æŸæ¡ä»¶çš„ä¸€ç»„å…ƒç´ é—®é¢˜ã€å­—ç¬¦ä¸²åè½¬é—®é¢˜ã€‚"},{"title":"hexo æ–°å»º/å¯åŠ¨/éƒ¨ç½²å‘½ä»¤","path":"2022/05/16/hexo-usage/","text":"1.æ–°å»ºä¸€ç¯‡æ–‡ç« 1hexo new post &quot;æ–‡ç« åç§°&quot; ä¾‹å­ 1hexo new post hexo_usage 2.éƒ¨ç½²ï¼ˆ1ï¼‰æ¸…é™¤ç¼“å­˜æ–‡ä»¶ (db.json) å’Œå·²ç”Ÿæˆçš„é™æ€æ–‡ä»¶ (public)ã€‚1hexo clean å…¶å®ä¸éœ€è¦æ¯æ¬¡éƒ½æ¸…é™¤ç¼“å­˜æ–‡ä»¶ï¼Œç›´æ¥è¿›è¡Œä¸‹é¢ä¸¤æ­¥å°±å¯ä»¥ ï¼ˆ2ï¼‰ç”Ÿæˆé™æ€æ–‡ä»¶ã€‚1hexo g ï¼ˆ3ï¼‰éƒ¨ç½²ç½‘ç«™éƒ¨ç½²ä¹‹å‰é¢„å…ˆç”Ÿæˆé™æ€æ–‡ä»¶ 1hexo d 3.å¯åŠ¨æœåŠ¡å™¨ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè®¿é—®ç½‘å€ä¸ºï¼šhttp://localhost:4000/ã€‚ 1hexo s"},{"title":"è‰¾å°”ç™»æ³•ç¯bossæˆ˜","path":"2022/05/16/elden-ring-boss/","text":"ä¸€å½“æˆ‘ä»¬è¤ªè‰²è€…é‡æ–°å›åˆ°äº¤ç•Œåœ°ï¼Œç¬¬ä¸€ä¸ªç›¸é‡çš„æ³•ç¯ç¢ç‰‡æŒæœ‰è€…å°±æ˜¯å²ä¸œå¨å°”åŸåŸä¸»â€œé»„é‡‘â€è‘›ç‘å…‹ï¼Œä¸€ä¸ªè‡­åæ˜­è‘—çš„ç¥ä¹‹åè£”ï¼Œé»„é‡‘å®¶æ—æˆå‘˜ï¼Œåœ¨å²ä¸œå¨å°”åŸé™„è¿‘çš„ç ´å±‹é‡Œï¼Œæˆ‘ä»¬ä¼šé‡åˆ°ä¸€ä½çº¢å¸½å¥³å­©ï¼Œä¼šçŸ¥é“è‘›ç‘å…‹åˆ©ç”¨è¢«ç§°ä¸ºæ¥è‚¢çš„æŠ€æœ¯å››å¤„åŠ«æ è¤ªè‰²è€…ï¼Œå°†ç ä¸‹çš„æ‰‹è„šæ¥åœ¨è‡ªå·±èº«ä¸Šæ¥å¢åŠ è‡ªèº«çš„å®åŠ›ã€‚è¿™åº§è…æœ½çš„åŸæ± é‡Œåˆ°å¤„éƒ½æ˜¯æ®‹è‚¢æ–­è‡‚ï¼Œåœ¨ä¸€åº§å¤§å…é‡Œæˆ‘ä»¬è¿˜èƒ½è§åˆ°åœ¨å‡ºç”Ÿç‚¹ç›¸ä¼¼çš„æˆªè‚¢è´µæ—ã€‚åœ¨åŸæ± é‡Œæˆ‘ä»¬è¿˜ä¼šé‡åˆ°åŒæ ·å¯¹è‘›ç‘å…‹æ‰€ä½œæ‰€ä¸ºååˆ†ä¸é½¿çš„å¥³æˆ˜å£«æ¶…æ–ä¸½Â·éœ²ï¼Œå¥¹ä¼šåœ¨æˆ‘ä»¬ä¸è‘›ç‘å…‹æˆ˜æ–—ä¸­åŠ©æˆ‘ä»¬ä¸€è‡‚ä¹‹åŠ›ã€‚ åœ¨æˆ‘ä»¬å°†ä»–å‡»é€€ä¹‹åï¼Œä»–è¿˜ä¼šç ä¸‹è‡ªå·±çš„å·¦æ‰‹ï¼Œå¹¶æ¥ä¸Šä¸€ä¸ªé¾™å¤´ï¼Œè¯•å›¾å†åº¦å¢å¼ºè‡ªå·±çš„åŠ›é‡ã€‚ä½†å½“æˆ‘ä»¬æœ€ç»ˆå‡»è´¥ä»–æ—¶ï¼Œä»–å–ƒå–ƒåœ°è¯´åˆ°ï¼šâ€œæ€»æœ‰ä¸€å¤©ï¼Œæˆ‘ä»¬ä¼šå›åˆ°é»„é‡‘æ ‘è„šä¸‹çš„æ•…ä¹¡â€¦â€¦â€œè‘›ç‘å…‹ä½œä¸ºæ›¾ç»æœ€å¼ºçš„ä¸€æ—â€”â€”â€é»„é‡‘â€œä¸€æ—çš„åäººï¼Œå´éå¸¸å­±å¼±ï¼Œè‰¾å°”ç™»æ³•ç¯è¢«å¥³ç¥ç›è‰å¡æ•²ç¢åï¼Œç¾¤é›„å¹¶èµ·ï¼Œå¼•å‘äº†æ—·æ—¥æŒä¹…çš„ç¢ç‰‡æˆ˜äº‰ï¼Œé»„é‡‘æ ‘è„šä¸‹çš„ç‹åŸå¤šæ¬¡é­åˆ°è¿›æ”»ï¼Œè‘›ç‘å…‹æ··åœ¨å¥³äººå †é‡Œé€ƒå‡ºç‹åŸï¼Œèº²åœ¨å²ä¸œè–‡å°”åŸè‹Ÿæ´»ï¼Œæ›¾ç»æƒ³æŒ‘æˆ˜å¥³æ­¦ç¥ï¼Œå´è¢«è¢«å¥³æ­¦ç¥æ‰“çš„æ»¡åœ°æ‰¾ç‰™ã€‚ ä»–å¦„å›¾é€šè¿‡æ¥è‚¢å˜å¾—æ›´å¼ºï¼Œå´æ˜¯æƒ³ç€èƒ½å¤Ÿæœ‰æœä¸€æ—¥å¯ä»¥é‡ç°é»„é‡‘ä¸€æ—çš„è¾‰ç…Œï¼Œå½“ä»–ç ä¸‹æ‰‹è‡‚æ¥ä¸Šé¾™å¤´æ—¶ï¼Œä»–ä¼šæœå¤©æ€’å¼ï¼šâ€œè¯¸ä½ç¥–å…ˆï¼Œæ•¬è¯·è§è¯ï¼â€åªå¯æƒœä¹±ä¸–ä¹‹ä¸­ï¼Œä¸ç¬¦åˆæ— ä¸Šæ„å¿—çš„æ£‹å­éƒ½ä¼šè¢«æŠ¹å»ã€‚ äºŒä¹˜ç€çµé©¬ç‰¹é›·æ‰˜ä¸€è·¯åŒ—ä¸Šï¼Œåœ¨é›·äºšå¢å¡åˆ©äºšé­”æ³•å­¦é™¢ï¼Œæˆ‘ä»¬ä¼šé­é‡æ›¾ç»è¢«ç§°ä¸ºâ€œæ»¡æœˆâ€å¥³ç‹çš„è•¾å¨œèˆã€‚ ä½œä¸ºå¡åˆ©äºšé­”æ³•ç‹å›½æ›¾ç»çš„é¢†å¯¼è€…ï¼Œå¡åˆ©äºšé­”æ³•ç‹å›½å’Œé»„é‡‘æ ‘åŠ¿åŠ›æ›¾ç»æ•Œå¯¹ï¼Œé»„é‡‘æ ‘æ´¾å‡ºäº†è‹±é›„æ‹‰è¾¾å†ˆå‰æ¥è®¨ä¼ï¼Œç»“æœè•¾å¨œèˆå’Œæ‹‰è¾¾å†ˆåœ¨æˆ˜åœºä¸Šç›¸çˆ±ï¼ŒåŒæ–¹åŒ–å¹²æˆˆä¸ºç‰å¸›ï¼Œå–œç»“è¿ç†è¿˜è¯ä¸‹äº†ä¸‰ä¸ªå­å—£ã€‚ï¼ˆåˆ†åˆ«æ˜¯ç¢æ˜Ÿå°†å†›æ‹‰å¡”æ©ï¼Œæœˆä¹‹å…¬ä¸»èˆå¦®ï¼ˆç¥äººï¼‰ï¼Œé»„é‡‘æ ‘å¸æ³•å®˜æ‹‰å¡å¾·ï¼‰ ä½†å¥½æ™¯ä¸é•¿ï¼Œæ‹‰è¾¾å†ˆçªç„¶æŠ›ä¸‹äº†è‡ªå·±çš„å¦»å­ï¼Œå›åˆ°é»„é‡‘æ ‘å’Œæ°¸æ’å¥³ç‹ç›ä¸½å¡ç»“å©šã€‚çªç„¶å¤±å»çˆ±æƒ…æ”¯æ’‘çš„è•¾å¨œèˆå°±æ­¤ä¸§å¤±äº†ç¥æ™ºï¼Œæˆä¸ºç°åœ¨è¿™å¹…æ¨¡æ ·å¹¶è¢«å¡åˆ©äºšç‹å®¤å›šç¦äºå¤§ä¹¦åº“ã€‚ å¥¹çš„æ‰‹é‡Œæ€€æŠ±ç€æ‹‰è¾¾å†ˆç•™ç»™å¥¹çš„ç¥ç€ä¸€æ ·çš„å¤§å¢æ©ï¼Œç¥å¿—ä¸æ¸…ï¼Œä¸æ–­åœ°åˆ©ç”¨å¤§å¢æ©çš„åŠ›é‡è¯ç”Ÿæ²¡æœ‰è‡ªæˆ‘æ„è¯†çš„å­©å­ã€‚ åœ¨æ‰“ç¢å¥³ç‹èº«è¾¹çš„é˜²æŠ¤ç½©å å¥³å„¿æœˆä¹‹å…¬ä¸»èˆå¦®ä¼šç”¨é­”æ³•ä»£æ›¿å¥¹çš„æ¯äº²ä¸æˆ‘ä»¬æˆ˜æ–—ï¼Œé‡ç°äº†å…¨ç››æ—¶æœŸçš„æ»¡æœˆå¥³ç‹ï¼šçµé­‚æ¿€æµä¸€ç±»çš„æ³•æœ¯éšæ„é‡Šæ”¾ï¼Œè¿˜å¯ä»¥å¬å”¤å·¨é¾™å·¨äººç‹¼ç¾¤çš„çµä½“ååŠ©æˆ˜æ–—ã€‚ ä¸‰å¾€ä¸œï¼Œæˆ‘ä»¬è¿›å…¥äº†æ»¡ç›®çŒ©çº¢è…è´¥çš„ç›–åˆ©å¾·åœ°åŒºï¼Œåˆšè¿›å…¥çº¢ç‹®å­åŸçš„é…ä¹æå…¶éœ‡æ’¼å’Œå¿§ä¼¤ï¼Œè¿™ä¹ˆä¸€ä½ä¸€ç­‰ä¸€çš„è‹±é›„ï¼Œåœ¨ç›–åˆ©å¾·å’Œå¥³æ­¦ç¥çš„æˆ˜æ–—ä¸­é­å—çŒ©çº¢è…è´¥çš„è…èš€åï¼Œè‡ªæˆ‘æ”¾é€åˆ°æ¸å“­å±±ä¸˜ï¼Œå³ä½¿åƒé‡ç‹—ä¸€æ ·å•ƒå™¬ç€æˆ˜åœºä¸Šçš„å°¸ä½“ï¼Œä¾ç„¶ç»´æŒç€æ˜Ÿç©ºçš„å°å°ã€‚ä»–çš„æ‰‹ä¸‹çº¢ç‹®å­å†›åœ¨ç›–åˆ©å¾·ä¿®ç­‘äº†ä¸€æ¡ç†çƒ§ç«å¢™ï¼Œç”¨ç«ç„°åŒè¢«çŒ©çº¢è…è´¥è…èš€å˜å¼‚çš„å·¨å¤§æ€ªç‰©å¼€å±•æ°¸æ— æ­¢å¢ƒçš„æ­»æ–—ã€‚ ä¸€æœ›æ— é™…çš„æˆ˜åœºä¸Šå¸ƒæ»¡äº†æ–­æˆŸæ®‹å£ï¼Œåªèƒ½è¿œè¿œçœ‹åˆ°ä»–çš„åºå¤§èº«èº¯å’Œè´¯ç©¿å¤©ç©ºçš„é‡åŠ›å¤§ç®­ï¼Œè¿™æ˜¯ä¸€åœºæˆ˜æ–—ç¥­å¥ ï¼Œæ‹‰å¡”æ©çš„æ‰‹ä¸‹å¥‡å¼‚éª‘å£«é‚€è¯·å¤©ä¸‹è±ªæ°ç¾¤èšäºæ­¤ï¼Œå¸Œæœ›èƒ½è§£é™¤ä»–çš„ç—›è‹¦ï¼Œåƒä¸€ä½æˆ˜å£«ä¸€æ ·æ­»å»ï¼Œå¦‚æœä¸æŠŠæˆ˜å£«å£¶äºšå†å±±å¤§å’Œç‹¼å“¥ç­‰è‹±é›„ä»¬å¬å”¤å‡ºæ¥ï¼Œå•å¯¹å•æˆ˜æ–—ç¡®å®æ˜¯éå¸¸å›°éš¾çš„äº‹ã€‚å¦‚æœå¬å”¤æ‰€æœ‰è‹±é›„è·Ÿè¿™ä½æœ€å¼ºåŠç¥è´´èº«è‚‰æï¼Œæ‰‘é¢è€Œæ¥çš„æ˜¯é‚£ç§è‹±é›„æœ«è·¯çš„æ‚²å£®æ„Ÿï¼Œå¤§å¼€å¤§åˆçš„æ‹›å¼åœ¨æˆ˜å£«ä»¬ä¸­æ€è¿›æ€å‡ºï¼Œèƒ½åšæŒæˆ˜æ–—åˆ°æœ€åä¸€åˆ»çš„å°±åªå‰©ä¸‹å£¶å“¥å’Œç‹¼å“¥ï¼Œç»ˆäºå‡»è´¥æ‹‰å¡”æ©å°†å†›åï¼Œå¤©ä¸Šé™æ»çš„æ˜Ÿæ˜Ÿçªç„¶å¼€å§‹æµåŠ¨ï¼Œéšç€æ‹‰å¡”æ©å°†å†›çš„é€å»ï¼Œç¾¤æ˜Ÿçš„å°å°è¢«è§£é™¤ï¼Œæ–°çš„å‘½è¿é½¿è½®å¼€å§‹è½¬åŠ¨ å››éšç€æ˜Ÿç©ºå°å°è§£é™¤ï¼Œä¸€æšæµæ˜Ÿç ¸ç©¿äº†åœ°é¢ï¼Œåœ°ä¸‹çš„æ°¸æ’ä¹‹åŸé‡ç°äººä¸–ï¼Œå……æ»¡æ¶æ„çš„ææ€–å¤–ç¥ï¼Œé»‘æš—å¼ƒå­è‰¾ä¸ç¼‡ä»æ˜Ÿç©ºå è½ï¼Œç ¸ç©¿äº†å¤©ç©ºåŸä¹‹åï¼Œåˆå°†è¯ºå…‹å²é»›æ‹‰æ²‰å…¥åœ°åº•ï¼Œè¿™ä¸æ°¸æ’ä¹‹åŸçš„ç§ç§æ‚–é€†ä¹‹ä¸¾æœ‰å…³ï¼Œä»–ä»¬åˆ¶é€ äº†å¯ä»¥ä¼¤å®³æ— ä¸Šæ„å¿—å’ŒäºŒæŒ‡çš„çŒæ€æŒ‡å¤´åˆ€ï¼Œåˆè¯•å›¾é€šè¿‡ä»¿èº«æ³ªæ»´é€ å‡ºæ–°çš„ç¥çµï¼Œä»è€Œå¼•æ¥äº†æ— ä¸Šæ„å¿—çš„æƒ©ç½šã€‚ å·¨å¤§çš„èº«èº¯ç”±æ˜Ÿæ˜Ÿæ„æˆï¼Œé¢éƒ¨æ˜¯ä¸€å¼ ä»¤äººä¸å¯’è€Œæ —çš„éª·é«…è„¸ï¼Œæ‹¥æœ‰é€šè¿‡é»‘æ´ç¬ç§»çš„èƒ½åŠ› äº”å½“è¤ªè‰²è€…æ”»è¿›ç‹åŸï¼Œè¸å…¥ç‹åº§å¤§å…ä¹‹æ—¶ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°ä¸€ä½èº«ä¸Šé•¿æ»¡çŠ„è§’ï¼Œé¢è²Œä¸‘é™‹çš„ç‹ï¼šå™©å…†ç‹è’™è‘›ç‰¹ã€‚ ä»–æ˜¯ä¸€ä½æ‚²å‰§çš„åŠç¥ï¼Œå› ä¸ºé•¿ç›¸ä¸‘é™‹ï¼Œè‡ªå‡ºç”Ÿæ—¶å°±å’Œå…„å¼Ÿè’™æ ¼ä¸€åŒè¢«æ‰”è¿›äº†ç‹åŸçš„ä¸‹æ°´é“ï¼Œè™½ç„¶æ˜¯é»„é‡‘ç‹æœçš„ç‹å­è¿‡å¾—å´æ˜¯è€é¼ ä¸€èˆ¬çš„ç”Ÿæ´»ã€‚ä»–æœ¬åº”è¯…å’’è¿™ä¸ªç•¸å½¢çš„ä¸–ç•Œï¼Œä½†è®½åˆºçš„æ˜¯ï¼Œå½“è‰¾å°”ç™»æ³•ç¯ç ´ç¢åï¼Œç¾¤é›„é€é¹¿ï¼Œç‹åŸä¹Ÿé­åˆ°å„è·¯äººé©¬çš„è¿›æ”»ï¼Œæ›¾ç»çš„åŠç¥å’Œç¥äººä»¬çº·çº·è‡ªç«‹é—¨æˆ·ï¼Œåªæœ‰è¿™ä½ç”Ÿæ´»åœ¨ä¸‹æ°´é“é‡Œçš„å™©å…†ç‹è’™è‘›ç‰¹ï¼Œåœ¨å…³é”®æ—¶é—´æŒ‘èµ·äº†å®ˆåŸçš„é‡ä»»ï¼Œå¹¶å‡»é€€äº†æ‰€æœ‰æ¥çŠ¯ä¹‹æ•Œï¼Œå¤šæ¬¡ä¿ä½äº†é»„é‡‘ç‹åŸï¼Œåœ¨ç¢ç‰‡æˆ˜äº‰ä¸­ï¼Œä»–ç”šè‡³å‡»è´¥äº†æœ‰ç€æœ€å¼ºåŠç¥åå·çš„æ‹‰å¡”æ©å°†å†›ã€‚ å‡»è´¥è’™è‘›ç‰¹åï¼Œä»–çš„è¿½å¿†ä¸­è¿™æ ·æè¿°ï¼šå³ä½¿ç”Ÿä¸ºèµç¦æ— ç¼˜çš„æ¶å…†ä¹‹å­ï¼Œè’™è‘›ç‰¹ä»æ„¿æ„ä¸ºé»„é‡‘æ ‘çš„å®ˆå«ï¼Œä¸æ˜¯å› ä¸ºè¢«çˆ±ï¼Œæƒ³è¦å›é¦ˆï¼Œè€Œæ˜¯ä»–å•çº¯å¸Œæœ›å»çˆ±ã€‚ä¼¼ä¹ä¸è¿™ä¸ªé»„é‡‘ç‹æœçš„å‘½è¿ä¸€æ ·ï¼Œä»–èº«åçš„ç‹åº§åªéœ€è½»è½»ä¸€ç¢°å°±å˜æˆäº†ç¢ç‰‡ã€‚ å…­å½“â€œé»„é‡‘â€è‘›å¾·æ–‡æˆä¸ºæ­»ç‹å­åï¼Œå¤é¾™å°±å¾…åœ¨ä»–çš„å¥½å‹ä½“å†…ï¼Œä¸åœä¸æ­»äº¡ææ–—ï¼Œåœ¨æ­»çœ å°‘å¥³è²é›…çš„æ¢¦å¢ƒä¸­ï¼Œæˆ‘ä»¬è§åˆ°äº†ä¼ è¯´ä¸­çš„â€œæ­»é¾™â€å¼—å°”æ¡‘å…‹æ–¯ã€‚ å½“æ­»é¾™é£ç¿”åœ¨å¤©ç©ºæ‰‹æŒçº¢é›·é…ä¸Šæœ¨æ˜Ÿå¤§çº¢æ–‘ä¼¼çš„èƒŒæ™¯ï¼Œåœºæ™¯æ··ä¹±åˆå……æ»¡äº†é˜´éƒçš„ç¾æ„Ÿã€‚ ä¸ƒåœ¨äºšå›é«˜åŸè¥¿è¾¹çš„ç«å±±åœ°åŒºï¼Œè¿™é‡Œæœ‰é»„é‡‘ç‹æœçš„å¸æ³•å®˜æ‹‰å¡å¾·ï¼Œæ˜¯ä¸€ä¸ªæ¯«æ— æ€œæ‚¯å¿ƒçš„æ³•å®˜ï¼Œä¹Ÿæ˜¯ä¼—å¤šæ‹·é—®å®˜çš„é•¿å®˜ã€‚å¦‚è›‡ä¸€èˆ¬ï¼Œä»¤äººæ„Ÿåˆ°ç”ŸåŒçš„ç”·äººã€‚ æ‹‰å¡å¾·æ˜¯æ‹‰è¾¾å†ˆå’Œæ»¡æœˆå¥³ç‹çš„å­©å­ä¹‹ä¸€ã€‚å¯¹äºé»„é‡‘æ ‘ä¿¡ä»°è€Œè¨€ï¼Œâ€œâ€¦â€¦æ‹‰å¡å¾·çŠ¯ä¸‹äº†äºµæ¸ç½ªï¼Œæ˜¯ç½ªæ— å¯èµ¦çš„æ•Œäººã€‚â€è‰¾å°”ç™»æ³•ç¯ç ´ç¢ä¹‹å‰çš„æ‹‰å¡å¾·æ˜¯æ®‹é…·çš„å¸æ³•å®˜ï¼Œæ•´ä¸ªç‰¢é•‡éšå¤„å¯è§è¢«æŠ˜ç£¨è™å¾…çš„ç™½é‡‘ä¹‹å­ã€‚åœ¨ç ´ç¢æˆ˜äº‰ä¸­ï¼Œä»–æ›¾æ˜¯åå¯¹é»„é‡‘æ ‘çš„éœ¸ç‹ï¼Œåå›é»„é‡‘æ ‘ä¿¡ä»°ï¼Œåå¯¹æ— ä¸Šæ„å¿—ï¼Œä¸ºäº†è¿½æ±‚æ›´å¼ºçš„åŠ›é‡åæŠ—é»„é‡‘æ ‘ä¸»åŠ¨è¢«å¤§è›‡åå™¬ã€‚æˆ‘ä»¬ä¼šå…ˆé€šè¿‡å°è›‡å¥³çš„é‚€è¯·åŠ å…¥åä¸ºå›å¾‹è€…çš„ç»„ç»‡ã€‚ é‚£äº›å…·æœ‰åå¯¹é»„é‡‘æ ‘æ½œè´¨çš„è‹±é›„ä»¬ï¼Œä¼šè¢«é‚€è¯·åˆ°ç«å±±åºœé‚¸ï¼Œå®Œæˆä¸€ç³»åˆ—äºµæ¸ï¼ˆåæŠ—é»„é‡‘å¾‹æ³•ï¼‰ä¹‹ä¸¾ã€‚ä½†æ˜¯åœ¨æ‹‰å¡å¾·å˜æˆå¤§è›‡ä¹‹åï¼Œå› ä¸ºæœ€ç»ˆèƒ½å‡ºè‰²å®Œæˆä»»åŠ¡çš„å›å¾‹è€…éƒ½è¦å»è°’è§æ‹‰å¡å¾·ï¼Œè€Œè¿™äº›å›å¾‹è€…æœ€ç»ˆçš„é­é‡ï¼Œå°±å’Œæ‹‰å¡å¾·æ›¾ç»çš„éª‘å£«ä¸€æ ·è¢«åå™¬ï¼Œå˜æˆå¤§è›‡çš„ä¸€éƒ¨åˆ†ã€‚ åœ¨å®Œæˆäº†ç«å±±å®˜é‚¸å®‰æ’çš„çº¢çµå…¥ä¾µä»»åŠ¡ï¼ˆå‡»æ€å…¶ä»–è¤ªè‰²è€…ï¼‰åï¼Œæ‹‰å¡å¾·çš„ä¾§å®¤å¡”å°¼æ–¯ï¼Œä¸€ä¸ªä¸€ç›´æˆ´ç€é¢å…·æ›¿æ‹‰å¡å¾·å¤„ç†æ—¥å¸¸äº‹åŠ¡çš„å¥³äººï¼Œç»ˆäºåŒæ„æˆ‘ä»¬è§è§äºµæ¸å›ç‹æ‹‰å¡å¾·ã€‚ åœ¨å¤§è›‡å‰çš„ä¸è¿œå¤„ï¼Œæœ‰ä¸€æŠŠå¤§è›‡ç‹©çŒçŸ›ï¼Œä¸å¤§è›‡å¯¹å³™æ—¶ï¼Œèƒ½å½¢æˆé£æš´ä¼¼çš„å…‰åˆƒ åœ¨æ‹‰å¡å¾·è¢«é£æš´ä¹‹åˆƒå‡»è´¥åï¼Œä»–çš„ä¾§å®¤ä¼šè·ªååœ¨å¤§è›‡çš„å°¸ä½“å¤„ï¼Œä¸æ–­åœ°å•ƒé£Ÿç€å°¸ä½“çš„å¤´éƒ¨ï¼Œå¸Œæœ›å€Ÿæ­¤å˜æˆè›‡äººç»§æ‰¿ä»–çš„æ„å¿—ï¼Œç®—æ˜¯äº¤ç•Œåœ°çš„ä¸€å¯¹è‹¦å‘½é¸³é¸¯äº†ã€‚ å…« å¥³æ­¦ç¥ç›è²å¦®äºšï¼Œâ€œç±³å‡¯æ‹‰çš„é”‹åˆƒâ€ï¼Œæ‰‹ä¸‹æœ‰æˆ˜æ— ä¸èƒœçš„å°Šè…éª‘å£«å¤§å†›ï¼Œè£…ä¸Šä¹‰æ‰‹ï¼Œå¸¦ä¸Šé£ç¿¼å¤´ç›”ï¼ŒæŒæ¡é‚£é«˜å±•é£ç¿¼çš„æŠ€èƒ½â€œæ°´é¸Ÿä¹±èˆâ€ã€‚ä¸ºäº†å¸®å“¥å“¥ç±³å‡¯æ‹‰ç™»ä¸Šç‹ä½å‚åŠ ç¢ç‰‡æˆ˜äº‰ï¼Œå¥³æ­¦ç¥ç›è²å¦®äºšåœ¨å¤–å››å¤„å¾æˆ˜ï¼Œé²œè¡€å›ç‹è’™æ ¼è¶è™šè€Œå…¥å°†ç±³å‡¯æ‹‰ä»åœ£æ ‘ä¸­æ³èµ°ï¼Œç›è²å¦®äºšç‡é¢†å¤§å†›ä¸€è·¯å—ä¸‹å¯»æ‰¾çº¿ç´¢ï¼Œè€Œç½ªé­ç¥¸é¦–è’™æ ¼çš„é²œè¡€ç‹æœå°±åœ¨ç›–åˆ©å¾·åœ°åŒºï¼ˆç¢æ˜Ÿå°†å†›æ‹‰å¡”æ©çš„ç»Ÿæ²»åŒºåŸŸï¼‰çš„åœ°ä¸‹æ·±å¤„ã€‚å½“å¥³æ­¦ç¥èµ¶åˆ°ç›–åˆ©å¾·æ—¶ï¼Œè®¤ä¸ºæ˜¯æ‹‰å¡”æ©æŠ¢èµ°äº†å“¥å“¥ç±³å‡¯æ‹‰ï¼Œä¸é©»å®ˆäºæ­¤çš„ç¢æ˜Ÿå°†å†›ä»¥åŠä»–çš„çº¢ç‹®å­å†›å›¢å±•å¼€äº†ä¸€åœºæƒŠå¤©åŠ¨åœ°çš„å¤§æˆ˜ï¼Œå²ç§°è‰¾å¥¥å°¼äºšä¹‹æˆ˜ã€‚åœ¨æœ€ç»ˆçš„å¯¹å†³ä¸­ï¼Œå¨‡è‰³çš„è…è´¥èŠ±æœµæ€’æ”¾ï¼Œåå™¬äº†æ•´ä¸ªè‰¾å¥¥å°¼äºšã€‚æ‹‰å¡”æ©ä¸ç›è²å¦®äºšæˆ˜æˆå¹³æ‰‹ã€‚è¿™åœºæ— äººèƒœåˆ©çš„æˆ˜äº‰ä¼´éšç€ç›è²å¦®äºšçš„æ˜è¿·å’Œæ‹‰å¡”æ©çš„ç–¯ç‹‚è½ä¸‹å¸·å¹•ã€‚ æ˜è¿·çš„ç›è²å¦®äºšè¢«è‹±é›„èŠ¬é›·å¸¦å›åœ£æ ‘ï¼Œä»é‚£ä»¥åå¥½åƒè¿·å¤±äº†è‡ªæˆ‘ï¼Œå®‰å®‰é™é™ååœ¨åœ£æ ‘æ·±å¤„ï¼Œç­‰å¾…ç€å“¥å“¥å›å½’ã€‚ åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡å‡»å€’å¥³æ­¦ç¥ä¹‹åï¼Œå¥¹å†æ¬¡é‡Šæ”¾äº†ä½“å†…çš„çŒ©çº¢è…è´¥ä¹‹åŠ› ç›è²å¦®äºšå¦‚åŒä¸€åªå¦–è‰³è€Œè‡´å‘½çš„è´è¶é£ç¿”åœ¨ç©ºä¸­ï¼Œå±•ç°ç€å®Œå…¨çŠ¶æ€ä¸‹å¥³æ­¦ç¥çš„ææ€–åŠ›é‡ï¼Œå¥¹é‡é‡çš„å°†åˆ€åŠˆå‘åœ°é¢ï¼Œä¸€æœµæœµçŒ©çº¢è…è´¥ä¹‹èŠ±æ€’æ”¾ã€‚ å‡»è´¥å¥³æ­¦ç¥ä¹‹åè·å¾—çš„å¤§å¢æ©ä¹Ÿå¦‚åŒå¥¹æœ¬äººä¸€æ ·ï¼Œä¹Ÿå……æ»¡äº†çŒ©çº¢è…è´¥çš„åŠ›é‡ ä¹ä¸å¾—ä¸è¯´ï¼Œç›è‰å¡çš„å­å—£ä»¬ï¼Œä¹Ÿå°±æ˜¯åŠç¥ä»¬ï¼Œéƒ½æœ‰ç€è‡ªå·±çš„é‡å¿ƒå’Œç†æƒ³ã€‚é²œè¡€å›ç‹è’™æ ¼ï¼Œä¸å­ªç”Ÿå…„å¼Ÿå™©å…†ç‹è’™è‘›ç‰¹ä¸€èµ·å®ˆå«ç‹åŸä¹‹æ—¶ï¼Œä¹ŸæœŸæœ›èƒ½å»ºç«‹å±äºè‡ªå·±çš„é²œè¡€ç‹æœã€‚ åœ¨ç¢ç‰‡æˆ˜äº‰ä¸­ï¼Œè’™æ ¼ç»‘èµ°äº†ç¥äººç±³å‡¯æ‹‰ï¼Œç¥äººæ˜¯ç¥çš„å€™è¡¥ï¼Œåœ¨ç›è‰å¡å¥³ç‹å¤±è¸ªä¹‹åæœ‰ç€æˆä¸ºç¥çš„èµ„æ ¼ï¼Œè’™æ ¼åˆ©ç”¨è¡€èŒ§åŸ¹è‚²ç€ç±³å‡¯æ‹‰ï¼Œå½“ç±³å‡¯æ‹‰æˆç¥ä¹‹é™…ï¼Œè‡ªå·±å°±å¯ä»¥ä»¥è‰¾å°”ç™»ä¹‹ç‹çš„èº«ä»½å›ä¸´å¤©ä¸‹ã€‚æ®Šä¸çŸ¥ï¼Œæ˜¯è’™æ ¼è‡ªå·±çš„æ„¿æœ›ï¼Œè¿˜æ˜¯ç±³å‡¯æ‹‰çš„è¯±æƒ‘å¯¼è‡´çš„å‘¢ï¼Ÿ åå¤©ç©ºåŸé‡Œçš„é»‘å‰‘ç›åˆ©å–€æ–¯æ˜¯ç›è‰å¡å¥³ç‹å¿ è¯šçš„ç»“æ‹œå¼Ÿå¼Ÿï¼Œå°†å‘½å®šä¹‹æ­»å¯„å®¿åœ¨è‡ªèº«çš„å‰‘é‡Œï¼Œä»¤æ‰€æœ‰çš„åŠç¥æ„Ÿåˆ°ç•æƒ§ã€‚è€Œå°±æ˜¯å› ä¸ºå®ƒä»¬æ˜ç™½ä½•è°“ç•æƒ§ï¼Œæ‰ä¼šæ˜¯è‹±é›„ã€‚ åœ¨é˜´è°‹ä¹‹å¤œï¼Œæ­»äº¡çš„ä¸€éƒ¨åˆ†è¢«å·èµ°ä¹‹åï¼Œç›åˆ©å–€æ–¯æŠŠé»‘å‰‘å°å°åœ¨è‡ªå·±ä½“å†…ï¼Œä¸ºçš„æ˜¯ä¸å†è®©å®ƒå¤±çªƒã€‚ è¤ªè‰²è€…å’Œé»‘å‰‘ç¬¬ä¸€æ¬¡ç›¸é‡æ˜¯åœ¨ç›–åˆ©å¾·çš„æœ€åŒ—è¾¹çš„é‡å…½ç¥­ç¥€å¡”ï¼Œè§åˆ°çš„æ˜¯é‡å…½ç¥­ç¥€æ¨¡æ ·çš„ç›åˆ©å–€æ–¯ï¼Œç©¿ç€è‚®è„ç ´çƒ‚çš„å¤–è¡£ï¼Œè¿«åˆ‡çš„æ¸´æœ›ç€æ­»æ ¹ï¼Œåœ¨åƒäº†å››ä¸ªæ­»æ ¹ä¹‹åä»–ç”šè‡³ä¼šé™·å…¥ç–¯ç‹‚æ”»å‡»æˆ‘ä»¬ï¼Œåœ¨åä¸ªæ­»æ ¹å®Œå…¨æ”¶é›†ä¹‹åï¼Œä»–ä¼šä»ç¥­ç¥€å¡”é‡Œæ¶ˆå¤±ï¼Œä¸‹ä¸€æ¬¡å†è§æ˜¯åœ¨å¤©ç©ºåŸã€‚ åœ£æ ‘çš„å¥³æ­¦ç¥æ˜¯æˆ‘æ­»äº¡æ¬¡æ•°æœ€å¤šçš„bossï¼Œä½†æœ‰çŒçŠ¬æ­¥ä¼åŠ ä¸Šè€æ— èµ–çš„ç”¨äº†å†¤é­‚ç»•åœˆæ‰“æ³•ï¼Œå…¶å®éš¾åº¦å¹¶æ²¡æœ‰æ‰“åªç‹¼çš„ä¸€å¿ƒè‰°éš¾ï¼Œå°±æ˜¯å¾—å¤šæŒ‚å‡ æ¬¡å­¦ä¸€ä¸‹æ€ä¹ˆèº²æ°´é¸Ÿï¼Œæ³•å¸ˆçš„ä¸€ä¸ªé—®é¢˜æ˜¯è¡€å¤ªè–„ï¼Œè¢«æ°´é¸Ÿçš„ä»»ä½•ä¸€ä¸ªè¿æ‹›ä¸­çš„ä¸¤åˆ€ç åˆ°å°±æ²¡äº†ã€‚ç‹åŸä¸‹æ°´é“çš„â€œæ¶å…†ä¹‹å­â€è’™æ ¼å’Œé²œè¡€ç‹æœçš„â€œç¢ç‰‡å›ç‹â€è’™æ ¼æˆ‘ä¹Ÿæ²¡ä»€ä¹ˆæˆ˜æ–—è®°å¿†ï¼Œåªè¦è®°å¾—å–æ»´éœ²å°±å¯ä»¥ç ´è§£ä»–çš„å€’è®¡æ—¶å¤§æ‹›ã€‚ç«ç„°å·¨äººå€’çœŸæ˜¯å¡ä½äº†æˆ‘ä¸€æ®µæ—¶é—´ï¼Œå› ä¸ºéåœ°æ‰“æ»šè¢«å‹ç¢äº†å¥½å‡ æ¬¡ï¼Œæ”¾å¼ƒäº†å½“ç”˜é“å¤«çš„æƒ³æ³•é€‰æ‹©ç”¨å²©çŸ³çƒå°±å¾ˆå®¹æ˜“äº†ã€‚é¾™ç‹æ™®æ‹‰é¡¿æ¡‘å…‹æ–¯å¯ä»¥è¯´æ˜¯åæœŸé™¤äº†å¥³æ­¦ç¥ä¹‹å¤–ç¬¬äºŒå¼ºçš„bossï¼Œç¬ç§»ï¼Œç§’äººå…‰ç‚®ï¼Œå¤§èŒƒå›´é¾™çˆªaoeï¼Œé»‘åˆ€å§ç¬¬ä¸€æ¬¡bossåŠè¡€éƒ½æ²¡åˆ°å°±è¢«æ‰“æ²¡äº†ï¼Œä¸»è¦æ˜¯æ¯æ­»ä¸€æ¬¡å¾—è·‘ä¸€é˜µæ‰èƒ½åˆ°bossæˆ¿ï¼ŒæŠ€èƒ½ä¹Ÿæ²¡æœ‰æ­»é¾™é…·ç‚«ï¼ŒåŸºæœ¬æ¯æ‹›éƒ½èƒ½ç§’æˆ‘ï¼Œæˆ˜æ–—ä½“éªŒå¾ˆç³Ÿç³•ã€‚ç„¶åæ˜¯é»‘å‰‘ï¼Œé»‘å‰‘äºŒé˜¶æ®µçš„æˆ˜æ–—èº«å§¿æ˜¯æœ€å¸…çš„ï¼Œé‚£å¥—ç›”ç”²é…ä¸Šé»‘å‰‘çš„ç«ç„°ç‡ƒçƒ§ç‰¹æ•ˆä»å¤©ä¸ŠåŠˆä¸‹åˆ€å…‰éå¸¸å¼•äººå…¥èƒœï¼Œä½†æ•´ä½“å¹¶ä¸éš¾æ‰“ï¼Œå› ä¸ºä»–è¡€å¾ˆè–„åˆæ²¡æœ‰å¥³æ­¦ç¥é‚£æ ·çš„å¸è¡€buffï¼Œå¹³å°ä¸Šè¿˜æœ‰å‡ æ ¹çŸ³æŸ±ï¼Œè™½ç„¶ä¸èƒ½ç§¦ç‹ç»•æŸ±ä½†å¯ä»¥èº²æŸ±å­åé¢å–å£è¯å›å›çŠ¶æ€ã€‚åˆä»£ç‹è·è±éœ²è¯´å®è¯å‡ºåœºè¡¨æ¼”å¾ˆä¸€èˆ¬ï¼Œå¹¶æ²¡æœ‰æ„Ÿè§‰åˆ°åˆä»£è‰¾å°”ç™»ä¹‹ç‹çš„é€¼æ ¼ï¼ŒçŒçŠ¬æ­¥ä¼èº²æŠ•æŠ€ï¼Œè·³èµ·æ¥èº²å¤§èŒƒå›´æ¶åœ°aoeï¼ŒäºŒé˜¶æ®µæ’•ç‹®å­é‚£æ®µå¾ˆæƒŠè®¶ï¼Œä½†åé¢é‹å­çš„ç‰¹å†™æœ‰ç‚¹å‡ºæˆï¼ˆé‹å¸¦ä¸å¥½ç³»å•Šï¼‰ï¼ŒäºŒé˜¶æ®µåœ¨éª¨ç°å’Œå¥³æˆ˜å£«ï¼ˆç°åœ¨æ˜¯å²ä¸œå¨å°”åŸåŸä¸»ï¼‰ä¹Ÿæ²¡ä»€ä¹ˆéš¾åº¦å°±è¿‡äº†ã€‚æœ€ç»ˆbossçº¢æ¯›æ‹‰è¾¾å†ˆå’Œè‰¾å°”ç™»ä¹‹å…½åœ¨åœ£é¾™å¾½æŠ¤ç¬¦+2ï¼ŒèƒèŸ¹è‚‰å’Œç¥·å‘Šåœ£é˜²æŠ¤çš„buffä¸‹æ‰“äº†ä¸¤æ¬¡å°±è¿‡äº†ï¼Œçº¢æ¯›æœ‰ä¸ªé—®é¢˜ï¼Œå°±æ˜¯è¯»æŒ‡ä»¤çš„åŠ¨ä½œå¤ªæ˜æ˜¾äº†ï¼Œå±äºæ•Œä¸åŠ¨æˆ‘ä¸åŠ¨é‚£ç§ï¼Œæ²¡æœ‰åŠ¨ä½œæ¸¸æˆçš„ä½“éªŒï¼Œå°±åƒåªç‹¼é‡Œçš„å¼¦ä¸€éƒåŠ ä¸€å¿ƒæˆ‘æ‰“äº†å¿«ä¸€å¤©æ‰èµ¢ï¼Œä½†æ˜¯ç»“æŸä»¥åå°±è§‰å¾—å¾ˆçˆ½ï¼Œå¼¹åˆ€å‡ºåˆ€å¿ä¹‰æ‰‹æœ‰ä¸€ç§è§æ‹›æ‹†æ‹›çš„å¿«æ„Ÿï¼Œè·Ÿæ‹‰è¾¾å†ˆæ‰“å°±åƒå›åˆåˆ¶æ¸¸æˆï¼Œä»–å‡ºæ‹›æˆ‘å°±ç¿»æ»šï¼Œç­‰ä»–æŠ€èƒ½åæ‘‡æˆ‘å†ç ä¸€å‰‘ç„¶åç»§ç»­æ³¥åœ°æ‰“æ»šæˆ–è€…çŒçŠ¬æ­¥ä¼æ‰¾æœºä¼šã€‚æˆ˜ç°çš„åŠ å…¥è™½ç„¶ç®€åŒ–äº†æˆ˜æ–—ï¼Œä½†ä¸ªåˆ«éª¨ç°çš„å¼ºåŠ¿å¯¼è‡´æˆ‘å®Œå…¨æ²¡æœ‰æƒ³æ³•ä½¿ç”¨å…¶ä»–çš„éª¨ç°ï¼Œç‚¹åé»‘åˆ€å§å’Œä»¿èº«æ³ªæ»´ã€‚ä»¿èº«æ³ªæ»´åœ¨æˆ‘ç©çš„æ—¶å€™å·²ç»è¢«å‰Šï¼Œä¸å†æ˜¯å¤§å“¥äº†ï¼Œä½†å®ƒè¡€åšå•Šã€‚é»‘åˆ€å§å°±æ›´å¼ºäº†ï¼Œæˆ˜æŠ€ç»å¸¸æ”¾è¿˜æ˜¯æ¯”ä¾‹æ‰è¡€ï¼Œä¼šç¬ç§»ï¼Œç§»åŠ¨çµæ´»ã€‚æ”»å‡»æ¬²æœ›å¼ºï¼Œæ‰“å¤§å‹æ€ªè·Ÿæˆ˜ç¥ä¸€æ ·ï¼Œå½“ç„¶å¸Œæœ›å®«å´è€è´¼çš„æ›´æ–°æ–¹å¼æ˜¯åŠ å¼ºå…¶ä»–éª¨ç°è€Œä¸æ˜¯å‰Šå·²æœ‰çš„å¼ºåŠ¿éª¨ç°ã€‚ ä½ å°†ä¼šåœ¨æ¸¸æˆé‡Œé‡åˆ°ä»¥ä¸‹è§’è‰²ï¼š ä¸€ä¸ªå§‘å¨˜å‘Šè¯‰ä½ å¥¹çš„åŸå ¡é‡Œå¥´éš¶é€ åäº†ï¼Œå¥¹çš„åŸä¸»çˆ¶äº²æ­£åœ¨åŠªåŠ›æŠµæŠ—å›å†›ï¼Œå¥¹ç»™ä½ ä¸€å°ä¿¡ï¼Œè®©ä½ å¸¦ç»™ä»–çˆ¶äº²ï¼ŒåŠè¯´ä»–ç¦»å¼€ã€‚äºæ˜¯ä½ æ€è¿›åŸå ¡æ‰¾åˆ°å¥¹çˆ¶äº²ï¼Œç»“æœä»–çˆ¶äº²è¯´è‡ªå·±å¥‰è‘›ç‘å…‹å¤§äººï¼ˆè¿™ç‰‡åŒºåŸŸçš„å›ç‹ï¼‰æŠµæŠ—å›å†›ï¼Œä¸èƒ½ç¦»å¼€ï¼Œå…³é”®æ˜¯é•‡åŸä¹‹å‰‘ä¸èƒ½è½å…¥å›å†›ä¹‹æ‰‹ï¼Œäºæ˜¯ä½ åˆæ€äº†å›å†›çš„è€å¤§æ‹¿å›äº†å‰‘ï¼Œä½ ä»¥ä¸ºåŸä¸»è¿™ä¸‹å¯ä»¥å’Œå¥³å„¿å›¢èšäº†ï¼Œäºæ˜¯é«˜å…´æ»´å›å»æ‰¾å§‘å¨˜ï¼Œç»“æœå‘ç°å§‘å¨˜å·²ç»å€’åœ¨äº†è¡€æ³Šä¸­ï¼Œæ—è¾¹èµ«ç„¶æ’ç€å¥´éš¶ä»¬ä½¿ç”¨çš„å¤§åˆ€ã€‚ä½ æ²®ä¸§åœ°å›å»æ‰¾åŸä¸»ï¼Œå´å‘ç°ä¸çŸ¥æƒ…çš„åŸä¸»è¯´è‡ªå·±çš„ä»»åŠ¡å·²ç»å®Œæˆäº†ï¼Œæœªæ¥è¦ä¸ºå¥³å„¿è€Œæ´»â€¦â€¦å†å›åˆ°å’Œå¦¹å­ç›¸é‡çš„åœ°æ–¹ï¼Œä¼šè§åˆ°è¿™ä¸ªå¿ƒç¢çš„çˆ¶äº²åœ¨å¥³å„¿çš„å°¸ä½“æ—æ¶åœ°æ€’å¼ï¼Œé«˜å–Šè¦ä¸ºäº†å¥³å„¿å¤ä»‡ã€‚åæœŸåœ¨ä¸€é—´å……æ»¡å°¸è‡­çš„ç ´å±‹é‡Œï¼Œè¿™ä¸ªçˆ¶äº²ä¼šå¤±æ™ºåœ°æ”»å‡»æˆ‘ä»¬ã€‚å¤ä»‡å·²ç»åå™¬äº†ä»–çš„å¿ƒï¼Œä¹Ÿè®¸å€’åœ¨ç©å®¶çš„å‰‘ä¸‹ï¼Œå’Œå¥³å„¿å›¢èšï¼Œæ˜¯å¯¹ä»–æ¥è¯´æœ€å¥½çš„ç»“å±€ã€‚ åœ¨é­”æ³•å­¦é™¢å¤–ï¼Œä½ ä¼šé‡åˆ°ä¸€ä¸ªè½é­„é­”æ³•å¸ˆæ‰˜æ™®æ–¯ï¼Œæ±‚ä½ ç»™ä»–åå—é’±å»å¼„ç‚¹åƒçš„ï¼Œä»–ä¼šæ•™ä½ é­”æ³•ä½œä¸ºæŠ¥é…¬ã€‚ä»–æ•™çš„é­”æ³•æœ‰ç‚¹å¥‡æ€ªï¼ˆæ¯”å¦‚ä¸€ä¸ªå¯ä»¥ç…§æ˜ç”¨é­”æ³•ï¼Œè™½ç„¶æ²¡æœ‰æˆ˜æ–—åŠ›ä½†å¾ˆå®ç”¨ï¼‰ï¼Œä»–è¯´è‡ªå·±å¾ˆæœ‰è‡ªçŸ¥ä¹‹æ˜ï¼ŒçŸ¥é“è‡ªå·±æ˜¯å—æœ½æœ¨ï¼Œå¾ˆé—æ†¾ä¸èƒ½æ•™ç»™ç©å®¶å¥½çš„é­”æ³•ï¼Œä»–å¸Œæœ›èƒ½è¿›å…¥é­”æ³•å­¦é™¢å»ç ”ç©¶ã€‚ä¹‹åç©å®¶æ‰¾åˆ°é­”æ³•å­¦é™¢é’¥åŒ™å¯ä»¥äº¤ç»™ä»–ï¼Œä»–ä¼šéå¸¸æ„Ÿè°¢ä½ ç„¶åç¦»å»ã€‚åœ¨ç©å®¶æ¢ç´¢é­”æ³•å­¦é™¢çš„æ—¶å€™ï¼Œå¯ä»¥åœ¨æŸä¸€ä¸ªåœ°æ–¹æ‰¾åˆ°æ‰˜æ™®æ–¯çš„å°¸ä½“ï¼šè¢«ç»‘åœ¨æ¤…å­ä¸Šï¼Œæ­»å‰ä¼¼ä¹ä¾ç„¶åœ¨ç ”ç©¶é­”æ³•ã€‚è€Œè°ƒæŸ¥ä»–çš„å°¸ä½“ï¼Œå¯ä»¥å‘ç°ä»–èµŒä¸Šæ€§å‘½ç ”ç©¶çš„é­”æ³•ï¼šæ‰˜æ™®æ–¯çš„ç«‹åœºã€‚è¿™ä¸ªé­”æ³•çš„æ•ˆæœéå¸¸é€†å¤©ï¼Œå¯ä»¥å¼¹å¼€æ‰€æœ‰é­”æ³•ã€‚ç‰©å“ä»‹ç»ä¸­è¿™æ ·æè¿°ï¼šåä¸–çš„äººä»¬ä¼šæ˜ç™½ï¼Œé‚£å—äººå˜²è®½çš„ç†å¿µï¼Œå…¶å®æ˜¯è¶³ä»¥æˆç«‹æ–°æ•™å®¤çš„å‘ç°ã€‚ åŒæ ·æ˜¯é­”æ³•å¸ˆï¼Œä½ ä¼šåœ¨æŸå¤„é—è¿¹åœ°ä¸‹å®¤é‡è§ä¸€ä¸ªå¥³é­”æ³•å¸ˆç‘Ÿå»‰ï¼Œå¦‚æœä½ å¸Œæœ›å¥¹æ•™ä½ é­”æ³•ï¼Œå¥¹ä¼šè­¦å‘Šä½ è‡ªå·±æ˜¯è¢«é­”æ³•å­¦é™¢é©±é€çš„é­”å¥³ã€‚å¦‚æœç©å®¶è¡¨ç¤ºä¸ä»‹æ„çš„è¯ï¼Œç‘Ÿå»‰ä¼šæƒŠè®¶å¹¶è¡¨ç¤ºæ„¿æ„æ•™æˆ‘ä»¬é­”æ³•ï¼Œå¹¶äº²åˆ‡ç§°å‘¼æˆ‘ä»¬ä¸ºå¾’å¼Ÿã€‚åœ¨ç©å®¶æ­¤åçš„å¾ç¨‹ä¸­ï¼Œè€å¸ˆçŸ¥æ— ä¸è¨€ï¼Œè¿˜ä¼šä¸€ç›´é¼“åŠ±æˆ‘ä»¬ï¼Œç”šè‡³è¡¨ç¤ºå°±ç®—ç©å®¶ä¸€æ— æ‰€æˆï¼Œè¿˜æ˜¯å¯ä»¥å»æ‰¾å¥¹ï¼Œæ¯•ç«Ÿè€å¸ˆæ°¸è¿œä¼šç»™å¼Ÿå­ç•™ä¸€ä¸ªä½ç½®ã€‚ç„¶è€Œéšç€å‰§æƒ…æ¨è¿›ï¼Œæˆ‘ä»¬ä¼šå‘ç°åŸæ¥è€å¸ˆå°±æ˜¯é­”æ³•å­¦é™¢é‡Œè¢«ç§°ä¸ºâ€œå°¸å—é­”å¥³â€çš„å­˜åœ¨ï¼Œä¸ºäº†æ¢ç´¢ç¦å¿Œçš„æ˜Ÿæ˜Ÿèµ·æºè€Œæ€å®³äº†æ— æ•°é­”æ³•å¸ˆã€‚å½“ç©å®¶å°†ä¸¤ä½å¤§é­”æ³•å¸ˆå°¸ä½“çš„ä½ç½®å‘Šè¯‰è€å¸ˆåï¼Œè€å¸ˆæœ€ç»ˆä¼šå’Œä»–ä»¬èåˆï¼Œå˜æˆä¸€é¢—ææ€–çš„äººé¢çƒï¼Œç—›è‹¦åœ°å‘æˆ‘ä»¬å‘»åŸï¼šâ€œå‘œå‘œå‘œå‘œï¼Œå¾’å¼Ÿï¼Œå‘œå‘œå‘œâ€¦â€¦â€è™½ç„¶æ¢ç´¢ç¦å¿Œçš„ç–¯ç‹‚è¡Œä¸ºç»ˆç©¶è¦ä»˜å‡ºä»£ä»·ï¼Œä½†å³ä½¿æ˜¯å†…å¿ƒå†æ€ä¹ˆç–¯ç‹‚ä¹‹äººï¼Œå¯¹äºé‚£ä¸ªå½“åˆä¸ä»‹æ„è‡ªå·±å‡ºèº«ï¼Œæ„¿æ„æ¥çº³è‡ªå·±çš„å°å¾’å¼Ÿï¼Œå¥¹ä¾ç„¶æ„¿æ„è¢’éœ²å†…å¿ƒçœŸå¿ƒç›¸å¯¹ã€‚ï¼ˆä¹Ÿæœ‰è¯´æ³•äººé¢çƒå°±æ˜¯æ˜Ÿæ˜Ÿçš„é›å½¢ï¼Œè€å¸ˆå…¶å®æ˜¯å¾—é“äº†ï¼‰ åœ¨ä¸€åº§æ¡¥æ—ï¼Œ ç©å®¶ä¼šé‡åˆ°ä¸€ä¸ªé•¿ç€æ‰‹è„šçš„å£¶è¢«å¡åœ¨åœ°ä¸Šï¼Œè¯·æ±‚æˆ‘ä»¬çš„å¸®å¿™ã€‚å¸®ä»–è„±å›°åï¼Œä»–ä¼šå‘Šè¯‰æˆ‘ä»¬è‡ªå·±æ˜¯æˆ˜å£«å£¶â€”â€”é“æ‹³äºšå†å±±å¤§ï¼Œæ­£è¦å»çº¢ç‹®å­åŸå‚åŠ æˆ˜æ–—ç¥­å¥ ã€‚ä»–çˆ½æœ—çš„ç¬‘å£°è®©äººå°è±¡æ·±åˆ»ã€‚åœ¨æˆ˜æ–—ç¥­å¥ ä¸Šæºæ‰‹å£¶å“¥ä¸€åŒå‡»è´¥åŠç¥æ‹‰å¡”æ©å°†å†›åï¼Œå£¶å“¥ä¼šæµ‘èº«è£‚ç—•è¶´åœ¨åœ°ä¸Šï¼Œå‘Šè¯‰æˆ‘ä»¬åˆšæ‰æˆ‘ä»¬çš„è¡¨ç°å¾ˆæ£’ï¼Œä½†è‡ªå·±æ²¡å‡ ä¸‹å°±è¢«æ‰“è¶´ä¸‹äº†ï¼Œè¿˜å‡ºç°äº†å¥½å¤šè£‚ç—•ï¼Œå£¶é‡Œçš„å†…å®¹ç‰©éƒ½æ¼å‡ºæ¥äº†ï¼Œå¥½åœ¨è¿™é‡Œæœ‰å¾ˆå¤šæˆ˜å£«çš„å°¸ä½“ï¼Œå¯ä»¥å¼¥è¡¥é—å¤±çš„å†…å®¹ç‰©ã€‚æˆ‘ä»¬è¿™æ‰çŸ¥é“åŸæ¥æˆ˜å£«å£¶å°±æ˜¯æˆ˜å£«å°¸ä½“çš„å®¹å™¨ï¼Œä»–æ˜¯æˆ˜å£«ä»¬æˆ˜æ„çš„æ‰¿è½½è€…ã€‚ä¸ºäº†å˜å¾—æ›´å¼ºï¼Œå£¶å“¥å†³å®šå»ç«å±±å®˜é‚¸æ—çš„ç†”å²©æ¥å—é«˜æ¸©ç‚™çƒ¤ï¼Œåˆå»å·¨äººé›ªå±±å¯»æ‰¾ç¥ç«é”»é€ è‡ªå·±ï¼Œæœ€ç»ˆä»–å’Œæˆ‘ä»¬åœ¨å¤©ç©ºåŸç›¸é€¢ã€‚æ¯æ¬¡ç¢°é¢ï¼Œä»–æ€»æ˜¯ç”¨çˆ½æœ—çš„ç¬‘å£°å›åº”æˆ‘ä»¬ï¼Œå¥½åƒä¸ç®¡ä½•ç§å¤±æ„éƒ½ä¸ä¼šå½±å“ä»–çš„æ–—å¿—ï¼Œå°½ç®¡ä»–èº«ä¸Šçš„è£‚ç—•è¶Šæ¥è¶Šå¤šã€‚åœ¨å¤©ç©ºåŸï¼Œå£¶å“¥é‚€è¯·æˆ‘ä»¬ä½œä¸ºä»–çš„ä¸€åœºè¯•ç‚¼ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯ä»–è®¤å¯çš„è‹±é›„ã€‚å¼€æ‰“åæˆ‘ä»¬å‘ç°ï¼Œç›¸æ¯”å…¶ä»–æˆ˜å£«å£¶ï¼Œå£¶å“¥å¼ºå¤ªå¤šå¤ªå¤šäº†ï¼Œä»–ä¸ä½†å¯ä»¥å–·ç«ï¼Œç”šè‡³æŒ¥æ‰‹å°±å¯ä»¥æ€èµ·ç«ç„°é£æš´ï¼Œä¸€åŒé“æ‹³ä½¿å‡ºçš„ç«ç„°å‡é¾™æ‹³ç”šè‡³å¯ä»¥å‡»é£æ›¾ç»å¼‘ç¥çš„ç©å®¶ã€‚ä½†æ˜¯å£¶çš„æ‰¿è½½åº¦ç»ˆå½’æœ‰é™ï¼Œå£¶å“¥è¿˜æ˜¯å€’ä¸‹äº†ã€‚ä»–å‘Šè¯‰æˆ‘ä»¬ï¼Œä»–çŸ¥é“å£¶ç»ˆå½’åªæ˜¯å£¶ï¼Œä½†ä½œä¸ºæˆ˜å£«ï¼Œä»–æˆ˜æ–—åˆ°äº†æœ€åä¸€åˆ»ã€‚æœ€ç»ˆï¼Œåœ¨çˆ½æœ—çš„ç¬‘å£°ä¸­ï¼Œå£¶å“¥åƒå…¶ä»–æˆ˜å£«å£¶ä¸€æ ·ç¢è£‚æˆäº†ç¢ç‰‡ã€‚ åœ¨æ¸¸æˆä¸­ï¼Œä½ ä¼šé‡åˆ°ä¸€ä¸ªè‡ªç§°éœåŠ³æ–¯çš„éª‘å£«ï¼Œè¯´ä»–å’Œå¥³ä»†èµ°æ•£äº†ï¼Œå¦‚æœä½ è§åˆ°äº†å¯ä»¥å‘Šè¯‰ä»–ï¼Œè¿˜è¯´å¦‚æœæœ‰äººæ•¢åŠ¨ä»–å¥³ä»†ä»–å°±ä¸å®¢æ°”äº†ï¼Œå˜´ä¸Šè¿˜è¯´ç€éœåŠ³æ–¯ä»¥è¡€ä»£è¨€ï¼ˆç”¨è®©ä½ å‡ºè¡€ä»£æ›¿ç”¨å˜´é€¼é€¼ï¼‰ï¼Œç»™äººæ„Ÿè§‰æ˜¯ä¸ªç‹ äººã€‚åæ¥åœ¨é­”æ³•å­¦é™¢å‰ï¼Œä½ å‘ç°ä»–æ‰¾åˆ°äº†å·²ç»è¢«æ€å®³çš„å¥³ä»†ï¼Œä»–å‘Šè¯‰ä½ å‡¶æ‰‹æ˜¯ç«å±±å®˜é‚¸çš„äººï¼Œä»–éè¦å¤ä»‡ä¸å¯ï¼Œå› ä¸ºéœåŠ³æ–¯å®¶æ—ä»¥è¡€ä»£è¨€ã€‚åæ¥åœ¨å¤§æœ¬è¥ï¼Œä»–å‘Šè¯‰ä½ ä»–æ‰¾åˆ°äº†ç«å±±å®˜é‚¸çš„äººï¼Œä½†å¯¹æ–¹ç«Ÿç„¶è¦æ‹‰ä»–å…¥ä¼™ï¼Œä»–è¡¨ç¤ºè‡ªå·±æ°”çš„è¦å¤§å¼€æ€æˆ’äº†ã€‚è®©äººå¤§è·Œçœ¼é•œçš„æ˜¯ï¼Œå½“ç©å®¶è¿›å…¥ç«å±±å®˜é‚¸åï¼Œç«Ÿç„¶è§åˆ°éœåŠ³æ–¯ï¼Œä»–å‘Šè¯‰ä½ ï¼Œä»–ä¹ŸåŠ å…¥ç«å±±å®˜é‚¸äº†ï¼Œä¸æƒ³å¤ä»‡äº†ã€‚ä»–è¿˜è‡ªå·±æ‰¾äº†ä¸€ä¸ªç†ç”±ï¼šè‹±é›„ä¸ä¼šåˆ»æ„èµ°å¹²å‡€çš„è·¯ï¼Œæˆ‘è¦é€‰æ‹©ä¸€æ¡æ±¡ç§½çš„è·¯æ¥è¯æ˜æˆ‘çš„è‹±é›„æ°”æ¦‚ã€‚æ— æ•°ç©å®¶åœ¨ä»–çš„è„šä¸‹ç•™è¨€ï¼šå‰æœ‰å¤§ä¾¿ï¼Œå‰æ— é©¬ï¼ˆå¦ˆï¼‰ï¼Œæ„¤æ€’ï¼ç­‰ç­‰æ¥è¡¨è¾¾å†…å¿ƒçš„ä¸æ»¡ã€‚ä¹‹åéœåŠ³æ–¯å±¡å±¡å‡ºä»»åŠ¡å¤±è´¥ï¼ˆç«å±±å®˜é‚¸ä»¥çŒæ€åŒç±»ä¸ºä»»åŠ¡ï¼‰ï¼Œä»–å‘ç©å®¶è¯‰è‹¦è‡ªå·±è¿™åŒæ‰‹æ ¹æœ¬ä¸é€‚åˆæˆä¸ºè‹±é›„ã€‚ç©å®¶é€šè¿‡æ”¯çº¿ä»»åŠ¡ä¹Ÿå¾—çŸ¥åŸæ¥éœåŠ³æ–¯æœ‰ä¸€ä¸ªå“¥å“¥ï¼Œç”±äºå¼Ÿå¼Ÿå¤ªè¿‡æ²¡ç”¨ï¼Œå“¥å“¥åæ­£è¨€é¡ºå½“ä¸Šäº†å®¶ä¸»ï¼Œä¹Ÿä¸€ç›´çˆ±ç€å¼Ÿå¼Ÿï¼Œå¹¶å¸Œæœ›å¼Ÿå¼Ÿä¸è¦èµ°ä¸ŠéœåŠ³æ–¯ä»¥è¡€ä»£è¨€çš„é“è¡€é“è·¯ã€‚ä½†å¼Ÿå¼Ÿä¹Ÿä¸€ç›´æƒ³ç€èµ°å‡ºå“¥å“¥çš„é˜´å½±â€¦â€¦åæ¥åœ¨å£¶æ‘ï¼Œç©å®¶å‘ç°éœåŠ³æ–¯é€ƒå‡ºäº†ç«å±±å®˜é‚¸ï¼Œåœ¨è¿™é‡Œå½“ä¸Šäº†ç»´å£¶å¸ˆï¼Œç»´ä¿®è¿™é‡Œçš„æˆ˜å£«å£¶ï¼Œè™½ç„¶è¿™ä»½å·¥ä½œçœ‹èµ·æ¥ä½å¾®ï¼Œä½†çœ‹ç€åœ¨è‡ªå·±çš„ç»´æŠ¤ä¸‹ï¼Œå£¶ä»¬ä¸€ä¸ªä¸ªæ¢å¤å¥åº·ï¼ŒéœåŠ³æ–¯è¯´ï¼šæˆ‘ä»ç«å±±å®˜é‚¸é€ƒäº†å‡ºæ¥ï¼Œä»æ‰€æœ‰åœ°æ–¹é€ƒäº†å‡ºæ¥ï¼Œé€ƒé¿ä¸€åˆ‡ã€‚è¯´å‡ºæ¥ä½ å¯èƒ½ä¸ä¿¡ï¼Œä½†æˆ‘åœ¨è¿™é‡Œï¼Œæ‰æœ‰äº†çœŸæ­£æ´»ç€çš„æ„Ÿè§‰ã€‚ä¸€æ®µæ—¶é—´åç©å®¶å›æ¥ï¼Œä¼šå‘ç°æ‰€æœ‰çš„å£¶éƒ½ç¢äº†ï¼Œåªæœ‰ä¸€ä¸ªå°å£¶è¿˜å®Œå¥½ï¼Œè€ŒéœåŠ³æ–¯åªå‰©ä¸‹æœ€åä¸€å£æ°”ã€‚åŸæ¥æ‘é‡Œé‡åˆ°äº†å·çŒè€…ï¼Œæ˜¯éœåŠ³æ–¯ç”¨æ€§å‘½å‡»é€€äº†ä»–ä»¬ã€‚å½“ä½ å‘Šè¯‰éœåŠ³æ–¯å£¶éƒ½æ²¡äº‹æ—¶ï¼Œä»–ä¼šæ¬£æ…°åœ°è¯´ï¼Œå°±ç®—æ˜¯è‡ªå·±è¿™æ ·æ²¡ç”¨çš„äººï¼Œä¹Ÿä¼šæœ‰æ´¾ä¸Šç”¨åœºçš„æ—¶å€™ï¼Œå¹¶æœ€åè¯´å‡ºäº†é‚£å¥ä»–ä¸€ç›´æŒ‚åœ¨å˜´è¾¹çš„è¯ï¼šéœåŠ³æ–¯ä»¥è¡€ä»£è¨€ã€‚åœ¨ä»–çš„å°¸ä½“æ—ï¼Œå…¨æ˜¯ç©å®¶çš„ç•™è¨€ï¼Œå‡ ä¹éƒ½æ˜¯ä¸€æ ·çš„å†…å®¹ï¼šå‰æœ‰è‹±é›„ã€‚ åœ¨ä¸€åº§å±±æ´ä¸­ï¼Œä½ ä¼šé‡åˆ°ä¸€ä¸ªåä¸ºå¸•å¥‡çš„å…‰å¤´ï¼Œä¸€å¼€å§‹ä»–ä¼šæ”»å‡»ä½ ï¼Œä½†å¦‚æœä½ å°†ä»–æ‰“åˆ°åŠè¡€ï¼Œä»–ä¼šè·ªåœ°æ±‚é¥¶ï¼Œå¦‚æœä½ æ”¾è¿‡ä»–ï¼Œä»–å°±å¼€å§‹æ‹ä½ é©¬å±ã€‚ä»–çš„æˆ¿é—´é‡Œæ”¾ç€ä¸€ä¸ªå®ç®±ï¼Œå¦‚æœç©å®¶å»å¼€ï¼Œå°±ä¼šä¸­é™·é˜±è¢«ä¼ é€åˆ°åˆ«å¤„ï¼Œå¸•å¥‡è¿˜ä¼šå˜²ç¬‘æˆ‘ä»¬æ˜¯è´ªå©ªä¹‹å¾’ã€‚ä¹‹åç©å®¶å¯ä»¥åœ¨ç«å±±å®˜é‚¸é‡åˆ°ä»–ï¼Œä»–ä¼šå°†è‡ªå·±çš„çŒæ€ä»»åŠ¡è®©ç»™ä½ ï¼ˆå¤§æ¦‚ç‡æ˜¯å¤ªå¼ºä»–è‡ªå·±æ‰“ä¸è¿‡ï¼‰ï¼Œå¦‚æœä½ å®Œæˆäº†ä»»åŠ¡ï¼Œä»–ä¼šè¯´å¸®ä½ å»æ±‡æŠ¥ï¼Œä½†ä¸ä¼šæŠŠä»»åŠ¡å¥–åŠ±ç»™ä½ ï¼Œé™¤éä½ äº²è‡ªé—®ä»–æ‰ä¼šä¸æƒ…æ„¿åœ°ç»™ä½ ï¼Œä½†å°±æ˜¯è¿™æ ·ä¸€ä¸ªæ»‘å¤´ï¼Œå´åœ¨æ¸¸æˆé‡Œå¾—åˆ°å–„ç»ˆï¼Œé€é¥å¿«æ´»ã€‚ NPCä¸å¾—å–„ç»ˆï¼Œå‡ ä¹æ˜¯é­‚ç³»åˆ—çš„å®šå¾‹ï¼Œé‚£äº›åšæŒåŸåˆ™çš„è§’è‰²ï¼Œå¤§éƒ¨åˆ†è½å¾—å‡„æƒ¨çš„ä¸‹åœºï¼Œåè€Œæ˜¯å¸•å¥‡è¿™æ ·çš„è§’è‰²ï¼Œå´èƒ½æ´»å¾—æ¸¸åˆƒæœ‰ä½™ï¼Œè¿™ä½•å°ä¸æ˜¯å¯¹ç°å®ä¸–ç•Œçš„ä¸€ç§æ— æƒ…å˜²å¼„ã€‚å½“ç„¶ï¼Œé‚£äº›æ˜çŸ¥ä¸å¯ä¸ºè€Œä¸ºä¹‹çš„è§’è‰²ï¼Œè™½ç„¶æœ€ç»ˆé™¨è½ï¼Œä½†å´å®å®åœ¨åœ¨ç»™ç©å®¶çš„å¿ƒé‡Œç•™ä¸‹äº†ä¸€ä»½æ„ŸåŠ¨ã€‚ â€”â€”â€”3.21æ›´æ–°â€”â€”â€”â€”"},{"title":"è‰¾å°”ç™»æ³•ç¯è¯„ä»·","path":"2022/05/16/elden-ring/","text":"è¯´å®è¯ï¼Œä½œä¸ºæˆ‘ç¬¬ä¸€æ¬¾å…¨ä»·è´­ä¹°çš„steamæ¸¸æˆï¼Œè‰¾å°”ç™»æ³•ç¯å°±åƒä¸€åœºç››å®´ï¼Œä»–å‡ ä¹æ»¡è¶³äº†æˆ‘å¯¹å¥‡å¹»ä¸–ç•Œå’Œå®å¤§å²è¯—çš„å…¨éƒ¨æœŸå¾…ã€‚ä»å››æœˆä¸€æ—¥åˆ°å››æœˆåå…«æ—¥ï¼Œä¸€å‘¨ç›®è€—æ—¶105å°æ—¶ï¼Œå®Œæˆäº†æ‰€æœ‰çš„ç»“å±€å’Œå‡ ä¹æ‰€æœ‰çš„æ”¯çº¿ï¼Œåœ¨æ­¤æ„Ÿè°¢â€œè€æˆ´è§£è¯´â€ï¼Œåœ¨ä»–çš„è§†é¢‘å¸®åŠ©ä¸‹æˆ‘æˆåŠŸä½“éªŒåˆ°äº†è€å¤´ç¯çš„é­…åŠ›ï¼Œè¿˜æœ‰å…¨æˆå°±(^_^)ã€‚ ä¼˜ç‚¹ï¼š1.å®å¤§å²è¯—å’Œåºå¤§çš„ä¸–ç•Œè§‚ã€‚æœ€æ—©æ¥è§¦çš„é­‚ç±»æ¸¸æˆæ˜¯åªç‹¼ï¼Œåœ¨æˆ‘å¤šå‘¨ç›®ä¸åŒçš„ç»“å±€åï¼Œæˆ‘å¼€å§‹ä½“éªŒåˆ°é­‚ç±»æ¸¸æˆçš„é­…åŠ›ï¼Œè™½ç„¶é»‘é­‚3å‰æœŸæ‰“bosså¯¹æˆ‘æ¥è¯´å¹¶ä¸éš¾ï¼Œä½†æœ‰ä¸ªå¾ˆå¤´ç–¼çš„é—®é¢˜æ˜¯è¿·è·¯ï¼Œè¿™ä¹Ÿæ˜¯å¼ƒå‘é»‘é­‚3çš„åŸå› ã€‚æˆ‘ä¸ªäººéå¸¸å–œæ¬¢å®å¤§ä¸–ç•Œè§‚å’Œå²è¯—æ•…äº‹ï¼Œçœ‹å®Œäº†é¾™å´æ£’æ£’ç³–æ‰€æœ‰å…³äºé»‘é­‚èƒŒæ™¯çš„ä»‹ç»è§†é¢‘ä¹‹åï¼Œæˆ‘å¾ˆæœŸå¾…ä¹”æ²»é©¬ä¸å’Œå®«å´è€è´¼èƒ½æç»˜å‡ºå¤šä¹ˆç²¾å½©çš„ç”»å·ï¼Œåœ¨å‰§æƒ…å’ŒèƒŒæ™¯çš„è®¾å®šä¸Šï¼Œè€å¤´ç¯è¾¾åˆ°äº†æˆ‘å¯¹æ¸¸æˆçš„æœ€é«˜è¯„ä»·ã€‚ 2.ç¾å­¦è®¾è®¡/å‰æœ‰ç»æ™¯æˆ‘ä»å‡ºç”Ÿç‚¹å¼€å§‹ï¼Œå°±ä¸æ–­çš„F12æˆªå›¾ï¼Œä¸€ç›´åˆ°æ¸¸æˆç»“æŸï¼Œæ—¢æ˜¯è®°å½•æ¸¸æˆå‰§æƒ…ï¼Œä¹Ÿæ˜¯å¯¹æ¸¸æˆç”»é¢çš„æ„Ÿå¹ã€‚è™½ç„¶è€å¤´ç¯çš„è´´å›¾ä¸ç®—ç²¾ç»†ï¼Œä½†æ•´ä½“ç¯å¢ƒå……æ»¡äº†ç‰¹ç‚¹ï¼Œå¹¶ä¸”åœ¨è€å¤´ç¯ï¼Œä¸åŒçš„åœ°åŒºä¼šæœ‰ä¸åŒçš„åœºæ™¯æç»˜ï¼Œä¸åƒé»‘é­‚éƒ½æ˜¯é»‘æš—é˜´æ£®ã€‚ ä¸­æ€§ï¼ˆä¸ªäººçœ‹æ³•ï¼‰1.æˆ˜æ–—è®¾è®¡è¯´å®è¯è¿™ç§ç±»ä¼¼é»‘é­‚çš„æˆ˜æ–—ä½“éªŒå¹¶æ²¡æœ‰å¾ˆä¼˜ç§€ï¼Œå¿«æ…¢åˆ€åŠ è¯»æŒ‡ä»¤è¿˜æ˜¯å¾ˆå¤´ç—›çš„ï¼Œä¸ªäººæ¥è¯´è¿˜æ˜¯æ›´å–œæ¬¢åªç‹¼é‚£ç§åå‘ACTçš„æˆ˜æ–—é£æ ¼ï¼Œè€Œä¸æ˜¯æ»¡åœ°æ‰“æ»šå½“é©´å­¦æ´¾ç©å®¶ã€‚ä¸è¿‡æ³•å¸ˆçš„åŠ å…¥è®©è€å¤´ç¯å…¥é—¨æ›´åŠ ç®€å•ï¼Œä½œä¸ºä¸ç”¨çµé­‚æ¿€æµå°±å–œæ¬¢æœˆå…‰å‰‘è´´è„¸ç çš„ç‹‚æˆ˜å£«ç”˜é“å¤«ï¼Œè™½ç„¶å°‘éƒ¨åˆ†æ—¶å€™åœ¨å—è‹¦ï¼Œæ•´ä½“æ¥è¯´æˆ˜æ–—ä½“éªŒè¿˜æ˜¯ä¸é”™çš„ã€‚ ä½†æ˜¯ï¼åæœŸåœ£æ ‘ï¼Œé›ªå±±å’Œé›ªåŸï¼Œæ•°å€¼è†¨èƒ€çš„å¤ªç¦»è°±äº†ï¼Œä¸åˆ·çº§ä¸è¡Œï¼Œå°è±¡æ·±åˆ»çš„æ˜¯åœ£æ ‘ç½—è•¾å¡”é—¨å£çš„ä¸¤ä¸ªé­”æ³•å¸ˆï¼Œé¡¶çº§æ³•å¸ˆäº†å±äºæ˜¯ï¼Œæ”»å‡»åŠ›æé«˜ï¼Œè¡€è´¼åšï¼Œæ²¡æœ‰è“æ¡ï¼Œè¿œæ¯”åé¢çš„ç½—è•¾å¡”bosså¼ºï¼Œåœ°æ–¹åˆç‹­çª„ï¼Œåˆ«è¯´æˆ˜æ–—äº†ï¼Œå°±æ˜¯è·‘é…·éƒ½ä¸å¥½è·‘ã€‚ï¼ˆæ‰“åˆ°è¿™çš„æ—¶å€™å°±æ„Ÿå¹è¿™é‡Œçš„æ¯ä¸ªå°å…µéƒ½èƒ½æš´æ¶è‘›ç‘å…‹ä¹‹æµï¼‰ 2.åœ°å›¾è®¾è®¡å‰æœŸæ´çªŸå’Œåœ°é¢åŸæ± çš„è®¾è®¡ç®—æ˜¯éå¸¸å·§å¦™ï¼Œå¾ˆå¤šåœ°æ–¹æœ‰æ·å¾„æˆ–è€…æ„æƒ³ä¸åˆ°çš„åˆ°è¾¾æ–¹å¼ï¼Œè™½ç„¶ä¾ç„¶æœ‰å„ç§è½¬è§’é‡åˆ°èƒŒåˆºçš„å°å…µå’ŒçŸ³åƒé¬¼ï¼Œä½†è¿™ä¹Ÿç®—æ˜¯æ³•ç¯ä½œä¸ºææ€–æ¸¸æˆçš„ä¸€ç§æ ‡ç­¾ï¼Œä½†åæœŸé›ªåŸéå¸¸ç©ºæ—·ï¼Œå¦‚æœä¸æ˜¯è¿›å»çš„æš´é£é›ªæŒ¡ä½äº†è§†çº¿ï¼Œåˆšè¿›å»çš„é‚£é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰ 3.NPCè®¾è®¡NPCçš„è®¾è®¡å¯ä»¥è¯´æ˜¯æœ‰å¥½æœ‰åï¼Œæå†™éå¸¸æ·±åˆ»çš„æœ‰æˆ˜å£«å£¶äºšå†å±±å¤§ç‹¼å“¥è¿˜æœ‰äº²çˆ±çš„è€å¸ˆç‘Ÿå»‰ï¼Œä½†å…¶ä»–çš„å°±ä¸æ˜¯é‚£ä¹ˆå°è±¡æ·±åˆ»äº†ï¼Œå…¶å®å¦‚æœå¯ä»¥æŠŠæ”¯çº¿è¿åœ¨ä¸€èµ·çœ‹ï¼Œå¤§éƒ¨åˆ†NPCéƒ½æ˜¯æœ‰è¡€æœ‰è‚‰ï¼ˆè™½ç„¶ç»å¤§éƒ¨åˆ†éƒ½æ˜¯æ‚²å‰§ç»“å±€ï¼‰ä½†å·§å°±å·§åœ¨æ³•ç¯çš„å†…å®¹é‡å¤ªå¤§ï¼Œåˆæœ‰æ¥ä¸‹æ¥æåˆ°çš„ä»»åŠ¡æŒ‡å¼•é—®é¢˜ï¼Œåªæœ‰çœ‹æ”»ç•¥çŒ›æ”»ä¸€ä¸ªæ•…äº‹ï¼Œæ‰èƒ½ä½“ä¼šæ·±åˆ»ï¼Œå°±æ¯”å¦‚è¯´æµ·å¾·è¦å¡é‚£ä¸ªåŸä¸»ï¼Œè¦æˆ‘æ¥å›è·‘å›¾ï¼ˆä¸­é€”è¿˜æ²¡æœ‰èµç¦ï¼‰æ‰èƒ½æ¥è¿‘å®Œæˆä»»åŠ¡ã€‚è¿˜æœ‰ä¸ªé—®é¢˜æ˜¯è€å¤´ç¯é‡Œçš„NPCè·ŸæŠ•å¸æœ¨é©¬ä¼¼çš„ï¼Œè¯æ€»æ˜¯ä¸ä¸€æ¬¡è®²å®Œï¼Œå¿…é¡»å¾—ä¸åœçš„å¯¹è¯ã€‚é¡ºä¾¿ä¸€æï¼Œä¼ è¯´ä¸­çš„é­‚ç³»ç»å…¸äººç‰©å¸•å¥‡ï¼Œè¯´å®è¯å¦‚æœæ²¡æœ‰è¿™å±‚buffå¸•å¥‡å°±æ˜¯ä¸ªæ‚å…µï¼Œåœ¨ä¸€å‘¨ç›®æˆ‘é€šè¿‡æ”»ç•¥ç»å†äº†æ‰€æœ‰å’Œå¸•å¥‡æœ‰å…³çš„æ•…äº‹ï¼ŒåŒ…æ‹¬è¢«ä»–åœ¨ç«å±±åœ°åŒºè¸¹ä¸‹æ‚¬å´–ã€‚æˆ‘éå¸¸ä¸ç†è§£ä¸ºä»€ä¹ˆç©å®¶ä»¬ä¼šå–œæ¬¢è¿™æ ·ä¸€ä¸ªå·å¥¸è€æ»‘ä½œå¥¸çŠ¯ç§‘çš„NPCï¼Œåœ¨äºŒå‘¨ç›®æˆ‘é€‰æ‹©ç›´æ¥æŠŠä»–ç ç¿»ï¼Œé™¤äº†å‡ ä¸ªçŒæ€è¤ªè‰²è€…ä»»åŠ¡ï¼Œå³ä½¿æ²¡æœ‰ä»–æ•´ä¸ªæ•…äº‹æµç¨‹ä¹Ÿæ²¡æœ‰å½±å“ã€‚ ç¼ºç‚¹ï¼š1.æœ€åƒåœ¾ï¼šä»»åŠ¡æŒ‡å¼•ä»»åŠ¡æŒ‡å¼•å…¶å®ä¸èƒ½ç”¨åƒåœ¾æ¥å½¢å®¹ï¼Œåº”è¯¥æ˜¯å®Œå…¨æ²¡æœ‰ã€‚ç¢ç‰‡åŒ–å™äº‹æˆ‘å¯ä»¥æ¥å—ï¼Œä»¥å¾€çš„é­‚ç±»æ¸¸æˆéƒ½æ˜¯åœ¨ä¸€ä¸ªèµ°å»Šé‡ŒæŠŠå‰§æœ¬ä¸€å¼ å¼ æ”¾å¥½ï¼ˆä¸ä¸€å®šæŒ‰é¡ºåºï¼‰ï¼Œä½†ç°åœ¨ï¼Œä»–æŠŠå‰§æœ¬æ’’åœ¨äº†ä¸€ä¸ªå…­åå±‚å¤§æ¥¼é‡Œï¼Œéœ€è¦ä¸æ–­åœ°ä¸Šè¹¿ä¸‹è·³å»æ‰¾ï¼Œè€Œä¸”é‡Œé¢è¿˜æœ‰å„ç§å„æ ·çš„ç²ªå‘ã€‚æˆ‘ä¸ç›¸ä¿¡ä½œä¸ºä¸€ä¸ªæ™®é€šç©å®¶èƒ½å¤Ÿåœ¨ä¸çœ‹æ”»ç•¥çš„æƒ…å†µä¸‹åšå®Œå¤§éƒ¨åˆ†ä»»åŠ¡ï¼Œç”šè‡³è¯´ï¼Œä¸çœ‹æ”»ç•¥è¿å¾ˆå¤šæ”¯çº¿éƒ½ä¸çŸ¥é“åœ¨å“ªå¼€å§‹æ¥ã€‚ä½œä¸ºä¸€ä¸ªå¼€æ”¾ä¸–ç•Œï¼Œæ²¡æœ‰ä»»åŠ¡æ¸…å•æ„å‘³ç€æˆ‘æ ¹æœ¬è®°ä¸ä½å¤šä¸ªä»»åŠ¡ï¼Œä¸€è¾¹åœ¨è¢«å°å…µæš´æ€çš„åŒæ—¶æˆ‘è¿˜è¦è®°ä¸‹ä¸€æ­¥æ”¯çº¿æ€ä¹ˆèµ°ï¼Ÿå¥½äº›NPCæˆ‘ä¸€å¼€å§‹ä¸çœ‹æ”»ç•¥ä¸€å¤´é›¾æ°´ï¼Œ â€œä½ è°å•Šå°±è·Ÿæˆ‘æ­è¯â€æ›´åˆ«è¯´ä»€ä¹ˆå•†äººå–çš„æƒ…æŠ¥äº†ï¼Œæœ‰äº›å•†äººè—åœ¨ä»€ä¹ˆé¸Ÿä¸æ‹‰å±çš„åœ°æ–¹å•Šï¼Œä¸¾ä¸ªä¾‹å­ï¼Œå¡åˆ©äºšå­¦é™¢ä¼ é€é—¨é‚£é‡Œï¼Œé‚£ä¸ªå•†äººåœ¨ä¼ é€é—¨åé¢çš„æ–­æ¡¥å¤„ï¼Œä½†æ˜¯ï¼Œä½ ä¸èƒ½é€šè¿‡ä¼ é€é—¨èµ°ï¼Œè¦æ²¿ç€æ–­æ¡¥èµ°ï¼Œæ–­æ¡¥ä¸Šå…¨æ˜¯æ ‘æœ¨å’ŒçŒæœ¨ä¸›é®æŒ¡è§†çº¿ï¼Œè¿˜æœ‰ä¸€ç‰‡ç‹¼ç¾¤ï¼Œç„¶åæ‰èƒ½çœ‹åˆ°å•†äººï¼Œä¸çœ‹æ”»ç•¥å“ªä¸ªæ­£å¸¸äººä¼šåœ¨çœ‹åˆ°ä¼ é€é—¨çš„æƒ…å†µä¸‹å¾€æ–­æ¡¥é‡Œé’»ï¼Ÿå°±ç®—æœ‰å•†äººçš„æƒ…æŠ¥ï¼Œç±³è‰æ£®çš„æ”¯çº¿è¿˜æœ‰ä¸‰æŒ‡å¥³å·«çš„æ”¯çº¿çš„åœ°ç‚¹å°±å®Œå…¨æ²¡æœ‰æç¤ºï¼Œæœ¬æ¥ä»»åŠ¡æµç¨‹çš„é—´éš”éå¸¸å¤§ï¼Œè¿™äº›æ”¯çº¿æœ¬èº«ä½“é‡åˆæœ‰é™ï¼Œå¼€æ”¾ä¸–ç•Œè¿›ä¸€æ­¥åˆ†å‰²å¹¶åŠ å‰§äº†ä»»åŠ¡çš„ç¢ç‰‡åŒ–ï¼Œä½ å¿…é¡»å¾—åœ¨è¿™ä¸ªå¼€æ”¾ä¸–ç•Œé—²é€›ï¼Œæ‰èƒ½æ‰¾åˆ°ä»–ä»¬ï¼Œè¿™æ ·å°±å…‰å‰©ç¢ç‰‡æ²¡æ•…äº‹äº†ã€‚ä¸»çº¿å‰§æƒ…æœ‰ä¸ªå¤§é—®é¢˜æ˜¯æˆ‘æŠŠè€å©†å½“æŸ´ç«çƒ§äº†æ ‘ä»¥åå°±é»‘å±åˆ°å¤©ç©ºåŸäº†ï¼Ÿåˆ°äº†å¤©ç©ºåŸæˆ‘ä¸ºä»€ä¹ˆè¦å»æé»‘å‰‘ï¼Ÿä»€ä¹ˆæç¤ºä¹Ÿæ²¡æœ‰å°±è®©æˆ‘å»æ‹¿å‘½å®šä¹‹æ­»ï¼Ÿå‘½å®šä¹‹æ­»å‰é¢åªæåˆ°å¯ä»¥å¹²æ‰åŠç¥ï¼Œæ²¡è¯´å¹²æ‰é»‘å‰‘é‡Šæ”¾å‘½å®šä¹‹æ­»æ‰èƒ½çœŸæ­£çƒ§é»„é‡‘æ ‘ã€‚å¦‚æœåªèƒ½é€šè¿‡çœ‹æ”»ç•¥æ‰èƒ½å®Œæˆä»»åŠ¡ï¼Œé‚£ä¹ˆä½œä¸ºä¸€æ¬¾æ¸¸æˆæˆ‘è®¤ä¸ºæ³•ç¯çš„ä»»åŠ¡æŒ‡å¼•æ˜¯æå…¶å¤±è´¥çš„ã€‚æœ‰äººä¼šæ´—ç™½è¯´è¿™æ˜¯é­‚ç³»æ¸¸æˆçš„ç‰¹è‰²ï¼Œâ€œè€assä¸€å‘¨ç›®åŸºæœ¬ä¸ä¼šä¸Šç½‘æŸ¥çœ‹æ”»ç•¥çš„ï¼Œæœ€å¤šäº¤æµä¸‹è‡ªå·±å‘ç°çš„é—®é¢˜ã€‚é­‚æ¸¸æˆçš„ä¸€å‘¨ç›®æ— çŸ¥æ¢ç´¢æ˜¯æœ€æœ‰ä¹è¶£çš„è€Œä¸”è¿™ä¸ªæ— çŸ¥ä¸å¯é€†ã€‚â€ä½†è¿™æ˜¯å¼€æ”¾ä¸–ç•Œï¼Œä¸æ˜¯ä»¥å¾€çš„çº¿æ€§å™äº‹ï¼Œé­‚ç³»æ¸¸æˆçš„å‰ææ˜¯æ¸¸æˆï¼Œè¿™ä¹ˆå¤§çš„æ¸¸æˆä½“é‡éš¾é“è¦æˆ‘ä¸€ä¸ªæ™®é€šç©å®¶æ‹¿ä¸ªç¬”è®°æœ¬è‡ªå·±è®°ï¼Ÿ 2.éƒ¨åˆ†ç‰©å“è·å¾—è®¾è®¡æ•…äº‹æ•£å¸ƒåœ¨å¤§æ¥¼é‡Œå°±ç®—äº†ï¼Œé—®é¢˜æ˜¯åº•ä¸‹è¿˜æœ‰ç²ªå‘ï¼Œåœ¨æ­»æ ¹æ·±å¤„æœ‰ä¸ªä¼ è¯´æŠ¤ç¬¦ï¼Œéœ€è¦ç©¿è¿‡ä¸€ç‰‡é»‘æš—çš„èš‚èšçªï¼Œå°±æ˜¯åœ¨é»‘æš—ä¸­ï¼Œä½ å¾—è¾¨åˆ«èš‚èšçªçš„å¸ƒå±€çœ‹ç€æ— æ•°åªå·¨å¤§èš‚èšåœ¨è¾¹ä¸Šè¿›æ”»éª‘é©¬ç©¿æ¢­è·³è·ƒï¼Œæˆ‘æ˜¯çœŸçš„è¢«æ¶å¿ƒåˆ°äº†ï¼Œçº¯ç²¹çš„ç”Ÿç†æ¶å¿ƒï¼Œè¿™ä¸ªæŠ¤ç¬¦çš„æ”¾ç½®åœ°ç‚¹è®©æˆ‘ä¸å¯èƒ½ç»™è¿™ä¸ªæ¸¸æˆæ‰“æ»¡åˆ†ï¼Œçº¯ç²¹æ•…æ„æ¶å¿ƒç©å®¶ï¼Œä¸ä¼šæœ‰æ‰“ç€é­‚ç±»æ¸¸æˆçš„æ——å·çš„æ˜†è™«çˆ±å¥½è€…å–œæ¬¢å§ï¼Œä¸ä¼šå§ä¸ä¼šå§æ›´åˆ«æä»€ä¹ˆå¤§æ‰‹æ€ªè¿˜æœ‰èš¯èš“è„¸äº†ï¼Œä½†å¥½æ­¹æ²¡æœ‰é‚£ç§å¼ºåˆ¶ä½ ç›¯ç€çœ‹çš„è®¾è®¡å‡ºç°è¿˜æœ‰å„ç§å„æ ·çš„å¥‡æ€ªè—ä¸œè¥¿åœ°ç‚¹ï¼Œè®©æˆ‘æ„Ÿè§‰åˆ¶ä½œç»„åªæ˜¯æ•…æ„æŠŠä»–ä»¬è—åœ¨ç©å®¶æ‰¾ä¸åˆ°çš„åœ°ç‚¹ï¼Œè€Œä¸æ˜¯æ‰“å®Œä¸€åœºæˆ˜æ–—åçš„æˆ˜åˆ©å“ï¼Œæˆ‘åœ¨æ”¶é›†ç‰©å“æ—¶ï¼ˆç‰¹åˆ«æ˜¯åæœŸï¼‰å®Œå…¨æ²¡æœ‰é‚£ç§â€œåŸæ¥åœ¨è¿™é‡Œâ€çš„æƒŠå–œ 3.è·‘é…·è®¾è®¡åœ¨å°å…µå’Œæˆ¿é¡¶ç©¿æ¢­çš„æ—¶é—´è¿œè¿œå¤§äºæ‰“bossçš„æ—¶é—´ï¼Œå¾ˆå¤šæ— æ„ä¹‰çš„å †æ€ªè€—å°½è€å¿ƒã€‚å°è±¡æœ€æ·±çš„æ˜¯å¡åˆ©äºšå­¦é™¢æ¥¼é¡¶çš„è·‘é…·ï¼Œè·³åˆ°æœ‰ä¸€å¤„æˆ¿é¡¶çš„æ—¶å€™ï¼Œæœ¬æ¥è·ç¦»å°±è¿œä¸å¤ªå¥½è·³ï¼Œè¿˜åœ¨è¿™é‡Œå¸ƒç½®äº†ä¸€ä¸ªç±»ä¼¼åªç‹¼çš„é£ç­æ€ªï¼Œæˆ‘åœ¨ç©ºä¸­è¢«å®ƒæ‰“ä¸‹å»å¾ˆå¤šæ¬¡ï¼Œæˆ‘å¿äº†å¾ˆä¹…æ‰æ²¡æœ‰å¸æ¸¸æˆã€‚å½“ç„¶æœ‰äººæ´—ç™½è¯´è¿™æ˜¯é­‚ç³»æ¸¸æˆçš„ç‰¹ç‚¹ï¼Œæˆ‘åªèƒ½è¯´é€‚å½“çš„æ¶å¿ƒäººå¯ä»¥ï¼Œæ¶å¿ƒå¤šäº†å°±åªèƒ½å¾’å¢åŒæ¶ 4.å‰§æƒ…bugé»‘å‰‘å’Œé‡å…½ç¥­ç¥€ï¼Œè¿™æ˜¯å¾ˆå¤šäººéƒ½æåˆ°çš„bugäº†ï¼Œæ‰“å®Œé»‘å‰‘é‡å…½ç¥­ç¥€è¿˜åœ¨ï¼Œæœ‰äº›äººæ´—ç™½è¯´è¿™æ˜¯ä¸åŒæ—¶ç©ºçš„é»‘å‰‘ï¼Œä½†è€å¤´ç¯å‰é¢æ²¡æœ‰å‡ºç°ä»€ä¹ˆæ—¶ç©ºåˆ†å‰²çš„è®¾å®šï¼Œæˆ‘å€¾å‘äºæ˜¯æœ‰ä¸ªbugæˆ–è€…æ˜¯è¿™éƒ¨åˆ†æ²¡åšå®Œå°±æ‹¿å‡ºæ¥å‘å”®äº†ã€‚åæ§½ä¸€ä¸‹ï¼Œè¿˜æœ‰çƒ§æ ‘åé£åˆ°å¤©ç©ºåŸï¼Œè¿™éƒ½å•¥å•Šå°±é£ä¸Šå»äº†ï¼Ÿå’‹é£çš„å•Šï¼Œè¦æ˜¯æ¢…ç³å¨œæœ‰è¿™æœ¬äº‹å¥¹æ€ä¹ˆä¸æ—©ç”¨å‘¢ã€‚æœ‰äººè¯´æ˜¯æ¡‚å¥¥å°”é¾™å¢“çš„é‚£æ¡å¤§ç™½é¾™å¸¦æˆ‘ä»¬åˆ°å¤©ç©ºåŸçš„ï¼Œä½†è¿™éƒ½åªæ˜¯è§£åŒ…æ¨æµ‹çš„ï¼Œæœ¬èº«å‰§æƒ…å°±æ˜¯æœ‰æ–­å±‚ï¼Œå³ä½¿åç»­æœ‰æ›´æ–°ä½†æ¸¸æˆéƒ½å‘å”®äº†æ€»å¾—å…ˆæœ‰ä¸ªè‡ªåœ†å…¶è¯´çš„è§£é‡Šå§ï¼Œæ‹¿ä¸ªä»€ä¹ˆå•†äººæƒ…æŠ¥æˆ–è€…çŠ„è§’æ—®æ—¯é‡Œçš„ç¢ç‰‡å…ˆå½“è°œè¯­äººä¹Ÿè¡Œå•Šï¼Œä½†ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œå³ä½¿æ´—ç™½æœ‰æ³•ç¯ä½“é‡å¤§çš„ç†ç”±ï¼Œä½†äº‹å®åœ¨è¿™é‡Œï¼Œåœ¨è¿™ä¸€æ®µå°±æ˜¯æœ‰å‰§æƒ…ä¸Šçš„æ¼æ´ã€‚è¿˜æœ‰ä¸€ä¸ªæ˜¯å…³äºç«å±±å·¨äººçš„ï¼Œä»–ä¸æ˜¯è¢«é»„é‡‘å®¶æ—å¹²å€’äº†å—ï¼Œéƒ½è¢«ç›è‰å¡æ§åˆ¶äº†æ€ä¹ˆäºŒé˜¶æ®µè¿˜å¯ä»¥é€šè¿‡çŒ®ç¥­è·å¾—é‚ªç¥åŠ›é‡å•Šï¼Ÿè¦æ˜¯èƒ½å’Œé‚ªç¥æ²Ÿé€šæœ‰è‡ªæˆ‘æ„è¯†ä¸ºä»€ä¹ˆè¦é˜»æ­¢æˆ‘çƒ§æ ‘ï¼Œä¸åº”è¯¥é«˜é«˜å…´å…´æŠŠé»„é‡‘æ ‘ç»™ç‚¹äº†å—ï¼Œåˆä½•å¿…æ‰“ä¸Šè¿™ä¸€æ¶ã€‚"},{"title":"LeetCode01 K Sum","path":"2022/04/13/LeetCode01/","text":"ç»ˆäºå¼€å§‹æ­£å¼åˆ·é¢˜äº†ã€‚è¿™ä¹Ÿæ˜¯ç¬¬ä¸€ç¯‡å­¦ä¹ ç¬”è®°ï¼Œæˆ‘è®¡åˆ’ç”¨ä¸¤ä¸ªæœˆçš„æ—¶é—´ä»å¤´å¼€å§‹å­¦ä¹ ç®—æ³•å’Œleetcodeï¼Œäº‰å–åœ¨ç§‹æ‹›å‰åˆ·å®Œ200é¢˜ ä¸¤æ•°ä¹‹å’Œèµ·æ­¥å°±æ˜¯æœ€ç®€å•çš„ç¬¬ä¸€é¢˜ï¼Œè‹±æ–‡åï¼š1. Two Sum æš´åŠ›æ±‚è§£æ²¡æœ‰å­¦è¿‡ç®—æ³•çš„æˆ‘ç¬¬ä¸€ååº”å°±æ˜¯æš´åŠ›è§£æ³•ï¼Œç›´æ¥éå†ç®—ä¸€åœˆå°±å¯ä»¥å®Œäº‹ï¼Œä½†é€šå¸¸ä¼šè¶…æ—¶ã€‚ 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i = 0; i &lt; nums.size(); ++i) &#123; for(int j = i + 1; j &lt; nums.size(); ++j) &#123; if(target == nums[i] + nums[j]) &#123; return &#123;nums[i], nums[j]&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; å¤æ‚åº¦æˆ‘ä¹Ÿæ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦è¿™ä¸¤ä¸ªæ¦‚å¿µ å…·ä½“å­¦ä¹ é“¾æ¥:ç®—æ³•çš„æ—¶é—´ä¸ç©ºé—´å¤æ‚åº¦ï¼ˆä¸€çœ‹å°±æ‡‚ï¼‰ç®€å•æ¥è¯´æ—¶é—´å¤æ‚åº¦ï¼šæ‰§è¡Œç®—æ³•èŠ±äº†å¤šé•¿æ—¶é—´ç©ºé—´å¤æ‚åº¦ï¼šæ‰§è¡Œç®—æ³•èŠ±äº†å¤šå°‘å†…å­˜ å¸¸è§çš„æ—¶é—´å¤æ‚åº¦é‡çº§æœ‰ï¼š1. å¸¸æ•°é˜¶O(1)é‡ç‚¹ï¼šæ²¡æœ‰å¾ªç¯ç­‰å¤æ‚ç»“æ„ 12345int i = 1;int j = 2;++i;j++;int m = i + j; 2. å¯¹æ•°é˜¶O(logN)12345int i = 1;while(i&lt;n)&#123; i = i * 2;&#125; åœ¨whileå¾ªç¯é‡Œé¢ï¼Œæ¯æ¬¡éƒ½å°† i ä¹˜ä»¥ 2ï¼Œä¹˜å®Œä¹‹åï¼Œi è·ç¦» n å°±è¶Šæ¥è¶Šè¿‘äº†ã€‚å‡è®¾å¾ªç¯xæ¬¡ä¹‹åiå°±å¤§äºnï¼Œæ­¤æ—¶è¿™ä¸ªå¾ªç¯å°±é€€å‡ºäº†ï¼Œä¹Ÿå°±æ˜¯è¯´ 2 çš„ x æ¬¡æ–¹ç­‰äº nï¼Œé‚£ä¹ˆ x = log2(n)è¿™é‡ŒæŠŠæ•°å­—è®¾æˆ2ï¼Œå½“næ— é™å¤§çš„æ—¶å€™ï¼Œæ•°å­—æ˜¯å¤šå°‘éƒ½æ— æ‰€è°“ï¼Œæ‰€ä»¥ç»Ÿç§°ä¸ºlogN 3. çº¿æ€§é˜¶O(n)12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; forå¾ªç¯é‡Œé¢çš„ä»£ç ä¼šæ‰§è¡Œnéï¼Œå› æ­¤å®ƒæ¶ˆè€—çš„æ—¶é—´æ˜¯éšç€nçš„å˜åŒ–è€Œå˜åŒ–çš„ã€‚ç®€è€Œè¨€ä¹‹ï¼Œnè·Ÿç»“æœæœ‰å…³ç³»å°±ä¸æ˜¯å¸¸æ•°é˜¶ï¼Œä¸€ä¸ªå¾ªç¯å¯¹åº”ä¸€ä¸ªçº¿æ€§é˜¶ 4. çº¿æ€§å¯¹æ•°é˜¶O(nlogN)çº¿æ€§å¯¹æ•°é˜¶O(nlogN) å°±æ˜¯æŠŠæ—¶é—´å¤æ‚åº¦ä¸ºO(logN)çš„ä»£ç å¤–é¢å¥—ä¸€ä¸ªå¾ªç¯ï¼Œå¾ªç¯Néçš„è¯ï¼Œé‚£ä¹ˆå®ƒçš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ n * O(logN)ï¼Œä¹Ÿå°±æ˜¯äº†O(nlogN) 12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i&lt;n) &#123; i = i * 2; &#125;&#125; 5. å¹³æ–¹é˜¶O($n^2$)æ€»ç»“ï¼šä¸¤ä¸ªå¾ªç¯æˆ–è€…è¯´ä¸¤ä¸ªçº¿æ€§é˜¶å¥—å¨ƒ 12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 6. ç«‹æ–¹é˜¶O($n^3$)æ€»ç»“ï¼šä¸‰ä¸ªå¾ªç¯æˆ–è€…è¯´ä¸‰ä¸ªçº¿æ€§é˜¶å¥—å¨ƒ 1234567891011for(y=1;y&lt;=n;y++&gt;)&#123; for(x=1; i&lt;=n; x++) &#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125; &#125;&#125; 7. Kæ¬¡æ–¹é˜¶O($n^k$)æ€»ç»“ï¼šKä¸ªå¾ªç¯æˆ–è€…è¯´Kä¸ªçº¿æ€§é˜¶å¥—å¨ƒ 8. æŒ‡æ•°é˜¶(2^n)å›å¿†ä¸€ä¸‹æŒ‡æ•°çš„å›¾åƒï¼Œéšç€æ•°æ®è§„æ¨¡çš„å¢é•¿ï¼Œç®—æ³•çš„æ‰§è¡Œæ—¶é—´å’Œç©ºé—´å ç”¨æš´å¢ï¼Œè¿™ç±»ç®—æ³•æ€§èƒ½æå·®ã€‚ 12345678aFunc( n ) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; å¸¸è§çš„ç©ºé—´å¤æ‚åº¦é‡çº§æœ‰ï¼šO(1)ã€O(n)ã€O(nÂ²)1. O(1)å¦‚æœç®—æ³•æ‰§è¡Œæ‰€éœ€è¦çš„ä¸´æ—¶ç©ºé—´ä¸éšç€æŸä¸ªå˜é‡nçš„å¤§å°è€Œå˜åŒ–ï¼Œå³æ­¤ç®—æ³•ç©ºé—´å¤æ‚åº¦ä¸ºä¸€ä¸ªå¸¸é‡ï¼Œå¯è¡¨ç¤ºä¸º O(1) 12345int i = 1;int j = 2;++i;j++;int m = i + j; ä»£ç ä¸­çš„ iã€jã€m æ‰€åˆ†é…çš„ç©ºé—´éƒ½ä¸éšç€å¤„ç†æ•°æ®é‡å˜åŒ–ï¼Œå› æ­¤å®ƒçš„ç©ºé—´å¤æ‚åº¦ S(n) = O(1) 2. O($n$)123456int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; è¿™æ®µä»£ç ä¸­ï¼Œç¬¬ä¸€è¡Œnewäº†ä¸€ä¸ªæ•°ç»„å‡ºæ¥ï¼Œè¿™ä¸ªæ•°æ®å ç”¨çš„å¤§å°ä¸ºnï¼Œè¿™æ®µä»£ç çš„2-6è¡Œï¼Œè™½ç„¶æœ‰å¾ªç¯ï¼Œä½†æ²¡æœ‰å†åˆ†é…æ–°çš„ç©ºé—´ï¼Œå› æ­¤ï¼Œè¿™æ®µä»£ç çš„ç©ºé—´å¤æ‚åº¦ä¸»è¦çœ‹ç¬¬ä¸€è¡Œå³å¯ï¼Œå³ S(n) = O(n) 3. O($n^2$)12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; äºŒåˆ†æŸ¥æ‰¾å…·ä½“å­¦ä¹ é“¾æ¥:å¤œæ·±äººé™å†™ç®—æ³•ï¼ˆå››åå››ï¼‰- n æ•°ä¹‹å’Œfucking-algorithm/ç®—æ³•æ€ç»´ç³»åˆ—/äºŒåˆ†æŸ¥æ‰¾è¯¦è§£.mdäºŒåˆ†æŸ¥æ‰¾ç®€å•æ¥è¯´å°±æ˜¯ä»ä¸­é—´ä¸€ä¸ªæ•°å¼€å§‹åˆ†æˆä¸¤è¾¹ï¼Œå·¦è¾¹æ‰¾ä¸€ä¸‹ï¼Œæ‰¾ä¸åˆ°å°±æ‰¾å³è¾¹çš„ï¼Œå³è¾¹é‡Œå‘ç°äº†è¿™ä¸ªæ•°ï¼Œå°±å†é€šè¿‡ä¸­é—´ä¸€ä¸ªæ•°åˆ†æˆä¸¤è¾¹ï¼Œå¾ªç¯è‡³æ‰¾åˆ°è¿™ä¸ªæ•°äºŒåˆ†æŸ¥æ‰¾æ¡†æ¶123456789101112131415int binarySearch(int[] nums, int target) &#123; int left = 0, right = ...; while(...) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; ... &#125; else if (nums[mid] &lt; target) &#123; left = ... &#125; else if (nums[mid] &gt; target) &#123; right = ... &#125; &#125; return ...;&#125; è®²å›è¿™é“é¢˜ 1.å¯¹æ•°ç»„æ’åºï¼›2.ä»å‰å¾€åæšä¸¾ç¬¬ä¸€ä¸ªæ•° nums[i]ï¼›3.ç”±äºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥å¯ä»¥ä»å‰©ä¸‹çš„æ•°ä¸­ï¼ŒäºŒåˆ†æŸ¥æ‰¾target - nums[i]ï¼Œä¸€æ—¦æ‰¾åˆ°ï¼Œåˆ™è¿”å›äºŒå…ƒç»„ &#123; nums[i], target - nums[i] &#125;ï¼›Hashmapå…·ä½“å­¦ä¹ é“¾æ¥:å¤œæ·±äººé™å†™ç®—æ³•ï¼ˆå››åå››ï¼‰- n æ•°ä¹‹å’Œfucking-algorithm/ç®—æ³•æ€ç»´ç³»åˆ—/äºŒåˆ†æŸ¥æ‰¾è¯¦è§£.mdå…·ä½“å­¦ä¹ é“¾æ¥:å°ç™½ Python å‡ ç§è§£æ³•12345678910111213141516class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; hashmap=&#123;&#125; for ind,num in enumerate(nums): hashmap[num] = ind for i,num in enumerate(nums): j = hashmap.get(target - num) if j is not None and i!=j: return [i,j] 12Runtime: 46 ms, faster than 90.61% of Python online submissions for Two Sum.Memory Usage: 14.3 MB, less than 45.68% of Python online submissions for Two Sum. æ”¹è¿›ç‰ˆ 1234567class Solution(object): def twoSum(nums, target): hashmap=&#123;&#125; for i,num in enumerate(nums): if hashmap.get(target - num) is not None: return [i,hashmap.get(target - num)] hashmap[num] = i #è¿™å¥ä¸èƒ½æ”¾åœ¨ifè¯­å¥ä¹‹å‰ï¼Œè§£å†³listä¸­æœ‰é‡å¤å€¼æˆ–target-num=numçš„æƒ…å†µ 12Runtime: 41 ms, faster than 95.66% of Python online submissions for Two Sum.Memory Usage: 14.4 MB, less than 45.68% of Python online submissions for Two Sum. Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sitesMore info: Deployment è§£ç®—å‡ºæ¥çš„ä»£ç  12345678910class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: seen = &#123;&#125; for i, value in enumerate(nums): remaining = target - nums[i] if remaining in seen: return [i, seen[remaining]] seen[value] = i ç»“æœ 12Runtime: 68 ms, faster than 84.35% of Python3 online submissions for Two Sum.Memory Usage: 15.3 MB, less than 25.99% of Python3 online submissions for Two Sum."},{"title":"plan","path":"2021/10/05/plan/","text":"Steins;Gate"},{"title":"first blog","path":"2021/09/24/first-blog/","text":"è¿™é‡Œæ˜¯è®°å½•ç ”ç©¶ç”Ÿç”Ÿæ´»å’Œå­¦ä¹ çš„ç¬¬ä¸€ç¯‡æ–‡ç« ï¼Œä¹Ÿæ˜¯ä¸€åˆ‡çš„å¼€å§‹ã€‚ç”Ÿæ´»ç¯‡åˆ†ä¸ºæ—¥è®°ï¼Œå›å¿†ï¼Œç”Ÿæ´»æŠ€å·§ã€‚ æ—¥è®°12021.9.24å·²ç»æ˜¯ä¸Šè¯¾çš„ç¬¬ä¸‰å‘¨äº†ï¼Œé€æ¸ä¹ æƒ¯äº†è¿™æ ·çš„å­¦ä¹ èŠ‚å¥å’Œè‡ªå·±åšé¥­çš„ç”Ÿæ´»ã€‚ä»Šå¤©çƒ§äº†ä¸€ä»½çº¢çƒ§è¹„è†€ã€‚åœ¨åè¶…ä¹°çš„è¹„è†€ï¼Œè®©äººå‡ºä¹æ„æ–™çš„äº‹è¹„è†€å±…ç„¶æ˜¯æœ€ä¾¿å®œçš„è‚‰ç±»ï¼ŒçœŸæ˜¯æš´æ®„å¤©ç‰©å•Šã€‚"},{"title":"how to start the first blog","path":"2021/09/24/å¦‚ä½•å†™blog/","text":"åˆ›å»ºæ–°blogä¸ªäººåšå®¢å­¦ä¹ æ€»ç»“åŸºæœ¬å¯ä»¥æŒ‰ç…§è¿™ä¸ªæµç¨‹èµ° http://localhost:4000/ hexo ç¾åŒ–Hexo å…¥é—¨æŒ‡å—ï¼ˆå››ï¼‰ - é¡µé¢ã€å¯¼èˆªã€è¾¹æ ã€åº•æ  https://hexo.io/themes/ https://picx.xpoet.cn/#/management github corners å›¾æ ‡ https://hexo.io/zh-cn/docs/writing æµç¨‹"},{"title":"Hello World","path":"2021/09/07/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]