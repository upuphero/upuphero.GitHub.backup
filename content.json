[{"title":"599. Minimum Index Sum of Two Lists(easy)","path":"2022/11/21/599/","text":"599. Minimum Index Sum of Two Lists(easy)Given two arrays of strings list1 and list2, find the common strings with the least index sum.A common string is a string that appeared in both list1 and list2.A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.Return all the common strings with the least index sum. Return the answer in any order.先找出两个list相同的字符，再记录下最小的数值，然后用hashmap找到对应的字符 class Solution: def findRestaurant(self, list1: List[str], list2: List[str]) -&gt; List[str]: ans=[] d=&#123;&#125; for i in range(len(list1)): if list1[i] in list2: d[list1[i]]=i+list2.index(list1[i]) min_index=min(d.values()) res=[] for i in d: if d[i]==min_index: res.append(i) return res"},{"title":"917. Reverse Only Letters(easy)","path":"2022/11/21/917/","text":"917. Reverse Only Letters(easy)Given a string s, reverse the string according to the following rules:All the characters that are not English letters remain in the same position.All the English letters (lowercase or uppercase) should be reversed.Return s after reversing it.stack用在这里正好，字母存进栈，等识别到符号就放符号，不是符号就pop 12345678910class Solution: def reverseOnlyLetters(self, s: str) -&gt; str: letters=[c for c in s if c.isalpha()] ans=[] for c in s: if c.isalpha(): ans.append(letters.pop()) else: ans.append(c) return &quot;&quot;.join(ans)"},{"title":"598. Range Addition II(easy)","path":"2022/11/21/598/","text":"You are given an m x n matrix M initialized with all 0’s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi. Count and return the number of maximum integers in the matrix after performing all the operations. class Solution: def maxCount(self, m: int, n: int, ops: List[List[int]]) -&gt; int: mina, minb = m, n for a, b in ops: mina = min(mina, a) minb = min(minb, b) return mina * minb"},{"title":"709. To Lower Case(easy)","path":"2022/11/21/709/","text":"709. To Lower Case(easy)Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.123class Solution: def toLowerCase(self, s: str) -&gt; str: return s.lower()"},{"title":"222. Count Complete Tree Nodes(medium)","path":"2022/11/16/222/","text":"222. Count Complete Tree Nodes(medium)Given the root of a complete binary tree, return the number of the nodes in the tree.According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.Design an algorithm that runs in less than O(n) time complexity.Solution:wiki:完全二叉树 (Complete Binary Tree)：A Complete Binary Tree （CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. 对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 换句话说，完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。 完美二叉树 (Perfect Binary Tree)：A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2. 二叉树的第i层至多拥有 2^{i-1} 个节点数；深度为k的二叉树至多总共有 {\\displaystyle 2^{\\begin{aligned}k+1\\end{aligned}}-1} 个节点数，而总计拥有节点数匹配的，称为“满二叉树”； 完满二叉树 (Full Binary Tree):A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children. 换句话说，所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子。） 思路我们还是要来利用一下完全二叉树这个条件，不然感觉对出题者不太尊重。通过上面对完全二叉树跟完美二叉树的定义比较，可以看出二者的关系是，完美二叉树一定是完全二叉树，而完全二叉树不一定是完美二叉树。那么这道题给的完全二叉树就有可能是完美二叉树，若是完美二叉树，节点个数很好求，为2的h次方减1，h为该完美二叉树的高度。若不是的话，只能老老实实的一个一个数结点了。思路是由 root 根结点往下，分别找最靠左边和最靠右边的路径长度，如果长度相等，则证明二叉树最后一层节点是满的，是满二叉树，直接返回节点个数，如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1(根节点)，其中左右子树节点个数的计算可以使用递归来计算，参见代码如下： 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def countNodes(self, root: Optional[TreeNode]) -&gt; int: hLeft=0 hRight=0 pLeft=root pRight=root while pLeft: hLeft+=1 pLeft=pLeft.left while pRight: hRight+=1 pRight=pRight.right if hLeft==hRight: return pow(2,hLeft)-1 return self.countNodes(root.left)+self.countNodes(root.right)+1"},{"title":"354. Russian Doll Envelopes(hard)","path":"2022/11/16/354/","text":"354. Russian Doll Envelopes(hard)You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope’s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope. 这道题和300. Longest Increasing Subsequence(medium)属于类似问题，只不过该问题把维度升到二维了，先对宽度 w 进行升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序；之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案。 12345678910111213141516171819202122class Solution: def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int: if not envelopes: return 0 n = len(envelopes) envelopes.sort(key=lambda x: (x[0], -x[1]))#w升序排列，h降序排列 arr=[envelopes[0][1]] for i in range(n): if envelopes[i][1]&gt;arr[-1]: arr.append(envelopes[i][1]) elif envelopes[i][1]&lt;arr[-1]: left,right=0,n-1 while left&lt;right: mid=left+(right-left)//2 #这里用mid=(left+right)//2 会超范围 if arr[mid]&gt;=envelopes[i][1]: right=mid else: left=mid+1 arr[left]=envelopes[i][1] return len(arr)"},{"title":"521. Longest Uncommon Subsequence I(easy)","path":"2022/11/16/521/","text":"521. Longest Uncommon Subsequence I(easy)Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.An uncommon subsequence between two strings is a string that is a subsequence of one but not the other.A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.For example, “abc” is a subsequence of “aebdc” because you can delete the underlined characters in “aebdc” to get “abc”. Other subsequences of “aebdc” include “aebdc”, “aeb”, and “” (empty string).这道题很唬人啊，我一开始以为是双指针两个字符串不断比较，后来发现，只需要判断一点即可，如果字符串a和b相同，那么返回-1如果不相同，最大的不同子字符串就是最长的那个字符串 123456class Solution: def findLUSlength(self, a: str, b: str) -&gt; int: if a==b: return -1 else: return max(len(a),len(b))"},{"title":"520. Detect Capital(easy)","path":"2022/11/16/520/","text":"520. Detect Capital(easy)We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”.All letters in this word are not capitals, like “leetcode”.Only the first letter in this word is capital, like “Google”.Given a string word, return true if the usage of capitals in it is right. 分几种情况讨论，然后用到了isupper()和islower()两个函数 1234567891011121314151617class Solution: def detectCapitalUse(self, word: str) -&gt; bool: n=len(word) if n==1: return True elif word.isupper(): return True elif word.islower(): return True elif word[0].isupper(): if word[1:].islower(): return True else: return False else: return False"},{"title":"300. Longest Increasing Subsequence(medium)","path":"2022/11/15/300/","text":"300. Longest Increasing Subsequence(medium)Given an integer array nums, return the length of the longest strictly increasing subsequence.求最长严格递增子序列的长度。 官方题解方法一：动态规划这个方法会超时 123456789101112class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [] for i in range(len(nums)): dp.append(1) for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 方法二：贪心 + 二分查找这道题的方法二，原题解写的不太容易理解，试着在这里再解释一遍： 无序列表最关键的一句在于： 数组 d[i]表示长度为 i 的最长上升子序列的末尾元素的最小值，即在数组 1,2,3,4,5,6中长度为3的上升子序列可以为 1,2,3也可以为 2,3,4等等但是d[3]=3，即子序列末尾元素最小为3。 无序列表解释清了数组d的含义之后，我们接着需要证明数组d具有单调性，即证明i&lt;j时，d[i]&lt;d[j]，使用反证法，假设存在k&lt;j时，d[k]&gt;d[j]，但在长度为j，末尾元素为d[j]的子序列A中，将后j-i个元素减掉，可以得到一个长度为i的子序列B，其末尾元素t1必然小于d[j]（因为在子序列A中，t1的位置上在d[j]的后面），而我们假设数组d必须符合表示长度为 i 的最长上升子序列的末尾元素的最小值，此时长度为i的子序列的末尾元素t1&lt;d[j]&lt;d[k]，即t1&lt;d[k]，所以d[k]不是最小的，与题设相矛盾，因此可以证明其单调性 无序列表证明单调性有两个好处：1.可以使用二分法；2.数组d的长度即为最长子序列的长度；"},{"title":"501. Find Mode in Binary Search Tree(easy)","path":"2022/11/15/501/","text":"501. Find Mode in Binary Search Tree(easy)Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.If the tree has more than one mode, return them in any order.Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees. 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findMode(self, root: Optional[TreeNode]) -&gt; List[int]: counter= defaultdict(int) def dfs(root): if not root: return counter[root.val]+=1 dfs(root.left) dfs(root.right) dfs(root) max_val=max(counter.values()) return [i for i in counter if counter[i]==max_val]"},{"title":"506. Relative Ranks(easy)","path":"2022/11/15/506/","text":"506. Relative Ranks(easy)You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:The 1st place athlete’s rank is “Gold Medal”.The 2nd place athlete’s rank is “Silver Medal”.The 3rd place athlete’s rank is “Bronze Medal”.For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete’s rank is “x”).Return an array answer of size n where answer[i] is the rank of the ith athlete. 123456789101112131415class Solution: def findRelativeRanks(self, score: List[int]) -&gt; List[str]: nums=sorted(score) res=[] for i in range(len(score)): if nums.index(score[i])==len(score)-1: res.append(&#x27;Gold Medal&#x27;) elif nums.index(score[i])==len(score)-2: res.append(&#x27;Silver Medal&#x27;) elif nums.index(score[i])==len(score)-3: res.append(&#x27;Bronze Medal&#x27;) else: res.append(str(len(nums)-nums.index(score[i]))) return res"},{"title":"507. Perfect Number(easy)","path":"2022/11/15/507/","text":"A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly. Given an integer n, return true if n is a perfect number, otherwise return false. 所有的余数之和等于num本身 123456789101112class Solution: def checkPerfectNumber(self, num: int) -&gt; bool: res=[] x=sqrt(num) if num==1: return False for i in range(1,int(x)+1): if num%i==0: res.append(i) if i!=1: res.append(num//i) return sum(res)==num"},{"title":"504. Base 7(easy)","path":"2022/11/15/504/","text":"504. Base 7(easy)Given an integer num, return a string of its base 7 representation.12345678910111213141516class Solution: def convertToBase7(self, num: int) -&gt; str: res=list() x=num num=abs(num) if num==0: return &quot;0&quot; while num!=0: carry=num%7 num=(num-carry)//7 res.append(carry) res=res[::-1] if x&gt;0: return &quot;&quot;.join(map(str,res)) elif x&lt;0: return &quot;-&quot;+&quot;&quot;.join(map(str,res))"},{"title":"500. Keyboard Row(easy)","path":"2022/11/15/500/","text":"500. Keyboard Row(easy)Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below. In the American keyboard: the first row consists of the characters “qwertyuiop”,the second row consists of the characters “asdfghjkl”, andthe third row consists of the characters “zxcvbnm”. 123456789101112131415class Solution: def findWords(self, words: List[str]) -&gt; List[str]: s1 = &quot;qwertyuiop&quot; s2 = &quot;asdfghjkl&quot; s3 = &quot;zxcvbnm&quot; res = [] for word in words: cnt1 = cnt2 = cnt3 = 0 for c in list(word.lower()): if c in s1: cnt1 += 1 if c in s2: cnt2 += 1 if c in s3: cnt3 += 1 if (len(word) == cnt1) or (len(word) == cnt2) or (len(word) == cnt3): res.append(word) return res"},{"title":"482. License Key Formatting(easy)","path":"2022/11/15/482/","text":"482. License Key Formatting(easy)You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.Return the reformatted license key.1234Input: s = &quot;5F3Z-2e-9-w&quot;, k = 4Output: &quot;5F3Z-2E9W&quot;Explanation: The string s has been split into two parts, each part has 4 characters.Note that the two extra dashes are not needed and can be removed. 1234567891011121314151617class Solution: def licenseKeyFormatting(self, s: str, k: int) -&gt; str: ans = list() cnt = 0 for i in range(len(s) - 1, -1, -1): if s[i] != &quot;-&quot;: ans.append(s[i].upper()) cnt += 1 if cnt % k == 0: ans.append(&quot;-&quot;) if ans and ans[-1] == &quot;-&quot;: ans.pop() return &quot;&quot;.join(ans[::-1])"},{"title":"495. Teemo Attacking(easy)","path":"2022/11/15/495/","text":"495. Teemo Attacking(easy)Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.Return the total number of seconds that Ashe is poisoned.123456class Solution: def findPoisonedDuration(self, timeSeries: List[int], duration: int) -&gt; int: ans=duration*len(timeSeries) for i in range(1,len(timeSeries)): ans-=max(0,duration-(timeSeries[i]-timeSeries[i-1])) return ans"},{"title":"492. Construct the Rectangle(easy)","path":"2022/11/15/492/","text":"492. Construct the Rectangle(easy)A web developer needs to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:The area of the rectangular web page you designed must equal to the given target area.The width W should not be larger than the length L, which means L &gt;= W.The difference between length L and width W should be as small as possible.Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.1234Input: area = 4Output: [2,2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. 12345class Solution: def constructRectangle(self, area: int) -&gt; List[int]: for i in range(int(area**0.5),0,-1): if area%i==0: return [area//i,i]"},{"title":"476. Number Complement(easy)","path":"2022/11/15/476/","text":"476. Number Complement(easy)The complement of an integer is the integer you get when you flip all the 0’s to 1’s and all the 1’s to 0’s in its binary representation.For example, The integer 5 is “101” in binary and its complement is “010” which is the integer 2.Given an integer num, return its complement.今天这道题乍看之下很简单，直接跟二进制全 1 的数异或即可： 比如：给定数字为 5 （101），跟 111 进行异或运算，结果为 010。 实则不然，因为计算机在存储 5 这个数字的时候是按照 32 位来进行存储的，应该为 00000000000000000000000000000101（下简写为00..00101），所以，跟 32 位全是 1 的数字异或之后，高位的那些 0 也会全部变成 1，最终的结果为 11111111111111111111111111111010，与题目给定的结果将不一致。 所以，我们需要换一种思路。 其实，我们只需要找到最高位的 1，将最高位的 1 所在的位置及比它低的位置全变成 1，再异或即可。 比如，给定数字为 5（00..00101），最高位的 1 是第三位，我们将第三位及比它低的位置全变成 1，即 00..00111，再进行异或就得到了 010 这个结果。 那么，如何找到最高位的 1，又如何将其及比它低的位置全变成 1 呢？ 关于第一个问题：我们这里介绍一种非常简单高效的方式，每次找到最低位（最右边）的 1 并把它打掉（变成 0），最终找到最高位的 1。 关于第二个问题：我们只需要将最高位的 1 左移一位，再减 1，就可以得到最高位为 1 的位置及比它低的位置全是 1 的数字了。 比如，给定数字为 5（00..00101），我们第一次找到的 1 是 00.00001，把它打掉后数字变为 00..00100，然后，找到的第二个 1 是 00..00100，把这个 1 再打掉后数字变为 00..00000，所以，我们要找的最高位的 1 就是 00..00100 这个数字，把这个数字左移一位变成00..01000，再减 1 得到 00..00111，最后，再与原数字异或，得到 00..00010，完事儿。 关于溢出：题目约定了给定的数字为大于或等于 1 的 32 位数字，所以，32 位的最高位不会为 1，因此，不会溢出 。 作者：tong-zhu链接：https://leetcode.cn/problems/number-complement/solution/tong-ge-lai-shua-ti-la-jian-dan-gao-xiao-k0p9/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 12345678class Solution: def findComplement(self, num: int) -&gt; int: highbit=1 x=num while x!=0: highbit=x&amp;(-x) x=x&amp;(x-1) return num^((highbit&lt;&lt;1)-1)"},{"title":"796. Rotate String(easy)","path":"2022/11/14/796/","text":"Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.A shift on s consists of moving the leftmost character of s to the rightmost position.For example, if s = “abcde”, then it will be “bcdea” after one shift.可以用子字符串的方式，判断goal在不在两个s连在一起的字符串里 class Solution: def rotateString(self, s: str, goal: str) -&gt; bool: if len(s)!=len(goal): return False else: if goal in s+s: return True else: return False"},{"title":"128. Longest Consecutive Sequence(medium)","path":"2022/11/14/128/","text":"128. Longest Consecutive Sequence(medium)Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.You must write an algorithm that runs in O(n) time.123Input: nums = [100,4,200,1,3,2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 先对nums取set后排序(如果有相同的数字，是可以直接跳过，而且计数也不会停的)，然后不断计数连续的数字 1234567891011121314151617class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: nums=list(set(nums)) nums.sort() if len(nums)==0: return 0 elif len(nums)==1: return 1 res=0 count=1 for i in range(1,len(nums)): if nums[i]-nums[i-1]==1: count+=1 else: count=1 res=max(res,count) return res"},{"title":"238. Product of Array Except Self(medium)","path":"2022/11/14/238/","text":"238. Product of Array Except Self(medium)Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation.因为题目限制了除法，所以为了缩减时间复杂度，模仿前缀和数组，建立两个数组，一个从左边乘得到的数组，一个从右边乘得到的数组，最后的结果就等于两个数组在相同位置的乘积 12345678910111213class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: n=len(nums) L,R,res=[0]*n,[0]*n,[0]*n L[0]=1 R[n-1]=1 for i in range(1,n): L[i]=nums[i-1]*L[i-1] for i in reversed(range(n-1)): R[i]=nums[i+1]*R[i+1] for i in range(n): res[i]=L[i]*R[i] return res"},{"title":"49. Group Anagrams(medium)","path":"2022/11/14/49/","text":"49. Group Anagrams(medium)Given an array of strings strs, group the anagrams together. You can return the answer in any order.An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.leetcode 官方题解由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。这道题主要是把字符串本身当作键，字母相同的字符作为键是同一个 12345678class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: n=len(strs) mp=collections.defaultdict(list) for st in strs: key=&quot;&quot;.join(sorted(st)) mp[key].append(st) return list(mp.values())"},{"title":"217. Contains Duplicate(easy)","path":"2022/11/14/217/","text":"217. Contains Duplicate(easy)Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.12Input: nums = [1,2,3,1]Output: true 利用ｓｅｔ的去重属性 123class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: return len(set(nums))!=len(nums)"},{"title":"2131. Longest Palindrome by Concatenating Two Letter Words(medium)","path":"2022/11/12/2131/","text":"2131. Longest Palindrome by Concatenating Two Letter Words(medium)You are given an array of strings words. Each element of words consists of two lowercase English letters.Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.A palindrome is a string that reads the same forward and backward.力扣官方题解 方法一：贪心 + 哈希表思路与算法 根据回文串的定义，回文串可以由奇数或者偶数个 words 中的单词拼接而成，但必须满足以下条件： 如果数量为奇数，那么位于正中间的单词必须是回文字符串（即两个字符相等）； 每个单词和反转后对应位置的单词必须互为反转字符串。 根据上面的两个条件，我们可以得出构造最长回文串的规则： 对于两个字符不同的单词，需要尽可能多的成对选择它和它的反转字符串（如有）； 对于两个字符相同的单词，需要尽可能多的成对选择该单词； 如果按照上述条件挑选后，仍然存在未被选择的两个字符相同的单词（此时该字符串只可能有一个未被选择，且该字符串一定在 words 中出现奇数次），我们可以任意选择一个。 因此，我们用哈希表统计 words 中每个单词的出现次数。随后，我们遍历哈希表的所有元素，并用 res 维护可能构成回文字符串的最长长度，同时用初值为 false 的布尔变量 mid 判断是否存在可以作为中心单词的、出现奇数次的回文单词。在遍历到字符串 word 时，我们首先求出它反转后的字符串 rev，此时根据 word 与 rev 的关系，有以下两种情况： word≠rev，此时我们需要统计两者在 words 出现次数的最小值，即为成对选择的最多数目。假设此时对数为 n，则其对最长回文字符串贡献的字符长度为 4n，我们将 res 加上对应值； word=rev，此时可以构成的对数为 ⌊m/2⌋，即对最长回文字符串贡献的字符长度为 4⌊m/2⌋，我们同样将 res 加上对应值。除此以外，我们还需要判断 word 的出现次数 m 是否为奇数： 如果 m 为奇数，则存在可以作为中心单词的剩余回文单词，我们将 mid 置为 true； 如果 m 为偶数，则不存在可以作为中心单词的剩余回文单词，我们不改变 mid 的取值。 最后，我们根据 mid 的取值，判断最长回文串是否含有中心单词。如果 mid 为 true，则代表含有，我们将 res 加上 2；反之则没有，我们不进行任何操作。 最后，我们返回 res 作为最长回文串的长度。 细节 在遍历哈希表中的每个单词时，为了避免重复计算成对选择的单词，我们只在 word 的字典序大于等于 rev 时更新 res。 12345678910111213141516171819class Solution: def longestPalindrome(self, words: List[str]) -&gt; int: freq = Counter(words) # 单词出现次数 res = 0 # 最长回文串长度 mid = False # 是否含有中心单词 for word, cnt in freq.items(): # 遍历出现的单词，并更新长度 rev = word[1] + word[0] # 反转后的单词 if word == rev: if cnt % 2 == 1: mid = True res += 2 * (cnt // 2 * 2) elif word &gt; rev: # 避免重复遍历 res += 4 * min(freq[word], freq[rev]) if mid: # 含有中心单词，更新长度 res += 2 return res"},{"title":"1641. Count Sorted Vowel Strings(medium)","path":"2022/11/12/1641/","text":"1641. Count Sorted Vowel Strings(medium)Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.官方解法数学解法看到题目的第一眼就感觉这是排列组合，但没想好怎么写出排列的公式，这位大佬的思路太牛了： 这个问题的数学解法，可以把问题转换成将 n 个小球放到 5 个盒子里，盒子可以为空。我们可以想象成把 n 个字符分配给五个元音所代表的盒子中。一旦每个盒子中的字符个数定了，那么这个字符串也固定下来了。因为题目要求必须是字典序，所以一定 a 字符在最前；其次是 e 字符；其次是 i 字符；其次是 o 字符；其次是 u 字符。 下面问题的关键就是，n 个小球放到 5 个盒子里，盒子可以为空，一共有多少种方法？ 这是经典的中学数学问题。更一般的，我们来探讨，将 n 个小球放到 m 个盒子里，有多少种方法？ 首先，我们考虑问题的简单版本，即盒子不能为空的情况。 此时，我们只需要在 n 个小球排成一排，中间放 m - 1 个隔板，放好以后，相当于把 n 个小球分成了 m 份。每一份对应一个盒子里的小球数量。 因为盒子不能为空，所以两个小球之间不可能放多个隔板，左右两端也不可能放隔板。因此，放隔板的位置有 n - 1 个，我们要放 m - 1 个隔板。答案为 C(n - 1, m - 1)。 有了这个结论，再来讨论问题的复杂版本，就简单了，即盒子可以为空的情况。 此时，我们只需要先拿 m 个新的小球，在 m 个盒子里，每个盒子中扔进去一个小球。之后，再分配原来的这 n 个小球，得到的分配结果，肯定 m 个盒子里都不为空。但此时，我们使用了 n + m 个小球。 换句话说，把 n 个小球放到 m 个盒子里，盒子可以为空，等价于：把 n + m 个小球放到 m 个盒子里，盒子不能为空。 大家也可以想成是：我们先把 n + m 个小球放到 m 个盒子里，盒子不能为空，然后再在每个盒子里拿走 1 个小球，总共拿走了 m 个小球，得到的结果，就是把 n 个小球放到 m 个盒子里，盒子可以为空的解。 把 n + m 个小球放到 m 个盒子里，盒子不能为空的分法，带入上面的公式，就是 C(n + m - 1, m - 1) 所以，把 n 个小球放到 m 个盒子里，盒子可以为空，答案为 C(n + m - 1, m - 1)。 总结：将 n 个小球放到 m 个盒子里，盒子不为空：C(n - 1, m - 1)； 将 n 个小球放到 m 个盒子里，盒子可以空：C(n + m - 1, m - 1)； 对于这个问题，m = 5，盒子可以为空，所以答案是 C(n + 5 - 1, 5 - 1) = C(n + 4, 4) 提醒：分成五个盒子，首先不论空与不空，我们的五个盒子最终组成我们答案的形式是生成与每个盒子数量相等的对应字符串，然后把五个字符串穿起来，如aa+e+i+o+u这种，盒子里球的数量是某一个元音字母连续出现的数量，所以可以空"},{"title":"1646. Get Maximum in Generated Array(easy)","path":"2022/11/10/1646/","text":"1646. Get Maximum in Generated Array(easy)You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:nums[0] = 0nums[1] = 1nums[2 * i] = nums[i] when 2 &lt;= 2 * i &lt;= nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &lt;= 2 * i + 1 &lt;= nReturn the maximum integer in the array nums​​​. 123456789101112Input: n = 7Output: 3Explanation: According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. 官方题解我们可以直接根据题目中描述的规则来计算出 nums 数组，并返回其最大元素。 为了简化代码逻辑，我们可以化简题目中的递推式。当 i≥2 时： 当i为偶数，nums[i]=nums[i//2]当i为奇数，nums[i]=nums[i//2]+nums[i//2+1] 所以总结在一起是，nums[i]=nums[i//2]+i%2*nums[i//2+1] 12345678910class Solution: def getMaximumGenerated(self, n: int) -&gt; int: if n==0: return 0 dp=[0]*(n+1) dp[1]=1 for i in range(2,n+1): dp[i]=dp[i//2]+i%2*dp[i//2+1] return max(dp)"},{"title":"1025. Divisor Game(easy)","path":"2022/11/10/1025/","text":"1025. Divisor Game(easy)Alice and Bob take turns playing a game, with Alice starting first.Initially, there is a number n on the chalkboard. On each player’s turn, that player makes a move consisting of:Choosing any x with 0 &lt; x &lt; n and n % x == 0.Replacing the number n on the chalkboard with n - x.Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally.基本思路： 最终结果应该是占到 2 的赢，占到 1 的输； 若当前为奇数，奇数的约数只能是奇数或者 1，因此下一个一定是偶数； 若当前为偶数， 偶数的约数可以是奇数可以是偶数也可以是 1，因此直接减 1，则下一个是奇数； 因此，奇则输，偶则赢。直接: 123class Solution: def divisorGame(self, n: int) -&gt; bool: return n%2==0"},{"title":"1047. Remove All Adjacent Duplicates In String(easy)","path":"2022/11/10/1047/","text":"1047. Remove All Adjacent Duplicates In String(easy)You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.We repeatedly make duplicate removals on s until we no longer can.Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.这道题用栈就可以解决，输入进来判断和stack队首是否相等，如果相等就弹出，不相等就存进去 class Solution: def removeDuplicates(self, s: str) -&gt; str: stack=[] for letter in s: if stack and letter==stack[-1]: stack.pop() else: stack.append(letter) return &quot;&quot;.join(stack)"},{"title":"905. Sort Array By Parity(easy)","path":"2022/11/09/905/","text":"905. Sort Array By Parity(easy)Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.Return any array that satisfies this condition.偶数放前面，奇数放后面 第一种方法对%2的值排序 1234class Solution: def sortArrayByParity(self, nums: List[int]) -&gt; List[int]: nums.sort(key = lambda x: x % 2) return nums 第二种方法通过交换队首和队尾的值 1234567891011class Solution(object): def sortArrayByParity(self, nums): i, j = 0, len(nums) - 1 while i &lt; j: if nums[i] % 2 &gt; nums[j] % 2: nums[i], nums[j] = nums[j], nums[i] if nums[i] % 2 == 0: i += 1 if nums[j] % 2 == 1: j -= 1 return nums"},{"title":"904. Fruit Into Baskets(medium)","path":"2022/11/09/904/","text":"904. Fruit Into Baskets(medium)You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.Once you reach a tree with fruit that cannot fit in your baskets, you must stop.Given the integer array fruits, return the maximum number of fruits you can pick. 这道题的本质是求连续子序列 力扣官方题解1234567891011121314class Solution: def totalFruit(self, fruits: List[int]) -&gt; int: cnt = Counter() left = ans = 0 for right, x in enumerate(fruits): cnt[x] += 1 while len(cnt) &gt; 2: cnt[fruits[left]] -= 1 if cnt[fruits[left]] == 0: cnt.pop(fruits[left]) left += 1 ans = max(ans, right - left + 1) return ans"},{"title":"901. Online Stock Span(medium)","path":"2022/11/09/901/","text":"901. Online Stock Span(medium)Design an algorithm that collects daily price quotes for some stock and returns the span of that stock’s price for the current day.The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today’s price.For example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6].Implement the StockSpanner class:StockSpanner() Initializes the object of the class.int next(int price) Returns the span of the stock’s price given that today’s price is price. 官方题解一开始我先试了直接用数组记录数据，然后每次往前遍历一遍记录有多少小于当前price的值，但是在后面的testcase中遇到了超时的问题。官方解答是用了stack来解决这个问题 调用 next 时，输入是新的一天的股票价格，需要返回包含此日在内的，往前数最多有连续多少日的股票价格是小于等于今日股票价格的。如果把每日的 price 当成数组不同下标的值，即需要求出每个值与上一个更大元素之间的下标之差。这种题目可以用单调栈求解，具体原理可以参考「496. 下一个更大元素 I 的官方题解的方法二」。此题的具体解法上，栈的元素可以是股票价格的下标（即天数）和股票价格的二元数对，并且在栈中先插入一个最大值作为天数为 −1 天的价格，来保证栈不会为空。调用 next 时，先将栈中价格小于等于此时 price 的元素都弹出，直到遇到一个大于 price 的值，并将 price 入栈，计算下标差返回。 1234567891011class StockSpanner: def __init__(self): self.stack = [(-1, inf)] self.idx = -1 def next(self, price: int) -&gt; int: self.idx += 1 while price &gt;= self.stack[-1][1]: self.stack.pop() self.stack.append((self.idx, price)) return self.idx - self.stack[-2][0] 作者：力扣官方题解链接：https://leetcode.cn/problems/online-stock-span/solutions/1906765/gu-piao-jie-ge-kua-du-by-leetcode-soluti-5cm7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"2244. Minimum Rounds to Complete All Tasks(medium)","path":"2022/11/09/2244/","text":"2244. Minimum Rounds to Complete All Tasks(medium)You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.12345678Input: tasks = [2,2,3,3,2,4,4,4,4,4]Output: 4Explanation: To complete all the tasks, a possible plan is:- In the first round, you complete 3 tasks of difficulty level 2. - In the second round, you complete 2 tasks of difficulty level 3. - In the third round, you complete 3 tasks of difficulty level 4. - In the fourth round, you complete 2 tasks of difficulty level 4. It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4. Solution:通过Counter记录相同task，然后遍历每个value的个数count分情况讨论，遇到只有一个的直接返回-1，对3能整除的ans加上count除3剩下的都是除三向下取整加1 12345678910111213141516#from collections import Counterclass Solution: def minimumRounds(self, tasks: List[int]) -&gt; int: ans=0 if len(tasks)==1: return -1 hashmap=Counter(tasks) ans=0 for count in hashmap.values(): if count==1: return -1 elif count%3==0: ans+=count/3 else: ans+=count//3+1 return int(ans)"},{"title":"746. Min Cost Climbing Stairs(easy)","path":"2022/11/08/746/","text":"746. Min Cost Climbing Stairs(easy)You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.You can either start from the step with index 0, or the step with index 1.Return the minimum cost to reach the top of the floor.官方题解创建长度为 n+1的数组 dp，其中 dp[i] 表示达到下标 i 的最小花费。 由于可以选择下标 0 或 1 作为初始阶梯，因此有 dp[0]=dp[1]=0 状态转移方程如下： dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2]) 有了这个方程，这道题就好下手了 12345678class Solution: def minCostClimbingStairs(self, cost: List[int]) -&gt; int: n=len(cost) dp=[0]*(n+1) dp[0]=dp[1]=0 for i in range(2,n+1): dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]) return dp[n] 优化：利用滚动数组 注意到当 i≥2时，dp[i] 只和 dp[i−1] 与 dp[i−2] 有关，因此可以使用滚动数组的思想，将空间复杂度优化到 O(1)。类似于不维护一个完整数组，只计算到最后一个数字 12345678class Solution: def minCostClimbingStairs(self, cost: List[int]) -&gt; int: n = len(cost) prev = curr = 0 for i in range(2, n + 1): nxt = min(curr + cost[i - 1], prev + cost[i - 2]) prev, curr = curr, nxt return curr"},{"title":"6. Zigzag Conversion(medium)","path":"2022/11/07/6/","text":"6. Zigzag Conversion(medium)The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); 题解这道题没有用到什么独特的数据结构或者算法，但是这里用一个flag记录是否要反方向记录 解题思路：题目理解：字符串 s 是以 Z 字形为顺序存储的字符串，目标是按行打印。设 numRows 行字符串分别为 s1, s2s_2s2,…, sn，则容易发现：按顺序遍历字符串 s 时，每个字符 c 在 Z 字形中对应的行索引先从 s1增大至 sn，再从 sn减小至 s1…… 如此反复。因此，解决方案为：模拟这个行索引的变化，在遍历 s 中把每个字符填到正确的行 res[i] 。算法流程： 按顺序遍历字符串 s；res[i] += c： 把每个字符 c 填入对应行 si；i += flag： 更新当前字符 c 对应的行索引；flag = - flag： 在达到 ZZZ 字形转折点时，执行反向。复杂度分析：时间复杂度 O(N) ：遍历一遍字符串 s；空间复杂度 O(N) ：各行字符串共占用 O(N)额外空间。 12345678910class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows &lt; 2: return s res = [&quot;&quot; for _ in range(numRows)] i, flag = 0, -1 for c in s: res[i] += c if i == 0 or i == numRows - 1: flag = -flag i += flag return &quot;&quot;.join(res) 确实是非常巧妙的方法"},{"title":"1684. Count the Number of Consistent Strings(easy)","path":"2022/11/07/1684/","text":"1684. Count the Number of Consistent Strings(easy)You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.Return the number of consistent strings in the array words.123Input: allowed = &quot;ab&quot;, words = [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;]Output: 2Explanation: Strings &quot;aaab&quot; and &quot;baa&quot; are consistent since they only contain characters &#x27;a&#x27; and &#x27;b&#x27;. 这道题原本是想对words进行set操作的，后面发现对list里的每一个数都操作太麻烦，所以换一个思路，选择从反方向入手。题目是要我们找words里的字母只含有allowed里的字母，所以将allowed去重后，如果words的单词里的字母如果不在allowed里，就记录下来cnt最后输出的是有相同字母的，那么就用words的总个数减去cnt即可 12345678910class Solution: def countConsistentStrings(self, allowed: str, words: List[str]) -&gt; int: allowed=set(allowed) cnt=0 for cha in words: for letter in cha: if letter not in allowed: cnt+=1 break return len(words)-cnt"},{"title":"1137. N-th Tribonacci Number(easy)","path":"2022/11/07/1137/","text":"1137. N-th Tribonacci Number(easy)The Tribonacci sequence Tn is defined as follows:T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn. 三个数连续相加的斐波那契数列，还是动态规划的思路 123456789101112class Solution: def tribonacci(self, n: int) -&gt; int: if n&lt;2: return n elif n==2: return 1 dp=[0]*(n+1) dp[1]=1 dp[2]=1 for i in range(3,n+1): dp[i]=dp[i-1]+dp[i-2]+dp[i-3] return dp[n]"},{"title":"509. Fibonacci Number(easy)","path":"2022/11/07/509/","text":"509. Fibonacci Number(easy)The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,12F(0) = 0, F(1) = 1F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n). 斐波那契数列F(0)=0,F(1)=1 123456789class Solution: def fib(self, n: int) -&gt; int: if n&lt;1: return n dp=[0]*(n+1) dp[1]=1 for i in range(2,n+1): dp[i]=dp[i-1]+dp[i-2] return dp[n]"},{"title":"1323. Maximum 69 Number(easy)","path":"2022/11/06/1323/","text":"1323. Maximum 69 Number(easy)You are given a positive integer num consisting only of digits 6 and 9.Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).将num转换为字符串，然后再转换成list判断list有没有6，如果没有直接输出numindex(x)返回找到的第一个x最后join把字符串连在一起 class Solution: def maximum69Number (self, num: int) -&gt; int: s=list(str(num)) if &#39;6&#39; not in s: return num s[s.index(&#39;6&#39;)]=&#39;9&#39; return &#39;&#39;.join(s)"},{"title":"408. Valid Word Abbreviation(easy)","path":"2022/11/06/408/","text":"408. Valid Word Abbreviation(easy)A string can be abbreviated by replacing any number of non-adjacent, non-empty substrings with their lengths. The lengths should not have leading zeros.For example, a string such as “substitution” could be abbreviated as (but not limited to): “s10n” (“s ubstitutio n”)“sub4u4” (“sub stit u tion”)“12” (“substitution”)“su3i1u2on” (“su bst i t u ti on”)“substitution” (no substrings replaced)The following are not valid abbreviations: “s55n” (“s ubsti tutio n”, the replaced substrings are adjacent)“s010n” (has leading zeros)“s0ubstitution” (replaces an empty substring)Given a string word and an abbreviation abbr, return whether the string matches the given abbreviation. A substring is a contiguous non-empty sequence of characters within a string. 这道题就是直接模拟计算题解 12345678910111213141516171819class Solution: def validWordAbbreviation(self, word, abbr): i = j = 0 m, n = len(word), len(abbr) while i &lt; m and j &lt; n: if word[i] == abbr[j]: i += 1 j += 1 elif abbr[j] == &quot;0&quot;: return False elif abbr[j].isnumeric(): k = j while k &lt; n and abbr[k].isnumeric(): k += 1 i += int(abbr[j:k]) j = k else: return False return i == m and j == n"},{"title":"459. Repeated Substring Pattern(easy)","path":"2022/11/06/459/","text":"459. Repeated Substring Pattern(easy)Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.题解这道题的题解非常有技巧： First char of input string is first char of repeated substring Last char of input string is last char of repeated substring Let S1 = S + S (where S in input string) Remove 1 and last char of S1. Let this be S2 If S exists in S2 then return true else false Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1] 这里最基础的一点是，新字符串s2=s+s，s是一开始的字符串。如果s是重复的，那么s2从第二个字符到倒数第二个字符里一定包含了s class Solution: def repeatedSubstringPattern(self, s: str) -&gt; bool: if not s: return False s2=(s+s)[1:-1] return s2.find(s)!=-1"},{"title":"422. Valid Word Square(easy)","path":"2022/11/06/422/","text":"422. Valid Word Square(easy)Given an array of strings words, return true if it forms a valid word square.A sequence of strings forms a valid word square if the kth row and column read the same string, where 0 &lt;= k &lt; max(numRows, numColumns).12345678Input: words = [&quot;abcd&quot;,&quot;bnrt&quot;,&quot;crmy&quot;,&quot;dtye&quot;]Output: trueExplanation:The 1st row and 1st column both read &quot;abcd&quot;.The 2nd row and 2nd column both read &quot;bnrt&quot;.The 3rd row and 3rd column both read &quot;crmy&quot;.The 4th row and 4th column both read &quot;dtye&quot;.Therefore, it is a valid word square. 找矩阵是否对称 12345678910class Solution: def validWordSquare(self, words: List[str]) -&gt; bool: if words==None or len(words)==0: return True row=len(words) for i in range(row): for j in range(len(words[i])): if j&gt;=len(words) or i &gt;=len(words[j]) or words[i][j]!=words[j][i]: return False return True"},{"title":"463. Island Perimeter(easy)","path":"2022/11/06/463/","text":"463. Island Perimeter(easy)You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.直接模拟，看当前为1的格子四边有没有其他为1的格子 123456789101112131415161718class Solution: def islandPerimeter(self, grid: List[List[int]]) -&gt; int: row=len(grid) col=len(grid[0]) ans=0 for i in range(row): for j in range(col): if grid[i][j]==1: ans+=4 if i+1&lt;row and grid[i+1][j]==1: ans-=1 if i-1&gt;=0 and grid[i-1][j]==1: ans-=1 if j+1&lt;col and grid[i][j+1]==1: ans-=1 if j-1&gt;=0 and grid[i][j-1]==1: ans-=1 return ans"},{"title":"461. Hamming Distance(easy)","path":"2022/11/06/461/","text":"461. Hamming Distance(easy)The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, return the Hamming distance between them.这个用运位算的方法很巧妙设x=1(0001),y=4(0100)xor就是5(0101)xor%2是1xor&gt;&gt;=1 向右移了一位，此时是xor=(0010)xor%2=0xor&gt;&gt;=1 向右移一位，此时是xor=(0001)xor%2=1xor&gt;&gt;=1 向右移一位，此时是xor=(0000)这时返回就是2 12345678class Solution: def hammingDistance(self, x: int, y: int) -&gt; int: xor=x^y res=0 while xor!=0: res+=xor%2 xor&gt;&gt;=1 return res"},{"title":"405. Convert a Number to Hexadecimal(easy)","path":"2022/11/06/405/","text":"405. Convert a Number to Hexadecimal(easy)Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.Note: You are not allowed to use any built-in library method to directly solve this problem.分大于0小于0两种情况，大于0则对16求余，再除。小于0则基于0xffffffff进行计算 12345678910111213class Solution: def toHex(self, num: int) -&gt; str: if num==0: return &quot;0&quot; if num&lt;0: num=0xffffffff+1+num hex_digits=&quot;0123456789abcdef&quot; ans=&quot;&quot; while num: ans+=hex_digits[num%16] num//=16 return ans[::-1]"},{"title":"394. Decode String(medium)","path":"2022/11/06/394/","text":"394. Decode String(medium)Given an encoded string, return its decoded string.The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].The test cases are generated so that the length of the output will never exceed 10^5.123456789101112131415161718192021class Solution: def decodeString(self, s: str) -&gt; str: stack = [] for c in s: if c != &quot;]&quot;: stack.append(c) else: tmp = &quot;&quot; while stack[-1] != &quot;[&quot;: tmp = stack.pop(-1) + tmp stack.pop(-1) times = &quot;&quot; while stack and stack[-1].isdigit(): times = stack.pop(-1) + times times = int(times) tmp = &quot;&quot;.join(tmp for _ in range(times)) for t in tmp: stack.append(t) return &quot;&quot;.join(stack) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public String decodeString(String s) &#123; Deque&lt;Integer&gt; numStack = new ArrayDeque&lt;&gt;(); Deque&lt;String&gt; strStack = new ArrayDeque&lt;&gt;(); char[] chs = s.toCharArray(); int n = chs.length; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; n; i++)&#123; if(chs[i] - &#x27;0&#x27; &gt;= 0 &amp;&amp; chs[i] - &#x27;0&#x27; &lt;= 9) &#123; // 遇到数字 int num = 0; while(chs[i] - &#x27;0&#x27; &gt;= 0 &amp;&amp; chs[i] - &#x27;0&#x27; &lt;= 9)&#123; // 截取数字 num = num * 10 + chs[i] - &#x27;0&#x27;; i++; &#125; numStack.push(num); &#125; if(chs[i] == &#x27;[&#x27;) strStack.push(String.valueOf(chs[i])); // 遇到 &#x27;[&#x27; 推入字符串栈 else if(chs[i] == &#x27;]&#x27;)&#123; // 遇到 &#x27;]&#x27; StringBuilder curSb = new StringBuilder(); while(!strStack.peek().equals(String.valueOf(&#x27;[&#x27;)))&#123; // 拼接 &#x27;[&#x27; 之前的字符串 curSb.insert(0, strStack.pop()); &#125; strStack.pop(); // 推出 &#x27;[&#x27; int k = numStack.pop(); // 推出数字 String repeatedStr = repeate(curSb.toString(), k); // 重复 k 次 strStack.push(repeatedStr); // 然后推入字符串栈 &#125; else strStack.push(String.valueOf(chs[i])); &#125; StringBuilder res = new StringBuilder(); while(!strStack.isEmpty())&#123; res.insert(0, strStack.pop()); &#125; return res.toString(); &#125; private String repeate(String s, int k)&#123; // 倍增拼接 (快速幂思想) StringBuilder res = new StringBuilder(); StringBuilder sb = new StringBuilder(s); while(k &gt; 0)&#123; if(k % 2 == 1) res = res.append(sb); sb = sb.append(sb); k /= 2; &#125; return res.toString(); &#125;&#125;"},{"title":"434. Number of Segments in a String(easy)","path":"2022/11/05/434/","text":"Given a string s, return the number of segments in the string.A segment is defined to be a contiguous sequence of non-space characters.直接用split分割字符串 123class Solution: def countSegments(self, s: str) -&gt; int: return len(s.split())"},{"title":"441. Arranging Coins(easy)","path":"2022/11/05/441/","text":"441. Arranging Coins(easy)You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.Given the integer n, return the number of complete rows of the staircase you will build.这道题就是个等差数列，从1加到i层，然后和n比较大小，所以数学方法解出即可 1234class Solution: def arrangeCoins(self, n: int) -&gt; int: return int(sqrt(2 * n + 0.25) - 0.50)"},{"title":"448. Find All Numbers Disappeared in an Array(easy)","path":"2022/11/05/448/","text":"448. Find All Numbers Disappeared in an Array(easy)Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.这题是找到缺失的数字暴力解法 12345678910111213141516class Solution: def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: n=len(nums) res=[] nums=sorted(set(nums)) if len(nums)&lt;n: nums.append(0) for i in range(1,n+1): if i &gt;len(nums): res.append(i) nums.append(i) if i!= nums[i-1]: res.append(i) nums.insert(i-1,i) return res python enumerate解法 12345678910class Solution: def findDisappearedNumbers(self, nums): res = [] for x in nums: if nums[abs(x)-1] &gt; 0: nums[abs(x)-1]*=-1 for i, x in enumerate(nums): if x&gt; 0: res.append(i+1) return res"},{"title":"415. Add Strings(easy)","path":"2022/11/05/415/","text":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.将字符串转换成数字相加后再转回字符串 123class Solution: def addStrings(self, num1: str, num2: str) -&gt; str: return str(int(num1)+int(num2))"},{"title":"414. Third Maximum Number(easy)","path":"2022/11/05/414/","text":"414. Third Maximum Number(easy)Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.这里就是对数组排序，然后取第三大的数 12345678class Solution: def thirdMax(self, nums: List[int]) -&gt; int: nums=sorted(set(nums),reverse= True) if len(nums)&gt;2: return nums[2] else: return nums[0]"},{"title":"409. Longest Palindrome(easy)","path":"2022/11/05/409/","text":"409. Longest Palindrome(easy)Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.Letters are case sensitive, for example, “Aa” is not considered a palindrome here.这道题就是利用hashmap计数，然后偶数直接加到结果，奇数分情况讨论，只有一个的情况那就放到最后加在结果里，如果大于1的奇数，就在结果加上数量减1 12345678910111213141516class Solution: def longestPalindrome(self, s: str) -&gt; int: result=Counter(s) cnt=0 sums=0 for cha in result: if result[cha]%2==0: sums+=result[cha] elif result[cha]%2!=0 and result[cha]&gt;2: sums+=result[cha]-1 cnt+=1 else: cnt+=1 if cnt!=0: sums+=1 return sums"},{"title":"412. Fizz Buzz(easy)","path":"2022/11/05/412/","text":"412. Fizz BuzzGiven an integer n, return a string array answer (1-indexed) where:answer[i] == “FizzBuzz” if i is divisible by 3 and 5.answer[i] == “Fizz” if i is divisible by 3.answer[i] == “Buzz” if i is divisible by 5.answer[i] == i (as a string) if none of the above conditions are true. 这道题是hackerrank一开始遇到的题 12345678910111213class Solution: def fizzBuzz(self, n: int) -&gt; List[str]: result=[] for i in range(1,n+1): if i%3 ==0 and i%5==0: result.append(&quot;FizzBuzz&quot;) elif i%3==0: result.append(&quot;Fizz&quot;) elif i%5==0: result.append(&quot;Buzz&quot;) else: result.append(str(i)) return result"},{"title":"1636. Sort Array by Increasing Frequency(easy)","path":"2022/10/31/1636/","text":"1636. Sort Array by Increasing Frequency(easy)Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.Return the sorted array.对hashmap的value进行升序排序，简单但有用当frequency相同时，数值按降序排列 123456class Solution: def frequencySort(self, nums: List[int]) -&gt; List[int]: cnt=Counter(nums) nums.sort(key=lambda x:(cnt[x],-x) ) return nums 例：输入nums = [2,3,1,3,2]得到 cnt : Counter({2: 2, 3: 2, 1: 1}) 无参的 sort() 会依次对nums的值升序排序而 sort(key) 会先把nums的值传给表达式key,按照key返回的值大小再给对应的nums排序第1次传2，(cnt[2], -2)) 得到 (2,-2)第2次传3，(cnt[3], -3)) 得到 (2,-3)第3次传1，(cnt[1], -1)) 得到 (1,-1)第4次传3，(cnt[3], -3)) 得到 (2,-3)第5次传2，(cnt[2], -2)) 得到 (2,-2)排序顺序为(1,-1),(2,-3),(2,-3),(2,-2),(2,-2)对应的nums的值为1,3,3,2,2 sort是针对于列表的排列方法。默认升序排序。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。此处传入的是一个元组，先以第一个字段进行排列。第一个字段一样，再以第二个字段进行排序。"},{"title":"8. String to Integer (atoi)(medium)","path":"2022/10/19/8/","text":"8. String to Integer (atoi)(medium)Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++’s atoi function).The algorithm for myAtoi(string s) is as follows:Read in and ignore any leading whitespace.Check if the next character (if not already at the end of the string) is ‘-‘ or ‘+’. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.Convert these digits into an integer (i.e. “123” -&gt; 123, “0032” -&gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.Return the integer as the final result. 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 1234567891011输入：s = &quot;42&quot;输出：42解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格） ^第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;） ^第 3 步：&quot;42&quot;（读入 &quot;42&quot;） ^解析得到整数 42 。由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。 方法一：正则表达式123class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall(&#x27;^[\\+\\-]?\\d+&#x27;, s.lstrip())), 2**31 - 1), -2**31) 1234567891011正则表达re模块re.findall返回string中所有与pattern匹配的全部字符串,返回形式为数组。^：匹配字符串开头[\\+\\-]：代表一个+字符或-字符?：前面一个字符可有可无\\d：一个数字+：前面一个字符的一个或多个\\D：一个非数字字符*：前面一个字符的0个或多个Python lstrip() 方法用于截掉字符串左边的空格或指定字符 详细版 12345678910import reclass Solution: def myAtoi(self, str: str) -&gt; int: INT_MAX = 2147483647 INT_MIN = -2147483648 str = str.lstrip() #清除左边多余的空格 num_re = re.compile(r&#x27;^[\\+\\-]?\\d+&#x27;) #设置正则规则 num = num_re.findall(str) #查找匹配的内容 num = int(*num) #由于返回的是个列表，解包并且转换成整数 return max(min(num,INT_MAX),INT_MIN) #返回值 方法二：有限状态机准确地说，这是确定有限状态机（deterministic finite automaton, DFA）。 我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。 1234567891011121314151617181920212223242526272829303132333435363738INT_MAX = 2 ** 31 - 1INT_MIN = -2 ** 31class Automaton: def __init__(self): self.state = &#x27;start&#x27; self.sign = 1 self.ans = 0 self.table = &#123; &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;in_number&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;], &#125; def get_col(self, c): if c.isspace(): return 0 if c == &#x27;+&#x27; or c == &#x27;-&#x27;: return 1 if c.isdigit(): return 2 return 3 def get(self, c): self.state = self.table[self.state][self.get_col(c)] if self.state == &#x27;in_number&#x27;: self.ans = self.ans * 10 + int(c) self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN) elif self.state == &#x27;signed&#x27;: self.sign = 1 if c == &#x27;+&#x27; else -1class Solution: def myAtoi(self, str: str) -&gt; int: automaton = Automaton() for c in str: automaton.get(c) return automaton.sign * automaton.ans"},{"title":"LeetCode16-deterministic-finite-automaton","path":"2022/10/19/LeetCode16-deterministic-finite-automaton/","text":"确定有限状态机（deterministic finite automaton, DFA）。 我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。 String to Integer (atoi)(medium) 1234567891011121314151617181920212223242526272829303132333435363738INT_MAX = 2 ** 31 - 1INT_MIN = -2 ** 31class Automaton: def __init__(self): self.state = &#x27;start&#x27; self.sign = 1 self.ans = 0 self.table = &#123; &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;in_number&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_number&#x27;, &#x27;end&#x27;], &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;], &#125; def get_col(self, c): if c.isspace(): return 0 if c == &#x27;+&#x27; or c == &#x27;-&#x27;: return 1 if c.isdigit(): return 2 return 3 def get(self, c): self.state = self.table[self.state][self.get_col(c)] if self.state == &#x27;in_number&#x27;: self.ans = self.ans * 10 + int(c) self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN) elif self.state == &#x27;signed&#x27;: self.sign = 1 if c == &#x27;+&#x27; else -1class Solution: def myAtoi(self, str: str) -&gt; int: automaton = Automaton() for c in str: automaton.get(c) return automaton.sign * automaton.ans 有效数字 UTF-8 Validation"},{"title":"692. Top K Frequent Words","path":"2022/10/18/692/","text":"Given an array of strings words and an integer k, return the k most frequent strings.Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.Top K问题 1234Input: words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2Output: [&quot;i&quot;,&quot;love&quot;]Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order. Leetcode题解 12345678910111213141516171819202122232425262728class Solution: def topKFrequent(self, words: List[str], k: int) -&gt; List[str]: counter = Counter(words) occur = list(counter.items()) for i in range(k // 2 - 1, -1, -1): self.heapify(occur, i, k) for i in range(k, len(occur)): if occur[i][1] &gt; occur[0][1] or occur[i][1] == occur[0][1] and occur[i][0] &lt; occur[0][0]: occur[i], occur[0] = occur[0], occur[i] self.heapify(occur, 0, k) ans = deque() for i in range(k): ans.appendleft(occur[0][0]) occur[0] = occur[k - 1 - i] self.heapify(occur, 0, k - 1 - i) return list(ans) def heapify(self, heap: List[Tuple], root: int, length: int): smallest = root left = 2 * root + 1 right = left + 1 if left &lt; length and (heap[left][1] &lt; heap[smallest][1] or heap[left][1] == heap[smallest][1] and heap[left][0] &gt; heap[smallest][0]): smallest = left if right &lt; length and (heap[right][1] &lt; heap[smallest][1] or heap[right][1] == heap[smallest][1] and heap[right][0] &gt; heap[smallest][0]): smallest = right if smallest != root: heap[smallest], heap[root] = heap[root], heap[smallest] self.heapify(heap, smallest, length)"},{"title":"38. Count and Say(medium)","path":"2022/10/18/38/","text":"38. Count and Say(medium)The count-and-say sequence is a sequence of digit strings defined by the recursive formula:countAndSay(1) = “1” countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.To determine how you “say” a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.For example, the saying and conversion for digit string “3322251”:Given a positive integer n, return the nth term of the count-and-say sequence.说实话这道题给的例子让人非常疑惑，但其实就是一个类似于斐波那契数列的递归数列,国区题库的题目描述更详细也更准确 123456789101. 12. 113. 214. 12115. 111221第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot; 官方题解123456789101112131415161718192021class Solution: def countAndSay(self, n: int) -&gt; str: if n==1:return &quot;1&quot; if n==2: return &quot;11&quot; res=[1,1] for i in range(3,n+1): new_res=[] num=1 cur=res[0] for s in res[1:]: if s ==cur: num+=1 else: new_res.append(num) new_res.append(cur) num=1 cur=s new_res.append(num) new_res.append(cur) res=new_res return &#x27;&#x27;.join(list(map(str,res))) map函数1map(function, iterable, ...) def square(x) : # 计算平方数… return x ** 2…map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 list(map(square, [1,2,3,4,5])) # 使用 list() 转换为列表[1, 4, 9, 16, 25]list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # 使用 lambda 匿名函数[1, 4, 9, 16, 25] ``` 比如n=6,res=[3,1,2,2,1,1],通过map函数list(map(str,res))以后是[‘3’, ‘1’, ‘2’, ‘2’, ‘1’, ‘1’]。再通过’’.join()函数将list里的字符连在一起就这道题而言，转不转换成list都不影响结果，’’.join(map(str,res))也是可以的"},{"title":"4. Median of Two Sorted Arrays(hard)","path":"2022/10/17/4/","text":"4. Median of Two Sorted Arrays(hard)Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).leetcode题解这道题如果时间复杂度没有限定在 O(log(m+n))，我们可以用 O(m+n) 的算法解决，用两个指针分别指向两个数组，比较指针下的元素大小，一共移动次数为 (m+n + 1)/2，便是中位数。 首先，我们理解什么中位数：指的是该数左右个数相等。 比如：odd : [1,| 2 |,3]，2 就是这个数组的中位数，左右两边都只要 1 位； even: [1,| 2, 3 |,4]，2,3 就是这个数组的中位数，左右两边 1 位； 那么，现在我们有两个数组： num1: [a1,a2,a3,…an] nums2: [b1,b2,b3,…bn] [nums1[:left1],nums2[:left2] | nums1[left1:], nums2[left2:]] 只要保证左右两边 个数 相同，中位数就在 | 这个边界旁边产生。 如何找边界值，我们可以用二分法，我们先确定 num1 取 m1 个数的左半边，那么 num2 取 m2 = (m+n+1)/2 - m1 的左半边，找到合适的 m1，就用二分法找。 当 [ [a1],[b1,b2,b3] | [a2,..an],[b4,…bn] ] 我们只需要比较 b3 和 a2 的关系的大小，就可以知道这种分法是不是准确的！ 例如：我们令： nums1 = [-1,1,3,5,7,9] nums2 =[2,4,6,8,10,12,14,16] 当 m1 = 4,m2 = 3 ,它的中位数就是median = (num1[m1] + num2[m2])/2 时间复杂度：O(log(min(m,n))) 对于代码中边界情况，大家需要自己琢磨。 12345678910111213141516171819202122232425262728293031class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: m, n = len(nums1), len(nums2) if m &gt; n: return self.findMedianSortedArrays(nums2, nums1) left, right = 0, m half = (m + n + 1) // 2 while left &lt; right: i = (left + right) // 2 j = half - i if nums1[i] &lt; nums2[j - 1]: left = i + 1 else: right = i i, j = left, half - left if i == 0: mid1 = nums2[j - 1] elif j == 0: mid1 = nums1[i - 1] else: mid1 = max(nums1[i - 1], nums2[j - 1]) if (m + n) &amp; 1: return mid1 if i == m: mid2 = nums2[j] elif j == n: mid2 = nums1[i] else: mid2 = min(nums1[i], nums2[j]) return (mid1 + mid2) / 2"},{"title":"1832. Check if the Sentence Is Pangram(easy)","path":"2022/10/17/1832/","text":"1832. Check if the Sentence Is Pangram(easy)A pangram is a sentence where every letter of the English alphabet appears at least once.Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.利用set的特性判断无重复后是否有26个字母 12345678class Solution: def checkIfPangram(self, sentence: str) -&gt; bool: if len(sentence)&lt;=25: return False if len(set(sentence))==26: return True else: return False"},{"title":"7. Reverse Integer(medium)","path":"2022/10/16/7/","text":"7. Reverse Integer(medium)Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned).leetcodde题解初始解：将数组转换成字符串，从后往前输出字符串得到结果 123456789101112def reverse_force(self, x: int) -&gt; int: if -10 &lt; x &lt; 10: return x str_x = str(x) if str_x[0] != &quot;-&quot;: str_x = str_x[::-1] x = int(str_x) else: str_x = str_x[:0:-1] x = int(str_x) x = -x return x if -2147483648 &lt; x &lt; 2147483647 else 0 优化解： 1234567891011class Solution: def reverse(self, x: int) -&gt; int: y, res = abs(x), 0 # 则其数值范围为 [−2^31, 2^31 − 1] boundry = (1&lt;&lt;31) -1 if x&gt;0 else 1&lt;&lt;31 while y != 0: res = res*10 +y%10 if res &gt; boundry : return 0 y //=10 return res if x &gt;0 else -res 这题没有考什么深的东西，不过可以复习一下 python 的字符运算语法： 复习一下 python 的位运算符： (a &amp; b)按位与运算符：参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0 。输出结果 12 ，二进制解释： 0000 1100 (a | b)按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。输出结果 61 ，二进制解释： 0011 1101 (a ^ b)按位异或运算符：当两对应的二进位相异时，结果为 1输出结果 49 ，二进制解释： 0011 0001 (a )按位取反运算符：对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1 。x 类似于 -x-1输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 a &lt;&lt; 2左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补 0。输出结果 240 ，二进制解释： 1111 0000 a &gt;&gt; 2右移动运算符：把 “&gt;&gt;” 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数输出结果 15 ，二进制解释： 0000 1111 python 赋值运算符： *= 乘法赋值运算符 c *= a 等效于 c = c * a/= 除法赋值运算符 c /= a 等效于 c = c / a%= 取模赋值运算符 c %= a 等效于 c = c % a**= 幂赋值运算符 c **= a 等效于 c = c ** a//= 取整除赋值运算符 c //= a 等效于 c = c // a 作者：stray_camel链接：https://leetcode.cn/problems/reverse-integer/solution/pythondan-chu-he-tui-ru-shu-zi-yi-chu-qian-jin-xin/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1"},{"title":"2095. Delete the Middle Node of a Linked List(medium)","path":"2022/10/14/2095/","text":"2095. Delete the Middle Node of a Linked List(medium)You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list. The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x. For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively. 思路：先遍历一遍链表，判断链表总长度，然后算出一半的长度n在哪里最后遍历到n-1的位置，跳过位置n直接连到n+1 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head.next==None: return None n=0 p1=p2=head while p1: p1=p1.next n+=1 k=n//2 for i in range(k-1): p2=p2.next #p2.next=p2.next.next p2.next = p2.next.next return head"},{"title":"401. Binary Watch(easy)","path":"2022/10/12/401/","text":"401. Binary Watch(easy)A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.For example, the below binary watch reads “4:51”. 一共十个灯，四个是二进制显示小时，六个是二进制显示分钟 官方题解12345678class Solution: def readBinaryWatch(self, turnedOn: int) -&gt; List[str]: ans = list() for h in range(12): for m in range(60): if bin(h).count(&quot;1&quot;) + bin(m).count(&quot;1&quot;) == turnedOn: ans.append(f&quot;&#123;h&#125;:&#123;m:02d&#125;&quot;) return ans 由题意可知，小时由 4 个比特表示，分钟由 6 个比特表示，比特位值为 0 表示灯灭，为 1 表示灯亮。 我们可以枚举小时的所有可能值 [0,11]，以及分钟的所有可能值 [0,59]，并计算二者的二进制中 1 的个数之和，若为 turnedOn，则将其加入到答案中。"},{"title":"404. Sum of Left Leaves(easy)","path":"2022/10/12/404/","text":"404. Sum of Left Leaves(easy)Given the root of a binary tree, return the sum of all left leaves.A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.左子树之和 Leetcode题解123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int: def dfs(root, isLeft): if not root: return 0 if not root.left and not root.right: return root.val if isLeft else 0 return dfs(root.left, True) + dfs(root.right, False) return dfs(root, False)"},{"title":"389. Find the Difference(easy)","path":"2022/10/12/389/","text":"389. Find the Difference(easy)You are given two strings s and t.String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. 这题和383. Ransom Note(easy)方法几乎一样用counter得到每个字母和对应的个数，第一步判断是不是s里没有的字母，然后把个数不断减去，减到负数，那个负数的就是多出来的那一个 123456789101112131415class Solution: def findTheDifference(self, s: str, t: str) -&gt; str: l1=Counter(s) l2=Counter(t) for char in t: if char not in s: return char else: l1[char]-=1 if l1[char]&lt;0: return char"},{"title":"237. Delete Node in a Linked List(medium)","path":"2022/10/12/237/","text":"237. Delete Node in a Linked List(medium)There is a singly-linked list head and we want to delete a node node in it.You are given the node to be deleted node. You will not be given access to the first node of head.All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:The value of the given node should not exist in the linked list.The number of nodes in the linked list should decrease by one.All the values before node should be in the same order.All the values after node should be in the same order. Custom testing:For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.We will build the linked list and pass the node to your function.The output will be the entire list after calling your function. 这题其实很简单，因为只给了需要删除的节点node，所以只需要使node的val等于下一个节点的值，当前node的下一个链接到下下个 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val=node.next.val node.next=node.next.next return"},{"title":"383. Ransom Note(easy)","path":"2022/10/12/383/","text":"383. Ransom Note(easy)Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.Each letter in magazine can only be used once in ransomNote.用counter得到每个字母和对应的个数，第一步判断是不是magazine有所有的字母，然后把个数不断减去，减到负数，证明个数不够 12345678910111213class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool: l1=Counter(ransomNote) l2=Counter(magazine) for ch in ransomNote: if ch not in magazine: return False else: l2[ch]-=1 if l2[ch]&lt;0: return False return True"},{"title":"374. Guess Number Higher or Lower(easy)","path":"2022/10/12/374/","text":"374. Guess Number Higher or Lower(easy)We are playing the Guess Game. The game is as follows:I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: -1: Your guess is higher than the number I picked (i.e. num &gt; pick).1: Your guess is lower than the number I picked (i.e. num &lt; pick).0: your guess is equal to the number I picked (i.e. num == pick).Return the number that I picked. 猜数字，本身有个内置函数guess(),一开始就直接写循环挨个算是不是相等，发现后面超时，所以改用二分查找 12345678910111213141516171819202122# The guess API is already defined for you.# @param num, your guess# @return -1 if num is higher than the picked number# 1 if num is lower than the picked number# otherwise return 0# def guess(num: int) -&gt; int:class Solution: def guessNumber(self, n: int) -&gt; int: low=1 high=n while low&lt;=high: mid = low + (high - low) // 2 res=guess(mid) if res==0: return mid elif res&lt;0: high = mid-1 else: low=mid+1 return mid"},{"title":"346. Moving Average from Data Stream(easy)","path":"2022/10/12/346/","text":"346. Moving Average from Data Stream(easy)Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.Implement the MovingAverage class:MovingAverage(int size) Initializes the object with the size of the window size.double next(int val) Returns the moving average of the last size values of the stream. 123456789101112Input[&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;][[3], [1], [10], [3], [5]]Output[null, 1.0, 5.5, 4.66667, 6.0]ExplanationMovingAverage movingAverage = new MovingAverage(3);movingAverage.next(1); // return 1.0 = 1 / 1movingAverage.next(10); // return 5.5 = (1 + 10) / 2movingAverage.next(3); // return 4.66667 = (1 + 10 + 3) / 3movingAverage.next(5); // return 6.0 = (10 + 3 + 5) / 3 12345678910111213141516class MovingAverage: def __init__(self, size: int): self.res=[] self.size=size def next(self, val: int) -&gt; float: queue=self.res size=self.size queue.append(val) window_sum=sum(queue[-size:]) return window_sum/min(len(queue),size)# Your MovingAverage object will be instantiated and called as such:# obj = MovingAverage(size)# param_1 = obj.next(val)"},{"title":"157. Read N Characters Given Read4(easy)","path":"2022/10/12/157/","text":"157. Read N Characters Given Read4(easy)Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters.Method read4:The API read4 reads four consecutive characters from file, then writes those characters into the buffer array buf4. The return value is the number of actual characters read. Note that read4() has its own file pointer, much like FILE *fp in C. Definition of read4:1234 Parameter: char[] buf4 Returns: intbuf4[] is a destination, not a source. The results from read4 will be copied to buf4[]. 给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。 read4 方法： API read4 可以从文件中读取 4 个连续的字符，并且将它们写入缓存数组 buf 中。 返回值为实际读取的字符个数。 注意 read4() 自身拥有文件指针，很类似于 C 语言中的 FILE *fp 。 read4 的定义： 123参数类型: char[] buf4返回类型: int注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。 read 方法：通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作文件。 返回值为实际读取的字符。 read 的定义： 123参数类型: char[] buf, int n返回类型: int注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。 hint123你不能直接操作该文件，文件只能通过 read4 获取而 不能 通过 read。read 函数只在每个测试用例调用一次。你可以假定目标缓存数组 buf 保证有足够的空间存下 n 个字符。 12345678910111213141516171819202122232425262728293031323334353637&quot;&quot;&quot;The read4 API is already defined for you. @param buf4, a list of characters @return an integer def read4(buf4):# Below is an example of how the read4 API can be called.file = File(&quot;abcdefghijk&quot;) # File is &quot;abcdefghijk&quot;, initially file pointer (fp) points to &#x27;a&#x27;buf4 = [&#x27; &#x27;] * 4 # Create buffer with enough space to store charactersread4(buf4) # read4 returns 4. Now buf = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;], fp points to &#x27;e&#x27;read4(buf4) # read4 returns 4. Now buf = [&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;], fp points to &#x27;i&#x27;read4(buf4) # read4 returns 3. Now buf = [&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,...], fp points to end of file&quot;&quot;&quot;class Solution: def read(self, buf, n): &quot;&quot;&quot; :type buf: Destination buffer (List[str]) :type n: Number of characters to read (int) :rtype: The number of actual characters read (int) &quot;&quot;&quot; temp = [&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;] count = read4(temp) s = temp[:count] while count &gt; 0: if len(s) &gt;= n: break count = read4(temp) s += temp[:count] total = min(n, len(s)) for i in range(total): buf[i] = s[i] return total"},{"title":"2434. Using a Robot to Print the Lexicographically Smallest String(medium)","path":"2022/10/12/2434/","text":"2434. Using a Robot to Print the Lexicographically Smallest String(medium)You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.Remove the last character of a string t and give it to the robot. The robot will write this character on paper. Return the lexicographically smallest string that can be written on the paper.周赛题，一道关于栈的题 123456789101112131415class Solution: def robotWithString(self, s: str) -&gt; str: d, stack, ans = Counter(s), [], [] for ch in s: d[ch]-= 1 stack.append(ch) if not d[ch]: d.pop(ch) while d and stack and min(d) &gt;= stack[-1]: ans += stack.pop() return &#x27;&#x27;.join(ans + stack[::-1])"},{"title":"359. Logger Rate Limiter(easy)","path":"2022/10/12/359/","text":"359. Logger Rate Limiter(easy)Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).All messages will come in chronological order. Several messages may arrive at the same timestamp.Implement the Logger class:Logger() Initializes the logger object.bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false. 这题的意思是message包含不同的短语，相同的短语之间间隔得大于等于10，不同的短语可以直接返回true 1234567891011121314151617181920212223242526class Logger: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self._msg_dict = &#123;&#125; def shouldPrintMessage(self, timestamp: int, message: str) -&gt; bool: &quot;&quot;&quot; Returns true if the message should be printed in the given timestamp, otherwise returns false. &quot;&quot;&quot; if message not in self._msg_dict: # case 1). add the message to print self._msg_dict[message] = timestamp return True if timestamp - self._msg_dict[message] &gt;= 10: # case 2). update the timestamp of the message self._msg_dict[message] = timestamp return True else: return False # Your Logger object will be instantiated and called as such:# obj = Logger()# param_1 = obj.shouldPrintMessage(timestamp,message)"},{"title":"293. Flip Game(easy)","path":"2022/10/12/293/","text":"293. Flip Game(easy)You are playing a Flip Game with your friend.You are given a string currentState that contains only ‘+’ and ‘-‘. You and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move, and therefore the other person will be the winner.Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].12Input: currentState = &quot;++++&quot;Output: [&quot;--++&quot;,&quot;+--+&quot;,&quot;++--&quot;] 连着的++换成–，看能输出多少个 1234567class Solution: def generatePossibleNextMoves(self, currentState: str) -&gt; List[str]: res=[] for i in range(len(currentState)-1): if currentState[i:i+2]==&quot;++&quot;: res.append(currentState[:i]+&#x27;--&#x27;+currentState[i+2:]) return res"},{"title":"367. Valid Perfect Square(easy)","path":"2022/10/12/367/","text":"367. Valid Perfect Square(easy)Given a positive integer num, write a function which returns True if num is a perfect square else False.Follow up: Do not use any built-in library function such as sqrt.判断是否是平方数，可以通过等差数列来求，等差数列a0=1, d=2，最后求和的结果就是n^2,所以通过该等差数列来求 1234567891011class Solution: def isPerfectSquare(self, num: int) -&gt; bool: i=1 d=2 while num&gt;0: num-=i i+=d if num==0: return True else: return False"},{"title":"338. Counting Bits(easy)","path":"2022/10/12/338/","text":"338. Counting Bits(easy)Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1’s in the binary representation of i.123456Input: n = 2Output: [0,1,1]Explanation:0 --&gt; 01 --&gt; 12 --&gt; 10 官方题解Use previous count results to generate the count for a new integer. DP + Most Significant Bit 12345678910111213141516class Solution: def countBits(self, n: int) -&gt; List[int]: ans = [0] * (n + 1) x = 0 b = 1 # [0, b) is calculated while b &lt;= n: # generate [b, 2b) or [b, n) from [0, b) while x &lt; b and x + b &lt;= n: ans[x + b] = ans[x] + 1 x += 1 x = 0 # reset x b &lt;&lt;= 1 # b = 2b return ans"},{"title":"292. Nim Game(easy)","path":"2022/10/12/292/","text":"292. Nim Game(easy)You are playing the following Nim Game with your friend:Initially, there is a heap of stones on the table.You and your friend will alternate taking turns, and you go first.On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.The one who removes the last stone is the winner.Given , the number of stones in the heap, return if you can win the game assuming both you and your friend play optimally, otherwise return .n truefalse 总结就是让对手只能拿到4或者4的倍数，这样他拿几个我都有机会赢 123class Solution: def canWinNim(self, n: int) -&gt; bool: return n%4"},{"title":"270. Closest Binary Search Tree Value(easy)","path":"2022/10/12/270/","text":"270. Closest Binary Search Tree Value(easy)Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.二叉搜索树上与target最近的数字leetcode题解 12345678910111213# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def closestValue(self, root, target): a = root.val kid = root.left if target &lt; a else root.right if not kid: return a b = self.closestValue(kid, target) return min((b, a), key=lambda x: abs(target - x))"},{"title":"976. Largest Perimeter Triangle(easy)","path":"2022/10/12/976/","text":"976. Largest Perimeter Triangle(easy)Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.组成三角形的条件是两边之和大于第三边，先将数组排序，然后从大往小挨个算能否组成三角形，如果可以就输出，到最后都没有发现就直接return 0 123456789101112class Solution: def largestPerimeter(self, nums: List[int]) -&gt; int: nums.sort(reverse=True) n=len(nums) for i in range(n-2): if nums[i]&gt;=nums[i+1]+nums[i+2]: continue elif nums[i]&lt;nums[i+1]+nums[i+2]: return sum(nums[i:i+3]) return 0"},{"title":"263. Ugly Number(easy)","path":"2022/10/12/263/","text":"263. Ugly Number(easy)An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.Given an integer n, return true if n is an ugly number.这是一个系列题263. 丑数（简单） 丑数 II（中等） 丑数 III（中等） 超级丑数（中等） 123456789101112131415class Solution: def isUgly(self, n: int) -&gt; bool: if n&lt;1: return False while n%2==0 or n%3==0 or n%5==0: if n %2==0: n/=2 elif n%3==0: n/=3 elif n%5==0: n/=5 if n==1: return True return False"},{"title":"266. Palindrome Permutation(easy)","path":"2022/10/12/266/","text":"266. Palindrome Permutation(easy)Given a string s, return true if a permutation of the string could form a palindrome.这题判断string能否组成回文串，回文串的特点就是最多只能有一个字母是奇数，其他的都得是偶数，这里很巧妙的运用了set的去重特性，最多只有一个字母留在set里 Leetcode题解 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: # Set: Iterate over the given string # Add the character when it is not there, Remove it when it is. # At the end, the length of the sets is lesser than 2 # TC O(n) n is the number of the character of string # SC O(1) the maximum size of the set would be 128 ASCII characters # This is bounded (constant), def canPermutePalindrome(self, s: str) -&gt; bool: sets = set() for char in s: if char not in sets: sets.add(char) else: sets.remove(char) return (len(sets) &lt;= 1) # # Hashmap: Count the number of occurence of characters# # TC O(n) n is the number of the character of string# # SC O(1) the maximum size of the map would be 128 ASCII characters# # This is bounded (constant)# def canPermutePalindrome(self, s: str) -&gt; bool:# # Iterate over a given string# # Count the number of occurence of characters# # key: Character, value: count# maps = collections.defaultdict(int)# for char in s:# if maps.get(char):# maps[char] += 1# else:# maps[char] = 1 # # Traverse over the map to find even number# count = 0# for key in maps:# count += maps[key] %2# # if maps[key] % 2 == 1:# # # Odd number of occuerence# # if the count is lesser than 2, it is palindrome# return (count &lt;= 1)"},{"title":"334. Increasing Triplet Subsequence(easy)","path":"2022/10/11/334/","text":"334. Increasing Triplet Subsequence(easy)Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.在一个队列里找到三个不断增大的数，不需要连续float(“inf”)是一个upper bound，也就是无穷大的边界专门用来做比较用的 123456789101112class Solution: def increasingTriplet(self, nums: List[int]) -&gt; bool: first_num = float(&quot;inf&quot;) second_num = float(&quot;inf&quot;) for n in nums: if n &lt;= first_num:# 第一小的数 first_num = n elif n &lt;= second_num:# 第二小的数 second_num = n else: #最后一个数 return True return False"},{"title":"257. Binary Tree Paths(easy)","path":"2022/10/10/257/","text":"257. Binary Tree Paths(easy)Given the root of a binary tree, return all root-to-leaf paths in any order.A leaf is a node with no children.作者：LeetCode-Solution链接：https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; def construct_paths(root, path): if root: path += str(root.val) if not root.left and not root.right: # 当前节点是叶子节点 paths.append(path) # 把路径加入到答案中 else: path += &#x27;-&gt;&#x27; # 当前节点不是叶子节点，继续递归遍历 construct_paths(root.left, path) construct_paths(root.right, path) paths = [] construct_paths(root, &#x27;&#x27;) return paths"},{"title":"243. Shortest Word Distance(easy)","path":"2022/10/10/243/","text":"243. Shortest Word Distance(easy)Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest distance between these two words in the list.这题先找到对应word的index，但这里有些case是word出现了很多次，所以再加循环遍历求最小值 123456789101112class Solution: def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -&gt; int: l=wordsDict.index(word1) r=wordsDict.index(word2) l=[index for (index,value) in enumerate(wordsDict) if value==word1] r=[index for (index,value) in enumerate(wordsDict) if value==word2] res=abs(l[0]-r[0]) for i in l: for j in r: res=min(res,abs(i-j)) return res"},{"title":"232. Implement Queue using Stacks(easy)","path":"2022/10/10/232/","text":"232. Implement Queue using Stacks(easy)Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).Implement the MyQueue class:void push(int x) Pushes element x to the back of the queue.int pop() Removes the element from the front of the queue and returns it.int peek() Returns the element at the front of the queue.boolean empty() Returns true if the queue is empty, false otherwise.Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.这题和225. Implement Stack using Queues(easy)互为镜像 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue: def __init__(self): &quot;&quot;&quot; in主要负责push，out主要负责pop &quot;&quot;&quot; self.stack_in = [] self.stack_out = [] def push(self, x: int) -&gt; None: &quot;&quot;&quot; 有新元素进来，就往in里面push &quot;&quot;&quot; self.stack_in.append(x) def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element from in front of queue and returns that element. &quot;&quot;&quot; if self.empty(): return None if self.stack_out: return self.stack_out.pop() else: for i in range(len(self.stack_in)): self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() def peek(self) -&gt; int: &quot;&quot;&quot; Get the front element. &quot;&quot;&quot; ans = self.pop() self.stack_out.append(ans) return ans def empty(self) -&gt; bool: &quot;&quot;&quot; 只要in或者out有元素，说明队列不为空 &quot;&quot;&quot; return not (self.stack_in or self.stack_out)# Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()"},{"title":"1328. Break a Palindrome(medium)","path":"2022/10/10/1328/","text":"1328. Break a Palindrome(medium)Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, “abcc” is lexicographically smaller than “abcd” because the first position they differ is at the fourth character, and ‘c’ is smaller than ‘d’.1234Input: palindrome = &quot;abccba&quot;Output: &quot;aaccba&quot;Explanation: There are many ways to make &quot;abccba&quot; not a palindrome, such as &quot;zbccba&quot;, &quot;aaccba&quot;, and &quot;abacba&quot;.Of all the ways, &quot;aaccba&quot; is the lexicographically smallest. 这道题其实很简单，是个贪心找回文串中，第一个大于’a’的字符，替换成’a’如果没有，说明整串都是a，最后一个换成b就行。所以破坏远比构建要容易 12345678class Solution: def breakPalindrome(self, palindrome: str) -&gt; str: if len(palindrome)==1: return &quot;&quot; for i in range(len(palindrome)//2): if palindrome[i]&gt;&#x27;a&#x27;: return palindrome[:i]+&#x27;a&#x27;+palindrome[i+1:] return palindrome[:len(palindrome)-1]+ &#x27;b&#x27;"},{"title":"145. Binary Tree Postorder Traversal(easy)","path":"2022/10/09/145/","text":"145. Binary Tree Postorder Traversal(easy)Given the root of a binary tree, return the postorder traversal of its nodes’ values.后序遍历，和前序遍历几乎一样 Leetcode官方题解123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: def postorder(root:TreeNode): if not root: return postorder(root.left) postorder(root.right) res.append(root.val) res=list() postorder(root) return res"},{"title":"144. Binary Tree Preorder Traversal(easy)","path":"2022/10/09/144/","text":"144. Binary Tree Preorder Traversal(easy)Given the root of a binary tree, return the preorder traversal of its nodes’ values.Leetcode官方题解二叉树的前序遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: def preorder(root:TreeNode): if not root: return res.append(root.val) preorder(root.left) preorder(root.right) res=list() preorder(root) return res"},{"title":"258. Add Digits(easy)","path":"2022/10/09/258/","text":"258. Add Digits(easy)Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.官方题解其实是一道数学题 123class Solution: def addDigits(self, num: int) -&gt; int: return (num - 1) % 9 + 1 if num else 0"},{"title":"252. Meeting Rooms(easy)","path":"2022/10/09/252/","text":"252. Meeting Rooms(easy)Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.安排会议的第一题，没有什么技巧，先将数组排序，然后判断后一个会议的开始时间是不是小于前一个会议的结束时间 1234567class Solution: def canAttendMeetings(self, intervals: List[List[int]]) -&gt; bool: intervals.sort() for i in range(len(intervals)-1): if intervals[i][1]&gt;intervals[i+1][0]: return False return True"},{"title":"246. Strobogrammatic Number（easy)","path":"2022/10/09/246/","text":"246. Strobogrammatic Number（easy)Given a string num which represents an integer, return true if num is a strobogrammatic number.A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).12Input: num = &quot;69&quot;Output: true 有点像求回文数的方法，双指针，但是有相同构造的数就那么几对，列出来即可 123456789101112class Solution: def isStrobogrammatic(self, num: str) -&gt; bool: if not num: return False pairs= set([(&#x27;0&#x27;,&#x27;0&#x27;), (&#x27;1&#x27;,&#x27;1&#x27;), (&#x27;6&#x27;,&#x27;9&#x27;), (&#x27;8&#x27;,&#x27;8&#x27;), (&#x27;9&#x27;,&#x27;6&#x27;)]) l,r=0,len(num)-1 while l&lt;=r: if (num[l],num[r]) not in pairs: return False l+=1 r-=1 return True"},{"title":"228. Summary Ranges(easy)","path":"2022/10/09/228/","text":"228. Summary Ranges(easy)You are given a sorted unique integer array nums.A range [a,b] is the set of all integers from a to b (inclusive).Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.Each range [a,b] in the list should be output as:“a-&gt;b” if a != b“a” if a == b 12345678910111213141516class Solution: def summaryRanges(self, nums: List[int]) -&gt; List[str]: res = [] cur = 0 while cur&lt;len(nums): start = cur while cur&lt;len(nums)-1 and nums[cur]+1==nums[cur+1]: cur+=1 if cur!=start: res.append(str(nums[start]) + &quot;-&gt;&quot; + str(nums[cur])) else: res.append(str(nums[cur])) cur+=1 return res"},{"title":"225. Implement Stack using Queues(easy)","path":"2022/10/09/225/","text":"225. Implement Stack using Queues(easy)Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).Implement the MyStack class:void push(int x) Pushes element x to the top of the stack.int pop() Removes the element on the top of the stack and returns it.int top() Returns the element on the top of the stack.boolean empty() Returns true if the stack is empty, false otherwise. Notes:You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations. 12345678910111213Input[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]Output[null, null, null, 2, 2, false]ExplanationMyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // return 2myStack.pop(); // return 2myStack.empty(); // return False Leetcode官方题解栈是一种后进先出的数据结构，元素从顶端入栈，然后从顶端出栈。 队列是一种先进先出的数据结构，元素从后端入队，然后从前端出队。 为了满足栈的特性，即最后入栈的元素最先出栈，在使用队列实现栈时，应满足队列前端的元素是最后入栈的元素。可以使用两个队列实现栈的操作，其中 queue1用于存储栈内的元素，queue2作为入栈操作的辅助队列。 入栈操作时，首先将元素入队到 queue2，然后将 queue1的全部元素依次出队并入队到 queue2，此时 queue2的前端的元素即为新入栈的元素，再将 queue1和 queue2互换，则 queue1的元素即为栈内的元素，queue1的前端和后端分别对应栈顶和栈底。 由于每次入栈操作都确保 queue1的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1的前端元素并返回即可（不移除元素）。 由于 queue1用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1是否为空即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty()class MyStack: def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.queue1 = collections.deque() self.queue2 = collections.deque() def push(self, x: int) -&gt; None: &quot;&quot;&quot; Push element x onto stack. &quot;&quot;&quot; self.queue2.append(x) while self.queue1: self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 def pop(self) -&gt; int: &quot;&quot;&quot; Removes the element on top of the stack and returns that element. &quot;&quot;&quot; return self.queue1.popleft() def top(self) -&gt; int: &quot;&quot;&quot; Get the top element. &quot;&quot;&quot; return self.queue1[0] def empty(self) -&gt; bool: &quot;&quot;&quot; Returns whether the stack is empty. &quot;&quot;&quot; return not self.queue1"},{"title":"190. Reverse Bits(easy)","path":"2022/10/09/190/","text":"Reverse bits of a given 32 bits unsigned integer.Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.123Input: n = 00000010100101000001111010011100Output: 964176192 (00111001011110000010100101000000)Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. 二进制颠倒顺序，用位运算的方法 1234567891011class Solution: def reverseBits(n): res=0 ans=0 n1=0 for i in range(32): ans=res&lt;&lt;1 n1=n&amp;1 # n1=n&amp;1 res=ans|n1 # 或运算：同0为0，否则为1 n&gt;&gt;=1 # x &gt;&gt; y 右移操作，最左边用 0 填充 return res"},{"title":"168. Excel Sheet Column Title(easy)","path":"2022/10/09/168/","text":"168. Excel Sheet Column Title(easy)Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.For example:12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 12Input: columnNumber = 1Output: &quot;A&quot; 这道题和 171. Excel Sheet Column Number(easy)属于镜像题，可以用高中学过的十进制转二进制的思想，利用求余和除法不断求出每一位的系数 1234567891011class Solution: def convertToTitle(self, columnNumber: int) -&gt; str: ans=[] while columnNumber&gt;0: columnNumber-=1 current=columnNumber%26 columnNumber=columnNumber//26 ans.append(chr(current+ord(&#x27;A&#x27;))) #The chr() method converts an integer to its unicode character and returns it. return &#x27;&#x27;.join(ans[::-1]) # [::-1] , it starts from the end towards the first taking each element."},{"title":"342. Power of Four(easy)","path":"2022/10/08/342/","text":"342. Power of Four(easy)Given an integer n, return true if it is a power of four. Otherwise, return false.An integer n is a power of four, if there exists an integer x such that n == 4^x.123456789101112class Solution: def isPowerOfFour(self, n: int) -&gt; bool: hashset1=set() i=0 while math.pow(4,i)&lt;math.pow(2,31)-1: hashset1.add(math.pow(4,i)) i+=1 if n in hashset1: return True else: return False"},{"title":"326. Power of Three(easy)","path":"2022/10/08/326/","text":"326. Power of Three(easy)Given an integer n, return true if it is a power of three. Otherwise, return false.An integer n is a power of three, if there exists an integer x such that n == 3x.通用代码 123456789101112class Solution: def isPowerOfThree(self, n: int) -&gt; bool: hashset1=set() i=0 while math.pow(3,i)&lt;math.pow(2,31)-1: hashset1.add(math.pow(3,i)) i+=1 if n in hashset1: return True else: return False"},{"title":"1380. Lucky Numbers in a Matrix(easy)","path":"2022/10/05/1380/","text":"1380. Lucky Numbers in a Matrix(easy)Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.class Solution: def luckyNumbers(self, matrix: List[List[int]]) -&gt; List[int]: m = len(matrix) n = len(matrix[0]) # Calculate the strength of each row. strengths = [] col=[] res=[] for i, row in enumerate(matrix): strength = row[0] ind=0 for j in range(1,n): if row[j]&lt;strength: ind=j strength=row[j] strengths.append((strength, ind)) for i in range(len(strengths)): col = [sub[strengths[i][1]] for sub in matrix] if strengths[i][0]==max(col): res.append(strengths[i][0]) return res"},{"title":"1337. The K Weakest Rows in a Matrix(easy)","path":"2022/10/05/1337/","text":"1337. The K Weakest Rows in a Matrix(easy)You are given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row.A row i is weaker than a row j if one of the following is true:The number of soldiers in row i is less than the number of soldiers in row j.Both rows have the same number of soldiers and i &lt; j.Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.思路分成两步，第一步先求出每行1的个数，用一个二维数组储存第二步再输出前K个 leetcode题解 12345678910111213141516171819202122232425262728class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&gt; List[int]: # Note that there is a more conscise solution just below. This code # avoids the use of advanced language features. m = len(mat) n = len(mat[0]) # Calculate the strength of each row. strengths = [] for i, row in enumerate(mat): strength = 0 for j in range(n): if row[j] == 0: break strength += 1 strengths.append((strength, i)) # Sort all the strengths. This will sort firstly by strength # and secondly by index. strengths.sort() # Pull out and return the indexes of the smallest k entries. indexes = [] for i in range(k): indexes.append(strengths[i][1]) return indexes"},{"title":"1351. Count Negative Numbers in a Sorted Matrix","path":"2022/10/04/1351/","text":"1351. Count Negative Numbers in a Sorted MatrixGiven a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.还是一样的，都是挨个遍历一遍 12345678910class Solution: def countNegatives(self, grid: List[List[int]]) -&gt; int: n=len(grid) m=len(grid[0]) res=0 for i in range(n): for j in range(m): if grid[i][j]&lt;0: res+=1 return res"},{"title":"832. Flipping an Image(easy)","path":"2022/10/04/832/","text":"832. Flipping an Image(easy)Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.To flip an image horizontally means that each row of the image is reversed.For example, flipping [1,1,0] horizontally results in [0,1,1].To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.For example, inverting [0,1,1] results in [1,0,0].两次遍历，第一次遍历是10互换，第二次遍历是前后数字互换 123456789101112131415161718192021class Solution: def flipAndInvertImage(self, image: List[List[int]]) -&gt; List[List[int]]: n=len(image) for i in range(n): for j in range(n): if image[i][j]==1: image[i][j]=0 else: image[i][j]=1 for i in range(n): if n%2==0: for j in range(n//2): tmp=image[i][j] image[i][j]=image[i][n-j-1] image[i][n-j-1]=tmp else: for j in range(n//2+1): tmp=image[i][j] image[i][j]=image[i][n-j-1] image[i][n-j-1]=tmp return image 相对轻便的算法[::-1] 顺序相反操作[-1] 读取倒数第一个元素[3::-1] 从下标为3（从0开始）的元素开始翻转读取 1234567891011121314class Solution: def flipAndInvertImage(self, image: List[List[int]]) -&gt; List[List[int]]: result=[] for i in image: result.append(i[::-1]) for i in range(len(result)): for j in range(len(result[i])): if result[i][j]==0: result[i][j]=1 else: result[i][j]=0 return result"},{"title":"2373. Largest Local Values in a Matrix(easy)","path":"2022/10/04/2373/","text":"2373. Largest Local Values in a Matrix(easy)You are given an n x n integer matrix grid.Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.Return the generated matrix.二维矩阵遍历 12345678class Solution: def largestLocal(self, grid: List[List[int]]) -&gt; List[List[int]]: n=len(grid) ans=[[0]*(n-2) for _ in range(n-2)] for i in range(n-2): for j in range(n-2): ans[i][j]=max(grid[x][y] for x in range(i,i+3) for y in range(j,j+3)) return ans"},{"title":"LeetCode-skill11-matrix","path":"2022/10/04/LeetCode-skill11-matrix/","text":"Richest Customer Wealth(easy) Spiral Matrix(medium)"},{"title":"1672. Richest Customer Wealth(easy)","path":"2022/10/04/1672/","text":"1672. Richest Customer Wealth(easy)You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.A customer’s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.123456789101112class Solution: def maximumWealth(self, accounts: List[List[int]]) -&gt; int: res=0 for i in range(len(accounts)): res=max(res,sum(accounts[i])) return res``` ```pythonaccounts = [[1,2,3],[3,2,1]]print(len(accounts)) #2 行print(len(accounts[0])) #3 列"},{"title":"171. Excel Sheet Column Number(easy)","path":"2022/10/03/171/","text":"171. Excel Sheet Column Number(easy)Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.For example:12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 这道题是一经典题目，相当于从26进制转换成十进制，这是一个标准算法，我们从右到左迭代数字，并将它们乘以基数到数字位置的幂。为了将字母转换为数字，我们使用ord，该方法返回字母的Unicode代码。通过将代码减去 64，我们可以将字母映射到从 1 到 26 的数字。和 168. Excel Sheet Column Title(easy) 是一道镜像题目 26进制转换为十进制，相当于K*(26^(n-1)) 12345678class Solution: def titleToNumber(self, columnTitle: str) -&gt; int: val=0 for i,c in enumerate(reversed(columnTitle)): val+=(26**i)*(ord(c) - ord(&#x27;A&#x27;) + 1) return val#** 代表乘方"},{"title":"LeetCode-skill10-Data-structure-design","path":"2022/10/03/LeetCode-skill10-Data-structure-design/","text":"Two Sum III - Data structure design(easy) Implement Stack using Queues(easy) Moving Average from Data Stream Logger Rate Limiter(easy) Online Stock Span(medium)"},{"title":"170. Two Sum III - Data structure design(easy)","path":"2022/10/03/170/","text":"170. Two Sum III - Data structure design(easy)Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.Implement the TwoSum class:TwoSum() Initializes the TwoSum object, with an empty array initially.void add(int number) Adds number to the data structure.boolean find(int value) Returns true if there exists any pair of numbers whose sum is equal to value, otherwise, it returns false. 12345678910111213Input[&quot;TwoSum&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;find&quot;, &quot;find&quot;][[], [1], [3], [5], [4], [7]]Output[null, null, null, null, true, false]ExplanationTwoSum twoSum = new TwoSum();twoSum.add(1); // [] --&gt; [1]twoSum.add(3); // [1] --&gt; [1,3]twoSum.add(5); // [1,3] --&gt; [1,3,5]twoSum.find(4); // 1 + 3 = 4, return truetwoSum.find(7); // No two integers sum up to 7, return false leetcode题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TwoSum: def __init__(self): self.nums=[] self.is_sorted=False def add(self, number: int) -&gt; None: # Inserting while maintaining the ascending order. # for index, num in enumerate(self.nums): # if number &lt;= num: # self.nums.insert(index, number) # return ## larger than any number #self.nums.append(number) self.nums.append(number) self.is_sorted = False def find(self, value: int) -&gt; bool: &quot;&quot;&quot; Find if there exists any pair of numbers which sum is equal to the value. :type value: int :rtype: bool &quot;&quot;&quot; if not self.is_sorted: self.nums.sort() self.is_sorted = True low, high = 0, len(self.nums)-1 while low &lt; high: currSum = self.nums[low] + self.nums[high] if currSum &lt; value: low += 1 elif currSum &gt; value: high -= 1 else: # currSum == value return True return False # Your TwoSum object will be instantiated and called as such:# obj = TwoSum()# obj.add(number)# param_2 = obj.find(value)"},{"title":"1572. Matrix Diagonal Sum(easy)","path":"2022/10/03/1572/","text":"1572. Matrix Diagonal Sum(easy)Given a square matrix mat, return the sum of the matrix diagonals.Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.矩阵对角线之和，这题很典型 逐行取数思路与算法 逐行遍历，记当前的行号为 i，对于一行我们把 (i, i)位置和 (i, n - i - 1) 加入答案。这样如果 n 是奇数的话，最中间的格子会被加入两次。所以 n 为奇数的时候，我们需要减掉矩阵最中心的那个值。 12345678class Solution: def diagonalSum(self, mat: List[List[int]]) -&gt; int: n = len(mat) total = 0 mid = n // 2 for i in range(n): total += mat[i][i] + mat[i][n - 1 - i] return total - mat[mid][mid] * (n &amp; 1) n&amp;1是用来判断奇偶性的n&amp;1 与运算 可以判断n是否为偶数 如果是偶数，n&amp;1返回0；否则返回1，为奇数。一个整数 n，n&amp;1 这个表达式 可以用来 判断 a的奇偶性。二进制的末位为 0表示偶数，末位为 1表是奇数。使用 n%2 来判断奇偶性 和 n&amp;1 是一样的作用，但是 n&amp;1 要快好多。"},{"title":"163. Missing Ranges(easy)","path":"2022/10/03/163/","text":"163. Missing Ranges(easy)You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are in the inclusive range.A number x is considered missing if x is in the range [lower, upper] and x is not in nums.Return the smallest sorted list of ranges that cover every missing number exactly. That is, no element of nums is in any of the ranges, and each missing number is in one of the ranges.Each range [a,b] in the list should be output as:“a-&gt;b” if a != b“a” if a == b 1234567Input: nums = [0,1,3,50,75], lower = 0, upper = 99Output: [&quot;2&quot;,&quot;4-&gt;49&quot;,&quot;51-&gt;74&quot;,&quot;76-&gt;99&quot;]Explanation: The ranges are:[2,2] --&gt; &quot;2&quot;[4,49] --&gt; &quot;4-&gt;49&quot;[51,74] --&gt; &quot;51-&gt;74&quot;[76,99] --&gt; &quot;76-&gt;99&quot; 这题是通过lower和upper确定上下边界，然后再挨个前后相减得到范围 12345678910111213141516171819202122class Solution: def findMissingRanges(self, nums: List[int], lower: int, upper: int) -&gt; List[str]: numList = nums nums = [lower - 1] for num in numList: nums.append(num) nums.append(upper + 1) ranges = list() for i in range(len(nums) - 1): dist = nums[i + 1] - nums[i] if dist &gt; 1: if dist == 2: ranges.append(str(nums[i] + 1)) else: start = nums[i] + 1 end = nums[i + 1] - 1 ranges.append(&quot;&#123;0:d&#125;-&gt;&#123;1:d&#125;&quot;.format(start, end)) return ranges"},{"title":"1155. Number of Dice Rolls With Target Sum(medium)","path":"2022/10/02/1155/","text":"Number of Dice Rolls With Target Sum(medium) You have n dice and each die has k faces numbered from 1 to k. Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7. 这题乍一看就是dp，而且类似于爬楼梯问题，相当于一次爬K个台阶，一共爬n次爬到target的位置 1234Input: n = 1, k = 6, target = 3Output: 1Explanation: You throw one die with 6 faces.There is only one way to get a sum of 3. 题解We are asked to figure out how many times we get target sum with n dice with values 1..k.The important point is - sum of all faced-up numbers. So it cannot be a subset of n dice. It should be sum of all faced-up dice. We are going to pick the 1st dice with value 1. Then we going to pick the 2nd dice with value 1 and so on until we ran out of dice.sum([1,1,1,..1] n times) == target? Then we are going to pick the 1st dice with value 1 and the 2nd dice with value 2 and so on.sum([[1,2,1,..1] n times) == target? …sum([[3,1,5,..4] n times) == target?… … n) sum([k,k,…k] n times) == target?When we ran out of dice (n -&gt; 0) we check if the sum of all picked dice values == target. If yes, return 1, else return 0 for a specific permutation. They want us to count [1,2] and [2,1] as 2 different sets. The order of items is important. We are working with permutations. Find the target sum in all permutations of size n with element values ranging from 1…k. 1234567891011121314151617181920212223242526272829303132333435class Solution: def numRollsToTarget(self, N: int, k: int, target: int) -&gt; int: # [1] 2 3 4 5 6 # 1 2 3 4 5 [6] # bottom-up/tabulation TC: (N*k*target) SC: (N*target) MOD = 10**9 + 7 dp = [[0] * (target + 1) for _ in range(N + 1)] dp[0][0] = 1 for n in range(1, N + 1): for i in range(1, k + 1): for t in range(i, target + 1): dp[n][t] += dp[n - 1][t - i] % MOD return dp[N][target] % MOD # top-down# @cache# def solve(n, t):# if n == 0:# return 1 if t == 0 else 0 # if we ran out of dice and we got our target value# count = 0# for j in range(1, k + 1):# if t - j &gt;= 0:# count += solve(n - 1, t - j) # return count # return solve(n, target) % MOD"},{"title":"119. Pascal's Triangle II(easy)","path":"2022/10/02/119/","text":"119. Pascal’s Triangle II(easy)Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle.In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:跟118几乎一模一样，只不过这道题是输出特定的某一行 123456789class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: if rowIndex==0:return [1] res=[[1]] while len(res)&lt;rowIndex+1: newRow=[a+b for a,b in zip([0]+res[-1],res[-1]+[0])] res.append(newRow) return newRow"},{"title":"139","path":"2022/10/02/139/","text":""},{"title":"118. Pascal's Triangle","path":"2022/10/02/118/","text":"118. Pascal’s TriangleGiven an integer numRows, return the first numRows of Pascal’s triangle.In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:杨辉三角,算是数学题观察一下规律，发现当前一行只比上一行多了一个元素，最最关键的一点：本行元素等于上一行元素往后错一位再逐个相加： 题解12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows == 0: return [] res = [[1]] while len(res) &lt; numRows: newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])] res.append(newRow) return res"},{"title":"125. Valid Palindrome","path":"2022/10/02/125/","text":"125. Valid PalindromeA phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.Given a string s, return true if it is a palindrome, or false otherwise.123Input: s = &quot;A man, a plan, a canal: Panama&quot;Output: trueExplanation: &quot;amanaplanacanalpanama&quot; is a palindrome. 这里有个重要的函数isalnum()，用来判断是不是字母 1234567891011121314class Solution: def isPalindrome(self, s: str) -&gt; bool: n=len(s) left,right=0,n-1 while left&lt;right: while left&lt;right and not s[left].isalnum(): left+=1 while left&lt;right and not s[right].isalnum(): right-=1 if left&lt;right: if s[left].lower()!=s[right].lower(): return False left,right=left+1,right-1 return True"},{"title":"111. Minimum Depth of Binary Tree(easy)","path":"2022/10/02/111/","text":"111. Minimum Depth of Binary Tree(easy)Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children.题解 根据大佬的Java代码写的python Java12345678910111213141516class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null) return 0; //这道题递归条件里分为三种情况 //1.左孩子和右孩子都为空的情况，说明到达了叶子节点，直接返回1即可 if(root.left == null &amp;&amp; root.right == null) return 1; //2.如果左孩子和右孩子其中一个为空，那么需要返回比较大的那个孩子的深度 int m1 = minDepth(root.left); int m2 = minDepth(root.right); //这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1; if(root.left == null || root.right == null) return m1 + m2 + 1; //3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可 return Math.min(m1,m2) + 1; &#125;&#125; Python12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def minDepth(self, root: Optional[TreeNode]) -&gt; int: if root==None: return 0 #这道题递归条件里分为三种情况 #1.左孩子和右孩子都为空的情况，说明到达了叶子节点，直接返回1即可 if root.left==None and root.right==None: return 1 #2.如果左孩子和右孩子其中一个为空，那么需要返回比较大的那个孩子的深度 m1=self.minDepth(root.left) m2=self.minDepth(root.right) #这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1; if root.left==None or root.right==None: return m1+m2+1 #3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可 return min(m1,m2)+1"},{"title":"108. Convert Sorted Array to Binary Search Tree(easy)","path":"2022/10/02/108/","text":"108. Convert Sorted Array to Binary Search Tree(easy)Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.中序遍历 中序遍历，总是选择中间位置左边的数字作为根节点选择中间位置左边的数字作为根节点，则根节点的下标为 \\textit{mid}=(\\textit{left}+\\textit{right})/2mid=(left+right)/2，此处的除法为整数除法。 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: def helper(left, right): if left &gt; right: return None # 总是选择中间位置左边的数字作为根节点 mid = (left + right) // 2 root = TreeNode(nums[mid]) root.left = helper(left, mid - 1) root.right = helper(mid + 1, right) return root return helper(0, len(nums) - 1)"},{"title":"100. Same Tree(easy)","path":"2022/10/02/100/","text":"100. Same Tree(easy)Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.12Input: p = [1,2,3], q = [1,2,3]Output: true Recursion递归 123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool: if not p and not q: return True if not q or not p: return False if p.val!=q.val: return False return self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left)"},{"title":"94. Binary Tree Inorder Traversal(easy)","path":"2022/10/02/94/","text":"94. Binary Tree Inorder Traversal(easy)Given the root of a binary tree, return the inorder traversal of its nodes’ values.二叉树的中序遍历 递归遍历 前序遍历：打印 - 左 - 右中序遍历：左 - 打印 - 右后序遍历：左 - 右 - 打印题目要求的是中序遍历，那就按照 左-打印-右这种顺序遍历树就可以了，递归函数实现 终止条件：当前节点为空时函数内：递归的调用左节点，打印当前节点，再递归调用右节点时间复杂度：O(n)空间复杂度：O(h)，h 是树的高度 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: res=[] def dfs(root): if not root: return dfs(root.left) res.append(root.val) dfs(root.right) dfs(root) return res"},{"title":"70. Climbing Stairs(easy)","path":"2022/10/02/70/","text":"70. Climbing Stairs(easy)You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?12345Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 一道经典DP题 状态转移方程：dp[i]=dp[i−1]+dp[i−2]f(1) = 1 f(2) = 2 1234567891011class Solution: def climbStairs(self, n: int) -&gt; int: if n&lt;=2: return n before_last=1 last=2 for i in range(2,n): current=before_last+last before_last=last last = current return last"},{"title":"67. Add Binary(easy)","path":"2022/10/02/67/","text":"67. Add Binary(easy)Given two binary strings a and b, return their sum as a binary string.12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; 实现二进制加法官方题解 12345678910111213141516171819202122232425class Solution: def addBinary(self, a, b) -&gt; str: n = max(len(a), len(b)) a, b = a.zfill(n), b.zfill(n) carry = 0 answer = [] for i in range(n - 1, -1, -1): if a[i] == &#x27;1&#x27;: carry += 1 if b[i] == &#x27;1&#x27;: carry += 1 if carry % 2 == 1: answer.append(&#x27;1&#x27;) else: answer.append(&#x27;0&#x27;) carry //= 2 if carry == 1: answer.append(&#x27;1&#x27;) answer.reverse() return &#x27;&#x27;.join(answer)"},{"title":"66. Plus One(easy)","path":"2022/10/02/66/","text":"66. Plus One(easy)You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s.Increment the large integer by one and return the resulting array of digits.这道题可以用数学方法分类去算，但也可以先把digits转换为一整个数字，加1后，再转换回数组 class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: res=&quot;&quot;.join(str(digit) for digit in digits) res= int(res)+1 return str(res)"},{"title":"58. Length of Last Word(easy)","path":"2022/10/02/58/","text":"58. Length of Last Word(easy)Given a string s consisting of words and spaces, return the length of the last word in the string.A word is a maximal substring consisting of non-space characters only.1234class Solution: def lengthOfLastWord(self, s: str) -&gt; int: l=s.split() return len(l[-1])"},{"title":"35. Search Insert Position(easy)","path":"2022/10/02/35/","text":"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You must write an algorithm with O(log n) runtime complexity.基础做法，遍历 123456789101112131415class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: res=0 if len(nums)==1: if target&gt;nums[0]: return 1 else: return 0 if target&gt;nums[-1]: return len(nums) for i in range(len(nums)): if nums[i]&gt;=target: res=i break return res 二分查找 12345678910111213class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: length=len(nums) left = 0 right = length while left&lt;right: mid = int(left + (right - left) / 2) if nums[mid]&lt;target: left = mid+1 else: right= mid return left"},{"title":"14. Longest Common Prefix(easy)","path":"2022/10/02/14/","text":"14. Longest Common Prefix(easy)Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string “”.官方题解 纵向扫描方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。 123456789101112class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return &quot;&quot; length, count = len(strs[0]), len(strs) for i in range(length): c = strs[0][i] if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)): return strs[0][:i] return strs[0]"},{"title":"1480. Running Sum of 1d Array(easy)","path":"2022/10/02/1480/","text":"Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums. 123Input: nums = [1,2,3,4]Output: [1,3,6,10]Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. 其实这题就是前缀和数组 1234567class Solution: def runningSum(self, nums: List[int]) -&gt; List[int]: res=[0]*len(nums) res[0]=nums[0] for i in range(1,len(nums)): res[i]=nums[i]+res[i-1] return res"},{"title":"231. Power of Two(easy)","path":"2022/10/01/231/","text":"231. Power of Two(easy)Given an integer n, return true if it is a power of two. Otherwise, return false.An integer n is a power of two, if there exists an integer x such that n == 2^x.How to get / isolate the rightmost 1-bit : x &amp; (-x). How to turn off (= set to 0) the rightmost 1-bit : x &amp; (x - 1).官方题解 Approach 1: Bitwise Operators : Get the Rightmost 1-bit"},{"title":"260. Single Number III(medium)","path":"2022/10/01/260/","text":"260. Single Number III(medium)Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.123Input: nums = [1,2,1,3,2,5]Output: [3,5]Explanation: [5, 3] is also a valid answer. 官方题解 Two bitmasks"},{"title":"91. Decode Ways(medium)","path":"2022/10/01/91/","text":"91. Decode Ways(medium)A message containing letters from A-Z can be encoded into numbers using the following mapping:1234&#x27;A&#x27; -&gt; &quot;1&quot;&#x27;B&#x27; -&gt; &quot;2&quot;...&#x27;Z&#x27; -&gt; &quot;26&quot; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into: “AAJF” with the grouping (1 1 10 6)“KJF” with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”. Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. 123Input: s = &quot;12&quot;Output: 2Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12). 123Input: s = &quot;226&quot;Output: 3Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). Leetcode Solution12345678910111213141516171819class Solution: def numDecodings(self, s: str) -&gt; int: if s[0] == &quot;0&quot;: return 0 two_back = 1 one_back = 1 for i in range(1, len(s)): current = 0 if s[i] != &quot;0&quot;: current = one_back two_digit = int(s[i - 1: i + 1]) if two_digit &gt;= 10 and two_digit &lt;= 26: current += two_back two_back = one_back one_back = current return one_back"},{"title":"137. Single Number II(medium)","path":"2022/10/01/137/","text":"137. Single Number(medium)Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.You must implement a solution with a linear runtime complexity and use only constant extra space.12Input: nums = [2,2,3,2]Output: 3 官方题解 这里用到了异或XOR Let’s start from XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc. XOR of zero and a bit results in that bit 0⊕x=x XOR of two equal bits (even if they are zeros) results in a zero x⊕x=0 and so on and so forth, i.e. one could see the bit in a bitmask only if it appears odd number of times.That’s already great, so one could detect the bit which appears once, and the bit which appears three times. The problem is to distinguish between these two situations. AND and NOT To separate number that appears once from a number that appears three times let’s use two bitmasks instead of one: seen_once and seen_twice. The idea is to change seen_once only if seen_twice is unchanged change seen_twice only if seen_once is unchanged 1234567891011121314151617181920class Solution: def singleNumber(self, nums: List[int]) -&gt; int: seen_once = seen_twice = 0 for num in nums: # first appearance: # add num to seen_once # don&#x27;t add to seen_twice because of presence in seen_once # second appearance: # remove num from seen_once # add num to seen_twice # third appearance: # don&#x27;t add to seen_once because of presence in seen_twice # remove num from seen_twice seen_once = ~seen_twice &amp; (seen_once ^ num) seen_twice = ~seen_once &amp; (seen_twice ^ num) return seen_once"},{"title":"136. Single Number(easy)","path":"2022/09/30/136/","text":"136. Single Number(easy)Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space.12Input: nums = [2,2,1]Output: 1 这道题的关键在于异或运算，异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0 假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。a1⊕a1⊕a2⊕a2⊕a3⊕a3⊕a4⊕a4⊕a5⊕a5⋯⋯⋯⊕am⊕am⊕am+1=0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕am+1=am+1​ 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。 1234class Solution: def singleNumber(self, nums: List[int]) -&gt; int: return reduce(lambda x, y: x ^ y, nums) python reduceThe reduce() function accepts a function and a sequence and returns a single value calculated as follows: Initially, the function is called with the first two items from the sequence and the result is returned.The function is then called again with the result obtained in step 1 and the next value in the sequence. This process keeps repeating until there are items in the sequence.The syntax of the reduce() function is as follows: Syntax: reduce(function, sequence[, initial]) -&gt; value When the initial value is provided, the function is called with the initial value and the first item from the sequence."},{"title":"191. Number of 1 Bits(easy)","path":"2022/09/30/191/","text":"191. Number of 1 Bits(easy)Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).Note:Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3.1234567class Solution(object): def hammingWeight(self, n): res = 0 while n: res += n &amp; 1 n &gt;&gt;= 1 return res"},{"title":"LeetCode-skill9-bitwise","path":"2022/09/30/LeetCode-skill9-bitwise/","text":"位运算 Bit Manipulation n &amp; 1 使用 n &amp; 1 得到二进制末尾是否为 1；n &gt;&gt;= 1 把 n 右移 1 位，直至结束。 bit操作&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算 与运算：同1为1，否则为0 12340 &amp; 0 = 00 &amp; 1 = 01 &amp; 0 = 01 &amp; 1 = 1 | 符号，x | y ，会将两个十进制数在二进制下进行或运算 或运算：同0为0，否则为1 12340 | 0 = 01 | 0 = 10 | 1 = 11 | 1 = 1 ^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算 异或：相同为0，不同为1 12340 ^ 0 = 00 ^ 1 = 11 ^ 0 = 11 ^ 1 = 0 &lt;&lt; 符号，x &lt;&lt; y 左移操作，最右边用 0 填充 10011 =&gt; 0110 符号，x &gt;&gt; y 右移操作，最左边用 0 填充~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反 1~0 = 1 x ^ 0 = x 任何数与0异或，结果都是它本身x ^ x = 0 任何数与它本身异或，结果都是0x ^ 1s = x (1s为全1) 一个数和全1异或，相当于取反x ^ (x) = 1s 一个数和它取反后的结果异或，结果为全1c = a ^ b =&gt; a ^ c = b, b ^ c = a 交换两个数a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c 加法（异或）结合律 x &amp; (0&lt;&lt;n) 将x最右边的n位清零(x&gt;&gt;n) &amp; 1 获取x的第n位值（0或者1）x &amp; (1&lt;&lt;n) 获取x的第n位的幂值x 丨 (1&lt;&lt;n) 仅将第n位置为1x &amp; ((1&lt;&lt;n) - 1) 将x最高位至第n位（包含）清零x &amp; ((1 &lt;&lt; n)) 仅将第n位置为0 整数集合set位运算整数集合做标志时，比如回溯时的visited标志数组vstd 访问 i ：vstd | (1 &lt;&lt; i)vstd 离开 i ：vstd &amp; ~(1 &lt;&lt; i)vstd 不包含 i : not vstd &amp; (1 &lt;&lt; i) 并集 ：A | B交集 ：A &amp; B全集 ：(1 &lt;&lt; n) - 1补集 ：((1 &lt;&lt; n) - 1) ^ A子集 ：(A &amp; B) == B判断是否是 2 的幂 ：A &amp; (A - 1) == 0最低位的 1 变为 0 ：n &amp;= (n - 1)最低位的 1：A &amp; (-A)，最低位的 1 一般记为 lowbit(A) 这题没有考什么深的东西，不过可以复习一下 python 的字符运算语法： 复习一下 python 的位运算符： (a &amp; b)按位与运算符：参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0 。输出结果 12 ，二进制解释： 0000 1100 (a | b)按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。输出结果 61 ，二进制解释： 0011 1101 (a ^ b)按位异或运算符：当两对应的二进位相异时，结果为 1输出结果 49 ，二进制解释： 0011 0001 (a )按位取反运算符：对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1 。x 类似于 -x-1输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 a &lt;&lt; 2左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补 0。输出结果 240 ，二进制解释： 1111 0000 a &gt;&gt; 2右移动运算符：把 “&gt;&gt;” 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数输出结果 15 ，二进制解释： 0000 1111 python 赋值运算符： *= 乘法赋值运算符 c *= a 等效于 c = c * a/= 除法赋值运算符 c /= a 等效于 c = c / a%= 取模赋值运算符 c %= a 等效于 c = c % a**= 幂赋值运算符 c **= a 等效于 c = c ** a//= 取整除赋值运算符 c //= a 等效于 c = c // a Reverse Bits(easy) Number of 1 Bits 计算数字的二进制中有多少个1。 Single Number找出数组中不重复的元素。其它元素出现两次。原题 Single Number II找出数组中出现一次的元素，其它元素出现三次。原题 Add Binary(easy)二进制加法 Reverse Integer(medium)"},{"title":"218. The Skyline Problem(hard)","path":"2022/09/29/218/","text":"218. The Skyline Problem(hard)A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:lefti is the x coordinate of the left edge of the ith building.righti is the x coordinate of the right edge of the ith building.heighti is the height of the ith building. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.The skyline should be represented as a list of “key points” sorted by their x-coordinate in the form [[x1,y1],[x2,y2],…]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […,[2 3],[4 5],[7 5],[11 5],[12 7],…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […,[2 3],[4 5],[12 7],…]12345Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]Explanation:Figure A shows the buildings of the input.Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution(object): def getSkyline(self, buildings: List[List[int]]) -&gt; List[List[int]]: # Iterate over the left and right edges of all the buildings, # If its a left edge, add (left, height) to &#x27;edges&#x27;. # Otherwise, add (right, -height) to &#x27;edges&#x27;. edges = [] for left, right, height in buildings: edges.append([left, height]) edges.append([right, -height]) edges.sort() # Initailize two empty priority queues &#x27;live&#x27; and &#x27;past&#x27; # for the live buildings and the past buildings. live, past = [], [] answer = [] idx = 0 # Iterate over all the sorted edges. while idx &lt; len(edges): # Since we might have multiple edges at same x, # Let the &#x27;curr_x&#x27; be the current position. curr_x = edges[idx][0] # While we are handling the edges at &#x27;curr_x&#x27;: while idx &lt; len(edges) and edges[idx][0] == curr_x: height = edges[idx][1] # If &#x27;height&#x27; &gt; 0, meaning a building of height &#x27;height&#x27; # is live, push &#x27;height&#x27; to &#x27;live&#x27;. # Otherwise, a building of height &#x27;height&#x27; is passed, # push the height to &#x27;past&#x27;. if height &gt; 0: heapq.heappush(live, -height) else: heapq.heappush(past, height) idx += 1 # While the top height from &#x27;live&#x27; equals to that from &#x27;past&#x27;, # Remove top height from both &#x27;live&#x27; and &#x27;past&#x27;. while past and past[0] == live[0]: heapq.heappop(live) heapq.heappop(past) # Get the maximum height from &#x27;live&#x27;. max_height = -live[0] if live else 0 # If the height changes at &#x27;curr_x&#x27;, we add this # skyline key point [curr_x, max_height] to &#x27;answer&#x27;. if not answer or answer[-1][1] != max_height: answer.append([curr_x, max_height]) # Return &#x27;answer&#x27; as the skyline. return answer"},{"title":"189. Rotate Array(medium)","path":"2022/09/29/189/","text":"189. Rotate Array(medium)Given an array, rotate the array to the right by k steps, where k is non-negative.123456Input: nums = [1,2,3,4,5,6,7], k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 这道题其实不像是rotate，意思是把最后一个数不断的移到第一位，就跟开火车似的。把这个数组分成两部分，Part1[P1] 和 Part2[P2]举个例子：[P1] 是最后三位数字之前的数字，[1,2,3,4][P2] 是我们要翻转的数字 [5,6,7]然后分别把P1 和P2前后调转P1=[4321]P2=[765]这样整个数组就是[4321765]将最后三位与前三位互换位置就是[5,6,7,1,2,3,4][P1] is defined as the array part just before the last 3 values. What I mean is something like [1,2,3,4][P2] is defined as the array part just after remaining values which we have to rotate [5,6,7] 但是这里根据K有不同的情况，比如说k = 101, 就是说K大于整个数组长度了，但我们不需要翻转数组101次，利用K对数组长度求余就行，因为转过7次以后就是 [1,2,3,4,5,6,7] 123456789101112131415161718192021222324class Solution: def reverse (self, nums, i, j) : li = i ri = j while li &lt; ri: temp = nums[li] nums[li] = nums[ri] nums[ri] = temp li += 1 ri -= 1 def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; k = k % len(nums) if k &lt; 0 : k += len(nums) self.reverse(nums, 0, len(nums) - k - 1); self.reverse(nums, len(nums) - k, len(nums) - 1); self.reverse(nums, 0, len(nums) - 1);"},{"title":"622. Design Circular Queue(medium)","path":"2022/09/25/622/","text":"622. Design Circular Queue(medium)Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called “Ring Buffer”.One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.Implementation the MyCircularQueue class:MyCircularQueue(k) Initializes the object with the size of the queue to be k.int Front() Gets the front item from the queue. If the queue is empty, return -1.int Rear() Gets the last item from the queue. If the queue is empty, return -1.boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.boolean isEmpty() Checks whether the circular queue is empty or not.boolean isFull() Checks whether the circular queue is full or not. You must solve the problem without using the built-in queue data structure in your programming language.1234567891011121314151617Input[&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;][[3], [1], [2], [3], [4], [], [], [], [4], []]Output[null, true, true, true, false, 3, true, true, true, 4]ExplanationMyCircularQueue myCircularQueue = new MyCircularQueue(3);myCircularQueue.enQueue(1); // return TruemyCircularQueue.enQueue(2); // return TruemyCircularQueue.enQueue(3); // return TruemyCircularQueue.enQueue(4); // return FalsemyCircularQueue.Rear(); // return 3myCircularQueue.isFull(); // return TruemyCircularQueue.deQueue(); // return TruemyCircularQueue.enQueue(4); // return TruemyCircularQueue.Rear(); // return 4 循环队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。 在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是front=（rear+1)%MaxSize。 Solution对于一个固定大小的数组，只要知道队尾 rear 与队首 front，即可计算出队列当前的长度：front=（rear+1)%capacity 循环队列的属性如下:elements：一个固定大小的数组，用于保存循环队列的元素。capacity：循环队列的容量，即队列中最多可以容纳的元素数量。front：队列首元素对应的数组的索引。rear：队列尾元素对应的索引的下一个索引。循环队列的接口方法如下： MyCircularQueue(int k): 初始化队列，同时base 数组的空间初始化大小为 k + 1。front,rear 全部初始化为 0。enQueue(int value)：在队列的尾部插入一个元素，并同时将队尾的索引 rear 更新为 (rear+1)%capacity。deQueue()：从队首取出一个元素，并同时将队首的索引 front 更新为 (front+1)% capacity。Front()：返回队首的元素，需要检测队列是否为空。Rear()：返回队尾的元素，需要检测队列是否为空。isEmpty()：检测队列是否为空，根据之前的定义只需判断 rear 是否等于 front。isFull()：检测队列是否已满，根据之前的定义只需判断 front 是否等于 (rear+1)% capacity。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyCircularQueue: def __init__(self, k: int): self.front=self.rear=0 self.elements=[0]*(k+1) def enQueue(self, value: int) -&gt; bool: if self.isFull(): return False self.elements[self.rear]=value self.rear=(self.rear+1)%len(self.elements) return True def deQueue(self) -&gt; bool: if self.isEmpty(): return False self.front=(self.front+1)%len(self.elements) return True def Front(self) -&gt; int: return -1 if self.isEmpty() else self.elements[self.front] def Rear(self) -&gt; int: return -1 if self.isEmpty() else self.elements[(self.rear - 1) % len(self.elements)] def isEmpty(self) -&gt; bool: return self.rear==self.front def isFull(self) -&gt; bool: return (self.rear+1)%len(self.elements)==self.front # Your MyCircularQueue object will be instantiated and called as such:# obj = MyCircularQueue(k)# param_1 = obj.enQueue(value)# param_2 = obj.deQueue()# param_3 = obj.Front()# param_4 = obj.Rear()# param_5 = obj.isEmpty()# param_6 = obj.isFull()"},{"title":"1002. Find Common Characters(easy)","path":"2022/09/25/1002/","text":"1002. Find Common Characters(easy)Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.12Input: words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 这个就是利用hashmap判断数量和是否存在，然后用&amp;=判断相同值 123456class Solution: def commonChars(self, words: List[str]) -&gt; List[str]: res = collections.Counter(words[0]) for word in words: res &amp;=collections.Counter(word) return list(res.elements())"},{"title":"1081. Smallest Subsequence of Distinct Characters(medium)","path":"2022/09/24/1081/","text":"1081. Smallest Subsequence of Distinct Characters(medium)Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.相似题型316. 去除重复字母(困难)321. 拼接最大数(困难)402. 移掉 K 位数字(中等)1081. 不同字符的最小子序列（中等） Solution这题和316一模一样，代码不需要更改 class Solution: def smallestSubsequence(self, s: str) -&gt; str: stack=[] remain_counter=collections.Counter(s) for c in s: if c not in stack: while stack and c&lt;stack[-1] and remain_counter[stack[-1]]&gt;0: stack.pop() stack.append(c) remain_counter[c]-=1 return &#39;&#39;.join(stack)"},{"title":"321. Create Maximum Number(hard)","path":"2022/09/24/321/","text":"321. Create Maximum Number(hard)You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.Return an array of the k digits representing the answer.相似题型316. 去除重复字母(困难)321. 拼接最大数(困难)402. 移掉 K 位数字(中等)1081. 不同字符的最小子序列（中等） 12Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5Output: [9,8,6,5,3] Solution前置知识 分治 数学思路和316. 去除重复字母 类似，只不不过这一次是两个数组，而不是一个，并且是求最大数。 最大最小是无关紧要的，关键在于是两个数组，并且要求从两个数组选取的元素个数加起来一共是 k。 然而在一个数组中取 k 个数字，并保持其最小（或者最大），我们已经会了。但是如果问题扩展到两个，会有什么变化呢？ 实际上，问题本质并没有发生变化。 假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 = k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。 假如 k1 和 k2 个数字，已经取出来了。那么剩下要做的就是将这个长度分别为 k1 和 k2 的数字，合并成一个长度为 k 的数组合并成一个最大的数组。 以题目的 nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 为例。 假如我们从 num1 中取出 1 个数字，那么就要从 nums2 中取出 4 个数字。 运用第一题的方法，我们计算出应该取 nums1 的 [6]，并取 nums2 的 [9,5,8,3]。 如何将 [6] 和 [9,5,8,3]，使得数字尽可能大，并且保持相对位置不变呢？ 实际上这个过程有点类似归并排序中的治，而上面我们分别计算 num1 和 num2 的最大数的过程类似归并排序中的分。 我们将从 num1 中挑选的 k1 个数组成的数组称之为 A，将从 num2 中挑选的 k2 个数组成的数组称之为 B， 1234567def merge(A, B): ans = [] while A or B: bigger = A if A &gt; B else B ans.append(bigger[0]) bigger.pop(0) return ans 这里需要说明一下。 在很多编程语言中：如果 A 和 B 是两个数组，当前仅当 A 的首个元素字典序大于 B 的首个元素，A &gt; B 返回 true，否则返回 false。 比如： 1234567A = [1,2]B = [2]A &lt; B # TrueA = [1,2]B = [1,2,3]A &lt; B # False 具体算法：从 nums1 中 取 min(i, len(nums1)) 个数形成新的数组 A（取的逻辑同第一题），其中 i 等于 0,1,2, … k。从 nums2 中 对应取 min(j, len(nums2)) 个数形成新的数组 B（取的逻辑同第一题），其中 j 等于 k - i。将 A 和 B 按照上面的 merge 方法合并上面我们暴力了 k 种组合情况，我们只需要将 k 种情况取出最大值即可。 1234567891011121314151617181920212223class Solution: def maxNumber(self, nums1, nums2, k): def pick_max(nums, k): stack = [] drop = len(nums) - k for num in nums: while drop and stack and stack[-1] &lt; num: stack.pop() drop -= 1 stack.append(num) return stack[:k] def merge(A, B): ans = [] while A or B: bigger = A if A &gt; B else B ans.append(bigger[0]) bigger.pop(0) return ans return max(merge(pick_max(nums1, i), pick_max(nums2, k-i)) for i in range(k+1) if i &lt;= len(nums1) and k-i &lt;= len(nums2)) 复杂度分析时间复杂度：pick_max 的时间复杂度为 O(M + N)O(M+N) ，其中 MM 为 nums1 的长度，NN 为 nums2 的长度。 merge 的时间复杂度为 O(k)O(k)，再加上外层遍历所有的 k 中可能性。因此总的时间复杂度为 O(k^2 * (M + N))O(k^2 ∗(M+N))。空间复杂度：我们使用了额外的 stack 和 ans 数组，因此空间复杂度为 O(max(M, N, k))，其中 MM 为 nums1 的长度，NN 为 nums2 的长度。"},{"title":"316. Remove Duplicate Letters","path":"2022/09/24/316/","text":"316. Remove Duplicate Letters(medium)Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.12Input: s = &quot;bcabc&quot;Output: &quot;abc&quot; 相似题型316. 去除重复字母(困难)321. 拼接最大数(困难)402. 移掉 K 位数字(中等)1081. 不同字符的最小子序列（中等） 这道题和402. 移掉 K 位数字(中等)差不多，也是利用栈的特性减少时间复杂度 Solution函数哈希表在python中可以用collections.Counter计数来体现。该方法用于统计某序列中每个元素出现的次数，以键值对的方式存在字典中。但类型其实是Counter。 12345nums = [1, 2, 3, 1, 2, 1]counts = collections.Counter(nums)print(counts)## Counter(&#123;1: 3, 2: 2, 3: 1&#125;) 凭借这个结构，可以计算出某个序列中出现次数最多的某个元素。也即在得到了counts之后求max即可。但这个max需要给依据索引。 12print(max(counts)) # 3，这里只是求得最大的键值print(max(counts.keys(), key=counts.get)) # 1，这里是按照key方法求最大 这里max是两个参数，前一个代表要max的是什么，也就是要返回最大键，后面的key代表要返回的最大的依据是什么，默认是本身，但这里给了key方法，count.get也就是求值，所以该方法就是说返回一个最大键，但这个最大的依据是值。如果某个键值对的值是最大的，那就返回其键。 12dic = dict(counts)print(dic.get(1)) # 4 get在字典中就是传一个键，根据键求对应的值。 前面是一种理解，但max的两个参数也可以理解为key后面的方法是要将前面的第一个参数作为参数，也就是counts.keys()要作为counts.get的参数，然后求max。即get键对应的值，然后返回最大的值对应的键（感觉python中存在很多这种情况，比如lambda表达式，后面也是传一个func来将前面的参数带入） 前置知识字典序数学思路与上面题目不同，这道题没有一个全局的删除次数 k。而是对于每一个在字符串 s 中出现的字母 c 都有一个 k 值。这个 k 是 c 出现次数 - 1。 沿用上面的知识的话，我们首先要做的就是计算每一个字符的 k，可以用一个字典来描述这种关系，其中 key 为 字符 c，value 为其出现的次数。 具体算法：建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1.对于每一个字符，如果其对应的剩余出现次数大于 1，我们可以选择丢弃（也可以选择不丢弃），否则不可以丢弃。是否丢弃的标准和上面题目类似。如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。还记得上面题目的边界条件么？如果栈中剩下的元素大于 n - kn−k，我们选择截取前 n - kn−k 个数字。然而本题中的 k 是分散在各个字符中的，因此这种思路不可行的。 不过不必担心。由于题目是要求只出现一次。我们可以在遍历的时候简单地判断其是否在栈上即可。 123456789101112class Solution: def removeDuplicateLetters(self, s) -&gt; int: stack = [] remain_counter = collections.Counter(s) for c in s: if c not in stack: while stack and c &lt; stack[-1] and remain_counter[stack[-1]] &gt; 0: stack.pop() stack.append(c) remain_counter[c] -= 1 return &#x27;&#x27;.join(stack) 复杂度分析 时间复杂度：由于判断当前字符是否在栈上存在需要 O(N)的时间，因此总的时间复杂度就是 O(N^2)，其中 N 为字符串长度。空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 O(N)，其中 N 为字符串长度。 优化：利用hashset空间换时间 123456789101112131415class Solution: def removeDuplicateLetters(self, s) -&gt; int: stack = [] seen = set() remain_counter = collections.Counter(s) for c in s: if c not in seen: while stack and c &lt; stack[-1] and remain_counter[stack[-1]] &gt; 0: seen.discard(stack.pop()) seen.add(c) stack.append(c) remain_counter[c] -= 1 return &#x27;&#x27;.join(stack) 复杂度分析 时间复杂度：O(N)，其中 N 为字符串长度。空间复杂度：我们使用了额外的栈和 hashset，因此空间复杂度为 O(N)，其中 N 为字符串长度。"},{"title":"985. Sum of Even Numbers After Queries(medium)","path":"2022/09/21/985/","text":"985. Sum of Even Numbers After Queries(medium)You are given an integer array nums and an array queries where queries[i] = [vali, indexi].For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.Return an integer array answer where answer[i] is the answer to the ith query.1234567Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]Output: [8,6,2,4]Explanation: At the beginning, the array is [1,2,3,4].After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. 这道题的思路很有特点，维护一个数组，先把原数组的偶数和求出来，接下来根据queries不断调整 S，即每一步操作之后整个数组的偶数和。操作数组中的某一个元素 A[index] 的时候，数组 A 其他位置的元素都应保持不变。如果 A[index] 是偶数，我们就从 S 中减去它，然后计算 A[index] + val 对 S 的影响（如果是偶数则在 S 中加上它）。相当于再计算前先把这个value减去（如果是偶数），算上新加入的index再计算对整个和的影响（如果是偶数） 123456789101112131415class Solution: def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -&gt; List[int]: even_sum=0 for num in nums: if num%2==0: even_sum+=num ans=[] for val,i in queries: if nums[i]%2==0: even_sum-=nums[i] nums[i]+=val if nums[i]%2==0: even_sum+=nums[i] ans.append(even_sum) return ans"},{"title":"402. Remove K Digits(medium)","path":"2022/09/21/402/","text":"402. Remove K Digits(medium)Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.相似题型316. 去除重复字母(困难)321. 拼接最大数(困难)402. 移掉 K 位数字(中等)1081. 不同字符的最小子序列（中等） 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意:num 的长度小于 10002 且 ≥ k。num 不会包含任何前导零。 123456789101112131415示例 1 :输入: num = &quot;1432219&quot;, k = 3输出: &quot;1219&quot;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。示例 2 :输入: num = &quot;10200&quot;, k = 1输出: &quot;200&quot;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。示例 3 :输入: num = &quot;10&quot;, k = 2输出: &quot;0&quot;解释: 从原数字移除所有的数字，剩余为空就是 0。 函数 1231. strip():- This method is used to delete all the leading and trailing characters mentioned in its argument.2. lstrip():- This method is used to delete all the leading characters mentioned in its argument.3. rstrip():- This method is used to delete all the trailing characters mentioned in its argument. 123456789101112131415161718# Python code to demonstrate working of# strip(), lstrip() and rstrip()str = &quot;---geeksforgeeks---&quot;# using strip() to delete all &#x27;-&#x27;print ( &quot; String after stripping all &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.strip(&#x27;-&#x27;) )# String after stripping all &#x27;-&#x27; is : geeksforgeeks# using lstrip() to delete all trailing &#x27;-&#x27;print ( &quot; String after stripping all leading &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.lstrip(&#x27;-&#x27;) )# String after stripping all leading &#x27;-&#x27; is : geeksforgeeks---# using rstrip() to delete all leading &#x27;-&#x27;print ( &quot; String after stripping all trailing &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.rstrip(&#x27;-&#x27;) )# String after stripping all trailing &#x27;-&#x27; is : ---geeksforgeeks Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence) sequence – 要连接的元素序列。 12345s1 = &quot;-&quot;s2 = &quot;&quot;seq = (&quot;r&quot;, &quot;u&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;b&quot;) # 字符串序列print (s1.join( seq )) #r-u-n-o-o-bprint (s2.join( seq )) #runoob 123456or &#x27;0&#x27;类似于if 判断if variable_1: x = variable_1else: x = 0 Solution因此我们的思路就是： 从左到右遍历对于遍历到的元素，我们选择保留。但是我们可以选择性丢弃前面相邻的元素。丢弃与否的依据如上面的前置知识中阐述中的方法。 然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远选择不丢弃。这个题目中要求的，我们要永远确保丢弃 k 个矛盾。 一个简单的思路就是： 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。 我们需要把思路逆转过来。刚才我的关注点一直是丢弃，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 n - kn−k 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前n - k个元素即可。 按照上面的思路，我们来选择数据结构。由于我们需要保留和丢弃相邻的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现。 12345678910class Solution: def removeKdigits(self, num: str, k: int) -&gt; str: stack=[] remain= len(num)-k for digit in num: while k and stack and stack[-1]&gt;digit: stack.pop() k-=1 stack.append(digit) return &#x27;&#x27;.join(stack[:remain]).lstrip(&#x27;0&#x27;) or &#x27;0&#x27;"},{"title":"718","path":"2022/09/21/718/","text":""},{"title":"739. Daily Temperatures(medium)","path":"2022/09/20/739/","text":"739. Daily Temperatures(medium)Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.单调栈可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。 正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。 为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 temperatures[i] 一定是 temperatures[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。 由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。 以下用一个具体的例子帮助读者理解单调栈。对于温度列表 [73,74,75,71,69,72,76,73]，单调栈 stack 的初始状态为空，答案 ans 的初始状态是 [0,0,0,0,0,0,0,0]，按照以下步骤更新单调栈和答案，其中单调栈内的元素都是下标，括号内的数字表示下标在温度列表中对应的温度。 123456789101112class Solution: def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]: length = len(temperatures) ans = [0] * length stack = [] for i in range(length): temperature = temperatures[i] while stack and temperature &gt; temperatures[stack[-1]]: prev_index = stack.pop() ans[prev_index] = i - prev_index stack.append(i) return ans KMP 这是评论里的解法，相对更好理解一些 1234567891011121314class Solution: def dailyTemperatures(self, T: List[int]) -&gt; List[int]: n=len(T) ans=[0]*n for i in range(n-2,-1,-1): now=i+1 while T[now]&lt;=T[i]: if ans[now]: now+=ans[now] else: break else: ans[i]=now-i return ans"},{"title":"496. Next Greater Element I(easy)","path":"2022/09/20/496/","text":"496. Next Greater Element I(easy)The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2]Output: [-1,3,-1]Explanation: The next greater element for each value of nums1 is as follows:- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. 单调栈 + 哈希表思路 我们可以先预处理 nums2 ，使查询 nums1中的每个元素在 nums2中对应位置的右边的第一个更大的元素值时不需要再遍历 nums2。于是，我们将题目分解为两个子问题： 第 1 个子问题：如何更高效地计算 nums2中每个元素右边的第一个更大的值； 第 2 个子问题：如何存储第 1 个子问题的结果。 算法 我们可以使用单调栈来解决第 1 个子问题。倒序遍历 nums2，并用单调栈中维护当前位置右边的更大的元素列表，从栈底到栈顶的元素是单调递减的。 具体地，每次我们移动到数组中一个新的位置 i，就将当前单调栈中所有小于 nums2[i]的元素弹出单调栈，当前位置右边的第一个更大的元素即为栈顶元素，如果栈为空则说明当前位置右边没有更大的元素。随后我们将位置 i 的元素入栈。 可以结合以下例子来理解。 因为题目规定了 nums2是没有重复元素的，所以我们可以使用哈希表来解决第 22 个子问题，将元素值与其右边第一个更大的元素值的对应关系存入哈希表。 细节 因为在这道题中我们只需要用到 nums2中元素的顺序而不需要用到下标，所以栈中直接存储 nums2中元素的值即可。 1234567891011class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: res = &#123;&#125; stack = [] for num in reversed(nums2): while stack and num &gt;= stack[-1]: stack.pop() res[num] = stack[-1] if stack else -1 stack.append(num) return [res[num] for num in nums1]"},{"title":"380. Insert Delete GetRandom O(1)(medium)","path":"2022/09/13/380/","text":"380. Insert Delete GetRandom O(1)(medium)Implement the RandomizedSet class:RandomizedSet() Initializes the RandomizedSet object.bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.int getRandom() Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity.123456789101112131415Input[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;][[], [1], [2], [2], [], [1], [2], []]Output[null, true, false, true, 2, true, false, 2]ExplanationRandomizedSet randomizedSet = new RandomizedSet();randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.randomizedSet.remove(2); // Returns false as 2 does not exist in the set.randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].randomizedSet.insert(2); // 2 was already in the set, so return false.randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Solution本题的难点在于两点： 1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)。 2、getRandom 方法返回的元素必须等概率返回随机元素，也就是说，如果集合里面有 n 个元素，每个元素被返回的概率必须是 1/n。 我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？ HashSet 肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。 那么请问对于这样一个标准的 HashSet，你能否在 O(1) 的时间内实现 getRandom 函数？ 其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，所以做不到 O(1) 时间「等概率」随机获取元素。 除了 HashSet，还有一些类似的数据结构，比如哈希链表 LinkedHashSet，我们后文 手把手实现LRU算法 和 手把手实现LFU算法 讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中。 但是，LinkedHashSet 只是给 HashSet 增加了有序性，依然无法按要求实现我们的 getRandom 函数，因为底层用链表结构存储元素的话，是无法在 O(1) 的时间内访问某一个元素的。 根据上面的分析，对于 getRandom 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：底层用数组实现，且数组必须是紧凑的。 这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。 但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢？ 可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。 所以，如果我们想在 O(1) 的时间删除数组中的某一个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。 交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 valToIndex 来记录每个元素值对应的索引。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class RandomizedSet: def __init__(self): # 存储元素的值 self.nums=[] # 记录每个元素对应在 nums 中的索引 self.valToIndex=&#123;&#125; def insert(self, val: int) -&gt; bool: #若 val 已存在，不用再插入 if val in self.valToIndex: return False #若 val 不存在，插入到 nums 尾部， #并记录 val 对应的索引值 self.valToIndex[val]=len(self.nums) self.nums.append(val) return True def remove(self, val: int) -&gt; bool: #若 val 不存在，不用再删除 if val not in self.valToIndex: return False #先拿到 val 的索引 index= self.valToIndex[val] #将最后一个元素对应的索引修改为 index self.nums[index]=self.nums[-1] #交换 val 和最后一个元素 self.valToIndex[self.nums[index]]=index #在数组中删除元素 val self.nums.pop() #删除元素 val 对应的索引(hashmap) del self.valToIndex[val] return True def getRandom(self) -&gt; int: # 随机获取 nums 中的一个元素 return choice(self.nums) # Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()"},{"title":"647. Palindromic Substrings(medium)","path":"2022/09/13/647/","text":"647. Palindromic Substrings(medium)Given a string s, return the number of palindromic substrings in it.A string is a palindrome when it reads the same backward as forward.A substring is a contiguous sequence of characters within the string.123456789class Solution: def countSubstrings(self, s: str) -&gt; int: L, r = len(s), 0 for i in range(L): for a,b in [(i,i),(i,i+1)]: while a &gt;= 0 and b &lt; L and s[a] == s[b]: a -= 1; b += 1 r += (b-a)//2 return r"},{"title":"870. Advantage Shuffle(medium)","path":"2022/09/12/870/","text":"870. Advantage Shuffle(medium)You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] &gt; nums2[i].Return any permutation of nums1 that maximizes its advantage with respect to nums2.12Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]Output: [2,11,7,15] 12Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]Output: [2,11,7,15] 类似于田忌赛马的故事，排序nums2使得nums2比nums1有优势 Solution按照上面的思路，可以考虑贪心的思维模式。 首先需要将nums2按照[value,index]的模式加入保存至数组中，最终按照value值逆序生成一个二维数组之后对nums1进行排序分配left、right指针指向nums1的头尾节点创建一个长度为nums1的初始化数组ret，开始循环二维数组按照上面的思路如果right节点比nums2当前的下表数字大，那就是强强对碰，正面硬刚如果不敌则用left节点的小兵以次充好不论1、2如何选择，都将left或right对应的num，根据二维数组的index将value保存至ret数组最终返回ret数组即可 1234567891011121314151617181920212223class Solution(object): def advantageCount(self, A, B): sortedA = sorted(A) sortedB = sorted(B) # assigned[b] = list of a that are assigned to beat b # remaining = list of a that are not assigned to any b assigned = &#123;b: [] for b in B&#125; remaining = [] # populate (assigned, remaining) appropriately # sortedB[j] is always the smallest unassigned element in B j = 0 for a in sortedA: if a &gt; sortedB[j]: assigned[sortedB[j]].append(a) j += 1 else: remaining.append(a) # Reconstruct the answer from annotations (assigned, remaining) return [assigned[b].pop() if assigned[b] else remaining.pop() for b in B]"},{"title":"528. Random Pick with Weight(medium)","path":"2022/09/12/528/","text":"528. Random Pick with Weight(medium)You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).前缀和数组加二分搜索的题目 Solution1234567891011121314class Solution: def __init__(self, w: List[int]): self.pre = list(accumulate(w)) self.total = sum(w) def pickIndex(self) -&gt; int: x = random.randint(1, self.total) return bisect_left(self.pre, x) # Your Solution object will be instantiated and called as such:# obj = Solution(w)# param_1 = obj.pickIndex()"},{"title":"567. Permutation in String(medium)","path":"2022/09/11/567/","text":"567. Permutation in String(medium)Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.In other words, return true if one of s1’s permutations is the substring of s2."},{"title":"1356. Sort Integers by The Number of 1 Bits(easy)","path":"2022/09/11/1356/","text":"1356. Sort Integers by The Number of 1 Bits(easy)You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order.Return the array after sorting it.1234567Input: arr = [0,1,2,3,4,5,6,7,8]Output: [0,1,2,4,8,3,5,6,7]Explantion: [0] is the only integer with 0 bits.[1,2,4,8] all have 1 bit.[3,5,6] have 2 bits.[7] has 3 bits.The sorted array by bits is [0,1,2,4,8,3,5,6,7] Solutionclass Solution: def sortByBits(self, arr: List[int]) -&gt; List[int]: return sorted(arr, key = lambda num : (sum((num &gt;&gt; i) &amp; 1 for i in range(32)), num))"},{"title":"76. Minimum Window Substring(hard)","path":"2022/09/11/76/","text":"76. Minimum Window Substring(hard)Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string “”.The testcases will be generated such that the answer is unique.A substring is a contiguous sequence of characters within the string.这道题是滑动窗口的经典题目，滑动窗口算法的思路是这样： 我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。 PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。 我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。 下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和「窗口」中的相应字符的出现次数。 C++解法12345678910111213141516171819202122232425262728293031323334353637383940414243string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引及长度 int start = 0, len = INT_MAX; while (right &lt; s.size()) &#123; // c 是将移入窗口的字符 char c = s[right]; // 扩大窗口 right++; // 进行窗口内数据的一系列更新 if (need.count(c)) &#123; window[c]++; if (window[c] == need[c]) valid++; &#125; // 判断左侧窗口是否要收缩 while (valid == need.size()) &#123; // 在这里更新最小覆盖子串 if (right - left &lt; len) &#123; start = left; len = right - left; &#125; // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 if (need.count(d)) &#123; if (window[d] == need[d]) valid--; window[d]--; &#125; &#125; &#125; // 返回最小覆盖子串 return len == INT_MAX ? &quot;&quot; : s.substr(start, len);&#125; python解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def minWindow(self, s: str, t: str) -&gt; str: # hash table to store the required char frequency need = collections.Counter(t) # total character count we need to care about missing = len(t) # windowStart and windowEnd to be windowStart, windowEnd = 0, 0 i = 0 # iterate over s starting over index 1 for j, char in enumerate(s, 1): # j is index,char is value # if char is required then decrease missing if need[char] &gt; 0: missing -= 1 # decrease the freq of char from need (maybe be negative - which basically denotes # that we have few extra characters which are not required but present in between current window) need[char] -= 1 # we found a valid window if missing == 0: # chars from start to find the real windowStart while i &lt; j and need[s[i]] &lt; 0: need[s[i]] += 1 i += 1 # if it&#x27;s only one char case or curr window is smaller, then update window if windowEnd == 0 or j-i &lt; windowEnd-windowStart: windowStart, windowEnd = i, j # now resetting the window to make it invalid # sure the first appearing char satisfies need[char]&gt;0 need[s[i]] += 1 # missed this first char, so add missing by 1 missing += 1 #update i to windowStart+1 for next window i += 1 return s[windowStart:windowEnd]"},{"title":"LeetCode-skill8-two_pointers","path":"2022/09/11/LeetCode-skill8-two-pointers/","text":"[滑动窗口框架python：](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/ Longest Substring Without Repeating Characters(medium) 1234567891011121314151617181920from collections import defaultdictclass Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: lookup=defaultdict(int) start=0 end=0 max_len=0 counter=0 while end&lt;len(s): if lookup[s[end]]&gt;0: counter+=1 lookup[s[end]]+=1 end+=1 while counter&gt;0: if lookup[s[start]]&gt;1: counter-=1 lookup[s[start]]-=1 start+=1 max_len=max(max_len,end-start) return max_len Minimum Window Substring(hard) 1234567891011121314151617181920212223242526class Solution: def minWindow(self, s: &#x27;str&#x27;, t: &#x27;str&#x27;) -&gt; &#x27;str&#x27;: from collections import defaultdict lookup = defaultdict(int) for c in t: lookup[c] += 1 start = 0 end = 0 min_len = float(&quot;inf&quot;) counter = len(t) res = &quot;&quot; while end &lt; len(s): if lookup[s[end]] &gt; 0: counter -= 1 lookup[s[end]] -= 1 end += 1 while counter == 0: if min_len &gt; end - start: min_len = end - start res = s[start:end] if lookup[s[start]] == 0: counter += 1 lookup[s[start]] += 1 start += 1 return res 12345678910111213141516171819202122232425262728/* 滑动窗口算法框架 */void slidingWindow(string s) &#123; unordered_map&lt;char, int&gt; window; int left = 0, right = 0; while (right &lt; s.size()) &#123; // c 是将移入窗口的字符 char c = s[right]; // 增大窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(&quot;window: [%d, %d)\\n&quot;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) &#123; // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 ... &#125; &#125;&#125; 1234567891011121314151617181920212223def slidingWindow(string s): window=&#123;&#125; int left = 0, right = 0 while right&lt;len(s): #c 是将移入窗口的字符 c=s[right] # 增大窗口 right+=1 # 进行窗口内数据的一系列更新 ... #*** debug 输出的位置 ***/ print(&quot;window: [%d, %d)\\n&quot;, left, right) #********************/ # 判断左侧窗口是否要收缩 while (window needs shrink) #d 是将移出窗口的字符 d = s[left] #缩小窗口 left+=1 #进行窗口内数据的一系列更新 ..."},{"title":"1360. Number of Days Between Two Dates","path":"2022/09/09/1360/","text":"1360. Number of Days Between Two Dates(easy)Write a program to count the number of days between two dates.The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.12Input: date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;Output: 1 官方题解:When m=1 or m=2 (January or February), we let m=13 or m=14 and let y decreased by 1. Imagine it is 13th or 14th month of the last year. By doing that, we let the magical formula also work for those two months. (153 * m + 8) // 5 is just a carefully designed way to record the days of each month. More specifically, it is designed to record the difference of days between two months. Suppose we have March 1st and April 1st, (153 * 3 + 8) // 5 = 93 while (153 * 4 + 8) // 5 = 124, the difference is 31 which is the number of days in March. Suppose we have April 1st to May 1st, (153 * 4 + 8) // 5 = 124 and (153 * 5 + 8) // 5 = 154, the difference is now 30 which is the number of days in April. You can also check other months. I learned this formula somewhere else before. It is not something to come up with in minutes.首先把1月2月加12当作13和14月，这样使得他们也可以套用公式这里有一个关键的函数(153 * m + 8) // 5，通过前后月代入以后的相减，可以区分不同月份的长度，确实是非常神奇 12345678910class Solution: def daysBetweenDates(self, date1: str, date2: str) -&gt; int: def f(date): y, m, d = map(int, date.split(&#x27;-&#x27;)) if m &lt; 3: m += 12 y -= 1 return 365 * y + y // 4 + y // 400 - y // 100 + d + (153 * m + 8) // 5 return abs(f(date1) - f(date2))"},{"title":"practicecodesignal4","path":"2022/09/05/practicecodesignal4/","text":"def samesign(a,b): if a/abs(a) == b/abs(b): return True else: return False def countSawSubarrays(arr): n = len(arr) if n&lt;2: return 0 s = 0 e = 1 count = 0 while(e&lt;n): sign = arr[e] - arr[s] while(e&lt;n and arr[e] != arr[e-1] and samesign(arr[e] - arr[e-1], sign)): sign = -1*sign e+=1 size = e-s if (size==1): e+=1 count += (size*(size-1))//2 s = e-1 e = s+1 return count arr1 = [9,8,7,6,5]print(countSawSubarrays(arr1))arr2 = [1,2,1,3,4,-2]print(countSawSubarrays(arr2))arr3 = [1,2,1,2,1]print(countSawSubarrays(arr3))arr4 = [10,10,10]print(countSawSubarrays(arr4)) def solution(matrix, a, b): if a + b - 1 &gt; min(len(matrix), len(matrix[0])): return 0 ret = 0 for w, h in ((a, b), (b, a)): # for every possible leftmost axb/bxa rectangle... for start in range(min(len(matrix), len(matrix[0])) - (a + b - 1) + 1): i = start cur = 0 deques = [] j1 = j2 = w - 1 # build the rectangle while j1 &lt;= j2: for k in range(j1, j2 + 1): cur += matrix[i][k] deques.append((j1, j2)) j1 += (-1 if i - start &lt; w - 1 else 1) j2 += (1 if i - start &lt; h - 1 else -1) i += 1 stop = False # slide it to the right until you can&#39;t anymore while True: ret = max(ret, cur) for ind, tup in enumerate(deques): j1, j2 = tup i = start + ind if j2 == len(matrix[0]) - 1: stop = True break j2 += 1 cur += matrix[i][j2] - matrix[i][j1] j1 += 1 deques[ind] = (j1, j2) if stop: break return ret You are given an array of integers numbers and two integers left and right. You task is to calculate a boolean array result, where result[i] = true if there exists an integer x, such that numbers[i] = (i + 1) * x and left ≤ x ≤ right. Otherwise, result[i] should be set to false. You are given two strings - pattern and source. The first string pattern contains only the symbols 0 and 1, and the second string source contains only lowercase English letters. Let’s say that pattern matches a substring source[l..r] of source if the following three conditions are met:they have equal length,for each 0 in pattern the corresponding letter in the substring is a vowel,for each 1 in pattern the corresponding letter is a consonant.Your task is to calculate the number of substrings of source that match pattern. Note: In this task we define the vowels as ‘a’, ‘e’, ‘i’, ‘o’, ‘u’, and ‘y’. All other letters are consonants. Given a matrix of integers, we’d like to consider the sum of the elements within the area of a 45° rotated rectangle. More formally, the area is bounded by two diagonals parallel to the main diagonal and two diagonals parallel to the secondary diagonal. The dimensions of the rotated rectangle are defined by the number of elements along the borders of the rectangle. A sawtooth sequence is a sequence of numbers that alternate between increasing and decreasing. In other words, each element is either strictly greater than its neighbouring elements or strictly less than its neighbouring elements."},{"title":"LeetCode-skill7-box_blur","path":"2022/09/03/LeetCode-skill7-box-blur/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980def square_matrix(square): &quot;&quot;&quot; This function will calculate the value x (i.e. blurred pixel value) for each 3 * 3 blur image. &quot;&quot;&quot; tot_sum = 0 # Calculate sum of all the pixels in 3 * 3 matrix for i in range(3): for j in range(3): tot_sum += square[i][j] return tot_sum // 9 # return the average of the sum of pixelsdef boxBlur(image): &quot;&quot;&quot; This function will calculate the blurred image for given n * n image. &quot;&quot;&quot; square = [] # This will store the 3 * 3 matrix # which will be used to find its blurred pixel square_row = [] # This will store one row of a 3 * 3 matrix and # will be appended in square blur_row = [] # Here we will store the resulting blurred # pixels possible in one row # and will append this in the blur_img blur_img = [] # This is the resulting blurred image # number of rows in the given image n_rows = len(image) # number of columns in the given image n_col = len(image[0]) # rp is row pointer and cp is column pointer rp, cp = 0, 0 # This while loop will be used to # calculate all the blurred pixel in the first row while rp &lt;= n_rows - 3: while cp &lt;= n_col-3: for i in range(rp, rp + 3): for j in range(cp, cp + 3): # append all the pixels in a row of 3 * 3 matrix square_row.append(image[i][j]) # append the row in the square i.e. 3 * 3 matrix square.append(square_row) square_row = [] # calculate the blurred pixel for given 3 * 3 matrix # i.e. square and append it in blur_row blur_row.append(square_matrix(square)) square = [] # increase the column pointer cp = cp + 1 # append the blur_row in blur_image blur_img.append(blur_row) blur_row = [] rp = rp + 1 # increase row pointer cp = 0 # start column pointer from 0 again # Return the resulting pixel matrix return blur_img# Driver codeimage = [[7, 4, 0, 1], [5, 6, 2, 2], [6, 10, 7, 8], [1, 4, 2, 0]] print(boxBlur(image))"},{"title":"codesignal-reverseInParentheses","path":"2022/09/02/codesignal-reverseInParentheses/","text":"12345678910111213141516171819202122232425def solution(inputString): &quot;&quot;&quot; Reverse the strings contained in each pair of matching parentheses, starting from the innermost pair. The results string should not contain any parentheses. &gt;&gt;&gt; reverse_parentheses(&#x27;a(bc)de&#x27;) &#x27;acbde&#x27; &gt;&gt;&gt; reverse_parentheses( ... &#x27;The ((quick (brown) (fox) jumps over the lazy) dog)&#x27; ... ) &#x27;The god quick nworb xof jumps over the lazy&#x27; &quot;&quot;&quot; chars = list(inputString) open_bracket_indexes = [] for i, c in enumerate(chars): if c == &#x27;(&#x27;: open_bracket_indexes.append(i) elif c == &#x27;)&#x27;: j = open_bracket_indexes.pop() chars[j:i] = chars[i:j:-1] if open_bracket_indexes: raise ArgumentError(&#x27;Unclosed parenthesis&#x27;) return &#x27;&#x27;.join(c for c in chars if c not in &#x27;()&#x27;)"},{"title":"485. Max Consecutive Ones(easy)","path":"2022/09/01/485/","text":"485. Max Consecutive Ones(easy)Given a binary array nums, return the maximum number of consecutive 1’s in the array.123Input: nums = [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. 这题没什么好说的，比较简单，设置两个独立变量然后遍历就行了 class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: cnt=0 ans=0 for num in nums: if num==1: cnt+=1 ans = max(ans,cnt) elif num==0: cnt=0 return ans"},{"title":"1909. Remove One Element to Make the Array Strictly Increasing(easy)","path":"2022/09/01/1909/","text":"1909. Remove One Element to Make the Array Strictly Increasing(easy)Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.The array nums is strictly increasing if nums[i - 1] &lt; nums[i] for each index (1 &lt;= i &lt; nums.length).1234Input: nums = [1,2,10,5,7]Output: trueExplanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].[1,2,5,7] is strictly increasing, so return true. 1234567891011121314151617181920class Solution: def canBeIncreasing(self, nums: List[int]) -&gt; bool: n = len(nums) # 检查数组 nums 在删去下标为 idx 的元素后是否严格递增 def check(idx: int) -&gt; bool: for i in range(1, n - 1): prev, curr = i - 1, i if prev &gt;= idx: prev += 1 if curr &gt;= idx: curr += 1 if nums[curr] &lt;= nums[prev]: return False return True for i in range(1, n): # 寻找非递增相邻下标对 if nums[i] &lt;= nums[i-1]: return check(i) or check(i - 1) return True 作者：LeetCode-Solution链接：https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution/shan-chu-yi-ge-yuan-su-shi-shu-zu-yan-ge-tnr7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"59. Spiral Matrix II(medium)","path":"2022/08/31/59/","text":"59. Spiral Matrix II(medium)Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.这道题和54. Spiral Matrix(medium)几乎一模一样leetcode官方题解 1234567891011121314151617181920212223242526class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left &lt;= right and top &lt;= bottom: for col in range(left, right + 1): matrix[top][col] = num num += 1 for row in range(top + 1, bottom + 1): matrix[row][right] = num num += 1 if left &lt; right and top &lt; bottom: for col in range(right - 1, left, -1): matrix[bottom][col] = num num += 1 for row in range(bottom, top, -1): matrix[row][left] = num num += 1 left += 1 right -= 1 top += 1 bottom -= 1 return matrix"},{"title":"151. Reverse Words in a String(medium)","path":"2022/08/31/151/","text":"151. Reverse Words in a String(medium)Given an input string s, reverse the order of the words.A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.Return a string of the words in reverse order concatenated by a single space.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.123Input: s = &quot;the sky is blue&quot;Output: &quot;blue is sky the&quot; 官方题解很多语言对字符串提供了 split（拆分），reverse（翻转）和 join（连接）等方法，因此我们可以简单的调用内置的 API 完成操作： 使用 split 将字符串按空格分割成字符串数组；使用 reverse 将字符串数组进行反转；使用 join 方法将字符串数组拼成一个字符串。 Solution123class Solution: def reverseWords(self, s: str) -&gt; str: return &quot; &quot;.join(reversed(s.split())) 复杂度分析 时间复杂度：O(n)O(n)，其中 nn 为输入字符串的长度。 空间复杂度：O(n)O(n)，用来存储字符串分割之后的结果。"},{"title":"54. Spiral Matrix(medium)","path":"2022/08/31/54/","text":"54. Spiral Matrix(medium)Given an m x n matrix, return all elements of the matrix in spiral order.leetcode官方题解方法二：按层模拟可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。 定义矩阵的第 kk 层是到最近边界距离为 kk 的所有顶点。例如，下图矩阵最外层元素都是第 11 层，次外层元素都是第 22 层，剩下的元素都是第 33 层。 12345[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]] 对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于 (bottom,right)，按照如下顺序遍历当前层的元素。 从左到右遍历上侧元素，依次为 (top,left) 到 (top,right)。 从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。 如果 left &lt; right 且 top &lt; bottom，则从右到左遍历下侧元素，依次为 (bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。 遍历完当前层的元素之后，将 left 和 top 分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。 1234567891011121314151617181920class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: if not matrix or not matrix[0]: return list() rows, columns = len(matrix), len(matrix[0]) order = list() left, right, top, bottom = 0, columns - 1, 0, rows - 1 while left &lt;= right and top &lt;= bottom: for column in range(left, right + 1): order.append(matrix[top][column]) for row in range(top + 1, bottom + 1): order.append(matrix[row][right]) if left &lt; right and top &lt; bottom: for column in range(right - 1, left, -1): order.append(matrix[bottom][column]) for row in range(bottom, top, -1): order.append(matrix[row][left]) left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1 return order"},{"title":"36. Valid Sudoku(medium)","path":"2022/08/31/36/","text":"36. Valid Sudoku(medium)Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable.Only the filled cells need to be validated according to the mentioned rules.1234567891011Input: board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true 123456789101112131415161718192021222324252627282930313233class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: N = 9 # Use binary number to check previous occurrence rows = [0] * N cols = [0] * N boxes = [0] * N for r in range(N): for c in range(N): # Check if the position is filled with number if board[r][c] == &quot;.&quot;: continue pos = int(board[r][c]) - 1 # Check the row if rows[r] &amp; (1 &lt;&lt; pos): return False rows[r] |= (1 &lt;&lt; pos) # Check the column if cols[c] &amp; (1 &lt;&lt; pos): return False cols[c] |= (1 &lt;&lt; pos) # Check the box idx = (r // 3) * 3 + c // 3 if boxes[idx] &amp; (1 &lt;&lt; pos): return False boxes[idx] |= (1 &lt;&lt; pos) return True leetcode题解12345678910111213141516class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row = [[0] * 9 for _ in range(9)] col = [[0] * 9 for _ in range(9)] block = [[0] * 9 for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] != &#x27;.&#x27;: num = int(board[i][j]) - 1 b = (i // 3) * 3 + j // 3 if row[i][num] or col[j][num] or block[b][num]: return False row[i][num] = col[j][num] = block[b][num] = 1 return True"},{"title":"48. Rotate Image(medium)","path":"2022/08/30/48/","text":"48. Rotate Image(medium)You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.12Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]Output: [[7,4,1],[8,5,2],[9,6,3]] 这题有一个非常巧妙的用翻转代替旋转的方法，作为例子，$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} \\tag{1}$$先将其通过水平轴翻转得到： $$ \\begin{bmatrix} 7 &amp; 8 &amp; 9 \\ 4 &amp; 5 &amp; 6 \\ 1 &amp; 2 &amp; 3 \\end{bmatrix} \\tag{2}$$ 再根据主对角线翻转得到：$$ \\begin{bmatrix} 7 &amp; 4 &amp; 1 \\ 8 &amp; 5 &amp; 2 \\ 9 &amp; 6 &amp; 3 \\end{bmatrix} \\tag{3}$$ 这样就可以看出来了，clockwise旋转90°就相当于先水平翻转再根据主对角线翻转 官方题解 123456789101112class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix) for i in range(n//2): for j in range(n): matrix[i][j],matrix[n-i-1][j]=matrix[n-i-1][j],matrix[i][j] for i in range(n): for j in range(i): matrix[i][j],matrix[j][i]=matrix[j][i],matrix[i][j]"},{"title":"1094. Car Pooling(medium)","path":"2022/08/30/1094/","text":"1094. Car Pooling(medium)There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car’s initial location.Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.12Input: trips = [[2,1,5],[3,3,7]], capacity = 4Output: false 差分数组经典题 leetcode题解123456789101112131415161718192021222324252627class Solution: def carPooling(self, trips: List[List[int]], capacity: int) -&gt; bool: # 确定最多有几站-&gt;数组长度 stations = 0 for change_list in trips: if change_list[2]+1 &gt; stations: stations = change_list[2] + 1 # 原数组，不接客时每站人数 ori = [0] * stations # 核心步骤1. 构造差分数组 diff = [0] * stations # 核心步骤2. 差分数组记录修改 for cnt, start, end in trips: diff[start] += cnt # diff下标为区间终点+1，因为修改区间为[start, end-1]，所以diff下表为end if end &lt; stations: diff[end] -= cnt # 核心步骤3. 差分数组推出修改后的数组，并判断修改后的数组中是否有超载的 for i in range(stations): if not i: res_i_1 = 0 res_i = res_i_1 + diff[i] # 第i站人数 res_i_1 = res_i if res_i &gt; capacity: return False return True"},{"title":"1109. Corporate Flight Bookings(medium)","path":"2022/08/30/1109/","text":"1109. Corporate Flight Bookings(medium)There are n flights that are labeled from 1 to n.You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.这道题又是一个标准的差分数组题，与370题几乎一模一样，差别在于length是0-4还是1-5 class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]: res = [0]*(n+1) for booking in bookings: start,end,v = booking s=start-1 e=end-1 res[s]+=v res[e+1]-=v for i in range(1,n): res[i] += res[i-1] return res[:-1]"},{"title":"370. Range Addition(medium)","path":"2022/08/30/370/","text":"370. Range Addition(medium)You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], …, arr[endIdxi] by inci.Return arr after applying all the updates.Example12Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]Output: [-2,0,3,5,3] leetcode题解 差分数组经典题目 1234567891011121314class Solution: def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]: res = [0]*length for update in updates: start, end, inc = update res[start]+=inc if end+1&lt;=length -1:#if endIdx + 1 is not out of range. If it is out of range, we don&#x27;t do anything res[end+1]-=inc sum = 0 for i in range(length): sum+= res[i] res[i]=sum return res 其实这个方法并不是差分数组，还是前缀和数组，也就是说差分数组和前缀和数组可以相互替换？ 123456789101112class Solution: def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]: res = [0] * (length + 1) for s, e, v in updates: res[s] += v res[e+1] -= v for i in range(1, length):#加上前面的数字 res[i] += res[i-1] return res[:-1]"},{"title":"LeetCode-skill6-stack","path":"2022/08/30/LeetCode-skill6-stack/","text":"1. 栈的定义栈是一种先进后出（FILO: First In Last Out,）的线性结构，即压栈和弹栈均在栈的尾部完成。压栈：即栈添加成员，在栈的尾部完成弹栈：即栈删除成员，在栈的尾部完成在创建栈时，如果以数组的数据结构为基础时，以数组的尾部为栈的尾部；在创建栈时，如果以链表的数据结构为基础时，以链表的头部为栈的尾部； 2. 栈的功能成员函数push(): 在栈的尾部添加成员pop(): 在栈的尾部删除成员top(): 返回栈的头部成员is_Empty(): 检测栈是否为空，若为空，则返回True， 否则返回Falselength(): 返回栈的成员数量travel(): 遍历栈的所有成员 常见栈的函数操作包括empty() – 返回栈是否为空 – Time Complexity : O(1) size() – 返回栈的长度 – Time Complexity : O(1) top() – 查看栈顶元素 – Time Complexity : O(1) push(g) – 向栈顶添加元素 – Time Complexity : O(1) pop() – 删除栈顶元素 – Time Complexity : O(1) python中栈可以用以下三种方法实现： １)list ２)collections.deque ３)queue.LifoQueue 使用列表实现栈 python的内置数据结构list可以用来实现栈，用append()向栈顶添加元素, pop() 可以以后进先出的顺序删除元素 但是列表本身有一些缺点，主要问题就是当列表不断扩大的时候会遇到速度瓶颈．列表是动态数组，因此往其中添加新元素而没有空间保存新的元素时，它会自动重新分配内存块，并将原来的内存中的值复制到新的内存块中．这就导致了一些append()操作会消耗更多的时间 使用collections.deque实现栈 python中栈也可以用deque类实现，当我们想要在实现在容器两端更快速地进行append和pop操作时，deque比列表更合适．deque可以提供O(1)时间的append和pop操作，而列表则需要O(n)时间. 使用queue module实现栈 Queue模块有LIFO queue，也就是栈结构．用put()和get()操作从Queue中添加和获得数据"},{"title":"20. Valid Parentheses(easy)","path":"2022/08/30/20/","text":"20. Valid Parentheses(easy)Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.12Input: s = &quot;()[]&#123;&#125;&quot;Output: true 官方题解判断括号的有效性可以使用「栈」这一数据结构来解决。 我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。 当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。 在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。 注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。 题解1 12345678class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;&#x27;&#123;&#x27;: &#x27;&#125;&#x27;, &#x27;[&#x27;: &#x27;]&#x27;, &#x27;(&#x27;: &#x27;)&#x27;, &#x27;?&#x27;: &#x27;?&#x27;&#125; stack = [&#x27;?&#x27;] for c in s: if c in dic: stack.append(c) elif dic[stack.pop()] != c: return False return len(stack) == 1 题解2 1234567891011121314151617181920class Solution: def isValid(self, s: str) -&gt; bool: if len(s) % 2 == 1: return False pairs = &#123; &quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;&#125;&quot;: &quot;&#123;&quot;, &#125; stack = list() for ch in s: if ch in pairs: if not stack or stack[-1] != pairs[ch]: return False stack.pop() else: stack.append(ch) return not stack"},{"title":"LeetCode-skill5-difference-array","path":"2022/08/29/LeetCode-skill5-difference-array/","text":"本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给… 一通操作猛如虎，然后问你，最后 nums 数组的值是什么？ 常规的思路很容易，你让我给区间 nums[i..j] 加上 val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改非常频繁，所以效率会很低下。 这里就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差： 1234567int[] diff = new int[nums.length];// 构造差分数组diff[0] = nums[0];for (int i = 1; i &lt; nums.length; i++) &#123; diff[i] = nums[i] - nums[i - 1];&#125; 通过这个 diff 差分数组是可以反推出原始数组 nums 的，代码逻辑如下： 123456int[] res = new int[diff.length];// 根据差分数组构造结果数组res[0] = diff[0];for (int i = 1; i &lt; diff.length; i++) &#123; res[i] = res[i - 1] + diff[i];&#125; 原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了？ 只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果。 现在我们把差分数组抽象成一个类，包含 increment 方法和 result 方法： 12345678910111213141516171819202122232425class Difference: def __init__(self, nums): self.nums = nums self.diff = self.make_diff(self.nums) def make_diff(self, nums): diff = [0 for _ in range(len(nums))] diff[0] = nums[0] for i in range(1,len(nums)): diff[i] = nums[i] - nums[i-1] return diff # 给闭区间[i,j]增加val # 原理很简单，回想diff数组反推nums数组的过程，diff[i] += 3意味着给nums[i..]所有的元素都加了 3，然后diff[j+1] -= 3又意味着对于nums[j+1..]所有元素再减 3，那综合起来，是不是就是对nums[i..j]中的所有元素都加 3 了？ def increment(self, i, j, val): self.diff[i] += val if j + 1 &lt; len(self.diff): self.diff[j + 1] -= val def recover(self): rdiff = [0 for _ in range(len(self.diff))] rdiff[0] = self.diff[0] for i in range(1,len(self.nums)): rdiff[i] = rdiff[i-1] + self.diff[i] return rdiff difference = Difference([8,5,9,6,1])print(difference.diff)rdiff = difference.recover()print(rdiff)difference.increment(2,3,1)print(difference.diff)rdiff = difference.recover()print(rdiff) 【python刷题】差分数组https://blog.51cto.com/u_15127632/3275175"},{"title":"LeetCode15-DFS","path":"2022/08/29/LeetCode15-DFS/","text":"我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。 本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。 在 LeetCode 中，「岛屿问题」是一个系列系列问题，比如： L200. 岛屿数量 （Easy）463. 岛屿的周长 （Easy）695. 岛屿的最大面积 （Medium）827. 最大人工岛 （Hard） 作者：nettee链接：https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"LeetCode14-BFS","path":"2022/08/29/LeetCode14-BFS/","text":""},{"title":"5. Longest Palindromic Substring(medium)","path":"2022/08/29/5/","text":"5. Longest Palindromic Substring(medium)Given a string s, return the longest palindromic substring in s.substring和subsequence：substring是子串。例如，‘wee’ 是 ‘helloween’的substring，‘hwn’ 不是 ‘helloween’的substring。取子串的时候不能隔着字符取。subsequence是子序列。例如，‘wee’ 和 ‘hwn’ 都是 ‘helloween’的subsequence。取子序列的时候可以隔着字符取。palindromic substring 是回文子串，例如‘soebeos’ 是 ‘absoebeostge’ 的回文子串。回文的意思是正过来念和反过来念都一样的字符串，比如“上海自来水来自海上”。 官方题解1234567891011121314151617class Solution: def expandAroundCenter(self, s, left, right): while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 def longestPalindrome(self, s: str) -&gt; str: start, end = 0, 0 for i in range(len(s)): left1, right1 = self.expandAroundCenter(s, i, i) left2, right2 = self.expandAroundCenter(s, i, i + 1) if right1 - left1 &gt; end - start: start, end = left1, right1 if right2 - left2 &gt; end - start: start, end = left2, right2 return s[start: end + 1]"},{"title":"344. Reverse String(easy)","path":"2022/08/29/344/","text":"344. Reverse String(easy)Write a function that reverses a string. The input string is given as an array of characters s.You must do this by modifying the input array in-place with O(1) extra memory.反转字符串，其实还是反转数组，双指针一左一右来回替换就行了，要注意的是在本体上变换 class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; left = 0 right = len(s)-1 while left&lt;right: tmp =s[left] s[left]=s[right] s[right]=tmp left+=1 right-=1"},{"title":"704. Binary Search(easy)","path":"2022/08/29/704/","text":"704. Binary Search(easy)Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity.123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 二分查找模板 12345678910111213class Solution: def search(self, nums: List[int], target: int) -&gt; int: left =0 right=len(nums)-1 while(left&lt;=right): mid =left+(right-left)//2 if nums[mid]==target: return mid elif nums[mid]&lt;target: left=mid+1 elif nums[mid]&gt;target: right = mid-1 return -1"},{"title":"LeetCode13-Array","path":"2022/08/29/LeetCode13-Array/","text":"Python3 二维数组，三维数组，多维数组的创建二维数组的创建：12345678910111213# 3行10列的二维数组的创建：m = [[0] * 3 for _ in range(10)]#或者m = [[0] * 3] * 10#我们来检查一下数组创建的对不对for i in range(10): for j in range(3): try: if (m[i][j] != 0): print(i, j) except: print(i, j, &quot;error&quot;)#没有输出error有关的东西，正确！ 三维数组的创建：12345678910111213141516#4行3列，Z = 2的三维数组的创建：m = [[[0] * 2 for _ in range(3)] for _ in range(4)]#或者m = [[[0] * 2] * 3] * 4#检查：for i in range(4): for j in range(3): for k in range(2): try: if (m[i][j][k] != 0): print(i, j, k); except: print(i, j, k, &quot;error&quot;)#没有输出error有关的东西，正确！#接下来多维数组的创建也就很简单了#m = [.....[[0] * q] * w] * e]*r]*t]*y]*u]*.........] 1. 快慢指针2. 左右指针二分查找Leetcode 题解 - 二分查找1. 求开方2. 大于给定元素的最小元素3. 有序数组的 Single Element4. 第一个错误的版本5. 旋转数组的最小数字6. 查找区间二分查找 binary search algorithm 时间复杂度二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。 m 计算有两种计算中值 m 的方式： m = (l + h) / 2m = l + (h - l) / 2l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。 未成功查找的返回值循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值： -1：以一个错误码表示没有查找到 keyl：将 key 插入到 nums 中的正确位置 模板 1234567891011121314int binarySearch(int[] nums, int target) &#123; // 一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125; 1234567891011121314class Solution: def search(self, nums: List[int], target: int) -&gt; int: left =0 right=len(nums)-1 while(left&lt;=right): mid =left+(right-left)//2 if nums[mid]==target: return mid elif nums[mid]&lt;target: left=mid+1 elif nums[mid]&gt;target: right = mid-1 return -1 12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… print(a[0:-1])python array:从位置0到位置-1之前的数 123456# 下面两个结果一样a = &#x27;1234568910’print(a[:-1]) print(a[0:-1])#result:a = &#x27;123456891’#result:a = &#x27;123456891’"},{"title":"283. Move Zeroes(easy)","path":"2022/08/29/283/","text":"283. Move Zeroes(easy)Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.Note that you must do this in-place without making a copy of the array.12Input: nums = [0,1,0,3,12]Output: [1,3,12,0,0] 这道题和26. Remove Duplicates from Sorted Array(easy) 差不多，还是双指针，重复数字改成了0，把非零数字写入数组前面，然后空位补0 class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; slow = 0 fast = 0 while fast&lt;len(nums): if nums[fast]!=0: nums[slow]=nums[fast] slow+=1 fast+=1 if slow&lt;len(nums): for i in range(slow,len(nums)): nums[i]=0 return nums"},{"title":"27. Remove Element(easy)","path":"2022/08/29/27/","text":"27. Remove Element(easy)Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:123456789int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; If all assertions pass, then your solution will be accepted.Example1234Input: nums = [3,2,2,3], val = 3Output: 2, nums = [2,2,_,_]Explanation: Your function should return k = 2, with the first two elements of nums being 2.It does not matter what you leave beyond the returned k (hence they are underscores). 解法：这道题和26. Remove Duplicates from Sorted Array(easy)几乎一模一样，其实数组是否有序没有任何影响，所以设置快慢指针可解决问题，慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不相同的元素就赋值给 slow 并让 slow 前进一步。这样，就保证了 nums[0..slow] 都是不相同的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组不相同val之后的结果 123456789101112class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: if len(nums)==0: return 0 slow, fast=0,0 while fast&lt;len(nums): if nums[fast]!=val: nums[slow]=nums[fast] slow+=1 fast+=1 return slow"},{"title":"26. Remove Duplicates from Sorted Array(easy)","path":"2022/08/29/26/","text":"26. Remove Duplicates from Sorted Array(easy)Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:123456789int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; If all assertions pass, then your solution will be accepted.Example1234Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). 解法：这道题并不难，因为只能在原数组上操作，所以设置快慢指针可解决问题，慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让 slow 前进一步。这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果 class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums)==0: return 0 slow = 0 fast = 0 while fast&lt;len(nums): if nums[fast]!=nums[slow]: slow+=1 nums[slow]=nums[fast] fast+=1 return slow+1"},{"title":"LeetCode-skill4-python-loop","path":"2022/08/28/LeetCode-skill4-python-loop/","text":"forfor i in range(n) range(n)输出的区间为 [ 0 , n − 1 ]，代码如下 for i in range(5): print(i) 输出结果为：0, 1, 2, 3, 4 for i in range(m, n) range(m, n)输出的区间为 [ m , n − 1 ] [m, n - 1][m,n−1]，代码如下 for i in range(2, 5): print(i) 输出结果为： 2, 3, 4 for i in range(m, n, s) 参数m,n为左右边界，s为步长range(m, n, s)输出的区间为 ( m , m + s , m + 2 s , ⋯ , n − k s ) (m, m + s, m + 2s, \\cdots , n - ks)(m,m+s,m+2s,⋯,n−ks)，代码如下 for i in range(1,7,2): print(i) 输出结果为：1, 3，5 for _ in range() _是一个变量（因为Python中的变量命名能够以下划线开始，单独的下划线也是一个变量），跟i一样，不同点在于，i会在后续的循环体中运用到，而_只是用来实现循环的次数。（因为基本上不会使用单独的下划线来用作变量传值）"},{"title":"25. Reverse Nodes in k-Group(hard)","path":"2022/08/28/25/","text":"25. Reverse Nodes in k-Group(hard)Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the list’s nodes, only nodes themselves may be changed.Example 12Input: head = [1,2,3,4,5], k = 2Output: [2,1,4,3,5] 我们要实现一个 reverse 函数反转一个区间之内的元素。在此之前我们再简化一下，给定链表头结点，如何反转整个链表？ 123456789101112131415// 反转以 a 为头结点的链表ListNode reverse(ListNode a) &#123; ListNode pre, cur, nxt; pre = null; cur = a; nxt = a; while (cur != null) &#123; nxt = cur.next; // 逐个结点反转 cur.next = pre; // 更新指针位置 pre = cur; cur = nxt; &#125; // 返回反转后的头结点 return pre;&#125; 这次使用迭代思路来实现的，借助动画理解应该很容易。 「反转以 a 为头结点的链表」其实就是「反转 a 到 null 之间的结点」，那么如果让你「反转 a 到 b 之间的结点」，你会不会？ 只要更改函数签名，并把上面的代码中 null 改成 b 即可：Java原版 1234567891011121314/** 反转区间 [a, b) 的元素，注意是左闭右开 */ListNode reverse(ListNode a, ListNode b) &#123; ListNode pre, cur, nxt; pre = null; cur = a; nxt = a; // while 终止的条件改一下就行了 while (cur != b) &#123; nxt = cur.next; cur.next = pre; pre = cur; cur = nxt; &#125; // 返回反转后的头结点 return pre;&#125; python 改版 1234567891011def reverse(a,b): pre= None current =a nxt=a while (current!=b): nxt = current.next current.next = pre pre = current current = nxt return pre 现在我们迭代实现了反转部分链表的功能，接下来就按照之前的逻辑编写 reverseKGroup 函数即可： 12345678910111213141516ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null) return null; // 区间 [a, b) 包含 k 个待反转元素 ListNode a, b; a = b = head; for (int i = 0; i &lt; k; i++) &#123; // 不足 k 个，不需要反转，base case if (b == null) return head; b = b.next; &#125; // 反转前 k 个元素 ListNode newHead = reverse(a, b); // 递归反转后续链表并连接起来 a.next = reverseKGroup(b, k); return newHead;&#125; python 完整版 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]: def reverse(a,b): pre= None current =a nxt=a while (current!=b): nxt = current.next current.next = pre pre = current current = nxt return pre if not head: return None a= head b = head for i in range(k): if b ==None: return head b=b.next newHead = reverse(a,b) a.next = self.reverseKGroup(b,k) return newHead"},{"title":"92. Reverse Linked List II(medium)","path":"2022/08/27/92/","text":"92. Reverse Linked List II(medium)Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.官方题解123456789101112131415class Solution: def reverseBetween(self, head: ListNode, left: int, right: int) -&gt; ListNode: # 设置 dummyNode 是这一类问题的一般做法 dummy_node = ListNode(-1) dummy_node.next = head pre = dummy_node for i in range(left - 1): pre = pre.next cur = pre.next for i in range(right - left): next = cur.next cur.next = next.next next.next = pre.next pre.next = next return dummy_node.next 第一步 12345next = cur.nextcur.next = next.nextnext.next = pre.nextpre.next = next 第二步"},{"title":"142. Linked List Cycle II(medium)","path":"2022/08/27/142/","text":"142. Linked List Cycle II(medium)快慢指针-leetcode题解 思路与算法 我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。 如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 bb 的距离与 fast 相遇。此时，fast 指针已经走完了环的 nn 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。 根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有 a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c) a=c+(n−1)(b+c)有了 a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。 因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if not head: return None fast = head slow = head while fast: slow = slow.next if fast.next: fast = fast.next.next else: return None if fast == slow: ptr = head while ptr!=slow: ptr=ptr.next slow = slow.next return ptr"},{"title":"LeetCode-skill3-python-if","path":"2022/08/27/LeetCode-skill3-python-if/","text":"if基本语句if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系1234567891011121314if 判断条件： 执行语句……else： 执行语句……‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… if or/and如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功12345678910111213if self.detail_image_tip.exists() or self.open_long_atlas.exists(): logger.info(&#x27;当前作品不支持相关推荐展示&#x27;) self.swipeByCount(&quot;up&quot;, 0.2, 1) logger.info(&#x27;上滑一个作品&#x27;)else: logger.info(&#x27;当前作品支持相关推荐展示&#x27;)#or 两个元素只要有一个为True 那么这个判断就为True 两个元素判断都为Flase才为Falseif self.link_icon.exists() and self.hot_live.exists(): logger.info(&#x27;当前作品不是普通作品&#x27;)else: logger.info(&#x27;当前作品普通作品&#x27;)#and 当前两个元素都存在为True时 if判断为True 一个为False 那么if判断就为False not12345678910111213141516171819202122232425if self.comment_frame.exists() is not True:#is not True的意思是当元素判断不为True的时候 if的判断为True 走True的部分不走else的部分if not number &gt; 6: self.swipeByCount(&quot;down&quot;, 0.2, 1) self.swipeByCount(&quot;up&quot;, 0.2, 1)#not的意思是 if判断当number不大于6时(也就是&lt;=6) 那么走if的True的部分#这样的好处就是不用去特地写else的部分#如下：if number &gt; 6: print(‘当前number大于6’)else： self.swipeByCount(&quot;down&quot;, 0.2, 1) self.swipeByCount(&quot;up&quot;, 0.2, 1)#有的同学就会说那我写&lt;=6不行吗if number &lt;= 6: self.swipeByCount(&quot;down&quot;, 0.2, 1) self.swipeByCount(&quot;up&quot;, 0.2, 1)#也可以这么写 但是我在定义这个函数的时候实际目的是找大于6条的评论 所以not number &gt; 6会更清晰 看个人习惯了def number_of_folds(self): &#x27;&#x27;&#x27; 判断折叠评论数量大于6条 :return: &#x27;&#x27;&#x27; if 缩写1A = A.next if A else headB 1234if A: A =A.nextelse: A= headB"},{"title":"876. Middle of the Linked List(easy)","path":"2022/08/27/876/","text":"876. Middle of the Linked List(easy)Given the head of a singly linked list, return the middle node of the linked list.If there are two middle nodes, return the second middle node.我们让两个指针 slow 和 fast 分别指向链表头结点 head。 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: slow = head fast =head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"title":"86. Partition List(medium)","path":"2022/08/27/86/","text":"86. Partition List(medium)Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.链表的基本操作，但是这里创立了两个链表,两个 dummy node 来持有两个分割出来的子链表，分别存储比x大和小的，最后在将数字小的那部分链接到大数字上 官方说明 直观来说我们只需维护两个链表 small 和 large 即可，small 链表按顺序存储所有小于 x 的节点，large 链表按顺序存储所有大于等于 x 的节点。遍历完原链表后，我们只要将 small 链表尾节点指向 large 链表的头节点即能完成对链表的分隔。 为了实现上述思路，我们设 smallHead 和 largeHead 分别为两个链表的哑节点，即它们的 next 指针指向链表的头节点，这样做的目的是为了更方便地处理头节点为空的边界条件。同时设 small 和 large 节点指向当前链表的末尾节点。开始时 smallHead=small,largeHead=large。随后，从前往后遍历链表，判断当前链表的节点值是否小于 x，如果小于就将 small 的 next 指针指向该节点，否则将 large 的 next 指针指向该节点。 遍历结束后，我们将 large 的 next 指针置空，这是因为当前节点复用的是原链表的节点，而其 next 指针可能指向一个小于 x 的节点，我们需要切断这个引用。同时将 small 的 next 指针指向 largeHead 的 next 指针指向的节点，即真正意义上的 large 链表的头节点。最后返回 smallHead 的 next 指针即为我们要求的答案。 1234567891011121314151617class Solution: def partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]: smallhead = small =ListNode(0) largehead = large =ListNode(0) while head: if head.val&lt;x: small.next = head small = small.next else: large.next = head large = large.next head = head.next large.next = None small.next = largehead.next return smallhead.next"},{"title":"203. Remove Linked List Elements(easy)","path":"2022/08/26/203/","text":"203. Remove Linked List Elements(easy)Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.12Input: head = [1,2,6,3,4,5,6], val = 6Output: [1,2,3,4,5] 这题是一个简单题，但可以学习如何添加dummy node 1234pre = ListNode(-1)pre.next = headcurrent = pre # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]: pre = ListNode(-1) pre.next = head current = pre while current.next!=None: if current.next.val== val: current.next= current.next.next else: current = current.next return pre.next"},{"title":"LeetCode-skill2-python_funciton","path":"2022/08/24/LeetCode-skill2-python-funciton/","text":"python 常用函数ListPython 的列表 List 基本就是其它语言的 Array. Initialization 初始化List 的初始化一般用 List comprehension，往往能一行解决问题 12345# 1d arrayl = [0 for _ in range(len(array)]# 2dl = [[0 for i in range(cols)] for j in range(rows)] Start from the behind你可以轻松从后往前访问： 1234567lastElement = l[-1]lastTwo = l[-2:]for i in range(0, -10, -1)# 0, -1, -2, -3, -4, -5, -6, -7, -8, -9 copy 复制shallow copy 浅拷贝123l2 = l1[:]# orl2 = l1.copy() 浅复制的问题在于，如果 l1 内部还有 list，那么这种嵌套的索引不能被复制，比如： 12345a = [1, 2, [3, 4]]b = a[:]a[2].append(5)print(b)# [1, 2, [3, 4, 5]] deep copy 深拷贝所以如果要做深拷贝，要节制自带库 copy 123import copycopy.deepcopy() enumerate 枚举当我们需要枚举一个数组并同时获得值与 index 的时候可以使用： 12345678l = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for i, v in enumerate(l): print(i, v)# 0 a# 1 b# 2 c zipzip 本意就是拉链，可以想象成将两个数组像拉链一样挨个聚合： 12345&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = [4, 5, 6]&gt;&gt;&gt; zipped = zip(x, y)&gt;&gt;&gt; list(zipped)[(1, 4), (2, 5), (3, 6)] reducereduce 可以分别对相邻元素使用同一种计算规则，同时每一步结果作为下一步的参数，很典型的函数式编程用法。 12345678910# importing functools for reduce()import functools# initializing listlis = [ 1, 3, 5, 6, 2, ]# using reduce to compute sum of listprint (&quot;The sum of the list elements is : &quot;,end=&quot;&quot;)print (functools.reduce(lambda a,b : a+b,lis))# The sum of the list elements is : 17 map可以将参数一一映射来计算， 比如map() 会根据提供的函数对指定序列做映射。 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。map(function, iterable, …) 12345678910&gt;&gt;&gt; def square(x) : # 计算平方数... return x ** 2...&gt;&gt;&gt; map(square, [1,2,3,4,5]) # 计算列表各个元素的平方&gt;&gt;&gt; list(map(square, [1,2,3,4,5])) # 使用 list() 转换为列表[1, 4, 9, 16, 25]&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) # 使用 lambda 匿名函数[1, 4, 9, 16, 25]&gt;&gt;&gt; 1234date = &quot;2019-8-15&quot;Y, M, D = map(int, date.split(&#x27;-&#x27;))# Y = 2019, M = 8, D = 15 dequelist 删除末尾的操作是O(1)的，但是删除头操作就是O(n)，这时候我们就需要一个双端队列 deque。首尾的常规操作为： append，添加到末尾appendleft, 添加到开头pop, 剔除末尾popleft，移除开头 sortlist 自身有自带的 sort(), 但是它不返回新的 list.可以加reverse使结果倒序 1234# vowels lista= [6, 2, 3, 8]a.sort(reverse=True)print(a)#[8, 6, 3, 2] sortedlist 自身有自带的 sort(), 但是它不返回新的 list. sorted 能返回一个新的 list, 并且支持传入参数reverse。 比如我们有一个 tuple 的数组，我们想按照 tuple 的第一个元素进行排序： 12345l1 = [(1,2), (0,1), (3,10) ]l2 = sorted(l1, key=lambda x: x[0])# l2 = [(0, 1), (1, 2), (3, 10)] 这里的 key 允许传入一个自定义参数，也可以用自带函数进行比较，比如在一个 string 数组里只想比较小写，可以传入key=str.lower 123456l1 = [&quot;banana&quot;,&quot;APPLE&quot;, &quot;Watermelon&quot;]l2 = sorted(l1, key=str.lower)print(l2)# [&#x27;APPLE&#x27;, &#x27;banana&#x27;, &#x27;Watermelon&#x27;] 123456&gt;&gt;&gt; word = &#x27;paper&#x27;&gt;&gt;&gt; len(word)5&gt;&gt;&gt; words = [&#x27;banana&#x27;, &#x27;pie&#x27;, &#x27;Washington&#x27;, &#x27;book&#x27;]&gt;&gt;&gt; sorted(words, key=len)[&#x27;pie&#x27;, &#x27;book&#x27;, &#x27;banana&#x27;, &#x27;Washington&#x27;] 1234tree=sorted([x for x in a if x!=-1])# 这个很神奇，把除了-1以外的数排序#tree=[150, 160, 170, 180, 190] lambda你注意到我们在上面使用了 lambda 来定义一个匿名函数，十分方便。如果你熟悉其它语言类似 JS 的话，可以把它理解成一个 callback 函数，参数名一一对应就行。 cmp_to_key在 python3 中，sorted 函数取消了自带的cmp函数，需要借助functools 库中的 cmp_to_key来做比较。比如如果要按照数组元素的绝对值来排序： 1234567891011from functools import cmp_to_keydef absSort(arr): newarr = sorted(arr, key = cmp_to_key(sortfunc)) return newarrdef sortfunc(a, b): if abs(a) &lt; abs(b): return -1 elif abs(a) &gt; abs(b): return 1 else: return a - b setset 的查找操作复杂度为O(1)，有时候可以替代dict 来存储中间过程。 add : set 的添加是 add 不是append remove vs discard: 都是删除操作，区别在于remove不存在的元素会报错，discard不会。 union, intersection: 快速获得并集和交集，方便一些去重操作。 dict字典，相当于其它语言中的map, hashtable, hashmap之类的，读取操作也是O(1) 复杂度 keys(), values(), items()这三个方法可以分别获得key, value, {key: value}的数组。 setdefault这个函数经常在初始化字典时候使用，如果某个key在字典中存在，返回它的value, 否则返回你给的 default 值。比如在建一个 trie 树的时候 OrderedDictOrderedDict 能记录你 key 和 value 插入的顺序，底层其实是一个双向链表加哈希表的实现。我们甚至可以使用move_to_end这样的函数： 12345678&gt;&gt;&gt; d = OrderedDict.fromkeys(&#x27;abcde&#x27;)&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;)&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())&#x27;acdeb&#x27;# 放开头&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;, last=False)&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())&#x27;bacde&#x27; defaultdictdefaultdict可以很好地来解决一些初始化的问题，比如 value 是一个 list，每次需要判断 key 是否存在的情况。这时我们可以直接定义 1234567d = defaultdict(list)s = [(&#x27;yellow&#x27;, 1), (&#x27;blue&#x27;, 2), (&#x27;yellow&#x27;, 3), (&#x27;blue&#x27;, 4), (&#x27;red&#x27;, 1)]for k, v in s: d[k].append(v)sorted(d.items())# [(&#x27;blue&#x27;, [2, 4]), (&#x27;red&#x27;, [1]), (&#x27;yellow&#x27;, [1, 3])] heapqheapq 就是 python 的 priority queue，heapq[0]即为堆顶元素。 heapq 的实现是小顶堆，如果需要一个大顶堆，常规的一个做法是把值取负存入，取出时再反转。以下是借助 heapq 来实现 heapsort 的例子： 12345678&gt;&gt;&gt; def heapsort(iterable):... h = []... for value in iterable:... heappush(h, value)... return [heappop(h) for i in range(len(h))]...&gt;&gt;&gt; heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] bisectpython 自带二分查找的库，在一些不要求实现 binary search，但是借助它能加速的场景下可以直接使用。 12bisect.bisect(a, x, lo=0, hi=len(a))这里的参数分别为 数组，要查找的数，范围起始点，范围结束点 相似函数还有 12bisect.bisect_leftbisect.bisect_right 分别返回可以插入 x 的最左和最右 index CounterCounter 接受的参数可以是一个 string, 或者一个 list, mapping 1234&gt;&gt;&gt; c = Counter() # a new, empty counter&gt;&gt;&gt; c = Counter(&#x27;gallahad&#x27;) # a new counter from an iterable&gt;&gt;&gt; c = Counter(&#123;&#x27;red&#x27;: 4, &#x27;blue&#x27;: 2&#125;) # a new counter from a mapping&gt;&gt;&gt; c = Counter(cats=4, dogs=8) # a new counter from keyword args most_common(n)可以得到出现次数最多的 n 个数： 12&gt;&gt;&gt; Counter(&#x27;abracadabra&#x27;).most_common(3) # doctest: +SKIP[(&#x27;a&#x27;, 5), (&#x27;r&#x27;, 2), (&#x27;b&#x27;, 2)] stringsord, charord 返回单个字符的 unicode: 12&gt;&gt;&gt; ord(&#x27;a&#x27;)97 char 则是反向操作： 12&gt;&gt;&gt; chr(100)&#x27;d&#x27; strip移除 string 前后的字符串，默认来移除空格，但是也可以给一个字符串，然后会移除含有这个字符串的部分： `` ‘ spacious ‘.strip()‘spacious’‘www.example.com&#39;.strip(&#39;cmowz.&#39;)‘example’`` split按照某个字符串来切分，返回一个 list, 可以传入一个参数maxsplit来限定分离数。 123456&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;, maxsplit=1)[&#x27;1&#x27;, &#x27;2,3&#x27;]&gt;&gt;&gt; &#x27;1,2,,3,&#x27;.split(&#x27;,&#x27;)[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;&#x27;] int/ float最大, 最小 number有时候初始化我们需要设定 Math.max() 和 Math.min(), 在 python 中分别以 float(‘inf’) 和 float(‘-inf’)表示 或者也可以用math库里的 math.inf 和 math.inf 在 python2 中我们也可以这么做： 1234import sys#maxintMax = sys.maxint 除法在 python3 中， / 会保留浮点，相当于 float 相除，如果需要做到像 pyhton2 中的 int 相除，需要 //： 1234&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 3 // 21 次方在 python 中为 **: 12&gt;&gt;&gt; 2 ** 101024 conditions在 python 的三项表达式(ternary operation) 与其它语言不太一样： 1res = a if condition else b 它表示如果 condition 满足，那么 res = a, 不然 res = b，在类 c 的语言里即为： 1res = condition ? a : b; strip()1231. strip():- This method is used to delete all the leading and trailing characters mentioned in its argument.2. lstrip():- This method is used to delete all the leading characters mentioned in its argument.3. rstrip():- This method is used to delete all the trailing characters mentioned in its argument. 123456789101112131415161718# Python code to demonstrate working of# strip(), lstrip() and rstrip()str = &quot;---geeksforgeeks---&quot;# using strip() to delete all &#x27;-&#x27;print ( &quot; String after stripping all &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.strip(&#x27;-&#x27;) )# String after stripping all &#x27;-&#x27; is : geeksforgeeks# using lstrip() to delete all trailing &#x27;-&#x27;print ( &quot; String after stripping all leading &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.lstrip(&#x27;-&#x27;) )# String after stripping all leading &#x27;-&#x27; is : geeksforgeeks---# using rstrip() to delete all leading &#x27;-&#x27;print ( &quot; String after stripping all trailing &#x27;-&#x27; is : &quot;, end=&quot;&quot;)print ( str.rstrip(&#x27;-&#x27;) )# String after stripping all trailing &#x27;-&#x27; is : ---geeksforgeeks join()join()Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。str.join(sequence) sequence – 要连接的元素序列。 12345s1 = &quot;-&quot;s2 = &quot;&quot;seq = (&quot;r&quot;, &quot;u&quot;, &quot;n&quot;, &quot;o&quot;, &quot;o&quot;, &quot;b&quot;) # 字符串序列print (s1.join( seq )) #r-u-n-o-o-bprint (s2.join( seq )) #runoob isalnum()isalnum()用来判断是不是字母 123456789# string contains either alphabet or number name1 = &quot;Python3&quot;print(name1.isalnum()) #True# string contains whitespacename2 = &quot;Python 3&quot;print(name2.isalnum()) #False 参考：https://hzhao.me/2019/08/16/python-leetcode-trick/#heapq https://xdren69.github.io/2021/03/31/leetcode-python/"},{"title":"304. Range Sum Query 2D - Immutable(medium)","path":"2022/08/24/304/","text":"304. Range Sum Query 2D - Immutable(medium)Given a 2D matrix matrix, handle multiple queries of the following type:Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).Implement the NumMatrix class:NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).You must design an algorithm where sumRegion works on O(1) time complexity.官方题解这道题是303题的升级版，从一维数组升级成二维矩阵，同样是前缀和数组 123456789101112131415class NumMatrix: def __init__(self, matrix: List[List[int]]): m, n = len(matrix), (len(matrix[0]) if matrix else 0) self.sums = [[0] * (n + 1) for _ in range(m + 1)] _sums = self.sums for i in range(m): for j in range(n): _sums[i + 1][j + 1] = _sums[i][j + 1] + _sums[i + 1][j] - _sums[i][j] + matrix[i][j] def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int: _sums = self.sums return _sums[row2 + 1][col2 + 1] - _sums[row1][col2 + 1] - _sums[row2 + 1][col1] + _sums[row1][col1] 作者：LeetCode-Solution链接：来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"303. Range Sum Query - Immutable(easy)","path":"2022/08/24/303/","text":"303. Range Sum Query - Immutable(easy)Given an integer array nums, handle multiple queries of the following type:Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.Implement the NumArray class:NumArray(int[] nums) Initializes the object with the integer array nums.int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive(i.e. nums[left] + nums[left + 1] + … + nums[right]).最基础的前缀和问题官方题解 12345678910111213141516class NumArray: def __init__(self, nums: List[int]): self.sums = [0] _sums = self.sums for num in nums: _sums.append(_sums[-1] + num) def sumRange(self, i: int, j: int) -&gt; int: _sums = self.sums return _sums[j + 1] - _sums[i]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(left,right) 1234567891011class NumArray: # 68 ms, faster than 97.72% def __init__(self, nums: List[int]): self.preSum = nums # pass by pointer! for i in range(len(nums)-1): self.preSum[i+1] += self.preSum[i] def sumRange(self, left: int, right: int) -&gt; int: if left == 0: return self.preSum[right] return self.preSum[right] - self.preSum[left-1]"},{"title":"LeetCode-skill1-prefix_sum","path":"2022/08/24/LeetCode-skill1-prefix-sum/","text":"前缀和（prefix sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现 “子数组和” 或者 “连续的子数组” 既可以考虑使用前缀和来求解会得到不错的效果。303题 304题"},{"title":"518. Coin Change 2(medium)","path":"2022/08/23/518/","text":"518. Coin Change 2(medium)You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.You may assume that you have an infinite number of each kind of coin.The answer is guaranteed to fit into a signed 32-bit integer.leetcode题解12345678910111213141516class Solution: def change(self, amount: int, coins: List[int]) -&gt; int: n = len(coins) dp = [[0]*(amount+1) for _ in range(n+1)] # 初始化 dp[0][0] = 1 # 合法的初始化 # 完全背包：优化后的状态转移 for i in range(1, n+1): # 第一层循环：遍历硬币 for j in range(amount+1): # 第二层循环：遍历背包 if j &lt; coins[i-1]: # 容量有限，无法选择第i个硬币 dp[i][j] = dp[i-1][j] else: # 可选择第i个硬币 dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]] return dp[n][amount] 作者：flix链接：https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"322. Coin Change(medium)","path":"2022/08/23/322/","text":"322. Coin Change(medium)You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.You may assume that you have an infinite number of each kind of coin."},{"title":"253. Meeting Rooms II","path":"2022/08/23/253/","text":"253. Meeting Rooms IIGiven an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.思想：红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 count 加一，每遇到绿色的点，计数器 count 减一：这样一来，每个时刻有多少个会议在同时进行，就是计数器 count 的值，count 的最大值，就是需要申请的会议室数量。 对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。 代码实现那么，如何写代码实现这个扫描的过程呢？ 首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器 count 的最大值就是答案：这里使用的是 双指针技巧，根据 i, j 的相对位置模拟扫描线前进的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution: def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int: n= len(intervals) begin =[] end = [] count = 0 res,c,j=0,0,0 for i in range(n): begin.append(intervals[i][0]) end.append(intervals[i][1]) begin.sort() end.sort() while (c&lt;n and j&lt;n): if begin[c]&lt;end[j]: count+=1 c+=1 else: count-=1 j+=1 res = max(res,count) return res``` ```javaint minMeetingRooms(int[][] meetings) &#123; int n = meetings.length; int[] begin = new int[n]; int[] end = new int[n]; for(int i = 0; i &lt; n; i++) &#123; begin[i] = meetings[i][0]; end[i] = meetings[i][1]; &#125; Arrays.sort(begin); Arrays.sort(end); // 扫描过程中的计数器 int count = 0; // 双指针技巧 int res = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; if (begin[i] &lt; end[j]) &#123; // 扫描到一个红点 count++; i++; &#125; else &#123; // 扫描到一个绿点 count--; j++; &#125; // 记录扫描过程中的最大值 res = Math.max(res, count); &#125; return res;&#125;"},{"title":"1207. Unique Number of Occurrences(easy)","path":"2022/08/22/1207/","text":"1207. Unique Number of Occurrences(easy)Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.123Input: arr = [1,2,2,1,1,3]Output: trueExplanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. 这道题相对比较简单，判断hashmap的value是否都是unique的，通过set的无重复性很容易就能判断 123456789101112class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: hashmap=&#123;&#125; res=[] for i in arr: if i not in hashmap: hashmap[i]=1 else: hashmap[i]+=1 for i in hashmap.keys(): res.append(hashmap[i]) return len(set(res))==len(res)"},{"title":"146. LRU Cache(medium)","path":"2022/08/22/146/","text":"146. LRU Cache(medium)Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.Implement the LRUCache class:LRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.The functions get and put must each run in O(1) average time complexity.官方答案这道题是hashmap频率第一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class DLinkedNode: def __init__(self, key=0, value=0): self.key = key self.value = value self.prev = None self.next = Noneclass LRUCache: def __init__(self, capacity: int): self.cache = dict() # 使用伪头部和伪尾部节点 self.head = DLinkedNode() self.tail = DLinkedNode() self.head.next = self.tail self.tail.prev = self.head self.capacity = capacity self.size = 0 def get(self, key: int) -&gt; int: if key not in self.cache: return -1 # 如果 key 存在，先通过哈希表定位，再移到头部 node = self.cache[key] self.moveToHead(node) return node.value def put(self, key: int, value: int) -&gt; None: if key not in self.cache: # 如果 key 不存在，创建一个新的节点 node = DLinkedNode(key, value) # 添加进哈希表 self.cache[key] = node # 添加至双向链表的头部 self.addToHead(node) self.size += 1 if self.size &gt; self.capacity: # 如果超出容量，删除双向链表的尾部节点 removed = self.removeTail() # 删除哈希表中对应的项 self.cache.pop(removed.key) self.size -= 1 else: # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部 node = self.cache[key] node.value = value self.moveToHead(node) def addToHead(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def removeNode(self, node): node.prev.next = node.next node.next.prev = node.prev def moveToHead(self, node): self.removeNode(node) self.addToHead(node) def removeTail(self): node = self.tail.prev self.removeNode(node) return node"},{"title":"290. Word Pattern(easy)","path":"2022/08/21/290/","text":"290. Word Pattern(easy)Given a pattern and a string s, find if s follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.12Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;Output: true 这道题与205.同构字符串几乎一样，区别在于：1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况 2.本题需要将s分隔成单个单词 常规做法是，根据pattern和s的对应关系建立一个hashmap，然后再遍历s与hashmap的映射做比较，有不一样就返回false 12345678910111213141516class Solution: def wordPattern(self, pattern: str, s: str) -&gt; bool: s=s.split() if len(s)!=len(pattern): return False if len(set(pattern))!=len(set(s)): return False hashmap=&#123;&#125; for i in range(len(s)): if pattern[i] not in hashmap: hashmap[pattern[i]]=s[i] for i in range(len(pattern)): if hashmap[pattern[i]]!=s[i]: return False return True 优雅的python解法是： 12345678class Solution: def wordPattern(self, pattern: str, s: str) -&gt; bool: s = s.split() if len(pattern) != len(s): return False return len(set(pattern)) == len(set(s)) == len(set(zip(pattern,s)))"},{"title":"350. Intersection of Two Arrays II(easy)","path":"2022/08/21/350/","text":"350. Intersection of Two Arrays II(easy)Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/intersection-of-two-arrays-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。官方题解用的是heap 加hashmap 123456789101112131415161718class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: if len(nums1) &gt; len(nums2): return self.intersect(nums2, nums1) m = collections.Counter() for num in nums1: m[num] += 1 intersection = list() for num in nums2: if (count := m.get(num, 0)) &gt; 0: intersection.append(num) m[num] -= 1 if m[num] == 0: m.pop(num) return intersection 这个方法用的是python一些独特的函数 Counter 123456class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: num1 = collections.Counter(nums1) num2 = collections.Counter(nums2) num = num1 &amp; num2 return num.elements() 链接：来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"349. Intersection of Two Arrays(easy)","path":"2022/08/21/349/","text":"349. Intersection of Two Arrays(easy)Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2] 这题相对比较简单，就是找到nums1 和nums2相同的数字，并且输出hashset（不能输出重复数字） 1234567891011121314class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: hashmap=&#123;&#125; res = [] for i in nums1: if i not in hashmap: hashmap[i]=1 else: hashmap[i]+=1 for i in nums2: if i in hashmap: res.append(i) return set(res)"},{"title":"299. Bulls and Cows","path":"2022/08/21/299/","text":"299. Bulls and CowsYou are playing the Bulls and Cows game with your friend.You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:The number of “bulls”, which are digits in the guess that are in the correct position.The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess.The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.原理：猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。"},{"title":"264. Ugly Number II(medium)","path":"2022/08/20/264/","text":"264. Ugly Number II(medium)An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.Given an integer n, return the nth ugly number.这是一个系列题263. 丑数（简单） 丑数 II（中等） 丑数 III（中等） 超级丑数（中等） “prime factor”是质因子，质因子是所有因子中是质数的 官方题解1234567891011121314class Solution: def nthUglyNumber(self, n: int) -&gt; int: factors = [2, 3, 5] seen = &#123;1&#125; heap = [1] for i in range(n - 1): curr = heapq.heappop(heap) for factor in factors: if (nxt := curr * factor) not in seen: seen.add(nxt) heapq.heappush(heap, nxt) return heapq.heappop(heap) https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution 12345678910111213141516171819202122232425262728class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; ugly = [1] p2, p3, p5 = 0, 0, 0 # pointers that point to the last element 2, 3 or 5 was multiplied to while len(ugly) &lt; n: u2 = 2 * ugly[p2] u3 = 3 * ugly[p3] u5 = 5 * ugly[p5] u = min(u2, u3, u5) if u == u2: # if the minimum result was result of multiplying the element(ugly[p2]) by 2 p2 += 1 if u == u3: # if minimum was result of multiplying the element(ugly[p3]) by 3 p3 += 1 if u == u5: # if minimus was result of multiplying the element(ugly[p5]) by 5 p5 += 1 ugly.append(u) return ugly[-1] # return the last element of ugly list"},{"title":"268. Missing Number","path":"2022/08/20/268/","text":"268. Missing NumberGiven an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.题目是说给了n个数，找到0-n之间缺的那个数 123Input: nums = [9,6,4,2,3,5,7,0,1]Output: 8Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. 思路：本质上与242. Valid AnagramZ(easy) 没有什么区别，相当于是两个hashmap的比较，这里有个隐性的比较，分别是nums建成的hashmap，还有一个是完整的0-n这样的list建成的hashmap，所以第一步是建造一个包含0-n数字的list，然后以nums建成的hasmap为基础，拿完整版进行比较，这样可以得到缺失的数字 class Solution: def missingNumber(self, nums: List[int]) -&gt; int: hashmap=&#123;&#125; n=len(nums) list = [] for i in nums: if i not in hashmap: hashmap[i]=1 else: hashmap[i]+=1 for i in range(n+1): list.append(i) for i in list: if i not in hashmap: a = i return a"},{"title":"242. Valid Anagram(easy)","path":"2022/08/20/242/","text":"242. Valid Anagram(easy)Given two strings s and t, return true if t is an anagram of s, and false otherwise.An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once.这道题和 205. Isomorphic Strings 有点像，但这道题更简单。这道题最容易想到的方法就是直接对字符串排序比较得到结果，首先字符串长度不同肯定输出false，接下来再对字符串排序，如果排序后相同就输出true 12345678910111213141516171819202122232425clas Solution: def isAnagram(self, s: str, t: str) -&gt; bool: if len(s)!=len(t): return False return sorted(s)==sorted(t)``` ### [但是！](htps://leetcode.cn/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/)复杂度分析时间复杂度：O(nlogn)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlogn+n)=O(nlogn)。空间复杂度：O(logn)。排序需要 O(logn) 的空间复杂度。注意，在某些语言（比如 Java &amp; JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：这依赖于语言的细节；这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。所以，有第二种方法，也就是hashmap：从另一个角度考虑，t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 26 个小写字母，因此我们可以维护一个长度为 26 的频次数组 table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现 table[i]&lt;0，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。其实简单点想，就是建两个hashmap，最后比较是否相同就完事了。比较的函数```pythonoperator.eq(hashmap1,hashmap2) 123456789101112131415161718class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: if len(s)!=len(t): return False hashmap1=&#123;&#125; hashmap2=&#123;&#125; for c1 in s: if c1 not in hashmap1: hashmap1[c1]=1 else: hashmap1[c1]+=1 for c2 in t: if c2 not in hashmap2: hashmap2[c2]=1 else: hashmap2[c2]+=1 return operator.eq(hashmap1,hashmap2) Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 Unicode 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和 UTF−16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。 回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。 12345678910111213clas Solution: def isAnagram(self, s: str, t: str) -&gt; bool: #Using Hashmaps: (O(s+t) time and space) s_map = &#123;&#125; t_map = &#123;&#125; for leter in s: s_map[leter] = s_map.setdefault(leter, 0) + 1 for leter in t: t_map[leter] = t_map.setdefault(leter, 0) + 1 return s_map == t_map"},{"title":"229. Majority Element II(easy)","path":"2022/08/20/229/","text":"229. Majority Element II(easy)Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.这道题有点像TOP K问题，看到all elements里的遍历想到hashmap 把top K 的代码和Majority Element I的放在一起就可以解决这个问题了 12345678910111213141516171819202122232425262728293031323334class Solution: def majorityElement(self, nums: List[int]) -&gt; List[int]: hashmap = &#123;&#125; n=len(nums) for ans in nums: if ans not in hashmap: hashmap[ans]=1 else: hashmap[ans]+=1 res=[] for i in hashmap.keys(): if hashmap[i]&gt; len(nums)//3: res.append(i) return res``` 这里需要注意的是，在输出所有有可能的数组时，TOP K 问题用的是extend，而这里用的是appendappend可以追加一个list，一个对象；extend则是把两个list连接起来，类似matlab的cat函数 ```pythonNumList1 = [1,2,3]NumList2 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]NumList1.append(NumList2)print(&quot;列表2append到列表1：&quot;,NumList1)#[1, 2, 3, [‘a’, ‘b’, ‘c’]]print(&#x27;第四个元素为&#x27;,NumList1[3]) #[‘a’, ‘b’, ‘c’]NumList1 = [1,2,3]NumList1.extend(NumList2)print(&quot;列表2extend到列表1：&quot;,NumList1)#[1, 2, 3, ‘a’, ‘b’, ‘c’]输出结果为：列表2append到列表1： [1, 2, 3, [‘a’, ‘b’, ‘c’]]第四个元素为 [‘a’, ‘b’, ‘c’]列表2extend到列表1： [1, 2, 3, ‘a’, ‘b’, ‘c’]"},{"title":"219. Contains Duplicate II(easy)","path":"2022/08/20/219/","text":"219. Contains Duplicate II(easy)Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.12Input: nums = [1,2,3,1], k = 3Output: true 官方题解可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 nums，当遍历到下标 i 时，进行如下操作： 如果哈希表中已经存在和 nums[i] 相等的元素且该元素在哈希表中记录的下标 j 满足 i−j≤k，返回 true； 将 nums[i] 和下标 i 存入哈希表，此时 i 是 nums[i] 的最大下标。 123456789class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: pos = &#123;&#125; for i, num in enumerate(nums): if num in pos and i - pos[num] &lt;= k: return True pos[num] = i return False"},{"title":"205. Isomorphic Strings(easy)","path":"2022/08/20/205/","text":"205. Isomorphic Strings(easy)Given two strings s and t, determine if they are isomorphic.Two strings s and t are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.官方题解此题是「290. 单词规律」的简化版，需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。 总结一下就是得一一对应，并且是互相对应。所以第一种方法可以用两个hashmap互相存储对应关系，再往后进行判断 12345678910111213class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: hashmap1 = &#123;&#125; hashmap2 = &#123;&#125; for c1, c2 in zip(s, t): #The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it. if hashmap1.get(c1, c2) != c2 or hashmap2.get(c2, c1) != c1: #The get() method returns the value for the specified key if the key is in the dictionary. return False hashmap1[c1] = c2 hashmap2[c2] = c1 return True 第二种方法也是评论里的很有意思的方法，利用set的无重复特性来判断 123class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: return len(set(s)) == len(set(t)) == len(set(zip(s, t))) zip 函数 1234567a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) # 返回一个对象list(zipped) # list() 转换为列表 [(1, 4), (2, 5), (3, 6)]list(zip(a,c)) # 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)]"},{"title":"202. Happy Number(easy)","path":"2022/08/19/202/","text":"202. Happy Number(easy)Write an algorithm to determine if a number n is happy.A happy number is a number defined by the following process:Starting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.Those numbers for which this process ends in 1 are happy.Return true if n is a happy number, and false if not.又是一个奇怪的数，叫做happy number 官方题解总结一下，数字每一位的平方和后的结果有两种可能性 变成1 变成循环 对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限增大的选择。 算法 算法分为两部分，我们需要设计和编写代码。 给一个数字 nn，它的下一个数字是什么？按照一系列的数字来判断我们是否进入了一个循环。 我们按照题目的要求做数位分离，求平方和。 可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。 如果它不在哈希集合中，我们应该添加它。如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。 我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。 Hashmap解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution: def isHappy(self, n: int) -&gt; bool: n_history=&#123;&#125; while True: try: n_history[n]+=1 return False except: n_history[n]=0 digit_li=[str(n)[i] for i in range(len(str(n)))] n=sum(list(map(lambda x:(int(x))**2,digit_li))) if n==1: return True``` 相当于把数字n转换成字符串，再进行平方和运算 ```python class Solution: def isHappy(self, n: int) -&gt; bool: seen = set() while n != 1: if n in seen: return False seen.add(n) num = str(n) temp = 0 for ch in num: temp += int(ch)**2 n = temp return True ``` hashset解法```pythonclass Solution: def isHappy(self, n: int) -&gt; bool: def get_next(n): total_sum = 0 while n &gt; 0: n, digit = divmod(n, 10) #divmod求余数 total_sum += digit ** 2 return total_sum seen = set() # python里hashset的本质就是set while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"title":"169. Majority Element(easy)","path":"2022/08/19/169/","text":"169. Majority Element(easy)Given an array nums of size n, return the majority element.The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.1234Example 1:Input: nums = [3,2,3]Output: 3 堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。class Solution: def majorityElement(self, nums: List[int]) -&gt; int: hashmap = &#123;&#125; n=len(nums) for ans in nums: if ans not in hashmap: hashmap[ans]=1 else: hashmap[ans]+=1 for ans in hashmap: if hashmap[ans]&gt;n//2: return ans"},{"title":"101. Symmetric Tree (Easy)","path":"2022/08/17/101/","text":"101. Symmetric Tree (Easy)Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).123456789101112131415161718192021class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True def dfs(left,right): # 递归的终止条件是两个节点都为空 # 或者两个节点中有一个为空 # 或者两个节点的值不相等 if not (left or right): return True if not (left and right): return False if left.val!=right.val: return False return dfs(left.left,right.right) and dfs(left.right,right.left) # 用递归函数，比较左节点，右节点 return dfs(root.left,root.right)"},{"title":"572. Subtree of Another Tree (Easy)","path":"2022/08/17/572/","text":"572. Subtree of Another Tree (Easy)Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isSubtree(self, root, subRoot) : queue = [root] while len(queue) &gt; 0: curr = queue.pop(0) if curr.val == subRoot.val : if self.compare(curr,subRoot): return True if curr.right: queue.append(curr.right) if curr.left: queue.append(curr.left) return False def compare(self,curr,subRoot): if curr is None and subRoot is None: return True elif not curr is None and subRoot is None : return False elif curr is None and not subRoot is None : return False elif curr.val == subRoot.val : r_flag = self.compare(curr.right,subRoot.right) l_flag = self.compare(curr.left,subRoot.left) if r_flag and l_flag: return True"},{"title":"437. Path Sum III (Easy)","path":"2022/08/17/437/","text":"437. Path Sum III (Easy)Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).前缀和思路与算法我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为 \\rightarrow p_1 \\rightarrow p_2 \\rightarrow \\ldots \\rightarrow p_k \\rightarrow root→p1​ →p2​ →…→pk​ →node，此时我们可以已经保存了节点 p_1, p_2, p_3, \\ldots, p_kp1​ ,p2​ ,p3​ ,…,pk​ 的前缀和，并且计算出了节点 node 的前缀和。 假设当前从根节点 root 到节点 node 的前缀和为 \\textit{curr}curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 \\textit{curr} - curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 p_ipi​ 到根节点 root 的前缀和为 \\textit{curr} - curr−targetSum，则节点 p_{i+1}pi+1​ 到 node 的路径上所有节点的和一定为 targetSum。 我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。 作者：LeetCode-Solution链接：https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"112. Path Sum (Easy)","path":"2022/08/16/112/","text":"112. Path Sum (Easy)Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.A leaf is a node with no children.官方题解 观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。 假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。 不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。 复杂度分析 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。 空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。 12345678910111213141516 # Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool: if not root: return False if not root.left and not root.right: return targetSum == root.val return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)"},{"title":"617. Merge Two Binary Trees (Easy)","path":"2022/08/15/617/","text":"617. Merge Two Binary Trees (Easy)You are given two binary trees root1 and root2.Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.Return the merged tree.Note: The merging process must start from the root nodes of both trees.参考解析对于二叉树来说，如果我们像遍历数组那样，挨个遍历两颗二叉树中的每个节点，再把他们相加，那问题就比较容易解决了。 遍历二叉树很简单，用 前序 遍历就可以了，再依次把访问到的节点值相加，因为题目没有说不能改变树的值和结构，我们不用再创建新的节点了，直接将树2合并到树1上再返回就可以了。需要注意：这两颗树并不是长得完全一样，有的树可能有左节点，但有的树没有。 总结下递归的条件： 终止条件：树 1 的节点为 null，或者树 2 的节点为 null递归函数内：将两个树的节点相加后，再赋给树 1 的节点。再递归的执行两个树的左节点，递归执行两个树的右节点 总结一下就是把root2的值复制到root1上 12345678910111213141516171819 # Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]: def dfs(root1,root2): if not (root1 and root2): return root1 if root1 else root2 root1.val += root2.val root1.left = dfs(root1.left,root2.left) root1.right = dfs(root1.right,root2.right) return root1 return dfs(root1,root2)"},{"title":"226. Invert Binary Tree (Easy)","path":"2022/08/15/226/","text":"226. Invert Binary Tree (Easy)Given the root of a binary tree, invert the tree, and return its root.官方题解这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]: if not root: return root left = self.invertTree(root.left) right = self.invertTree(root.right) root.left = right root.right = left return root"},{"title":"543. Diameter of Binary Tree (Easy)","path":"2022/08/14/543/","text":"543. Diameter of Binary Tree (Easy)Given the root of a binary tree, return the length of the diameter of the tree.The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.The length of a path between two nodes is represented by the number of edges between them.经典重现 官方题解深度优先搜索其实我看到这道题感觉和110. Balanced Binary Tree (Easy)很像，可以在求高度的基础上稍微改一下首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。 而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。 假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。 我们记节点node 为起点的路径经过节点数的最大值为 dnode，那么二叉树的直径就是所有节点 dnode的最大值减一。 最后的算法流程为：我们定义一个递归函数 depth(node) 计算 dnode，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为max(L,R)+1 该节点的 dnode 值为L+R+1 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int: self.ans = 1 def depth(root): # 访问到空节点了，返回0 if not root: return 0 # 左儿子为根的子树的深度 L = depth(root.left) # 右儿子为根的子树的深度 R = depth(root.right) # 计算d_node即L+R+1 并更新ans self.ans = max(self.ans, L + R + 1) # 返回该节点为根的子树的深度 return max(L, R) + 1 depth(root) return self.ans - 1"},{"title":"110. Balanced Binary Tree (Easy)","path":"2022/08/14/110/","text":"110. Balanced Binary Tree (Easy)Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as:a binary tree in which the left and right subtrees of every node differ in height by no more than 1.经典重现 平衡二叉树两种办法 方法一：自顶向下的递归定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：height(p)=max(height(p.left),height(p.right))+1 P是非空节点 有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。 12345678910class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def height(root: TreeNode) -&gt; int: if not root: return 0 return max(height(root.left), height(root.right)) + 1 if not root: return True return abs(height(root.left) - height(root.right)) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right) 方法二：自底向上的递归方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。 自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。 1234567891011121314class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def height(root: TreeNode) -&gt; int: if not root: return 0 leftHeight = height(root.left) rightHeight = height(root.right) if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) &gt; 1: return -1 else: return max(leftHeight, rightHeight) + 1 return height(root) &gt;= 0 优化 123456789101112class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def helper(node): if not node: return 0 left_depth = helper(node.left) right_depth = helper(node.right) if abs(left_depth - right_depth) &gt; 1: flag[0] = False return max(left_depth, right_depth) + 1 flag = [True] helper(root) return flag[0] 这里为什么要用flag[0]而不是一个变量呢？直接一个变量需要加self关键字，否则传不进递归函数里，因为变量的赋值和初始化都是一个语法会导致歧义，所以递归里修改flag的值会当成定义一个新的flag变量，而这个变量只在递归里生效，所以递归外部定义的flag无法被修改，大概类似局部变量和全局变量的区别，而列表、字典等，初始化和赋值的方法不同，因此不会导致歧义，所以函数对其修改也会改变调用代码中的值，结论如下: 列表、字典、集合：总是会按引用传入函数，函数代码组中对变量数据结构的任何改变都会反映到调用代码中。字符串、整数 、元组：总是会按值传入函数，函数中对变量的任何修改是这个函数私有的，不会反映到调用代码中。"},{"title":"104. Maximum Depth of Binary Tree (Easy)","path":"2022/08/14/104/","text":"104. Maximum Depth of Binary Tree (Easy)Given the root of a binary tree, return its maximum depth.A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.经典重现 这道题是求二叉树的深度，可以用深度优先搜索。算法思想： 一个节点的高度=max(左孩子的高度,右孩子的高度)+1。 进行先序遍历搜索，每次递归返回的时候统计其左右孩子中最大的深度。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if root is None: return 0 else: left_height = self.maxDepth(root.left) right_height = self.maxDepth(root.right) return max(left_height,right_height)+1"},{"title":"328. Odd Even Linked List (Medium)","path":"2022/08/06/328/","text":"328. Odd Even Linked List (Medium)Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.The first node is considered odd, and the second node is even, and so on.Note that the relative order inside both the even and odd groups should remain as it was in the input.You must solve the problem in O(1) extra space complexity and O(n) time complexity.总结是把奇数节点串一块儿，再把偶数节点串一起，然后把两个连成一条链表 官方题解 12345678910111213141516class Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head: return head evenHead = head.next #新建一个链表头 odd, even = head, evenHead while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head"},{"title":"725. Split Linked List in Parts(Medium)","path":"2022/08/06/725/","text":"725. Split Linked List in Parts(Medium)Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.Return an array of the k parts.题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。其实就是n个数分成m组，前面一些组多一个，n/m+1，后面的组数量是n/m 代码 1234567891011121314151617181920212223242526class Solution: def splitListToParts(self, head: ListNode, k: int) -&gt; List[ListNode]: L = 0 node = head while node: #一次遍历得到长度 L += 1 node = node.next quotient, remainder = L // k, L % k parts = [None for _ in range(k)] #create lists of size n and initialize with None i, curr = 0, head while i &lt; k and curr: parts[i] = curr if i&lt;remainder: part_size = quotient + 1 else: part_size = quotient for _ in range(part_size - 1): #for _ in range:When you are not interested in some values returned by a function we use underscore in place of variable name . Basically it means you are not interested in how many times the loop is run till now just that it should run some specific number of times overall. curr = curr.next next = curr.next curr.next = None curr = next i += 1 return parts"},{"title":"234. Palindrome Linked List (Easy)","path":"2022/08/04/234/","text":"234. Palindrome Linked List (Easy)Given the head of a singly linked list, return true if it is a palindrome.这道题的关键在于如何控制空间复杂度。 官方题解O(n):简单来说就是把链表的数值全都存到数组里，然后再进行判断 123456789class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: vals = [] current_node = head while current_node is not None: vals.append(current_node.val) current_node = current_node.next return vals == vals[::-1] O(1):避免使用 O(n)额外空间的方法就是改变输入。 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。 该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。 算法 整个流程可以分为以下五个步骤： 找到前半部分链表的尾节点。 反转后半部分链表。 判断是否回文。 恢复链表。 返回结果。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head is None: return True # 找到前半部分链表的尾节点并反转后半部分链表 first_half_end = self.end_of_first_half(head) second_half_start = self.reverse_list(first_half_end.next) # 判断是否回文 result = True first_position = head second_position = second_half_start while result and second_position is not None: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # 还原链表并返回结果 first_half_end.next = self.reverse_list(second_half_start) return result def end_of_first_half(self, head): fast = head slow = head while fast.next is not None and fast.next.next is not None: fast = fast.next.next slow = slow.next return slow def reverse_list(self, head): previous = None current = head while current is not None: next_node = current.next current.next = previous previous = current current = next_node return previous 回文链表这里运用到一个非常有趣的方法，借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表 实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已 首先，寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。对于单链表，无法直接倒序遍历，可以造一条新的反转链表，可以利用链表的后序遍历，也可以用栈结构倒序处理单链表。 具体到回文链表的判断问题，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到 O(1)。 优化1. 先通过 双指针技巧 中的快慢指针来找到链表的中点：1234567ListNode slow, fast;slow = fast = head;while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next;&#125;// slow 指针现在指向链表中点 2. 如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步：12if (fast != null) slow = slow.next; 3. 从slow开始反转后面的链表，现在就可以开始比较回文串了：12345678910ListNode left = head;ListNode right = reverse(slow);while (right != null) &#123; if (left.val != right.val) return false; left = left.next; right = right.next;&#125;return true; 4. 总代码java 原版 123456789101112131415161718192021222324252627282930313233boolean isPalindrome(ListNode head) &#123; ListNode slow, fast; slow = fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; if (fast != null) slow = slow.next; ListNode left = head; ListNode right = reverse(slow); while (right != null) &#123; if (left.val != right.val) return false; left = left.next; right = right.next; &#125; return true;&#125;ListNode reverse(ListNode head) &#123; ListNode pre = null, cur = head; while (cur != null) &#123; ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre;&#125; python 改版 12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def isPalindrome(self, head: Optional[ListNode]) -&gt; bool: def reverse(head): pre = None current = head while current: nxt = current.next current.next = pre pre = current current = nxt return pre slow =head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if fast: slow = slow.next left = head right = reverse(slow) while right: if left.val!=right.val: return False left= left.next right = right.next return True"},{"title":"445. Add Two Numbers II (Medium)","path":"2022/08/04/445/","text":"445. Add Two Numbers II (Medium)You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example: 12Input: l1 = [7,2,4,3], l2 = [5,6,4]Output: [7,8,0,7] 这个例子想讲的其实就是7243+564=7807 官方题解本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。 对于逆序处理应该首先想到栈代码 123456789101112131415161718192021class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: s1, s2 = [], [] while l1: s1.append(l1.val) l1 = l1.next while l2: s2.append(l2.val) l2 = l2.next ans = None carry = 0 while s1 or s2 or carry != 0: a = 0 if not s1 else s1.pop() b = 0 if not s2 else s2.pop() cur = a + b + carry carry = cur // 10 cur %= 10 curnode = ListNode(cur) curnode.next = ans ans = curnode return ans"},{"title":"24. Swap Nodes in Pairs (Medium)","path":"2022/08/04/24/","text":"24. Swap Nodes in Pairs (Medium)Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)官方题解12345678class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head newHead = head.next head.next = self.swapPairs(newHead.next) newHead.next = head return newHead"},{"title":"19. Remove Nth Node From End of List (medium)","path":"2022/08/01/19/","text":"19. Remove Nth Node From End of List (medium)Given the head of a linked list, remove the nth node from the end of the list and return its head.移除倒序的第n个节点 第一反应是两次遍历，第一次遍历先判断链表长度L，然后再遍历第二次算出应该删除的L−n+1节点 1234567891011121314151617class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def getLength(head: ListNode) -&gt; int: length = 0 while head: length += 1 head = head.next return length # 添加哑结点dummy dummy = ListNode(0, head) length = getLength(head) current = dummy for i in range(1, length - n + 1): current = current.next current.next = current.next.next return dummy.next 方法二 双指针解决问题思路：我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。 设置虚拟节点 dummyHead 指向 head 设定双指针 p 和 q，初始都指向虚拟节点 dummyHead 移动 q，直到 p 与 q 之间相隔的元素个数为 n 同时移动 p 与 q，直到 q 指向的为 NULL 将 p 的下一个节点指向下下个节点 代码：123456789101112131415class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dummy = ListNode(0, head) first = head second = dummy for i in range(n): first = first.next while first: first = first.next second = second.next second.next = second.next.next return dummy.next 添加哑节点：添加一个哑节点（dummy node），让它的next 指针指向链表的头节点。这样一来，头节点的前驱节点就是哑节点本身。 1dummy = ListNode(0,head) 1234567891011121314151617class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def findNth(head,n): p1=head for i in range(n): p1 = p1.next p2 = head while p1: p2 = p2.next p1= p1.next return p2 dummy = ListNode(-1) dummy.next = head x = findNth(dummy,n+1) x.next = x.next.next return dummy.next"},{"title":"83. Remove Duplicates from Sorted List (Easy)","path":"2022/08/01/83/","text":"83. Remove Duplicates from Sorted List (Easy)Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.删除重复节点因为是有序节点，经过一遍遍历，把重复的删除就可以了 123456789101112class Solution: def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if not head: return head current = head while current.next: if current.val== current.next.val: current.next = current.next.next else: current = current.next return head"},{"title":"206. Reverse Linked List(easy)","path":"2022/07/20/206/","text":"206. Reverse Linked List(easy)Given the head of a singly linked list, reverse the list, and return the reversed list. 反转数组，还是用双指针，另外设置了一个临时变量tmp记录current的下一个值图例可以看这个回答 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: pre = None current = head while current !=None: tmp = current.next current.next = pre pre = current current = tmp return pre"},{"title":"160. Intersection of Two Linked Lists (Easy)","path":"2022/07/20/160/","text":"160. Intersection of Two Linked Lists (Easy)Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure.Note that the linked lists must retain their original structure after the function returns.Custom Judge:The inputs to the judge are given as follows (your program is not given these inputs):intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.解法：这道题可以通过双指针的方法解决，一开始想的是通过两个链表的公共部分从后往前，但是该题题解里有个思路很好：160. 相交链表（双指针，清晰图解） ListA 头节点 headA 到 公共node 前，共有 a - c 个节点；ListB 头节点 headB 到 公共node 前，共有 b - c 个节点； 考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作： 指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 公共node 时，共走步数为：a + (b - c) = a + b - c 指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 公共node 时，共走步数为：b + (a - c) = a + b - c 所以这就有可以操作的地方了 如下式所示，此时指针 A , B 重合，并有两种情况： a + (b - c) = b + (a - c) 若两链表 有 公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node 。若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。 其实就是两边互相换家走一遍，相当于从一开始的头结点开始，指针A,B都走一遍list A和list B 12345678class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: A, B = headA, headB while A != B: A = A.next if A else headB B = B.next if B else headA return A 这行代码 1A = A.next if A else headB 其实没看懂实现逻辑（基础不牢固），后来搜了一下是python的一个条件表达式 123456789It&#x27;s a conditional expression:A if PREDICATE else BA is yielded if PREDICATE is true, otherwise B is yielded.&gt;&gt;&gt; &#x27;A&#x27; if 1 &lt; 2 else &#x27;B&#x27;&#x27;A&#x27;&gt;&gt;&gt; &#x27;A&#x27; if 1 &gt; 2 else &#x27;B&#x27;&#x27;B&#x27; 换成完整版就是 123if 1 &lt; 2: &#x27;A&#x27;else: &#x27;B&#x27; 所以题解里的写法其实可以写成 12345678910111213class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]: a,b= headA,headB while a!=b: if a: a =a.next else: a= headB if b: b =b.next else: b = headA return a"},{"title":"LeetCode12-Tree","path":"2022/07/20/LeetCode12-Tree/","text":"参考： Leetcode 题解 - 链表leetcode tag如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。 一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。"},{"title":"2. Add Two Numbers(medium)","path":"2022/07/15/2/","text":"2. Add Two Numbers(medium)You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.123Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807. 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: pre = ListNode(-1) current = pre carry = 0 while l1!=None or l2!= None or carry!=0: l1val= l1.val if l1 else 0 l2val= l2.val if l2 else 0 columnSum = l1val+l2val+carry carry = columnSum //10 newNode = ListNode(columnSum%10) current.next = newNode current = newNode l1 = l1.next if l1 else None l2 = l2.next if l2 else None return pre.next"},{"title":"LeetCode11-Linked list","path":"2022/07/15/LeetCode11-Linked list/","text":"链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。 参考： Leetcode 题解 - 链表leetcode tag如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。 Labuladong本文就总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题： 1、合并两个有序链表 2、链表的分解 3、合并 k 个有序链表 4、寻找单链表的倒数第 k 个节点 5、寻找单链表的中点 6、判断单链表是否包含环并找出环起点 7、判断两个单链表是否相交并找出交点 这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。 学习如何添加dummy node 1234pre = ListNode(-1)pre.next = headcurrent = pre Linked List Cycle Linked List Cycle II(medium) Intersection of Two Linked Lists (Easy) Remove Nth Node From End of List 1234567891011121314151617class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def findNth(head,n): p1=head for i in range(n): p1 = p1.next p2 = head while p1: p2 = p2.next p1= p1.next return p2 dummy = ListNode(-1) dummy.next = head x = findNth(dummy,n+1) x.next = x.next.next return dummy.next Merge Two Sorted Lists(easy) class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: current = pre =ListNode() while list1 and list2: if list1.val&lt;list2.val: current.next = list1 list1, current = list1.next, list1 #list1 = list1.next #current = list1 else: current.next = list2 list2, current = list2.next, list2 #list2=list2.next #current = list2 if list1 or list2: current.next=list1 if list1 else list2 return pre.next 23 86 Middle of the Linked List(easy) Palindrome Linked List回文链表这里运用到一个非常有趣的方法，借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表"},{"title":"LeetCode10-Backtracking","path":"2022/07/14/LeetCode10-Backtracking/","text":"回溯题目总结：Backtracking Python problems+ solutions- interview prepleetcode tag"},{"title":"17. Letter Combinations of a Phone Number(medium)","path":"2022/07/14/17/","text":"17. Letter Combinations of a Phone Number(medium)Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.123456789phone = &#123;&#x27;2&#x27;:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;], &#x27;3&#x27;:[&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;], &#x27;4&#x27;:[&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;], &#x27;5&#x27;:[&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;], &#x27;6&#x27;:[&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;], &#x27;7&#x27;:[&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;], &#x27;8&#x27;:[&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;], &#x27;9&#x27;:[&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]&#125; 特点这题属于是hashmap记录数字和字母的对应关系，然后再用回溯的方法解决 leetcode题解解法：1234567891011121314151617181920212223242526class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if not digits: return [] phone = &#123;&#x27;2&#x27;:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;], &#x27;3&#x27;:[&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;], &#x27;4&#x27;:[&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;], &#x27;5&#x27;:[&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;], &#x27;6&#x27;:[&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;], &#x27;7&#x27;:[&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;], &#x27;8&#x27;:[&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;], &#x27;9&#x27;:[&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]&#125; def backtrack(conbination,nextdigit): if len(nextdigit) == 0: res.append(conbination) else: for letter in phone[nextdigit[0]]: backtrack(conbination + letter,nextdigit[1:]) res = [] backtrack(&#x27;&#x27;,digits) return res"},{"title":"12. Integer to Roman(medium)","path":"2022/07/13/12/","text":"12. Integer to Roman(medium)Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:1234I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. 特点这题和接下来的13题是完全相反的思路，本题（12题）是整数转罗马数字，13题是罗马数字转整数 12345Example 1:Input: num = 3Output: &quot;III&quot;Explanation: 3 is represented as 3 ones. 12345Example 2:Input: num = 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. 12345Example 3:Input: num = 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 罗马数字由 77 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 66 个复合符号。这给了我们总共 1313 个独特的符号（每个符号由 11 个或 22 个字母组成），如下图所示。 官方题解 罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。 解法：根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。 编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。遍历 valueSymbols 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。 12345678910111213141516171819202122232425262728class Solution: VALUE_SYMBOLS = [ (1000, &quot;M&quot;), (900, &quot;CM&quot;), (500, &quot;D&quot;), (400, &quot;CD&quot;), (100, &quot;C&quot;), (90, &quot;XC&quot;), (50, &quot;L&quot;), (40, &quot;XL&quot;), (10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;), ] def intToRoman(self, num: int) -&gt; str: roman = list() for value, symbol in Solution.VALUE_SYMBOLS: while num &gt;= value: num -= value roman.append(symbol) if num == 0: break return &quot;&quot;.join(roman) 123456789101112class Solution: def intToRoman(self, num: int) -&gt; str: # 使用哈希表，按照从大到小顺序排列 hashmap = &#123;1000:&#x27;M&#x27;, 900:&#x27;CM&#x27;, 500:&#x27;D&#x27;, 400:&#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50:&#x27;L&#x27;, 40:&#x27;XL&#x27;, 10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125; res = &#x27;&#x27; for key in hashmap: if num // key != 0: count = num // key # 比如输入4000，count 为 4 res += hashmap[key] * count num %= key return res"},{"title":"21. Merge Two Sorted Lists(easy)","path":"2022/07/04/21/","text":"21. Merge Two Sorted Lists(easy)You are given the heads of two sorted linked lists list1 and list2.Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.Return the head of the merged linked list.我们判断 list1 和 list2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归） leetcode题解递归的方法： 1234567891011class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: if not list1: return list2 # 终止条件，直到两个链表都空 if not list2: return list1 if list1.val &lt;= list2.val: # 递归调用 list1.next = self.mergeTwoLists(list1.next,list2) return list1 else: list2.next = self.mergeTwoLists(list1,list2.next) return list2 leetcode题解这个更好理解一些 12345678910111213141516class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: cur = dummy = ListNode() while list1 and list2: if list1.val &lt; list2.val: cur.next = list1 list1, cur = list1.next, list1 else: cur.next = list2 list2, cur = list2.next, list2 if list1 or list2: cur.next = list1 if list1 else list2 return dummy.next"},{"title":"13. Roman to Integer(easy)","path":"2022/07/01/13/","text":"13. Roman to Integer(easy)Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 官方题解 这题的特点通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。 例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。 若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。 例如 XIV 可视作 X−I+V=10−1+5=14。 但是评论里有超神思路：从右到左遍历，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减，更好理解吧 12345678910111213141516class Solution: def romanToInt(self, s: str) -&gt; int: mapping = &#123; &#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000 &#125; highestLevel = 1 result = 0 for ch in s[::-1]: level = mapping[ch] if level &gt;= highestLevel: result += level highestLevel = level else: result -= level return result"},{"title":"9. Palindrome Number(easy)","path":"2022/07/01/9/","text":"9. Palindrome Number(easy)Given an integer x, return true if x is palindrome integer.An integer is a palindrome when it reads the same backward as forward.For example, 121 is a palindrome while 123 is not.找到回文数 官方题解反转一半数字思路 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。 第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。 按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。 例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。 算法首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。 现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。 现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？ 由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。 根据官方题解改的python代码 12345678910class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0 or (x % 10 == 0 and x != 0): return False revertedNumber = 0 while x &gt; revertedNumber: revertedNumber = revertedNumber * 10 + x % 10 x //= 10 return x == revertedNumber or x == revertedNumber // 10"},{"title":"15. 3Sum(medium)","path":"2022/07/01/15/","text":"15. 3Sum(medium)Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets.三数之和，经典题目 题解算法流程： 特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 []。 对数组进行排序。 遍历排序后数组：a. 若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。b. 对于重复元素：跳过，避免出现重复解c. 令左指针 L=i+1，右指针 R=n-1，当 L&lt;R 时，执行循环：当 nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解若和大于 0，说明 nums[R] 太大，R 左移若和小于 0，说明 nums[L] 太小，L 右移 1234567891011121314151617181920212223242526272829class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: n=len(nums) res=[] if(not nums or n&lt;3): return [] nums.sort() res=[] for i in range(n): if(nums[i]&gt;0): return res if(i&gt;0 and nums[i]==nums[i-1]): continue L=i+1 R=n-1 while(L&lt;R): if(nums[i]+nums[L]+nums[R]==0): res.append([nums[i],nums[L],nums[R]]) while(L&lt;R and nums[L]==nums[L+1]): L=L+1 while(L&lt;R and nums[R]==nums[R-1]): R=R-1 L=L+1 R=R-1 elif(nums[i]+nums[L]+nums[R]&gt;0): R=R-1 else: L=L+1 return res 123456789101112131415161718192021222324def threeSum(self, nums): nums.sort() result = [] for left in range(len(nums) - 2): # renamed this to left because this will always be the leftmost pointer in the triplet if left &gt; 0 and nums[left] == nums[left - 1]: # this step makes sure that we do not have any duplicates in our result output continue mid = left + 1 # renamed this to mid because this is the pointer that is between the left and right pointers right = len(nums) - 1 while mid &lt; right: curr_sum = nums[left] + nums[mid] + nums[right] if curr_sum &lt; 0: mid += 1 elif curr_sum &gt; 0: right -= 1 else: result.append([nums[left], nums[mid], nums[right]]) while mid &lt; right and nums[mid] == nums[mid + 1]: # Another conditional for not calculating duplicates mid += 1 while mid &lt; right and nums[right] == nums[right - 1]: # Avoiding duplicates check right -= 1 mid += 1 right -= 1 return result"},{"title":"11. Container With Most Water(medium)","path":"2022/07/01/11/","text":"11. Container With Most Water(medium)You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container.看了题解，双指针，从两头开始内卷，先卷矮的那头 123456789101112131415class Solution: def maxArea(self, height: List[int]) -&gt; int: l = 0 r = len(height)-1 ans = 0 while l&lt;r: area = min(height[l],height[r])*(r-l) ans = max(ans,area) l= if height[l]&lt;height[r]: l+=1 else: r-=1 return ans 12345678910class Solution: def maxArea(self, height): L, R, width, res = 0, len(height) - 1, len(height) - 1, 0 for w in range(width, 0, -1): #range(start, stop, step) if height[L] &lt; height[R]: res, L = max(res, height[L] * w), L + 1 else: res, R = max(res, height[R] * w), R - 1 return res"},{"title":"3. Longest Substring Without Repeating Characters(medium)","path":"2022/07/01/3/","text":"3. Longest Substring Without Repeating Characters(medium)Given a string s, find the length of the longest substring without repeating characters.123Input: s = &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. 这道题第一反应是双指针，通过滑动窗口来解决，但有个需要解决的问题是如果判断substring的字母有重复的。 利用hashmap查找重复字母leetcode评论 123456789101112class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: k, res, c_dict = -1, 0, &#123;&#125; for i, c in enumerate(s): if c in c_dict and c_dict[c] &gt; k: # 字符c在字典中 且 上次出现的下标大于当前长度的起始下标 k = c_dict[c] c_dict[c] = i else: c_dict[c] = i res = max(res, i-k) return res 利用队列查找字母 1234567891011class Solution(object): def lengthOfLongestSubstring(self, s): lst = [] n = len(s) ans = 0 for i in range(n): while s[i] in lst: del lst[0] # 队首元素出队 lst.append(s[i]) # 排除重复元素后 新元素入队 ans = max(ans, len(lst)) return ans"},{"title":"LeetCode09-hashmap","path":"2022/06/28/LeetCode09-hashmap/","text":"参考： Leetcode 题解 - 目录.mdhashmap 官方hashmaptag Integer to Roman(medium)123456789101112class Solution: def intToRoman(self, num: int) -&gt; str: # 使用哈希表，按照从大到小顺序排列 hashmap = &#123;1000:&#x27;M&#x27;, 900:&#x27;CM&#x27;, 500:&#x27;D&#x27;, 400:&#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50:&#x27;L&#x27;, 40:&#x27;XL&#x27;, 10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125; res = &#x27;&#x27; for key in hashmap: if num // key != 0: count = num // key # 比如输入4000，count 为 4 res += hashmap[key] * count num %= key return res 123456789101112131415161718192021222324252627class Solution: VALUE_SYMBOLS = [ (1000, &quot;M&quot;), (900, &quot;CM&quot;), (500, &quot;D&quot;), (400, &quot;CD&quot;), (100, &quot;C&quot;), (90, &quot;XC&quot;), (50, &quot;L&quot;), (40, &quot;XL&quot;), (10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;), ] def intToRoman(self, num: int) -&gt; str: roman = list() for value, symbol in Solution.VALUE_SYMBOLS: while num &gt;= value: num -= value roman.append(symbol) if num == 0: break return &quot;&quot;.join(roman) Roman to Integer(easy)12345678910111213141516class Solution: def romanToInt(self, s: str) -&gt; int: mapping = &#123; &#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000 &#125; highestLevel = 1 result = 0 for ch in s[::-1]: level = mapping[ch] if level &gt;= highestLevel: result += level highestLevel = level else: result -= level return result 从这两题我们可以看出hashmap的基础写法： 12345678910111213141516171819202122mapping = &#123; &#x27;I&#x27;:1,&#x27;V&#x27;:5,&#x27;X&#x27;:10,&#x27;L&#x27;:50,&#x27;C&#x27;:100,&#x27;D&#x27;:500,&#x27;M&#x27;:1000 &#125;VALUE_SYMBOLS = [ (1000, &quot;M&quot;), (900, &quot;CM&quot;), (500, &quot;D&quot;), (400, &quot;CD&quot;), (100, &quot;C&quot;), (90, &quot;XC&quot;), (50, &quot;L&quot;), (40, &quot;XL&quot;), (10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;), ]hashmap = &#123;1000:&#x27;M&#x27;, 900:&#x27;CM&#x27;, 500:&#x27;D&#x27;, 400:&#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50:&#x27;L&#x27;, 40:&#x27;XL&#x27;, 10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5:&#x27;V&#x27;, 4:&#x27;IV&#x27;, 1:&#x27;I&#x27;&#125; 1"},{"title":"LeetCode08-动态规划","path":"2022/06/28/LeetCode08-动态规划/","text":"具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 动态规划素数分解每一个数都可以分解成素数的乘积 整除令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * … 令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * … 如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。 最大公约数最小公倍数x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * … x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * … Fibonacci Number(easy) Climbing Stairs Min Cost Climbing Stairs(easy)"},{"title":"914. X of a Kind in a Deck of Cards","path":"2022/06/27/914/","text":"914. X of a Kind in a Deck of CardsIn a deck of cards, each card has an integer written on it.Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:Each group has exactly X cards.All the cards in each group have the same integer."},{"title":"204. Count Primes (Easy)","path":"2022/06/27/204/","text":"204. Count Primes (Easy)Given an integer n, return the number of prime numbers that are strictly less than n.官方题解方法一：枚举很直观的思路是我们枚举每个数判断其是不是质数。 考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。 方法二：埃氏筛枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。 我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。 我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。 这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 yy 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 xx 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。 当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。 leetcode题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution(object): def countPrimes(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; # Sieve of Eratosthenes埃氏筛 # We are only interested in numbers LESS than the input number # exit early for numbers LESS than 2; (two is prime) if n &lt; 2: return 0 # create strike list for the input range, initializing all indices to # prime (1). strikes = [1] * n # we know that 0 and 2 are not prime strikes[0] = 0 strikes[1] = 0 # Now set multiples of remaining numbers that are marked as prime to # not prime. It is safe ignore numbers alreay marked as not prime # because there are factor(s) that divide evenly into this number and # all its multiples. Use upper limit of (n**0.5)+1, because: # (a) the smallest factor of a non-prime number will not be &gt; sqrt(n). # Ex. non-prime = 100, # 5*20 # 10*10, # 20*5 # !! we have seen 5 before. for i in range(2, int(n**0.5)+1): if strikes[i] != 0: # slow: #for j in range(i*i, n, i): # strikes[j] = 0 # 3x faster: # strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1) # n = 11 # i = 2 # (n-1-i*i)//i + 1 # (n-1) # get total # of indicies for n (non-inclusive) # -i*i # shift to get # of slots in range of interest # //i # get number of groups # + 1 # get number of slots # strikes[2*2:11:2] = [0] * ((11-1-2*2)//2 + 1 # strikes[4:11:2] = [0] * 4 # s[4], s[6], s[8], s10] = 0, 0, 0, 0 strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1) return sum(strikes) 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def countPrimes(self, n: int) -&gt; int: &quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数， 如果值为False则为合数 &quot;&quot;&quot; primes = [True] * n primes[0]=primes[1]=False result = 0 for i in range(2, n): # 如果当前值是素数，就将它倍数标记为合数 if primes[i]: result += 1 _power = i * i if _power &lt; n : for j in range(_power, n, i): primes[j] = False return resultclass Solution: def countPrimes(self, n: int) -&gt; int: &quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数， 如果值为False则为合数 &quot;&quot;&quot; if n&lt;3: return 0 primes = [True] * n primes[0]= primes[1] = False result = 0 for i in range(2, n): # 如果当前值是素数，就将它倍数标记为合数 if primes[i]: result += 1 _power = i * i if _power &lt; n : for j in range(_power, n, i): primes[j] = False return result"},{"title":"LeetCode07-数学","path":"2022/06/26/LeetCode07-数学/","text":"具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 数学素数分解每一个数都可以分解成素数的乘积 整除令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * … 令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * … 如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。 最大公约数最小公倍数x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * … x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * … 1. 生成素数序列2. 最大公约数3. 使用位操作和减法求解最大公约数进制转换1. 7 进制2. 16 进制3. 26 进制阶乘1. 统计阶乘尾部有多少个 0字符串加法减法1. 二进制加法2. 字符串加法相遇问题1. 改变数组元素使所有的数组元素都相等多数投票问题1. 数组中出现次数多于 n / 2 的元素其它1. 平方数2. 3 的 n 次方3. 乘积数组4. 找出数组中的乘积最大的三个数"},{"title":"LeetCode06-搜索","path":"2022/06/23/LeetCode06-搜索/","text":"具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 搜索BFS1. 计算在网格中从原点到特定点的最短路径长度2. 组成整数的最小平方数数量3. 最短单词路径DFS1. 查找最大的连通面积2. 矩阵中的连通分量数目3. 好友关系的连通分量数目4. 填充封闭区域5. 能到达的太平洋和大西洋的区域Backtracking1. 数字键盘组合2. IP 地址划分3. 在矩阵中寻找字符串4. 输出二叉树中所有从根到叶子的路径5. 排列6. 含有相同元素求排列7. 组合8. 组合求和9. 含有相同元素的组合求和10. 1-9 数字的组合求和11. 子集12. 含有相同元素求子集13. 分割字符串使得每个部分都是回文数14. 数独15. N 皇后BFS宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 bfs是按一层一层来访问的，所以适合有目标求最短路的步数，你想想层层搜索每次层就代表了一步。bfs优先访问的是兄弟节点，只有这一层全部访问完才能访问下一层，也就是说bfs第几层就代表当前可以走到的位置(结点).而dfs是按递归来实现的，它优先搜索深度，再回溯，优先访问的是没有访问过的子节点DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易”控制”)，BFS通过控制队列可以很好解决”爆队列”风险。它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。"},{"title":"95. Unique Binary Search Trees II (Medium)","path":"2022/06/21/95/","text":"95. Unique Binary Search Trees II (Medium)Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.12Input: n = 3Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 官方leetcode 题解12345678910111213141516171819202122232425class Solution: def generateTrees(self, n: int) -&gt; List[TreeNode]: def generateTrees(start, end): if start &gt; end: return [None,] allTrees = [] for i in range(start, end + 1): # 枚举可行根节点 # 获得所有可行的左子树集合 leftTrees = generateTrees(start, i - 1) # 获得所有可行的右子树集合 rightTrees = generateTrees(i + 1, end) # 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上 for l in leftTrees: for r in rightTrees: currTree = TreeNode(i) currTree.left = l currTree.right = r allTrees.append(currTree) return allTrees return generateTrees(1, n) if n else []"},{"title":"241. Different Ways to Add Parentheses (Medium)","path":"2022/06/21/241/","text":"241. Different Ways to Add Parentheses (Medium)Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.12345Input: expression = &quot;2-1-1&quot;Output: [0,2]Explanation:((2-1)-1) = 0 (2-(1-1)) = 2 分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。分治法解题的一般步骤（如图1）：（1）分解，将要解决的问题划分成若干规模较小的同类问题；（2）求解，当子问题划分得足够小时，用较简单的方法解决；（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。leetcode 题解1234567891011121314151617181920212223class Solution: def diffWaysToCompute(self, input: str) -&gt; List[int]: # 如果只有数字，直接返回 if input.isdigit(): return [int(input)] res = [] for i, char in enumerate(input): if char in [&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;]: # 1.分解：遇到运算符，计算左右两侧的结果集 # 2.解决：diffWaysToCompute 递归函数求出子问题的解 left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) # 3.合并：根据运算符合并子问题的解 for l in left: for r in right: if char == &#x27;+&#x27;: res.append(l + r) elif char == &#x27;-&#x27;: res.append(l - r) else: res.append(l * r) return res"},{"title":"34. Find First and Last Position of Element in Sorted Array","path":"2022/06/20/34/","text":"34. Find First and Last Position of Element in Sorted Array (Medium)Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].You must write an algorithm with O(log n) runtime complexity.12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] 这个是二分查找的模板123456def lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first &lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] &lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 Solution:123456789101112131415161718class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: def binarysearchleft(nums, target): left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right)//2 if nums[mid] &gt;= target: right = mid -1 else: left = mid + 1 return left start = binarysearchleft(nums, target) end = binarysearchleft(nums, target + 1) - 1 if start == len(nums) or nums[start] != target: return [-1, -1] else: return [start, end]"},{"title":"153. Find Minimum in Rotated Sorted Array (Medium)","path":"2022/06/20/153/","text":"153. Find Minimum in Rotated Sorted Array (Medium)Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:[4,5,6,7,0,1,2] if it was rotated 4 times.[0,1,2,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].Given the sorted rotated array nums of unique elements, return the minimum element of this array.You must write an algorithm that runs in O(log n) time.这个是二分查找的模板123456def lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first &lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] &lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 Solution:123456789101112class Solution: def findMin(self, nums: List[int]) -&gt; int: first,last = 0,len(nums)-1 while first&lt;last: mid = first+(last-first)//2 if nums[mid]&lt;nums[last] : last = mid else: first = mid +1 return nums[first]"},{"title":"278. First Bad Version (Easy)","path":"2022/06/20/278/","text":"278. First Bad Version (Easy)You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.12345678Input: n = 5, bad = 4Output: 4Explanation:call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. 官方题解因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。 注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。 具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。 这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。 这个是二分查找的模板123456def lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first &lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] &lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 solution 123456789101112131415161718# The isBadVersion API is already defined for you.# @param version, an integer# @return an integer# def isBadVersion(version):class Solution: def firstBadVersion(self, n: int) -&gt; int: first,last=1,n while first&lt;last: mid = first+(last-first)//2 if isBadVersion(mid): last= mid else: first = mid +1 return first"},{"title":"540. Single Element in a Sorted Array (Medium)","path":"2022/06/20/540/","text":"540. Single Element in a Sorted Array (Medium)You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.Return the single element that appears only once.Your solution must run in O(log n) time and O(1) space.题目描述：一个有序数组只有一个数不出现两次，找出这个数。你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。 1.二分查找官方题解利用列表有序的特点，可以使用二分查找降低时间复杂度。 这道题的特点在于比较的不是数字本身的大小，而是下标的奇偶性。因为只有一个数只出现一次，所以这个数字的下标就只能是偶数。 由于数组是有序的，因此数组中相同的元素一定相邻。对于下标 x 左边的下标 y，如果 nums[y]=nums[y+1]，则 y 一定是偶数；对于下标 x 右边的下标 z，如果 nums[z]=nums[z+1]，则 z 一定是奇数。由于下标 x 是相同元素的开始下标的奇偶性的分界，因此可以使用二分查找的方法寻找下标 x。 初始时，二分查找的左边界是 0，右边界是数组的最大下标。每次取左右边界的平均值 mid 作为待判断的下标，根据 mid 的奇偶性决定和左边或右边的相邻元素比较： 如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等； 如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。 如果上述比较相邻元素的结果是相等，则 mid&lt;x, 调整左边界。否则 mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 x 的值。 得到下标 x 的值之后，nums[x] 即为只出现一次的元素。 ⊕ 是按位异或运算符 当 mid 是偶数时， mid+1=mid⊕1； 当 mid 是奇数时， mid−1=mid⊕1。 注：按位异或 ^ ,按位或 | ,按位与 &amp;也就是说判断奇偶性是靠异或运算 这个是二分查找的模板123456def lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first &lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] &lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 1234567891011class Solution: def singleNonDuplicate(self, nums: List[int]) -&gt; int: low, high = 0, len(nums) - 1 while low &lt; high: mid = (low + high) // 2 if nums[mid] == nums[mid ^ 1]: low = mid + 1 else: high = mid return nums[low]"},{"title":"16. 3Sum Closest(medium)","path":"2022/06/16/16/","text":"16. 3Sum Closest(medium)Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.Return the sum of the three integers.You may assume that each input would have exactly one solution.排序 + 双指针这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。 优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def threeSumClosest(self, nums, target): n = len(nums) nums.sort() # 排序 ans = float(&#x27;inf&#x27;) for first in range(n-2): # 枚举第一个元素 if first &gt; 0 and nums[first] == nums[first-1]: continue # 保证first不会有重复 second, third = first + 1, n - 1 max_sum = nums[first] + nums[-2] + nums[-1] min_sum = nums[first] + nums[first + 1] + nums[first + 2] if max_sum &lt;= target: # 最大的数 if abs(max_sum - target) &lt; abs(ans - target): ans = max_sum continue elif min_sum &gt;= target: # 最小的数 if abs(min_sum - target) &lt; abs(ans - target): ans = min_sum break while second &lt; third: two_sum_target = target - nums[first] s = nums[second] + nums[third] if abs(s + nums[first] - target) &lt; abs(ans - target): ans = s + nums[first] if s &gt; two_sum_target: # 当前数值太大 右指针左移 third -= 1 while third &gt; second and nums[third] == nums[third + 1]: third -= 1 elif s &lt; two_sum_target: # 当前数值太小 左指针右移 second += 1 while third &gt; second and nums[second] == nums[second - 1]: second += 1 else: # 刚好等于 直接返回target即可 return target return ans"},{"title":"744. Find Smallest Letter Greater Than Target (Easy)","path":"2022/06/16/744/","text":"744. Find Smallest Letter Greater Than Target (Easy)Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.123456789Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;Output: &quot;f&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;Output: &quot;c&quot; 题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。 官方题解1.线性查找由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。 如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。 1234class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: return next((letter for letter in letters if letter &gt; target), letters[0]) 2.二分查找利用列表有序的特点，可以使用二分查找降低时间复杂度。 首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。 初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。 1234class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: return letters[bisect_right(letters, target)] if target &lt; letters[-1] else letters[0] 这个是二分查找的模板123456def lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first &lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] &lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 自己写的完全版123456789101112131415class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: first,last=0,len(letters)-1 # 注意如果目标值大于或等于有序列表的最后一项，返回值为首元素 #letters[-1]是列表最后一个元素 if target&gt;=letters[-1]: return letters[0] while first&lt;last: mid = first+ (last-first)//2 #1//2=0,向下取整 if letters[mid]&lt;=target: first=mid+1 else: last = mid return letters[first]"},{"title":"69. Sqrt(x) (Easy)","path":"2022/06/16/69/","text":"69. Sqrt(x) (Easy)Given a non-negative integer x, compute and return the square root of x.Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5方法一：二分查找123456789def lower_bound(array, first, last, value): # 求非降序范围[first, last)内第一个不小于value的值的位置 while first &lt; last: # 搜索区间[first, last)不为空 mid = first + (last - first) // 2 # 防溢出 if array[mid] &lt; value: first = mid + 1 else: last = mid return first # last也行，因为[first, last)为空的时候它们重合 123456789101112class Solution: def mySqrt(self, x: int) -&gt; int: left, right, ans = 0, x, -1 while left &lt;= right: mid = left+(left-right)//2 # 防溢出 if mid * mid &lt;= x: ans = mid left = mid + 1 else: right = mid - 1 return ans 123456789101112class Solution: def mySqrt(self, x: int) -&gt; int: left, right, ans = 0, x, -1 while left &lt;= right: mid = left+(right-left)//2 # 防溢出 #mid = (left + right) // 2 if mid * mid &lt;= x: ans = mid left = mid + 1 else: right = mid - 1 return ans 方法二：牛顿迭代"},{"title":"Leetcode05- 二分查找","path":"2022/06/16/Leetcode05-二分查找/","text":"具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 二分查找1. 求开方2. 大于给定元素的最小元素3. 有序数组的 Single Element4. 第一个错误的版本5. 旋转数组的最小数字6. 查找区间二分查找 binary search algorithm 时间复杂度二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。 m 计算有两种计算中值 m 的方式： m = (l + h) / 2m = l + (h - l) / 2l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。 未成功查找的返回值循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值： -1：以一个错误码表示没有查找到 keyl：将 key 插入到 nums 中的正确位置 模板 1234567891011121314int binarySearch(int[] nums, int target) &#123; // 一左一右两个指针相向而行 int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125;"},{"title":"763. Partition Labels (Medium)","path":"2022/06/13/763/","text":"763. Partition Labels (Medium)You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.Return a list of integers representing the size of these parts.Example: 123456Input: s = &quot;ababcbacadefegdehijhklij&quot;Output: [9,7,8]Explanation:The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.This is a partition so that each letter appears in at most one part.A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts. 思路:其实思路很简单，1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或一段的最后位置大。如果没有刚才的last或一段的最后位置大，无视它继续往后找。如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或一段的最后位置更新为当前的字母的最后位置。3，肯定到有一个时间，这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。注意题目要分隔后的长度，我们就用last - startindex + 1。4，找到一个分割位，更新一下起始位置，同理搜索就行了。 用字典的好处就是不用每次都搜索位置了。直接用字典存所有字符的最后位置就好了。 1234567891011121314151617class Solution: def partitionLabels(self, S: &quot;str&quot;) -&gt; &quot;list[int]&quot;: maxIndex = dict() # 记录每个字符最后的位置 for i in range(len(S)): maxIndex[S[i]] = i ans = list() # 当前片段开始位置和结束位置 start = 0 end = 0 # 遍历整个字符串S，寻找所有合适的解 for i in range(len(S)): end = max(maxIndex[S[i]], end) #如果最后位置比刚才的大，就更新最后位置 if i == end: #这里就是找到这一段的结束了，就说明当前位置的index和这个字母在字典里的最后位置应该是相同的。 ans.append(end - start + 1) # 加入result start = end + 1 return ans"},{"title":"53. Maximum Subarray (Easy)","path":"2022/06/13/53/","text":"53. Maximum Subarray (Easy)Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.A subarray is a contiguous part of an array.Example: 123Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 这题第一眼非常像买股票第一弹 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: minprice = float(&#x27;inf&#x27;) #float(&#x27;inf&#x27;)表示正无穷大 maxprofit = 0 #保存当前最大的利润 for price in prices: #一次遍历 maxprofit = max(price - minprice, maxprofit)#当前利润与最大的利润相比 minprice = min(price, minprice) #保存当前最小的价格 return maxprofit 本质上是动态规划问题：leetcode题解 方法一：动态规划「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。 本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。 关键 1：理解题意题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。 题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。 关键 2：如何定义子问题（如何定义状态）设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。 友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。， 我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。 例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题： 子问题 1：经过 -2 的连续子数组的最大和是多少；子问题 2：经过 1 的连续子数组的最大和是多少；子问题 3：经过 -3 的连续子数组的最大和是多少；子问题 4：经过 4 的连续子数组的最大和是多少；子问题 5：经过 -1 的连续子数组的最大和是多少；子问题 6：经过 2 的连续子数组的最大和是多少；子问题 7：经过 1 的连续子数组的最大和是多少；子问题 8：经过 -5 的连续子数组的最大和是多少；子问题 9：经过 4 的连续子数组的最大和是多少。一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。 例如「子问题 3」：经过 -3 的连续子数组的最大和是多少。 「经过 -3 的连续子数组」我们任意举出几个： [-2,1,-3,4] ，-3 是这个连续子数组的第 3 个元素；[1,-3,4,-1] ，-3 是这个连续子数组的第 2 个元素；……我们不确定的是：-3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下： 子问题 1：以 -2 结尾的连续子数组的最大和是多少；子问题 2：以 1 结尾的连续子数组的最大和是多少；子问题 3：以 -3 结尾的连续子数组的最大和是多少；子问题 4：以 4 结尾的连续子数组的最大和是多少；子问题 5：以 -1 结尾的连续子数组的最大和是多少；子问题 6：以 2 结尾的连续子数组的最大和是多少；子问题 7：以 1 结尾的连续子数组的最大和是多少；子问题 8：以 -5 结尾的连续子数组的最大和是多少；子问题 9：以 4 结尾的连续子数组的最大和是多少。我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2： 子问题 1：以 -2 结尾的连续子数组的最大和是多少；以 -2 结尾的连续子数组是 [-2]，因此最大和就是 -2。 子问题 2：以 1 结尾的连续子数组的最大和是多少；以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 1。 大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为： 一个数 a 加上负数的结果比 a 更小；一个数 a 加上 0 的结果不会比 a 更大；而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。 接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。 定义状态（定义子问题）dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。 说明：「结尾」和「连续」是关键字。 状态转移方程（描述子问题之间的联系）根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。 假设数组 nums 的值全都严格大于 0，那么一定有 dp[i] = dp[i - 1] + nums[i]。 可是 dp[i - 1] 有可能是负数，于是分类讨论： 如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。 思考初始值dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。 思考输出注意： 这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；123456789101112131415class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: size = len(nums) if size == 0: return 0 dp = [0 for _ in range(size)] dp[0] = nums[0] for i in range(1, size): if dp[i - 1] &gt;= 0: dp[i] = dp[i - 1] + nums[i] else: dp[i] = nums[i] return max(dp)"},{"title":"665. Non-decreasing Array(medium)","path":"2022/06/13/665/","text":"665. Non-decreasing Array(medium)Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).题目描述：判断一个数组是否能只修改一个数就成为非递减数组。 123Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 这道题的关键在于修改哪个数，本题在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。 思路:nums[i] &lt; nums[i - 1]: nums[i - 1] = nums[i]nums[i] &lt; nums[i - 2]: nums[i] = nums[i - 1] 1234567891011121314class Solution: def checkPossibility(self, nums: List[int]) -&gt; bool: cnt = 0 for i in range(1,len(nums)): if nums[i]&lt;nums[i-2] and i-2&gt;=0 : nums[i]=nums[i-1] cnt+=1 if nums[i]&lt;nums[i-1]: nums[i-1]= nums[i] cnt+=1 if cnt&lt;=1: return True"},{"title":"392. Is Subsequence (Medium)","path":"2022/06/13/392/","text":"392. Is Subsequence (Medium)Given two strings s and t, return true if s is a subsequence of t, or false otherwise.A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。 而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。 这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。 最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。 Example 12Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;Output: true 12345678910111213class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: i=j=0 while i&lt;len(s) and j&lt;len(t): if s[i]==t[j]: i+=1 j+=1 else: j+=1 if i==len(s): return True 自己写的双指针 12345678910111213class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: if len(s)&gt;len(t): return False if len(s)==0: return True resultword= 0 for i in range(0,len(t)): if resultword&lt;= len(s)-1: if s[resultword] == t[i]: resultword+=1 return resultword == len(s)"},{"title":"605. Can Place Flowers (Easy)","path":"2022/06/11/605/","text":"605. Can Place Flowers (Easy)You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.leetcode官解评论 非常巧妙的方法，用数学归纳法很容易推出来公式 统计连续的0的区间，分别有多少个连续的0即可。对于每一段0区间，都可以根据公式直接算出可以种几朵花。 公式可以通过数学归纳法推出来，很简单： 对于中间的0区间： 1~2个0：可种0朵； 3~4个：可种1朵； 5~6个：可种2朵； … count个：可种 (count-1)/2 朵 对于两头的0区间，由于左边、右边分别没有1的限制，可种花朵数稍有不同。 为了代码流程的统一，可以在数组最左边、数组最右边分别补1个0，意味着花坛左边、右边没有花。 这样公式就跟1相同了。 1234567891011121314151617181920class Solution: def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool: if not flowerbed: return 0 countofZero = 1 # 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0 canPlace = 0 # 可以种的花的数量 for bed in flowerbed: if bed == 0: # 遇到0，连续0的数量+1 countofZero += 1 else: #遇到1，结算上一段连续的0区间，看能种下几盆花：(countofZero-1)/2 canPlace += int((countofZero-1)/2) if canPlace &gt;= n: return True countofZero = 0; # 0的数量清零，开始统计下一个全0分区 #最后一段0区还未结算： countofZero += 1# 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0 canPlace += (countofZero-1)/2 if canPlace &gt;= n: return True"},{"title":"123. Best Time to Buy and Sell Stock III(hard)","path":"2022/06/11/123/","text":"123. Best Time to Buy and Sell Stock III(hard)You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).1234Input: prices = [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. 卖股票第三弹（hard题了） 卖股票一共六题，分别是122,123,188,309,714 和第二题差不多，但是限制了最多两次交易，之前的小技巧有些用不上了，所以还是得走动态规划的路子。 官方题解思路与算法 由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种： 未进行过任何操作； 只进行过一次买操作； 进行了一次买操作和一次卖操作，即完成了一笔交易； 在完成了一笔交易的前提下，进行了第二次买操作； 完成了全部两笔交易。 由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 buy1,sell1,,buy2,sell2 12345678910111213class Solution: def maxProfit(self, prices: List[int]) -&gt; int: n = len(prices) buy1 = buy2 = -prices[0] sell1 = sell2 = 0 for i in range(1, n): buy1 = max(buy1, -prices[i]) sell1 = max(sell1, buy1 + prices[i]) buy2 = max(buy2, sell1 - prices[i]) sell2 = max(sell2, buy2 + prices[i]) return sell2"},{"title":"122. Best Time to Buy and Sell Stock II (Easy)","path":"2022/06/11/122/","text":"122. Best Time to Buy and Sell Stock II (Easy)You are given an integer array prices where prices[i] is the price of a given stock on the ith day.On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.Find and return the maximum profit you can achieve.卖股票第二弹 卖股票一共六题，分别是122,123,188,309,714 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大利润 。 这一题一样是可以用贪心算法或者动态规划写的，但是我在官方题解评论区发现一个极其简单的小技巧。在本题中买卖都是无限次的，所以只要把盈利（也就是上升段）全部加在一起就可以了，相当于每隔一天算一次盈利，盈利为正算在总利润里，盈利为负就丢掉。 简单来说就是只要把所有的盈利加在一起。 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: res = 0 i = 1 for i in range(1,len(prices)): if prices[i]-prices[i-1]&gt;0: res += prices[i]-prices[i-1] return res"},{"title":"121. Best Time to Buy and Sell Stock (Easy)","path":"2022/06/11/121/","text":"121. Best Time to Buy and Sell Stock (Easy)You are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.其实这题是动态规划的问题.卖股票一共六题，分别是121,122,123,188,309,714 官方题解 12345678class Solution: def maxProfit(self, prices: List[int]) -&gt; int: minprice = float(&#x27;inf&#x27;) #float(&#x27;inf&#x27;)表示正无穷大 maxprofit = 0 #保存当前最大的利润 for price in prices: #一次遍历 maxprofit = max(price - minprice, maxprofit)#当前利润与最大的利润相比 minprice = min(price, minprice) #保存当前最小的价格 return maxprofit"},{"title":"406. Queue Reconstruction by Height(Medium)","path":"2022/06/11/406/","text":"406. Queue Reconstruction by Height(Medium)You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).Example123456Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。 渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。 在本题目中，首先对数对进行排序，按照数对的元素 1(身高) 降序排序，按照数对的元素 2 (人数)升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。 leetcode题解 注： 1key = lambda x: (-x[0], x[1])) 第一个元素降序，第二个元素升序排列，以第一个元素的降序排列优先 例子12345678A = [[1,4],[2,3],[3,4],[1,3],[1,2]]print(sorted(A,key=lambda x:x[1]))print(sorted(A,key = lambda x: (-x[0], x[1])))print(sorted(A,key = lambda x: (-x[0]))) 结果1234[[1, 2], [2, 3], [1, 3], [1, 4], [3, 4]][[3, 4], [2, 3], [1, 2], [1, 3], [1, 4]][[3, 4], [2, 3], [1, 4], [1, 3], [1, 2]] 本题例子1[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 所以排序完： 1[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]] 1234567891011class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: res = [] people = sorted(people, key = lambda x: (-x[0], x[1])) #排序 for p in people: if len(res) &lt;= p[1]: #比较的变量是当前数组的长度 res.append(p) elif len(res) &gt; p[1]: res.insert(p[1], p) # p is inserted at index p[1]（参与这次排序的P[1]) return res 123456789101112131415class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: if not people: return 0 people.sort(key=lambda balloon: balloon[1]) pos = people[0][1] ans = 1 for balloon in people: if balloon[0] &gt; pos: pos = balloon[1] ans += 1 return ans"},{"title":"452. Minimum Number of Arrows to Burst Balloons (Medium)","path":"2022/06/10/452/","text":"452. Minimum Number of Arrows to Burst Balloons (Medium)There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.Given the array points, return the minimum number of arrows that must be shot to burst all balloons.题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。 也是计算不重叠的区间个数，不过和 Non-overlapping points 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。 Example 12345Input:[[10,16], [2,8], [1,6], [7,12]]Output:2 排序 + 贪心这道题和 435. Non-overlapping Intervals (Medium) 有些类似，都是寻找重合区间 贪心：既然每个气球都需要被引爆，那么在满足引爆对箭限制最大的那个气球（因为它一定要被引爆，而箭和其它同时被引爆的气球 都可以迁就它，所以满足它是必须的） 的同时，引爆尽可能多其他的气球。 在付出不变的的前提下，获得尽可能多。 简单来说就是先按照区间右边边界从小到大排序，为了尽可能的多引爆气球，第一支箭射在第一个区间的最右边，根据后面区间的左端点判断一共引爆了哪些区间，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。 有个问题是这 nn 个气球对应的区间互不重叠，while 循环需要执行 n 次。所以当遇到x(j) ≤ y(i)时 我们可以直接跳出循环，y(j)就是下一个箭的位置。 官方题解 1234567891011121314class Solution: def findMinArrowShots(self, points: List[List[int]]) -&gt; int: if not points: return 0 points.sort(key=lambda balloon: balloon[1]) pos = points[0][1] ans = 1 for balloon in points: if balloon[0] &gt; pos: pos = balloon[1] ans += 1 return ans"},{"title":"435. Non-overlapping Intervals (Medium)","path":"2022/06/09/435/","text":"435. Non-overlapping Intervals (Medium)Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 题目描述：计算让一组区间不重叠所需要移除的区间个数。 先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。 按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 官方题解 12345678910111213141516class Solution: def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int: if not intervals: return 0 intervals.sort(key=lambda x: x[1]) n = len(intervals) right = intervals[0][1] ans = 1 for i in range(1, n): if intervals[i][0] &gt;= right: ans += 1 right = intervals[i][1] return n - ans 注释：key=lambda 元素: 元素[字段索引] 比如 print(sorted(C, key=lambda x: x[2])) x:x[]字母可以随意修改，排序方式按照中括号[]里面的维度进行排序，[0]按照第一维排序，[2]按照第三维排序 例子 1234567C = [(&#x27;e&#x27;, 4, 2), (&#x27;a&#x27;, 2, 1), (&#x27;c&#x27;, 5, 4), (&#x27;b&#x27;, 3, 3), (&#x27;d&#x27;, 1, 5)]print(sorted(C, key=lambda y: y[0]))#输出[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]print(sorted(C, key=lambda x: x[0]))#[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]print(sorted(C, key=lambda x: x[2]))[(&#x27;a&#x27;, 2, 1), (&#x27;e&#x27;, 4, 2), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5)]"},{"title":"455. Assign Cookies (Easy)","path":"2022/06/09/455/","text":"455. Assign Cookies (Easy)Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。 证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。 个人理解就是尽力把小的孩子喂饱，每轮都按照这样喂饱就是最优解 自己写的，按照题目逻辑s[j]&gt;=g[i]判断 123456789101112131415class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() n, m = len(g), len(s) i = j = count = 0 # greed factor g[i] # cookie size s[j] while i &lt; n and j &lt; m: if s[j]&gt;=g[i]: count +=1 i +=1 j+=1 return count 官方题解 123456789101112131415161718class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() n, m = len(g), len(s) i = j = count = 0 # greed factor g[i] # cookie size s[j] while i &lt; n and j &lt; m: while j &lt; m and g[i] &gt; s[j]: j += 1 if j &lt; m: count += 1 i += 1 j += 1 return count"},{"title":"LeetCode04-贪心思想","path":"2022/06/09/LeetCode04-贪心思想/","text":"具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 贪心思想1. 分配饼干2. 不重叠的区间个数3. 投飞镖刺破气球4. 根据身高和序号重组队列5. 买卖股票最大的收益6. 买卖股票的最大收益 II7. 种植花朵8. 判断是否为子序列9. 修改一个数成为非递减数组10. 子数组最大的和11. 分隔字符串使同种字符出现在一起保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。"},{"title":"75. Sort Colors (Medium)","path":"2022/06/09/75/","text":"75. Sort Colors (Medium)Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.You must solve this problem without using the library’s sort function.有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。个人理解就是三指针，跟之前的双指针差不多，和之前不同的是因为有三个区间所以要三个指针荷兰国旗问题参考 123456789101112131415class Solution: def sortColors(self, nums: List[int]) -&gt; None: a = c = 0 b = len(nums) - 1 while c &lt;= b: if nums[c] == 0: nums[a], nums[c] = nums[c], nums[a] a += 1 c += 1 elif nums[c] == 2: nums[c], nums[b] = nums[b], nums[c] b -= 1 else: c += 1"},{"title":"451. Sort Characters By Frequency (Medium)","path":"2022/06/09/451/","text":"Sort Characters By Frequency (Medium) Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.Return the sorted string. If there are multiple answers, return any of them.Leetcode 题解 这道题和 347. Top K Frequent Elements (Medium) 几乎一样，一个是数字一个是字符串，方法也类似 1.建哈希表，将字符串s中的每个字符计数2.根据哈希表中的值进行降序排序即可3.直接字符乘以数目 123456789101112131415161718class Solution(object): def frequencySort(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; hashmap = &#123;&#125; for ans in s: if ans not in hashmap: hashmap[ans] = 1 else: hashmap[ans] += 1 result = sorted(hashmap.items(),key=lambda hashmap:hashmap[1],reverse=True) s = &#x27;&#x27; for i in range(len(result)): res = result[i][0] * result[i][1] s += res return s"},{"title":"347. Top K Frequent Elements (Medium)","path":"2022/06/09/347/","text":"347. Top K Frequent Elements (Medium)Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.Top K 问题hashmap1.建哈希表，将数组中的每个数字计数2.根据哈希表中的值进行降序排序即可 12345678910111213141516171819class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: dic = &#123;&#125; for val in nums: if val not in dic: dic[val] = 1 else: dic[val] += 1 result = [] count = 0 for num in sorted(dic, key=dic.get, reverse=True): result.append(num) count += 1 if count == k: break return result 题解评论 用字典去代替数组会不会好一些；倒序遍历频次时，最大不超过 n-k+1 ；python3版本: 12345678910111213141516171819class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: hashMap = dict() for num in nums: hashMap[num] = hashMap.get(num, 0) + 1 bucket = dict() for x, v in hashMap.items(): if v not in bucket: bucket[v] = [x] else: bucket[v].append(x) res = [] for v in range(len(nums) - k + 1, -1, -1): if len(res) &gt;= k: break if v in bucket: res.extend(bucket[v]) return res python dict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值 leetcode题解 对于 topk 问题：最大堆求topk小，最小堆求 topk 大。 topk小：构建一个 k 个数的最大堆，当读取的数小于根节点时，替换根节点，重新塑造最大堆topk大：构建一个 k 个数的最小堆，当读取的数大于根节点时，替换根节点，重新塑造最小堆这一题的总体思路 总体时间复杂度 O(nlogk)前k个数构造 规模为 k+1 的最小堆 minheap， O(k)， 注意 +1 是因为占位节点。遍历规模k之外的数据，大于堆顶则入堆，下沉维护规模为k的最小堆 minheap. O(nlogk)(如需按频率输出，对规模为k的堆进行排序) 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: def sift_down(arr, root, k): &quot;&quot;&quot;下沉log(k),如果新的根节点&gt;子节点就一直下沉&quot;&quot;&quot; val = arr[root] # 用类似插入排序的赋值交换 while root&lt;&lt;1 &lt; k: child = root &lt;&lt; 1 # 选取左右孩子中小的与父节点交换 if child|1 &lt; k and arr[child|1][1] &lt; arr[child][1]: child |= 1 # 如果子节点&lt;新节点,交换,如果已经有序break if arr[child][1] &lt; val[1]: arr[root] = arr[child] root = child else: break arr[root] = val def sift_up(arr, child): &quot;&quot;&quot;上浮log(k),如果新加入的节点&lt;父节点就一直上浮&quot;&quot;&quot; val = arr[child] while child&gt;&gt;1 &gt; 0 and val[1] &lt; arr[child&gt;&gt;1][1]: arr[child] = arr[child&gt;&gt;1] child &gt;&gt;= 1 arr[child] = val stat = collections.Counter(nums) stat = list(stat.items()) heap = [(0,0)] # 构建规模为k+1的堆,新元素加入堆尾,上浮 for i in range(k): heap.append(stat[i]) sift_up(heap, len(heap)-1) # 维护规模为k+1的堆,如果新元素大于堆顶,入堆,并下沉 for i in range(k, len(stat)): if stat[i][1] &gt; heap[1][1]: heap[1] = stat[i] sift_down(heap, 1, k+1) return [item[0] for item in heap[1:]] 12"},{"title":"215. Kth Largest Element in an Array (Medium)","path":"2022/06/09/215/","text":"215. Kth Largest Element in an Array (Medium)Given an integer array nums and an integer k, return the kth largest element in the array.Note that it is the kth largest element in the sorted order, not the kth distinct element.leetcode题解 方法一. 快速排序（Quick Sort）快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔（Tony Hoare ）提出。 12345678910111213141516171819202122232425262728293031323334353637class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def partition(arr: List[int], low: int, high: int) -&gt; int: pivot = arr[low] # 选取最左边为pivot left, right = low, high # 双指针 while left &lt; right: while left&lt;right and arr[right] &gt;= pivot: # 找到右边第一个&lt;pivot的元素 right -= 1 arr[left] = arr[right] # 并将其移动到left处 while left&lt;right and arr[left] &lt;= pivot: # 找到左边第一个&gt;pivot的元素 left += 1 arr[right] = arr[left] # 并将其移动到right处 arr[left] = pivot # pivot放置到中间left=right处 return left def randomPartition(arr: List[int], low: int, high: int) -&gt; int: pivot_idx = random.randint(low, high) # 随机选择pivot arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low] # pivot放置到最左边 return partition(arr, low, high) # 调用partition函数 def topKSplit(arr: List[int], low: int, high: int, k: int) -&gt; int: # mid = partition(arr, low, high) # 以mid为分割点【非随机选择pivot】 mid = randomPartition(arr, low, high) # 以mid为分割点【随机选择pivot】 if mid == k-1: # 第k小元素的下标为k-1 return arr[mid] #【找到即返回】 elif mid &lt; k-1: return topKSplit(arr, mid+1, high, k) # 递归对mid右侧元素进行排序 else: return topKSplit(arr, low, mid-1, k) # 递归对mid左侧元素进行排序 n = len(nums) return topKSplit(nums, 0, n-1, n-k+1) # 第k大元素即为第n-k+1小元素 方法二. 堆排序（Heap Sort）堆排序（英语：Heapsort）是指利用堆（heap）这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。[摘自@维基百科] leetcode题解 堆与排序： 对于一个待排序的包含 nn 个元素的数组 numsnums，堆排序 通常包含以下几个基本步骤： 建堆：将待排序的数组初始化为大根堆（小根堆）。此时，堆顶的元素（即根节点）即为整个数组中的最大值（最小值）。 交换和调整：将堆顶元素与末尾元素进行交换，此时末尾即为最大值（最小值）。除去末尾元素后，将其他 n-1n−1 个元素重新构造成一个大根堆（小根堆），如此便可得到原数组 nn 个元素中的次大值（次小值）。 重复步骤二，直至堆中仅剩一个元素，如此便可得到一个有序序列了 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def maxHeapify(arr, i, end): j = 2*i + 1 while j &lt;= end: if j+1 &lt;= end and arr[j+1] &gt; arr[j]: j += 1 if arr[i] &lt; arr[j]: arr[i], arr[j] = arr[j], arr[i] i = j j = 2*i + 1 else: break def maxHepify(arr, i, end): # 大顶堆 j = 2*i + 1 # j为i的左子节点【建堆时下标0表示堆顶】 while j &lt;= end: # 自上而下进行调整 if j+1 &lt;= end and arr[j+1] &gt; arr[j]: # i的左右子节点分别为j和j+1 j += 1 # 取两者之间的较大者 if arr[i] &lt; arr[j]: # 若i指示的元素小于其子节点中的较大者 arr[i], arr[j] = arr[j], arr[i] # 交换i和j的元素，并继续往下判断 i = j # 往下走：i调整为其子节点j j = 2*i + 1 # j调整为i的左子节点 else: # 否则，结束调整 break n = len(nums) # 建堆【大顶堆】 for i in range(n//2-1, -1, -1): # 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整 maxHepify(nums, i, n-1) # 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆 # k-1次重建堆（堆顶元素），或 k次交换到尾部（倒数第k个元素） for j in range(n-1, n-k-1, -1): nums[0], nums[j] = nums[j], nums[0] # 堆顶元素（当前最大值）放置到尾部j maxHepify(nums, 0, j-1) # j-1变成尾部，并从堆顶0开始调整堆 return nums[-k] 基于快排的所有TopK问题简单python模板"},{"title":"LeetCode03-排序","path":"2022/06/03/LeetCode03-排序/","text":"具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 排序1. 快速选择2. 堆-Kth Element3. 桶排序4. 荷兰国旗问题 快速选择（快速排序） 用于求解 Kth Element 问题，也就是第 K 个元素的问题。 快速选择算法是基于快速排序算法思想的用于解决Top K 问题的算法 可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。 步骤：a. 从数列中挑出一个元素，称为 “基准”（pivot）; b. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； c. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 堆排序 用于求解 TopK Elements 问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。 堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。 快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。 可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。 桶排序桶排序，简单来说就是将待排序序列，按照序列值的大小划分成几个桶，分别对每组进行排序，排完序之后再按照一定的顺序合并所有的桶，即排序完成。 对这道题而言，设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。 把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。 荷兰国旗问题 “荷兰国旗问题” 是计算机科学中的一个经典题目，它是由Edsger Dijkstra提出的。荷兰国旗由红、白、蓝三色组成。 荷兰国旗问题：现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。 这个问题之所以叫荷兰国旗，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。"},{"title":"524. Longest Word in Dictionary through Deleting (Medium)","path":"2022/05/31/524/","text":"524. Longest Word in Dictionary through Deleting (Medium)Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。 官方题解1.只有双指针这题还真有些难度，主要是有些问题不能一眼看到逻辑和结果。 根据题意，我们需要解决三个问题： 给定字符串s删除一些字符后能得到数组的字符串 找最长的字符串 如果长度相同，选字典顺序最小的字符串官方例子：Input: s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]Output: “apple” 第一点很好理解，就是在s这个字符串里找到子串。就像在一个集合里找到子集一样，可以发现[“ale”,”apple”,”plea”]符合 最长的字符串就是比较子串长度了，[“apple”] 就比 [“ale”] 和 [“plea”]长度要长 字典顺序最小，这个就是比较在字母表上的顺序了，以 a、b、c……z 的顺序排列，a最小，假如还有个新单词 [“appla”],那和[“apple”]比较，虽然长度一样，但是a的字典顺序在e前，所以我们得选择[“appla”] 12345678910111213class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: res = &quot;&quot; for t in dictionary: i = j = 0 while i &lt; len(t) and j &lt; len(s): if t[i] == s[j]: i += 1 j += 1 if i == len(t): if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res 排序+双指针 123456789101112131415161718192021222324252627class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: m = len(s) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): if ord(s[i]) == j + 97: f[i][j] = i else: f[i][j] = f[i + 1][j] res = &quot;&quot; for t in dictionary: match = True j = 0 for i in range(len(t)): if f[j][ord(t[i]) - 97] == m: match = False break j = f[j][ord(t[i]) - 97] + 1 if match: if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res"},{"title":"141. Linked List Cycle (Easy)","path":"2022/05/31/141/","text":"141. Linked List Cycle(Easy)Given head, the head of a linked list, determine if the linked list has a cycle in it.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.Return true if there is a cycle in the linked list. Otherwise, return false.快慢指针 官方题解：「Floyd 判圈算法」（又称龟兔赛跑算法）假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。 官方解法 123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True leetcode discussion（速度更快，但逻辑是类似的） 1234567891011class Solution: def hasCycle(self, head): try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False 这里有一点小不同 1while slow is not fast: 1while slow != fast: 这两个的编译速度在我多次尝试后发现没什么不同，应该没有什么影响"},{"title":"88. Merge Sorted Array (Easy)","path":"2022/05/29/88/","text":"88. Merge Sorted Array (Easy)You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.Merge nums1 and nums2 into a single array sorted in non-decreasing order.The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.python 数组技巧array[n:]：打印从第n个元素（下标为n-1）到最后一个元素(包括第n个元素)array[:n]：打印从第一个元素到第n个元素（下标为n-1）（包括第n个元素） Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6]Explanation: The arrays we are merging are [1,2,3] and [2,5,6].The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. 12345678910111213141516171819202122class Solution: def merge(self, nums1, m, nums2, n): while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] def merge(self, nums1, m, nums2, n): while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n]"},{"title":"680. Valid Palindrome II (Easy)","path":"2022/05/28/680/","text":"680. Valid Palindrome II(Easy)Given a string s, return true if the s can be palindrome after deleting at most one character from it.官方题解：list+双指针1234567891011121314151617class Solution(object): def validPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; isPalindrome = lambda s: s == s[::-1] strPart = lambda s, x: s[:x] + s[x + 1:] left = 0 right = len(s) - 1 while left &lt; right: if s[left] != s[right]: return isPalindrome(strPart(s, left)) or isPalindrome(strPart(s, right)) left += 1 right -= 1 return True 123456789101112class Solution(object): def validPalindrome(self, s): # Time: O(n) # Space: O(n) left, right = 0, len(s) - 1 while left &lt; right: if s[left] != s[right]: one, two = s[left:right], s[left + 1:right + 1] return one == one[::-1] or two == two[::-1] left, right = left + 1, right - 1 return True 123456789101112131415class Solution: def validPalindrome(self, s: str) -&gt; bool: i = 0 j = len(s)-1 while i &lt; j: if s[i] != s[j]: delete_i = s[i+1:j+1] delete_j = s[i:j] return self._isPalindrome(delete_i) or self._isPalindrome(delete_j) i += 1 j -= 1 return True def _isPalindrome(self, s): return s == s[::-1]"},{"title":"345. Reverse Vowels of a String (Easy)","path":"2022/05/28/345/","text":"345. Reverse Vowels of a StringGiven a string s, reverse only all the vowels in the string and return it.The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases.官方题解：list+双指针1234567891011121314151617181920class Solution: def reverseVowels(self, s: str) -&gt; str: def isVowel(ch: str) -&gt; bool: return ch in &quot;aeiouAEIOU&quot; n = len(s) s = list(s) left, right = 0, n - 1 while left &lt; right: while left &lt; n and not isVowel(s[i]): left += 1 while right &gt; 0 and not isVowel(s[j]): right -= 1 if left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return &quot;&quot;.join(s) 1234567891011121314151617class Solution(object): def reverseVowels(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; temp=[]#存储遇到的元音 for i in range(len(s)): if s[i] in [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;]: temp.append(s[i]) k=len(temp) s=list(s) for i in range(len(s)): if s[i] in [&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;]: s[i]=temp[k-1]#temp从后往前取值去覆盖 k-=1 return &#x27;&#x27;.join(s) list+双指针 123456789101112131415class Solution: def reverseVowels(self, s): vowels = [&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;A&quot;, &quot;E&quot;, &quot;I&quot;, &quot;O&quot;, &quot;U&quot;] # 元音字母列表 s = list(s) # 列表化输入字符串 left, right = 0, len(s) - 1 # 初始化左右指针位置 while left &lt; right: # 如果指针位置合法 if s[left] not in vowels: # 如果左指针处字符不是元音字母 left += 1 # 左指针右移 elif s[right] not in vowels: # 如果右指针处字符不是元音字母 right -= 1 # 右指针左移 else: # 如果左右指针处字符都是元音字母 s[left], s[right] = s[right], s[left] # 交换位置 left += 1 # 左指针右移 right -= 1 # 右指针左移 return &#x27;&#x27;.join(s) # 将列表中的字符连接起来"},{"title":"633. Sum of Square Numbers (Medium)","path":"2022/05/28/633-Sum of Square Numbers/","text":"633. Sum of Square NumbersGiven a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c.同样是双指针 本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。 因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。 123456789101112class Solution(object): def judgeSquareSum(self, c): l, r = 0, int(c**0.5) while l &lt;= r: sum = l*l+r*r if sum &lt; c: l +=1 elif sum&gt;c: r -=1 else: return True return False"},{"title":"167. Two Sum II - Input array is sorted (Easy)","path":"2022/05/28/167-twosum-sorted/","text":"167. Two Sum II - Input Array Is SortedGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.The tests are generated such that there is exactly one solution. You may not use the same element twice.Your solution must use only constant extra space.和第一题几乎可以用同样的思路，只不过这里的index从1开始，而且有序数组比第一题更简单 根据第一题改的hashmap123456789class Solution(object): def twoSum(self, numbers, target): Hashmap = &#123;&#125; for index, value in enumerate(numbers): key = target - value if key in Hashmap: return [Hashmap[key]+1, index+1] else: Hashmap[value] = index Two pointers: O(n) time and O(1) spaceDictionary: O(n) time and O(n) spaceBinary search: O(nlogn) time and O(1) space two-pointer1234567891011class Solution(object): def twoSum(self, numbers, target): l, r = 0, len(numbers)-1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: return [l+1, r+1] elif s &lt; target: l += 1 else: r -= 1 dictionary123456789101112131415161718192021222324class Solution(object): def twoSum(self, numbers, target): dic = &#123;&#125; for i, num in enumerate(numbers): if target-num in dic: return [dic[target-num]+1, i+1] dic[num] = i``` ### binary search ```pythondef twoSum(self, numbers, target): for i in xrange(len(numbers)): l, r = i+1, len(numbers)-1 tmp = target - numbers[i] while l &lt;= r: mid = l + (r-l)//2 if numbers[mid] == tmp: return [i+1, mid+1] elif numbers[mid] &lt; tmp: l = mid+1 else: r = mid-1 binary search 改进版123456789101112131415161718class Solution(object): def twoSum(self, numbers, target): investigatedSoFar = [] for i in range(len(numbers)): if not numbers[i] in investigatedSoFar: investigatedSoFar.append(numbers[i]) l, r = i + 1, len(numbers) - 1 tmp = target - numbers[i] while l &lt;= r: mid = l + (r-l) // 2 if numbers[mid] == tmp: return([i + 1, mid + 1]) elif numbers[mid] &lt; tmp: l = mid + 1 else: r = mid - 1"},{"title":"1. Two Sum","path":"2022/05/28/1-twosum/","text":"1. Two SumGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.（无序） hashmapenumerate()(单词意思是枚举的意思)是python中的内置函数enumerate(X,[start=0])函数中的参数X可以是一个迭代器(iterator)或者是一个序列，start是起始计数值，默认从0开始。X可以是一个字典。 12345678910class Solution(object): def twoSum(self, nums, target): Hashmap = &#123;&#125; for index, value in enumerate(nums): key = target - value if key in Hashmap: return [Hashmap[key], index] else: Hashmap[value] = index"},{"title":"LeetCode02-指针","path":"2022/05/25/LeetCode02-指针/","text":"第二篇学习笔记，换一个思路尝试学习 具体学习链接:Leetcode 题解 - 目录.mdLeetcode 题解 - 双指针1. 有序数组的 Two Sum2. 两数平方和3. 反转字符串中的元音字符4. 回文字符串5. 归并两个有序数组6. 判断链表是否存在环7. 最长子序列双指针类型对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。快慢指针：两个指针方向相同。适合解决数组中的移动、删除元素问题，或者链表中的判断是否有环、长度问题。分离双指针：两个指针分别属于不同的数组 / 链表。适合解决有序数组合并，求交集、并集问题。 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。"},{"title":"hexo 新建/启动/部署命令","path":"2022/05/16/hexo-usage/","text":"1.新建一篇文章1hexo new post &quot;文章名称&quot; 例子 1hexo new post hexo_usage 2.部署（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。1hexo clean 其实不需要每次都清除缓存文件，直接进行下面两步就可以 （2）生成静态文件。1hexo g （3）部署网站部署之前预先生成静态文件 1hexo d 3.启动服务器。默认情况下，访问网址为：http://localhost:4000/。 1hexo s"},{"title":"艾尔登法环boss战","path":"2022/05/16/elden-ring-boss/","text":"一当我们褪色者重新回到交界地，第一个相遇的法环碎片持有者就是史东威尔城城主“黄金”葛瑞克，一个臭名昭著的神之后裔，黄金家族成员，在史东威尔城附近的破屋里，我们会遇到一位红帽女孩，会知道葛瑞克利用被称为接肢的技术四处劫掠褪色者，将砍下的手脚接在自己身上来增加自身的实力。这座腐朽的城池里到处都是残肢断臂，在一座大厅里我们还能见到在出生点相似的截肢贵族。在城池里我们还会遇到同样对葛瑞克所作所为十分不齿的女战士涅斐丽·露，她会在我们与葛瑞克战斗中助我们一臂之力。 在我们将他击退之后，他还会砍下自己的左手，并接上一个龙头，试图再度增强自己的力量。但当我们最终击败他时，他喃喃地说到：“总有一天，我们会回到黄金树脚下的故乡……“葛瑞克作为曾经最强的一族——”黄金“一族的后人，却非常孱弱，艾尔登法环被女神玛莉卡敲碎后，群雄并起，引发了旷日持久的碎片战争，黄金树脚下的王城多次遭到进攻，葛瑞克混在女人堆里逃出王城，躲在史东薇尔城苟活，曾经想挑战女武神，却被被女武神打的满地找牙。 他妄图通过接肢变得更强，却是想着能够有朝一日可以重现黄金一族的辉煌，当他砍下手臂接上龙头时，他会朝天怒吼：“诸位祖先，敬请见证！”只可惜乱世之中，不符合无上意志的棋子都会被抹去。 二乘着灵马特雷托一路北上，在雷亚卢卡利亚魔法学院，我们会遭遇曾经被称为“满月”女王的蕾娜菈。 作为卡利亚魔法王国曾经的领导者，卡利亚魔法王国和黄金树势力曾经敌对，黄金树派出了英雄拉达冈前来讨伐，结果蕾娜菈和拉达冈在战场上相爱，双方化干戈为玉帛，喜结连理还诞下了三个子嗣。（分别是碎星将军拉塔恩，月之公主菈妮（神人），黄金树司法官拉卡德） 但好景不长，拉达冈突然抛下了自己的妻子，回到黄金树和永恒女王玛丽卡结婚。突然失去爱情支撑的蕾娜菈就此丧失了神智，成为现在这幅模样并被卡利亚王室囚禁于大书库。 她的手里怀抱着拉达冈留给她的琥珀一样的大卢恩，神志不清，不断地利用大卢恩的力量诞生没有自我意识的孩子。 在打碎女王身边的防护罩后 女儿月之公主菈妮会用魔法代替她的母亲与我们战斗，重现了全盛时期的满月女王：灵魂激流一类的法术随意释放，还可以召唤巨龙巨人狼群的灵体协助战斗。 三往东，我们进入了满目猩红腐败的盖利德地区，刚进入红狮子城的配乐极其震撼和忧伤，这么一位一等一的英雄，在盖利德和女武神的战斗中遭受猩红腐败的腐蚀后，自我放逐到恸哭山丘，即使像野狗一样啃噬着战场上的尸体，依然维持着星空的封印。他的手下红狮子军在盖利德修筑了一条熏烧火墙，用火焰同被猩红腐败腐蚀变异的巨大怪物开展永无止境的死斗。 一望无际的战场上布满了断戟残垣，只能远远看到他的庞大身躯和贯穿天空的重力大箭，这是一场战斗祭奠，拉塔恩的手下奇异骑士邀请天下豪杰群聚于此，希望能解除他的痛苦，像一位战士一样死去，如果不把战士壶亚历山大和狼哥等英雄们召唤出来，单对单战斗确实是非常困难的事。如果召唤所有英雄跟这位最强半神贴身肉搏，扑面而来的是那种英雄末路的悲壮感，大开大合的招式在战士们中杀进杀出，能坚持战斗到最后一刻的就只剩下壶哥和狼哥，终于击败拉塔恩将军后，天上静滞的星星突然开始流动，随着拉塔恩将军的逝去，群星的封印被解除，新的命运齿轮开始转动 四随着星空封印解除，一枚流星砸穿了地面，地下的永恒之城重现人世，充满恶意的恐怖外神，黑暗弃子艾丝缇从星空坠落，砸穿了天空城之后，又将诺克史黛拉沉入地底，这与永恒之城的种种悖逆之举有关，他们制造了可以伤害无上意志和二指的猎杀指头刀，又试图通过仿身泪滴造出新的神灵，从而引来了无上意志的惩罚。 巨大的身躯由星星构成，面部是一张令人不寒而栗的骷髅脸，拥有通过黑洞瞬移的能力 五当褪色者攻进王城，踏入王座大厅之时，我们会遇到一位身上长满犄角，面貌丑陋的王：噩兆王蒙葛特。 他是一位悲剧的半神，因为长相丑陋，自出生时就和兄弟蒙格一同被扔进了王城的下水道，虽然是黄金王朝的王子过得却是老鼠一般的生活。他本应诅咒这个畸形的世界，但讽刺的是，当艾尔登法环破碎后，群雄逐鹿，王城也遭到各路人马的进攻，曾经的半神和神人们纷纷自立门户，只有这位生活在下水道里的噩兆王蒙葛特，在关键时间挑起了守城的重任，并击退了所有来犯之敌，多次保住了黄金王城，在碎片战争中，他甚至击败了有着最强半神名号的拉塔恩将军。 击败蒙葛特后，他的追忆中这样描述：即使生为赐福无缘的恶兆之子，蒙葛特仍愿意为黄金树的守卫，不是因为被爱，想要回馈，而是他单纯希望去爱。似乎与这个黄金王朝的命运一样，他身后的王座只需轻轻一碰就变成了碎片。 六当“黄金”葛德文成为死王子后，古龙就待在他的好友体内，不停与死亡搏斗，在死眠少女菲雅的梦境中，我们见到了传说中的“死龙”弗尔桑克斯。 当死龙飞翔在天空手持红雷配上木星大红斑似的背景，场景混乱又充满了阴郁的美感。 七在亚坛高原西边的火山地区，这里有黄金王朝的司法官拉卡德，是一个毫无怜悯心的法官，也是众多拷问官的长官。如蛇一般，令人感到生厌的男人。 拉卡德是拉达冈和满月女王的孩子之一。对于黄金树信仰而言，“……拉卡德犯下了亵渎罪，是罪无可赦的敌人。”艾尔登法环破碎之前的拉卡德是残酷的司法官，整个牢镇随处可见被折磨虐待的白金之子。在破碎战争中，他曾是反对黄金树的霸王，反叛黄金树信仰，反对无上意志，为了追求更强的力量反抗黄金树主动被大蛇吞噬。我们会先通过小蛇女的邀请加入名为叛律者的组织。 那些具有反对黄金树潜质的英雄们，会被邀请到火山府邸，完成一系列亵渎（反抗黄金律法）之举。但是在拉卡德变成大蛇之后，因为最终能出色完成任务的叛律者都要去谒见拉卡德，而这些叛律者最终的遭遇，就和拉卡德曾经的骑士一样被吞噬，变成大蛇的一部分。 在完成了火山官邸安排的红灵入侵任务（击杀其他褪色者）后，拉卡德的侧室塔尼斯，一个一直戴着面具替拉卡德处理日常事务的女人，终于同意我们觐见亵渎君王拉卡德。 在大蛇前的不远处，有一把大蛇狩猎矛，与大蛇对峙时，能形成风暴似的光刃 在拉卡德被风暴之刃击败后，他的侧室会跪坐在大蛇的尸体处，不断地啃食着尸体的头部，希望借此变成蛇人继承他的意志，算是交界地的一对苦命鸳鸯了。 八 女武神玛莲妮亚，“米凯拉的锋刃”，手下有战无不胜的尊腐骑士大军，装上义手，带上飞翼头盔，掌握那高展飞翼的技能“水鸟乱舞”。为了帮哥哥米凯拉登上王位参加碎片战争，女武神玛莲妮亚在外四处征战，鲜血君王蒙格趁虚而入将米凯拉从圣树中掳走，玛莲妮亚率领大军一路南下寻找线索，而罪魁祸首蒙格的鲜血王朝就在盖利德地区（碎星将军拉塔恩的统治区域）的地下深处。当女武神赶到盖利德时，认为是拉塔恩抢走了哥哥米凯拉，与驻守于此的碎星将军以及他的红狮子军团展开了一场惊天动地的大战，史称艾奥尼亚之战。在最终的对决中，娇艳的腐败花朵怒放，吞噬了整个艾奥尼亚。拉塔恩与玛莲妮亚战成平手。这场无人胜利的战争伴随着玛莲妮亚的昏迷和拉塔恩的疯狂落下帷幕。 昏迷的玛莲妮亚被英雄芬雷带回圣树，从那以后好像迷失了自我，安安静静坐在圣树深处，等待着哥哥回归。 在我们第一次击倒女武神之后，她再次释放了体内的猩红腐败之力 玛莲妮亚如同一只妖艳而致命的蝴蝶飞翔在空中，展现着完全状态下女武神的恐怖力量，她重重的将刀劈向地面，一朵朵猩红腐败之花怒放。 击败女武神之后获得的大卢恩也如同她本人一样，也充满了猩红腐败的力量 九不得不说，玛莉卡的子嗣们，也就是半神们，都有着自己的野心和理想。鲜血君王蒙格，与孪生兄弟噩兆王蒙葛特一起守卫王城之时，也期望能建立属于自己的鲜血王朝。 在碎片战争中，蒙格绑走了神人米凯拉，神人是神的候补，在玛莉卡女王失踪之后有着成为神的资格，蒙格利用血茧培育着米凯拉，当米凯拉成神之际，自己就可以以艾尔登之王的身份君临天下。殊不知，是蒙格自己的愿望，还是米凯拉的诱惑导致的呢？ 十天空城里的黑剑玛利喀斯是玛莉卡女王忠诚的结拜弟弟，将命定之死寄宿在自身的剑里，令所有的半神感到畏惧。而就是因为它们明白何谓畏惧，才会是英雄。 在阴谋之夜，死亡的一部分被偷走之后，玛利喀斯把黑剑封印在自己体内，为的是不再让它失窃。 褪色者和黑剑第一次相遇是在盖利德的最北边的野兽祭祀塔，见到的是野兽祭祀模样的玛利喀斯，穿着肮脏破烂的外衣，迫切的渴望着死根，在吃了四个死根之后他甚至会陷入疯狂攻击我们，在十个死根完全收集之后，他会从祭祀塔里消失，下一次再见是在天空城。 圣树的女武神是我死亡次数最多的boss，但有猎犬步伐加上耍无赖的用了冤魂绕圈打法，其实难度并没有打只狼的一心艰难，就是得多挂几次学一下怎么躲水鸟，法师的一个问题是血太薄，被水鸟的任何一个连招中的两刀砍到就没了。王城下水道的“恶兆之子”蒙格和鲜血王朝的“碎片君王”蒙格我也没什么战斗记忆，只要记得喝滴露就可以破解他的倒计时大招。火焰巨人倒真是卡住了我一段时间，因为遍地打滚被压碎了好几次，放弃了当甘道夫的想法选择用岩石球就很容易了。龙王普拉顿桑克斯可以说是后期除了女武神之外第二强的boss，瞬移，秒人光炮，大范围龙爪aoe，黑刀姐第一次boss半血都没到就被打没了，主要是每死一次得跑一阵才能到boss房，技能也没有死龙酷炫，基本每招都能秒我，战斗体验很糟糕。然后是黑剑，黑剑二阶段的战斗身姿是最帅的，那套盔甲配上黑剑的火焰燃烧特效从天上劈下刀光非常引人入胜，但整体并不难打，因为他血很薄又没有女武神那样的吸血buff，平台上还有几根石柱，虽然不能秦王绕柱但可以躲柱子后面喝口药回回状态。初代王荷莱露说实话出场表演很一般，并没有感觉到初代艾尔登之王的逼格，猎犬步伐躲投技，跳起来躲大范围捶地aoe，二阶段撕狮子那段很惊讶，但后面鞋子的特写有点出戏（鞋带不好系啊），二阶段在骨灰和女战士（现在是史东威尔城城主）也没什么难度就过了。最终boss红毛拉达冈和艾尔登之兽在圣龙徽护符+2，螃蟹肉和祷告圣防护的buff下打了两次就过了，红毛有个问题，就是读指令的动作太明显了，属于敌不动我不动那种，没有动作游戏的体验，就像只狼里的弦一郎加一心我打了快一天才赢，但是结束以后就觉得很爽，弹刀出刀忍义手有一种见招拆招的快感，跟拉达冈打就像回合制游戏，他出招我就翻滚，等他技能后摇我再砍一剑然后继续泥地打滚或者猎犬步伐找机会。战灰的加入虽然简化了战斗，但个别骨灰的强势导致我完全没有想法使用其他的骨灰，点名黑刀姐和仿身泪滴。仿身泪滴在我玩的时候已经被削，不再是大哥了，但它血厚啊。黑刀姐就更强了，战技经常放还是比例掉血，会瞬移，移动灵活。攻击欲望强，打大型怪跟战神一样，当然希望宫崎老贼的更新方式是加强其他骨灰而不是削已有的强势骨灰。 你将会在游戏里遇到以下角色： 一个姑娘告诉你她的城堡里奴隶造反了，她的城主父亲正在努力抵抗叛军，她给你一封信，让你带给他父亲，劝说他离开。于是你杀进城堡找到她父亲，结果他父亲说自己奉葛瑞克大人（这片区域的君王）抵抗叛军，不能离开，关键是镇城之剑不能落入叛军之手，于是你又杀了叛军的老大拿回了剑，你以为城主这下可以和女儿团聚了，于是高兴滴回去找姑娘，结果发现姑娘已经倒在了血泊中，旁边赫然插着奴隶们使用的大刀。你沮丧地回去找城主，却发现不知情的城主说自己的任务已经完成了，未来要为女儿而活……再回到和妹子相遇的地方，会见到这个心碎的父亲在女儿的尸体旁捶地怒吼，高喊要为了女儿复仇。后期在一间充满尸臭的破屋里，这个父亲会失智地攻击我们。复仇已经吞噬了他的心，也许倒在玩家的剑下，和女儿团聚，是对他来说最好的结局。 在魔法学院外，你会遇到一个落魄魔法师托普斯，求你给他十块钱去弄点吃的，他会教你魔法作为报酬。他教的魔法有点奇怪（比如一个可以照明用魔法，虽然没有战斗力但很实用），他说自己很有自知之明，知道自己是块朽木，很遗憾不能教给玩家好的魔法，他希望能进入魔法学院去研究。之后玩家找到魔法学院钥匙可以交给他，他会非常感谢你然后离去。在玩家探索魔法学院的时候，可以在某一个地方找到托普斯的尸体：被绑在椅子上，死前似乎依然在研究魔法。而调查他的尸体，可以发现他赌上性命研究的魔法：托普斯的立场。这个魔法的效果非常逆天，可以弹开所有魔法。物品介绍中这样描述：后世的人们会明白，那受人嘲讽的理念，其实是足以成立新教室的发现。 同样是魔法师，你会在某处遗迹地下室遇见一个女魔法师瑟廉，如果你希望她教你魔法，她会警告你自己是被魔法学院驱逐的魔女。如果玩家表示不介意的话，瑟廉会惊讶并表示愿意教我们魔法，并亲切称呼我们为徒弟。在玩家此后的征程中，老师知无不言，还会一直鼓励我们，甚至表示就算玩家一无所成，还是可以去找她，毕竟老师永远会给弟子留一个位置。然而随着剧情推进，我们会发现原来老师就是魔法学院里被称为“尸块魔女”的存在，为了探索禁忌的星星起源而杀害了无数魔法师。当玩家将两位大魔法师尸体的位置告诉老师后，老师最终会和他们融合，变成一颗恐怖的人面球，痛苦地向我们呻吟：“呜呜呜呜，徒弟，呜呜呜……”虽然探索禁忌的疯狂行为终究要付出代价，但即使是内心再怎么疯狂之人，对于那个当初不介意自己出身，愿意接纳自己的小徒弟，她依然愿意袒露内心真心相对。（也有说法人面球就是星星的雏形，老师其实是得道了） 在一座桥旁， 玩家会遇到一个长着手脚的壶被卡在地上，请求我们的帮忙。帮他脱困后，他会告诉我们自己是战士壶——铁拳亚历山大，正要去红狮子城参加战斗祭奠。他爽朗的笑声让人印象深刻。在战斗祭奠上携手壶哥一同击败半神拉塔恩将军后，壶哥会浑身裂痕趴在地上，告诉我们刚才我们的表现很棒，但自己没几下就被打趴下了，还出现了好多裂痕，壶里的内容物都漏出来了，好在这里有很多战士的尸体，可以弥补遗失的内容物。我们这才知道原来战士壶就是战士尸体的容器，他是战士们战意的承载者。为了变得更强，壶哥决定去火山官邸旁的熔岩接受高温炙烤，又去巨人雪山寻找神火锻造自己，最终他和我们在天空城相逢。每次碰面，他总是用爽朗的笑声回应我们，好像不管何种失意都不会影响他的斗志，尽管他身上的裂痕越来越多。在天空城，壶哥邀请我们作为他的一场试炼，因为我们是他认可的英雄。开打后我们发现，相比其他战士壶，壶哥强太多太多了，他不但可以喷火，甚至挥手就可以掀起火焰风暴，一双铁拳使出的火焰升龙拳甚至可以击飞曾经弑神的玩家。但是壶的承载度终归有限，壶哥还是倒下了。他告诉我们，他知道壶终归只是壶，但作为战士，他战斗到了最后一刻。最终，在爽朗的笑声中，壶哥像其他战士壶一样碎裂成了碎片。 在游戏中，你会遇到一个自称霍劳斯的骑士，说他和女仆走散了，如果你见到了可以告诉他，还说如果有人敢动他女仆他就不客气了，嘴上还说着霍劳斯以血代言（用让你出血代替用嘴逼逼），给人感觉是个狠人。后来在魔法学院前，你发现他找到了已经被杀害的女仆，他告诉你凶手是火山官邸的人，他非要复仇不可，因为霍劳斯家族以血代言。后来在大本营，他告诉你他找到了火山官邸的人，但对方竟然要拉他入伙，他表示自己气的要大开杀戒了。让人大跌眼镜的是，当玩家进入火山官邸后，竟然见到霍劳斯，他告诉你，他也加入火山官邸了，不想复仇了。他还自己找了一个理由：英雄不会刻意走干净的路，我要选择一条污秽的路来证明我的英雄气概。无数玩家在他的脚下留言：前有大便，前无马（妈），愤怒！等等来表达内心的不满。之后霍劳斯屡屡出任务失败（火山官邸以猎杀同类为任务），他向玩家诉苦自己这双手根本不适合成为英雄。玩家通过支线任务也得知原来霍劳斯有一个哥哥，由于弟弟太过没用，哥哥名正言顺当上了家主，也一直爱着弟弟，并希望弟弟不要走上霍劳斯以血代言的铁血道路。但弟弟也一直想着走出哥哥的阴影……后来在壶村，玩家发现霍劳斯逃出了火山官邸，在这里当上了维壶师，维修这里的战士壶，虽然这份工作看起来低微，但看着在自己的维护下，壶们一个个恢复健康，霍劳斯说：我从火山官邸逃了出来，从所有地方逃了出来，逃避一切。说出来你可能不信，但我在这里，才有了真正活着的感觉。一段时间后玩家回来，会发现所有的壶都碎了，只有一个小壶还完好，而霍劳斯只剩下最后一口气。原来村里遇到了偷猎者，是霍劳斯用性命击退了他们。当你告诉霍劳斯壶都没事时，他会欣慰地说，就算是自己这样没用的人，也会有派上用场的时候，并最后说出了那句他一直挂在嘴边的话：霍劳斯以血代言。在他的尸体旁，全是玩家的留言，几乎都是一样的内容：前有英雄。 在一座山洞中，你会遇到一个名为帕奇的光头，一开始他会攻击你，但如果你将他打到半血，他会跪地求饶，如果你放过他，他就开始拍你马屁。他的房间里放着一个宝箱，如果玩家去开，就会中陷阱被传送到别处，帕奇还会嘲笑我们是贪婪之徒。之后玩家可以在火山官邸遇到他，他会将自己的猎杀任务让给你（大概率是太强他自己打不过），如果你完成了任务，他会说帮你去汇报，但不会把任务奖励给你，除非你亲自问他才会不情愿地给你，但就是这样一个滑头，却在游戏里得到善终，逍遥快活。 NPC不得善终，几乎是魂系列的定律，那些坚持原则的角色，大部分落得凄惨的下场，反而是帕奇这样的角色，却能活得游刃有余，这何尝不是对现实世界的一种无情嘲弄。当然，那些明知不可为而为之的角色，虽然最终陨落，但却实实在在给玩家的心里留下了一份感动。 ———3.21更新————"},{"title":"艾尔登法环评价","path":"2022/05/16/elden-ring/","text":"说实话，作为我第一款全价购买的steam游戏，艾尔登法环就像一场盛宴，他几乎满足了我对奇幻世界和宏大史诗的全部期待。从四月一日到四月十八日，一周目耗时105小时，完成了所有的结局和几乎所有的支线，在此感谢“老戴解说”，在他的视频帮助下我成功体验到了老头环的魅力，还有全成就(^_^)。 优点：1.宏大史诗和庞大的世界观。最早接触的魂类游戏是只狼，在我多周目不同的结局后，我开始体验到魂类游戏的魅力，虽然黑魂3前期打boss对我来说并不难，但有个很头疼的问题是迷路，这也是弃坑黑魂3的原因。我个人非常喜欢宏大世界观和史诗故事，看完了龙崎棒棒糖所有关于黑魂背景的介绍视频之后，我很期待乔治马丁和宫崎老贼能描绘出多么精彩的画卷，在剧情和背景的设定上，老头环达到了我对游戏的最高评价。 2.美学设计/前有绝景我从出生点开始，就不断的F12截图，一直到游戏结束，既是记录游戏剧情，也是对游戏画面的感叹。虽然老头环的贴图不算精细，但整体环境充满了特点，并且在老头环，不同的地区会有不同的场景描绘，不像黑魂都是黑暗阴森。 中性（个人看法）1.战斗设计说实话这种类似黑魂的战斗体验并没有很优秀，快慢刀加读指令还是很头痛的，个人来说还是更喜欢只狼那种偏向ACT的战斗风格，而不是满地打滚当驴学派玩家。不过法师的加入让老头环入门更加简单，作为不用灵魂激流就喜欢月光剑贴脸砍的狂战士甘道夫，虽然少部分时候在受苦，整体来说战斗体验还是不错的。 但是！后期圣树，雪山和雪原，数值膨胀的太离谱了，不刷级不行，印象深刻的是圣树罗蕾塔门口的两个魔法师，顶级法师了属于是，攻击力极高，血贼厚，没有蓝条，远比后面的罗蕾塔boss强，地方又狭窄，别说战斗了，就是跑酷都不好跑。（打到这的时候就感叹这里的每个小兵都能暴捶葛瑞克之流） 2.地图设计前期洞窟和地面城池的设计算是非常巧妙，很多地方有捷径或者意想不到的到达方式，虽然依然有各种转角遇到背刺的小兵和石像鬼，但这也算是法环作为恐怖游戏的一种标签，但后期雪原非常空旷，如果不是进去的暴风雪挡住了视线，刚进去的那里什么都没有 3.NPC设计NPC的设计可以说是有好有坏，描写非常深刻的有战士壶亚历山大狼哥还有亲爱的老师瑟廉，但其他的就不是那么印象深刻了，其实如果可以把支线连在一起看，大部分NPC都是有血有肉（虽然绝大部分都是悲剧结局）但巧就巧在法环的内容量太大，又有接下来提到的任务指引问题，只有看攻略猛攻一个故事，才能体会深刻，就比如说海德要塞那个城主，要我来回跑图（中途还没有赐福）才能接近完成任务。还有个问题是老头环里的NPC跟投币木马似的，话总是不一次讲完，必须得不停的对话。顺便一提，传说中的魂系经典人物帕奇，说实话如果没有这层buff帕奇就是个杂兵，在一周目我通过攻略经历了所有和帕奇有关的故事，包括被他在火山地区踹下悬崖。我非常不理解为什么玩家们会喜欢这样一个偷奸耍滑作奸犯科的NPC，在二周目我选择直接把他砍翻，除了几个猎杀褪色者任务，即使没有他整个故事流程也没有影响。 缺点：1.最垃圾：任务指引任务指引其实不能用垃圾来形容，应该是完全没有。碎片化叙事我可以接受，以往的魂类游戏都是在一个走廊里把剧本一张张放好（不一定按顺序），但现在，他把剧本撒在了一个六十层大楼里，需要不断地上蹿下跳去找，而且里面还有各种各样的粪坑。我不相信作为一个普通玩家能够在不看攻略的情况下做完大部分任务，甚至说，不看攻略连很多支线都不知道在哪开始接。作为一个开放世界，没有任务清单意味着我根本记不住多个任务，一边在被小兵暴杀的同时我还要记下一步支线怎么走？好些NPC我一开始不看攻略一头雾水， “你谁啊就跟我搭话”更别说什么商人卖的情报了，有些商人藏在什么鸟不拉屎的地方啊，举个例子，卡利亚学院传送门那里，那个商人在传送门后面的断桥处，但是，你不能通过传送门走，要沿着断桥走，断桥上全是树木和灌木丛遮挡视线，还有一片狼群，然后才能看到商人，不看攻略哪个正常人会在看到传送门的情况下往断桥里钻？就算有商人的情报，米莉森的支线还有三指女巫的支线的地点就完全没有提示，本来任务流程的间隔非常大，这些支线本身体量又有限，开放世界进一步分割并加剧了任务的碎片化，你必须得在这个开放世界闲逛，才能找到他们，这样就光剩碎片没故事了。主线剧情有个大问题是我把老婆当柴火烧了树以后就黑屏到天空城了？到了天空城我为什么要去揍黑剑？什么提示也没有就让我去拿命定之死？命定之死前面只提到可以干掉半神，没说干掉黑剑释放命定之死才能真正烧黄金树。如果只能通过看攻略才能完成任务，那么作为一款游戏我认为法环的任务指引是极其失败的。有人会洗白说这是魂系游戏的特色，“老ass一周目基本不会上网查看攻略的，最多交流下自己发现的问题。魂游戏的一周目无知探索是最有乐趣的而且这个无知不可逆。”但这是开放世界，不是以往的线性叙事，魂系游戏的前提是游戏，这么大的游戏体量难道要我一个普通玩家拿个笔记本自己记？ 2.部分物品获得设计故事散布在大楼里就算了，问题是底下还有粪坑，在死根深处有个传说护符，需要穿过一片黑暗的蚂蚁窝，就是在黑暗中，你得辨别蚂蚁窝的布局看着无数只巨大蚂蚁在边上进攻骑马穿梭跳跃，我是真的被恶心到了，纯粹的生理恶心，这个护符的放置地点让我不可能给这个游戏打满分，纯粹故意恶心玩家，不会有打着魂类游戏的旗号的昆虫爱好者喜欢吧，不会吧不会吧更别提什么大手怪还有蚯蚓脸了，但好歹没有那种强制你盯着看的设计出现还有各种各样的奇怪藏东西地点，让我感觉制作组只是故意把他们藏在玩家找不到的地点，而不是打完一场战斗后的战利品，我在收集物品时（特别是后期）完全没有那种“原来在这里”的惊喜 3.跑酷设计在小兵和房顶穿梭的时间远远大于打boss的时间，很多无意义的堆怪耗尽耐心。印象最深的是卡利亚学院楼顶的跑酷，跳到有一处房顶的时候，本来距离就远不太好跳，还在这里布置了一个类似只狼的风筝怪，我在空中被它打下去很多次，我忍了很久才没有卸游戏。当然有人洗白说这是魂系游戏的特点，我只能说适当的恶心人可以，恶心多了就只能徒增厌恶 4.剧情bug黑剑和野兽祭祀，这是很多人都提到的bug了，打完黑剑野兽祭祀还在，有些人洗白说这是不同时空的黑剑，但老头环前面没有出现什么时空分割的设定，我倾向于是有个bug或者是这部分没做完就拿出来发售了。吐槽一下，还有烧树后飞到天空城，这都啥啊就飞上去了？咋飞的啊，要是梅琳娜有这本事她怎么不早用呢。有人说是桂奥尔龙墓的那条大白龙带我们到天空城的，但这都只是解包推测的，本身剧情就是有断层，即使后续有更新但游戏都发售了总得先有个自圆其说的解释吧，拿个什么商人情报或者犄角旮旯里的碎片先当谜语人也行啊，但什么都没有，即使洗白有法环体量大的理由，但事实在这里，在这一段就是有剧情上的漏洞。还有一个是关于火山巨人的，他不是被黄金家族干倒了吗，都被玛莉卡控制了怎么二阶段还可以通过献祭获得邪神力量啊？要是能和邪神沟通有自我意识为什么要阻止我烧树，不应该高高兴兴把黄金树给点了吗，又何必打上这一架。"},{"title":"LeetCode01 K Sum","path":"2022/04/13/LeetCode01/","text":"终于开始正式刷题了。这也是第一篇学习笔记，我计划用两个月的时间从头开始学习算法和leetcode，争取在秋招前刷完200题 两数之和起步就是最简单的第一题，英文名：1. Two Sum 暴力求解没有学过算法的我第一反应就是暴力解法，直接遍历算一圈就可以完事，但通常会超时。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i = 0; i &lt; nums.size(); ++i) &#123; for(int j = i + 1; j &lt; nums.size(); ++j) &#123; if(target == nums[i] + nums[j]) &#123; return &#123;nums[i], nums[j]&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; 复杂度我也是第一次接触时间复杂度和空间复杂度这两个概念 具体学习链接:算法的时间与空间复杂度（一看就懂）简单来说时间复杂度：执行算法花了多长时间空间复杂度：执行算法花了多少内存 常见的时间复杂度量级有：1. 常数阶O(1)重点：没有循环等复杂结构 12345int i = 1;int j = 2;++i;j++;int m = i + j; 2. 对数阶O(logN)12345int i = 1;while(i&lt;n)&#123; i = i * 2;&#125; 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后i就大于n，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2(n)这里把数字设成2，当n无限大的时候，数字是多少都无所谓，所以统称为logN 3. 线性阶O(n)12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的。简而言之，n跟结果有关系就不是常数阶，一个循环对应一个线性阶 4. 线性对数阶O(nlogN)线性对数阶O(nlogN) 就是把时间复杂度为O(logN)的代码外面套一个循环，循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i&lt;n) &#123; i = i * 2; &#125;&#125; 5. 平方阶O($n^2$)总结：两个循环或者说两个线性阶套娃 12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 6. 立方阶O($n^3$)总结：三个循环或者说三个线性阶套娃 1234567891011for(y=1;y&lt;=n;y++&gt;)&#123; for(x=1; i&lt;=n; x++) &#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125; &#125;&#125; 7. K次方阶O($n^k$)总结：K个循环或者说K个线性阶套娃 8. 指数阶(2^n)回忆一下指数的图像，随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。 12345678aFunc( n ) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; 常见的空间复杂度量级有：O(1)、O(n)、O(n²)1. O(1)如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 12345int i = 1;int j = 2;++i;j++;int m = i + j; 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 2. O($n$)123456int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; 这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n) 3. O($n^2$)12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; 二分查找具体学习链接:夜深人静写算法（四十四）- n 数之和fucking-algorithm/算法思维系列/二分查找详解.md二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数二分查找框架123456789101112131415int binarySearch(int[] nums, int target) &#123; int left = 0, right = ...; while(...) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; ... &#125; else if (nums[mid] &lt; target) &#123; left = ... &#125; else if (nums[mid] &gt; target) &#123; right = ... &#125; &#125; return ...;&#125; 讲回这道题 1.对数组排序；2.从前往后枚举第一个数 nums[i]；3.由于数组是有序的，所以可以从剩下的数中，二分查找target - nums[i]，一旦找到，则返回二元组 &#123; nums[i], target - nums[i] &#125;；Hashmap具体学习链接:夜深人静写算法（四十四）- n 数之和fucking-algorithm/算法思维系列/二分查找详解.md具体学习链接:小白 Python 几种解法12345678910111213141516class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; hashmap=&#123;&#125; for ind,num in enumerate(nums): hashmap[num] = ind for i,num in enumerate(nums): j = hashmap.get(target - num) if j is not None and i!=j: return [i,j] 12Runtime: 46 ms, faster than 90.61% of Python online submissions for Two Sum.Memory Usage: 14.3 MB, less than 45.68% of Python online submissions for Two Sum. 改进版 1234567class Solution(object): def twoSum(nums, target): hashmap=&#123;&#125; for i,num in enumerate(nums): if hashmap.get(target - num) is not None: return [i,hashmap.get(target - num)] hashmap[num] = i #这句不能放在if语句之前，解决list中有重复值或target-num=num的情况 12Runtime: 41 ms, faster than 95.66% of Python online submissions for Two Sum.Memory Usage: 14.4 MB, less than 45.68% of Python online submissions for Two Sum. Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sitesMore info: Deployment 解算出来的代码 12345678910class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: seen = &#123;&#125; for i, value in enumerate(nums): remaining = target - nums[i] if remaining in seen: return [i, seen[remaining]] seen[value] = i 结果 12Runtime: 68 ms, faster than 84.35% of Python3 online submissions for Two Sum.Memory Usage: 15.3 MB, less than 25.99% of Python3 online submissions for Two Sum."},{"title":"plan","path":"2021/10/05/plan/","text":"Steins;Gate"},{"title":"first blog","path":"2021/09/24/first-blog/","text":"这里是记录研究生生活和学习的第一篇文章，也是一切的开始。生活篇分为日记，回忆，生活技巧。 日记12021.9.24已经是上课的第三周了，逐渐习惯了这样的学习节奏和自己做饭的生活。今天烧了一份红烧蹄膀。在华超买的蹄膀，让人出乎意料的事蹄膀居然是最便宜的肉类，真是暴殄天物啊。"},{"title":"how to start the first blog","path":"2021/09/24/如何写blog/","text":"创建新blog个人博客学习总结基本可以按照这个流程走 http://localhost:4000/ hexo 美化Hexo 入门指南（四） - 页面、导航、边栏、底栏 https://hexo.io/themes/ https://picx.xpoet.cn/#/management github corners 图标 https://hexo.io/zh-cn/docs/writing 流程"},{"title":"Hello World","path":"2021/09/07/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]