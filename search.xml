<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>16. 3Sum Closest(medium)</title>
      <link href="/2022/06/16/16/"/>
      <url>/2022/06/16/16/</url>
      
        <content type="html"><![CDATA[<h1 id="16-3Sum-Closest-medium"><a href="#16-3Sum-Closest-medium" class="headerlink" title="16. 3Sum Closest(medium)"></a>16. 3Sum Closest(medium)</h1><h2 id="Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target"><a href="#Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target" class="headerlink" title="Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target."></a>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</h2><h2 id="Return-the-sum-of-the-three-integers"><a href="#Return-the-sum-of-the-three-integers" class="headerlink" title="Return the sum of the three integers."></a>Return the sum of the three integers.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution" class="headerlink" title="You may assume that each input would have exactly one solution."></a>You may assume that each input would have exactly one solution.</h2><p><a href="https://leetcode.cn/problems/3sum-closest/solution/pythonshuang-zhi-zhen-you-hua-ji-bai-999-by-hardca/">排序 + 双指针</a><br>这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。</p><p>优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()         <span class="comment"># 排序</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):        <span class="comment"># 枚举第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]: <span class="keyword">continue</span>     <span class="comment"># 保证first不会有重复</span></span><br><span class="line"></span><br><span class="line">            second, third = first + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            max_sum = nums[first] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>]</span><br><span class="line">            min_sum = nums[first] + nums[first + <span class="number">1</span>] + nums[first + <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> max_sum &lt;= target:    <span class="comment"># 最大的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(max_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = max_sum</span><br><span class="line">                <span class="keyword">continue</span>              </span><br><span class="line">            <span class="keyword">elif</span> min_sum &gt;= target:  <span class="comment"># 最小的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(min_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = min_sum      </span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                two_sum_target = target - nums[first]</span><br><span class="line">                s = nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s + nums[first] - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = s + nums[first]</span><br><span class="line">                <span class="keyword">if</span> s &gt; two_sum_target:  <span class="comment"># 当前数值太大 右指针左移</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third + <span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; two_sum_target:  <span class="comment"># 当前数值太小 左指针右移</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 刚好等于 直接返回target即可</span></span><br><span class="line">                    <span class="keyword">return</span> target </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target (Easy)</title>
      <link href="/2022/06/16/744/"/>
      <url>/2022/06/16/744/</url>
      
        <content type="html"><![CDATA[<h1 id="744-Find-Smallest-Letter-Greater-Than-Target-Easy"><a href="#744-Find-Smallest-Letter-Greater-Than-Target-Easy" class="headerlink" title="744. Find Smallest Letter Greater Than Target (Easy)"></a>744. Find Smallest Letter Greater Than Target (Easy)</h1><h2 id="Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target"><a href="#Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target" class="headerlink" title="Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target."></a>Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x) (Easy)</title>
      <link href="/2022/06/16/69/"/>
      <url>/2022/06/16/69/</url>
      
        <content type="html"><![CDATA[<h1 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h1><h2 id="Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x"><a href="#Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x" class="headerlink" title="Given a non-negative integer x, compute and return the square root of x."></a>Given a non-negative integer x, compute and return the square root of x.</h2><h2 id="Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned"><a href="#Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned" class="headerlink" title="Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned."></a>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</h2><h2 id="Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5"><a href="#Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5" class="headerlink" title="Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5"></a>Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5</h2><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: </span><br><span class="line">            first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(left-right)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="comment">#mid = (left + right) // 2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="方法二：牛顿迭代"><a href="#方法二：牛顿迭代" class="headerlink" title="方法二：牛顿迭代"></a>方法二：牛顿迭代</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode05</title>
      <link href="/2022/06/16/LeetCode05/"/>
      <url>/2022/06/16/LeetCode05/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-二分查找"><a href="#Leetcode-题解-二分查找" class="headerlink" title="Leetcode 题解 - 二分查找"></a>Leetcode 题解 - 二分查找</h1><h2 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h2><h2 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h2><h2 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h2><h2 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h2><h2 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h2><h2 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h2><p>二分查找 binary search algorithm</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="m-计算"><a href="#m-计算" class="headerlink" title="m 计算"></a>m 计算</h2><p>有两种计算中值 m 的方式：</p><p>m = (l + h) / 2<br>m = l + (h - l) / 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p><h2 id="未成功查找的返回值"><a href="#未成功查找的返回值" class="headerlink" title="未成功查找的返回值"></a>未成功查找的返回值</h2><p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p><p>-1：以一个错误码表示没有查找到 key<br>l：将 key 插入到 nums 中的正确位置</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. Partition Labels (Medium)</title>
      <link href="/2022/06/13/763/"/>
      <url>/2022/06/13/763/</url>
      
        <content type="html"><![CDATA[<h1 id="763-Partition-Labels-Medium"><a href="#763-Partition-Labels-Medium" class="headerlink" title="763. Partition Labels (Medium)"></a>763. Partition Labels (Medium)</h1><h2 id="You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part"><a href="#You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part" class="headerlink" title="You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part."></a>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</h2><h2 id="Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s"><a href="#Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s" class="headerlink" title="Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s."></a>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</h2><h2 id="Return-a-list-of-integers-representing-the-size-of-these-parts"><a href="#Return-a-list-of-integers-representing-the-size-of-these-parts" class="headerlink" title="Return a list of integers representing the size of these parts."></a>Return a list of integers representing the size of these parts.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-labels/solution/python-jiu-zhe-quan-guo-zui-cai-you-hua-dai-ma-by-/">思路</a>:<br>其实思路很简单，<br>1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。<br>2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或一段的最后位置大。<br>如果没有刚才的last或一段的最后位置大，无视它继续往后找。<br>如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或一段的最后位置更新为当前的字母的最后位置。<br>3，肯定到有一个时间，这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。<br>注意题目要分隔后的长度，我们就用last - startindex + 1。<br>4，找到一个分割位，更新一下起始位置，同理搜索就行了。</p><p>用字典的好处就是不用每次都搜索位置了。直接用字典存所有字符的最后位置就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;<span class="built_in">list</span>[<span class="built_in">int</span>]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end) <span class="comment">#如果最后位置比刚才的大，就更新最后位置</span></span><br><span class="line">            <span class="keyword">if</span> i == end: <span class="comment">#这里就是找到这一段的结束了，就说明当前位置的index和这个字母在字典里的最后位置应该是相同的。</span></span><br><span class="line">                ans.append(end - start + <span class="number">1</span>) <span class="comment"># 加入result</span></span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray (Easy)</title>
      <link href="/2022/06/13/53/"/>
      <url>/2022/06/13/53/</url>
      
        <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a>53. Maximum Subarray (Easy)</h1><h2 id="Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum"><a href="#Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum" class="headerlink" title="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."></a>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</h2><h1 id="A-subarray-is-a-contiguous-part-of-an-array"><a href="#A-subarray-is-a-contiguous-part-of-an-array" class="headerlink" title="A subarray is a contiguous part of an array."></a>A subarray is a contiguous part of an array.</h1><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>这题第一眼非常像买股票第一弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure><h2 id="本质上是动态规划问题："><a href="#本质上是动态规划问题：" class="headerlink" title="本质上是动态规划问题："></a>本质上是动态规划问题：</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">leetcode题解</a></p><p>方法一：动态规划<br>「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。</p><p>本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。</p><h2 id="关键-1：理解题意"><a href="#关键-1：理解题意" class="headerlink" title="关键 1：理解题意"></a>关键 1：理解题意</h2><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><h2 id="关键-2：如何定义子问题（如何定义状态）"><a href="#关键-2：如何定义子问题（如何定义状态）" class="headerlink" title="关键 2：如何定义子问题（如何定义状态）"></a>关键 2：如何定义子问题（如何定义状态）</h2><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><p>子问题 1：经过 -2 的连续子数组的最大和是多少；<br>子问题 2：经过 1 的连续子数组的最大和是多少；<br>子问题 3：经过 -3 的连续子数组的最大和是多少；<br>子问题 4：经过 4 的连续子数组的最大和是多少；<br>子问题 5：经过 -1 的连续子数组的最大和是多少；<br>子问题 6：经过 2 的连续子数组的最大和是多少；<br>子问题 7：经过 1 的连续子数组的最大和是多少；<br>子问题 8：经过 -5 的连续子数组的最大和是多少；<br>子问题 9：经过 4 的连续子数组的最大和是多少。<br>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 -3 的连续子数组的最大和是多少。</p><p>「经过 -3 的连续子数组」我们任意举出几个：</p><p>[-2,1,-3,4] ，-3 是这个连续子数组的第 3 个元素；<br>[1,-3,4,-1] ，-3 是这个连续子数组的第 2 个元素；<br>……<br>我们不确定的是：-3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>子问题 3：以 -3 结尾的连续子数组的最大和是多少；<br>子问题 4：以 4 结尾的连续子数组的最大和是多少；<br>子问题 5：以 -1 结尾的连续子数组的最大和是多少；<br>子问题 6：以 2 结尾的连续子数组的最大和是多少；<br>子问题 7：以 1 结尾的连续子数组的最大和是多少；<br>子问题 8：以 -5 结尾的连续子数组的最大和是多少；<br>子问题 9：以 4 结尾的连续子数组的最大和是多少。<br>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>以 -2 结尾的连续子数组是 [-2]，因此最大和就是 -2。</p><p>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 1。</p><p>大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：</p><p>一个数 a 加上负数的结果比 a 更小；<br>一个数 a 加上 0 的结果不会比 a 更大；<br>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。<br>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><h2 id="定义状态（定义子问题）"><a href="#定义状态（定义子问题）" class="headerlink" title="定义状态（定义子问题）"></a>定义状态（定义子问题）</h2><p>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</p><p>说明：「结尾」和「连续」是关键字。</p><h2 id="状态转移方程（描述子问题之间的联系）"><a href="#状态转移方程（描述子问题之间的联系）" class="headerlink" title="状态转移方程（描述子问题之间的联系）"></a>状态转移方程（描述子问题之间的联系）</h2><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 dp[i] = dp[i - 1] + nums[i]。</p><p>可是 dp[i - 1] 有可能是负数，于是分类讨论：</p><p>如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；<br>如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</p><h2 id="思考初始值"><a href="#思考初始值" class="headerlink" title="思考初始值"></a>思考初始值</h2><p>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</p><h2 id="思考输出"><a href="#思考输出" class="headerlink" title="思考输出"></a>思考输出</h2><p>注意：</p><h3 id="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"><a href="#这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；" class="headerlink" title="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"></a>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>665. Non-decreasing Array(medium)</title>
      <link href="/2022/06/13/665/"/>
      <url>/2022/06/13/665/</url>
      
        <content type="html"><![CDATA[<h1 id="665-Non-decreasing-Array-medium"><a href="#665-Non-decreasing-Array-medium" class="headerlink" title="665. Non-decreasing Array(medium)"></a>665. Non-decreasing Array(medium)</h1><h2 id="Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element"><a href="#Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element" class="headerlink" title="Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element."></a>Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.</h2><h2 id="We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2"><a href="#We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2" class="headerlink" title="We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2)."></a>We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).</h2><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p>这道题的关键在于修改哪个数，本题在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><p>思路:<br>nums[i] &lt; nums[i - 1]:<br>    nums[i - 1] = nums[i]<br>nums[i] &lt; nums[i - 2]:<br>    nums[i] = nums[i - 1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">2</span>] <span class="keyword">and</span> i-<span class="number">2</span>&gt;=<span class="number">0</span> :</span><br><span class="line">                nums[i]=nums[i-<span class="number">1</span>]</span><br><span class="line">                cnt+=<span class="number">1</span>              </span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[i-<span class="number">1</span>]= nums[i]</span><br><span class="line">                cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392. Is Subsequence (Medium)</title>
      <link href="/2022/06/13/392/"/>
      <url>/2022/06/13/392/</url>
      
        <content type="html"><![CDATA[<h1 id="392-Is-Subsequence-Medium"><a href="#392-Is-Subsequence-Medium" class="headerlink" title="392. Is Subsequence (Medium)"></a>392. Is Subsequence (Medium)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise" class="headerlink" title="Given two strings s and t, return true if s is a subsequence of t, or false otherwise."></a>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</h2><h2 id="A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not"><a href="#A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not" class="headerlink" title="A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not)."></a>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</h2><p>本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。</p><p>而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。</p><p>这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。</p><p>最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i]==t[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>605. Can Place Flowers (Easy)</title>
      <link href="/2022/06/11/605/"/>
      <url>/2022/06/11/605/</url>
      
        <content type="html"><![CDATA[<h1 id="605-Can-Place-Flowers-Easy"><a href="#605-Can-Place-Flowers-Easy" class="headerlink" title="605. Can Place Flowers (Easy)"></a>605. Can Place Flowers (Easy)</h1><h2 id="You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots"><a href="#You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots" class="headerlink" title="You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots."></a>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.</h2><h2 id="Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule"><a href="#Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule" class="headerlink" title="Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule."></a>Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</h2><p><a href="https://leetcode.cn/problems/can-place-flowers/solution/chong-hua-wen-ti-by-leetcode-solution-sojr/728529">leetcode官解评论</a></p><p>非常巧妙的方法，用数学归纳法很容易推出来公式</p><p>统计连续的0的区间，分别有多少个连续的0即可。对于每一段0区间，都可以根据公式直接算出可以种几朵花。</p><p>公式可以通过数学归纳法推出来，很简单：</p><ol><li>对于中间的0区间：</li></ol><p>1~2个0：可种0朵；</p><p>3~4个：可种1朵；</p><p>5~6个：可种2朵；</p><p>…</p><p>count个：可种 (count-1)/2 朵</p><ol start="2"><li>对于两头的0区间，由于左边、右边分别没有1的限制，可种花朵数稍有不同。</li></ol><p>为了代码流程的统一，可以在数组最左边、数组最右边分别补1个0，意味着花坛左边、右边没有花。</p><p>这样公式就跟1相同了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flowerbed:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        countofZero = <span class="number">1</span> <span class="comment"># 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace = <span class="number">0</span> <span class="comment"># 可以种的花的数量</span></span><br><span class="line">        <span class="keyword">for</span> bed <span class="keyword">in</span> flowerbed:</span><br><span class="line">            <span class="keyword">if</span> bed == <span class="number">0</span>: <span class="comment"># 遇到0，连续0的数量+1</span></span><br><span class="line">                countofZero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#遇到1，结算上一段连续的0区间，看能种下几盆花：(countofZero-1)/2</span></span><br><span class="line">                canPlace += <span class="built_in">int</span>((countofZero-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                countofZero = <span class="number">0</span>; <span class="comment"># 0的数量清零，开始统计下一个全0分区        </span></span><br><span class="line">        <span class="comment">#最后一段0区还未结算：</span></span><br><span class="line">        countofZero += <span class="number">1</span><span class="comment"># 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace += (countofZero-<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123. Best Time to Buy and Sell Stock III(hard)</title>
      <link href="/2022/06/11/123/"/>
      <url>/2022/06/11/123/</url>
      
        <content type="html"><![CDATA[<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III-hard"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-hard" class="headerlink" title="123. Best Time to Buy and Sell Stock III(hard)"></a>123. Best Time to Buy and Sell Stock III(hard)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions"><a href="#Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions" class="headerlink" title="Find the maximum profit you can achieve. You may complete at most two transactions."></a>Find the maximum profit you can achieve. You may complete at most two transactions.</h2><h2 id="Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again"><a href="#Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again" class="headerlink" title="Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."></a>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure><p>卖股票第三弹（hard题了）</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>和第二题差不多，但是限制了最多两次交易，之前的小技巧有些用不上了，所以还是得走动态规划的路子。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/">官方题解</a></h2><p>思路与算法</p><p>由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p><ol><li><p>未进行过任何操作；</p></li><li><p>只进行过一次买操作；</p></li><li><p>进行了一次买操作和一次卖操作，即完成了一笔交易；</p></li><li><p>在完成了一笔交易的前提下，进行了第二次买操作；</p></li><li><p>完成了全部两笔交易。</p></li></ol><p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 buy1,sell1,,buy2,sell2 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy1 = buy2 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell1 = sell2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i])</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i])</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i])</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i])</span><br><span class="line">        <span class="keyword">return</span> sell2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II (Easy)</title>
      <link href="/2022/06/11/122/"/>
      <url>/2022/06/11/122/</url>
      
        <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a>122. Best Time to Buy and Sell Stock II (Easy)</h1><h2 id="You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an integer array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day"><a href="#On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day" class="headerlink" title="On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day."></a>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</h2><h2 id="Find-and-return-the-maximum-profit-you-can-achieve"><a href="#Find-and-return-the-maximum-profit-you-can-achieve" class="headerlink" title="Find and return the maximum profit you can achieve."></a>Find and return the maximum profit you can achieve.</h2><p>卖股票第二弹</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大利润 。</p><p>这一题一样是可以用贪心算法或者动态规划写的，但是我在<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/658886">官方题解评论区</a>发现一个极其简单的小技巧。在本题中买卖都是无限次的，所以只要把盈利（也就是上升段）全部加在一起就可以了，相当于每隔一天算一次盈利，盈利为正算在总利润里，盈利为负就丢掉。</p><p>简单来说就是只要把所有的盈利加在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                res += prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock (Easy)</title>
      <link href="/2022/06/11/121/"/>
      <url>/2022/06/11/121/</url>
      
        <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a>121. Best Time to Buy and Sell Stock (Easy)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock"><a href="#You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock" class="headerlink" title="You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock."></a>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</h2><h2 id="Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0"><a href="#Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0" class="headerlink" title="Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0."></a>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</h2><p>其实这题是动态规划的问题.卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-i/">121</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p><img src="https://pic.leetcode-cn.com/4eaadab491f2bf88639d66c9d51bb0115e694ae08d637841ac18172b631cb21f-0121.gif" alt="图片"></p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>406. Queue Reconstruction by Height(Medium)</title>
      <link href="/2022/06/11/406/"/>
      <url>/2022/06/11/406/</url>
      
        <content type="html"><![CDATA[<h1 id="406-Queue-Reconstruction-by-Height-Medium"><a href="#406-Queue-Reconstruction-by-Height-Medium" class="headerlink" title="406. Queue Reconstruction by Height(Medium)"></a>406. Queue Reconstruction by Height(Medium)</h1><h2 id="You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi"><a href="#You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi" class="headerlink" title="You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi."></a>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</h2><h2 id="Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue"><a href="#Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue" class="headerlink" title="Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue)."></a>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</h2><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。</p><p>渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</p><p>在本题目中，首先对数对进行排序，按照数对的元素 1(身高) 降序排序，按照数对的元素 2 (人数)升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。</p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/">leetcode题解</a></p><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = lambda x: (-x[0], x[1]))</span><br></pre></td></tr></table></figure><p>第一个元素降序，第二个元素升序排列，以第一个元素的降序排列优先</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = [[1,4],[2,3],[3,4],[1,3],[1,2]]</span><br><span class="line"></span><br><span class="line">print(sorted(A,key=lambda x:x[1]))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0], x[1])))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [2, 3], [1, 3], [1, 4], [3, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 2], [1, 3], [1, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 4], [1, 3], [1, 2]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="本题例子"><a href="#本题例子" class="headerlink" title="本题例子"></a>本题例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br></pre></td></tr></table></figure><p>所以排序完：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>])) <span class="comment">#排序</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= p[<span class="number">1</span>]:  <span class="comment">#比较的变量是当前数组的长度</span></span><br><span class="line">                res.append(p)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(res) &gt; p[<span class="number">1</span>]:</span><br><span class="line">                res.insert(p[<span class="number">1</span>], p)  <span class="comment"># p is inserted at index p[1]（参与这次排序的P[1])</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> people:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = people[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons (Medium)</title>
      <link href="/2022/06/10/452/"/>
      <url>/2022/06/10/452/</url>
      
        <content type="html"><![CDATA[<h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons (Medium)"></a>452. Minimum Number of Arrows to Burst Balloons (Medium)</h1><h2 id="There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons"><a href="#There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons" class="headerlink" title="There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons."></a>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.</h2><h2 id="Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path"><a href="#Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path" class="headerlink" title="Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path."></a>Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</h2><h2 id="Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons"><a href="#Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons" class="headerlink" title="Given the array points, return the minimum number of arrows that must be shot to burst all balloons."></a>Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</h2><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p><p>也是计算不重叠的区间个数，不过和 Non-overlapping points 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p><p><img src="https://assets.leetcode-cn.com/solution-static/452/1.png" alt="射箭"></p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h2><p>这道题和 435. Non-overlapping Intervals (Medium) 有些类似，都是寻找重合区间</p><p>贪心：<br>既然每个气球都需要被引爆，那么在满足引爆对箭限制最大的那个气球（因为它一定要被引爆，而箭和其它同时被引爆的气球 都可以迁就它，所以满足它是必须的） 的同时，引爆尽可能多其他的气球。</p><p>在付出不变的的前提下，获得尽可能多。</p><p>简单来说就是先按照区间右边边界从小到大排序，为了尽可能的多引爆气球，第一支箭射在第一个区间的最右边，根据后面区间的左端点判断一共引爆了哪些区间，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。</p><p>有个问题是这 nn 个气球对应的区间互不重叠，while 循环需要执行 n 次。所以当遇到x(j) ≤ y(i)时 我们可以直接跳出循环，y(j)就是下一个箭的位置。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. Non-overlapping Intervals (Medium)</title>
      <link href="/2022/06/09/435/"/>
      <url>/2022/06/09/435/</url>
      
        <content type="html"><![CDATA[<h1 id="435-Non-overlapping-Intervals-Medium"><a href="#435-Non-overlapping-Intervals-Medium" class="headerlink" title="435. Non-overlapping Intervals (Medium)"></a>435. Non-overlapping Intervals (Medium)</h1><h2 id="Given-an-array-of-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-intervals-you-need-to-remove-to-make-the-rest-of-the-intervals-non-overlapping"><a href="#Given-an-array-of-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-intervals-you-need-to-remove-to-make-the-rest-of-the-intervals-non-overlapping" class="headerlink" title="Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping."></a>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p><p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        n = <span class="built_in">len</span>(intervals)</span><br><span class="line">        right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= right:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - ans</span><br></pre></td></tr></table></figure><p>注释：<br>key=lambda 元素: 元素[字段索引]</p><p>比如   print(sorted(C, key=lambda x: x[2]))   </p><p>x:x[]字母可以随意修改，排序方式按照中括号[]里面的维度进行排序，[0]按照第一维排序，[2]按照第三维排序</p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C = [(<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> y: y[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#输出[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>]))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455. Assign Cookies (Easy)</title>
      <link href="/2022/06/09/455/"/>
      <url>/2022/06/09/455/</url>
      
        <content type="html"><![CDATA[<h1 id="455-Assign-Cookies-Easy"><a href="#455-Assign-Cookies-Easy" class="headerlink" title="455. Assign Cookies (Easy)"></a>455. Assign Cookies (Easy)</h1><h2 id="Assume-you-are-an-awesome-parent-and-want-to-give-your-children-some-cookies-But-you-should-give-each-child-at-most-one-cookie"><a href="#Assume-you-are-an-awesome-parent-and-want-to-give-your-children-some-cookies-But-you-should-give-each-child-at-most-one-cookie" class="headerlink" title="Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie."></a>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</h2><h2 id="Each-child-i-has-a-greed-factor-g-i-which-is-the-minimum-size-of-a-cookie-that-the-child-will-be-content-with-and-each-cookie-j-has-a-size-s-j-If-s-j-gt-g-i-we-can-assign-the-cookie-j-to-the-child-i-and-the-child-i-will-be-content-Your-goal-is-to-maximize-the-number-of-your-content-children-and-output-the-maximum-number"><a href="#Each-child-i-has-a-greed-factor-g-i-which-is-the-minimum-size-of-a-cookie-that-the-child-will-be-content-with-and-each-cookie-j-has-a-size-s-j-If-s-j-gt-g-i-we-can-assign-the-cookie-j-to-the-child-i-and-the-child-i-will-be-content-Your-goal-is-to-maximize-the-number-of-your-content-children-and-output-the-maximum-number" class="headerlink" title="Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number."></a>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</h2><p>题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。<br>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。<br>在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。 </p><p>个人理解就是尽力把小的孩子喂饱，每轮都按照这样喂饱就是最优解</p><p>自己写的，按照题目逻辑s[j]&gt;=g[i]判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">        i = j = count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># greed factor g[i]</span></span><br><span class="line">        <span class="comment"># cookie size s[j]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[j]&gt;=g[i]:</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">        i = j = count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># greed factor g[i]</span></span><br><span class="line">        <span class="comment"># cookie size s[j]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i] &gt; s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode04贪心思想</title>
      <link href="/2022/06/09/LeetCode04/"/>
      <url>/2022/06/09/LeetCode04/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-贪心思想"><a href="#Leetcode-题解-贪心思想" class="headerlink" title="Leetcode 题解 - 贪心思想"></a>Leetcode 题解 - 贪心思想</h1><h2 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1. 分配饼干"></a>1. 分配饼干</h2><h2 id="2-不重叠的区间个数"><a href="#2-不重叠的区间个数" class="headerlink" title="2. 不重叠的区间个数"></a>2. 不重叠的区间个数</h2><h2 id="3-投飞镖刺破气球"><a href="#3-投飞镖刺破气球" class="headerlink" title="3. 投飞镖刺破气球"></a>3. 投飞镖刺破气球</h2><h2 id="4-根据身高和序号重组队列"><a href="#4-根据身高和序号重组队列" class="headerlink" title="4. 根据身高和序号重组队列"></a>4. 根据身高和序号重组队列</h2><h2 id="5-买卖股票最大的收益"><a href="#5-买卖股票最大的收益" class="headerlink" title="5. 买卖股票最大的收益"></a>5. 买卖股票最大的收益</h2><h2 id="6-买卖股票的最大收益-II"><a href="#6-买卖股票的最大收益-II" class="headerlink" title="6. 买卖股票的最大收益 II"></a>6. 买卖股票的最大收益 II</h2><h2 id="7-种植花朵"><a href="#7-种植花朵" class="headerlink" title="7. 种植花朵"></a>7. 种植花朵</h2><h2 id="8-判断是否为子序列"><a href="#8-判断是否为子序列" class="headerlink" title="8. 判断是否为子序列"></a>8. 判断是否为子序列</h2><h2 id="9-修改一个数成为非递减数组"><a href="#9-修改一个数成为非递减数组" class="headerlink" title="9. 修改一个数成为非递减数组"></a>9. 修改一个数成为非递减数组</h2><h2 id="10-子数组最大的和"><a href="#10-子数组最大的和" class="headerlink" title="10. 子数组最大的和"></a>10. 子数组最大的和</h2><h2 id="11-分隔字符串使同种字符出现在一起"><a href="#11-分隔字符串使同种字符出现在一起" class="headerlink" title="11. 分隔字符串使同种字符出现在一起"></a>11. 分隔字符串使同种字符出现在一起</h2><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors (Medium)</title>
      <link href="/2022/06/09/75/"/>
      <url>/2022/06/09/75/</url>
      
        <content type="html"><![CDATA[<h1 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a>75. Sort Colors (Medium)</h1><h2 id="Given-an-array-nums-with-n-objects-colored-red-white-or-blue-sort-them-in-place-so-that-objects-of-the-same-color-are-adjacent-with-the-colors-in-the-order-red-white-and-blue"><a href="#Given-an-array-nums-with-n-objects-colored-red-white-or-blue-sort-them-in-place-so-that-objects-of-the-same-color-are-adjacent-with-the-colors-in-the-order-red-white-and-blue" class="headerlink" title="Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue."></a>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</h2><h2 id="We-will-use-the-integers-0-1-and-2-to-represent-the-color-red-white-and-blue-respectively"><a href="#We-will-use-the-integers-0-1-and-2-to-represent-the-color-red-white-and-blue-respectively" class="headerlink" title="We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively."></a>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</h2><h2 id="You-must-solve-this-problem-without-using-the-library’s-sort-function"><a href="#You-must-solve-this-problem-without-using-the-library’s-sort-function" class="headerlink" title="You must solve this problem without using the library’s sort function."></a>You must solve this problem without using the library’s sort function.</h2><h2 id="有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。"><a href="#有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。" class="headerlink" title="有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。"></a>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</h2><p>个人理解就是三指针，跟之前的双指针差不多，和之前不同的是因为有三个区间所以要三个指针<br><a href="https://cloud.tencent.com/developer/article/1624933#:~:text=%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%EF%BC%9A%E7%8E%B0%E5%9C%A8%E6%9C%89,%E5%90%8E%E6%AD%A3%E5%A5%BD%E7%BB%84%E6%88%90%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E3%80%82&text=%E8%BF%99%E9%81%93%E9%A2%98%E5%BE%88%E7%BB%8F%E5%85%B8%EF%BC%8C%E5%BE%88%E9%AB%98%E9%A2%91%E3%80%82">荷兰国旗问题参考</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        a = c = <span class="number">0</span></span><br><span class="line">        b = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> c &lt;= b:</span><br><span class="line">            <span class="keyword">if</span> nums[c] == <span class="number">0</span>:</span><br><span class="line">                nums[a], nums[c] = nums[c], nums[a]</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[c] == <span class="number">2</span>:</span><br><span class="line">                nums[c], nums[b] = nums[b], nums[c]</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>451. Sort Characters By Frequency (Medium)</title>
      <link href="/2022/06/09/451/"/>
      <url>/2022/06/09/451/</url>
      
        <content type="html"><![CDATA[<ol start="451"><li>Sort Characters By Frequency (Medium)</li></ol><h2 id="Given-a-string-s-sort-it-in-decreasing-order-based-on-the-frequency-of-the-characters-The-frequency-of-a-character-is-the-number-of-times-it-appears-in-the-string"><a href="#Given-a-string-s-sort-it-in-decreasing-order-based-on-the-frequency-of-the-characters-The-frequency-of-a-character-is-the-number-of-times-it-appears-in-the-string" class="headerlink" title="Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string."></a>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.</h2><h2 id="Return-the-sorted-string-If-there-are-multiple-answers-return-any-of-them"><a href="#Return-the-sorted-string-If-there-are-multiple-answers-return-any-of-them" class="headerlink" title="Return the sorted string. If there are multiple answers, return any of them."></a>Return the sorted string. If there are multiple answers, return any of them.</h2><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/python3-shuang-90-by-key-wu-xbod/">Leetcode 题解</a></p><p>这道题和 347. Top K Frequent Elements (Medium) 几乎一样，一个是数字一个是字符串，方法也类似</p><p>1.建哈希表，将字符串s中的每个字符计数<br>2.根据哈希表中的值进行降序排序即可<br>3.直接字符乘以数目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans] += <span class="number">1</span></span><br><span class="line">        result = <span class="built_in">sorted</span>(hashmap.items(),key=<span class="keyword">lambda</span> hashmap:hashmap[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">            res = result[i][<span class="number">0</span>] * result[i][<span class="number">1</span>]</span><br><span class="line">            s += res</span><br><span class="line">        <span class="keyword">return</span> s </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements (Medium)</title>
      <link href="/2022/06/09/347/"/>
      <url>/2022/06/09/347/</url>
      
        <content type="html"><![CDATA[<h1 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a>347. Top K Frequent Elements (Medium)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-the-k-most-frequent-elements-You-may-return-the-answer-in-any-order"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-the-k-most-frequent-elements-You-may-return-the-answer-in-any-order" class="headerlink" title="Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order."></a>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</h2><p>hashmap<br>1.建哈希表，将数组中的每个数字计数<br>2.根据哈希表中的值进行降序排序即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums, k</span>):</span> </span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans] += <span class="number">1</span></span><br><span class="line">        result = <span class="built_in">sorted</span>(hashmap.items(),key=<span class="keyword">lambda</span> hashmap:hashmap[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            res.extend(result[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">           </span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/bi-guan-fang-ti-jie-geng-kuai-de-fang-fa-lgsc/">题解评论</a></p><p>用字典去代替数组会不会好一些；<br>倒序遍历频次时，最大不超过 n-k+1 ；<br>python3版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashMap = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            hashMap[num] = hashMap.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        bucket = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> x, v <span class="keyword">in</span> hashMap.items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> bucket:</span><br><span class="line">                bucket[v] = [x]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[v].append(x)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - k + <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt;= k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> bucket:</span><br><span class="line">                res.extend(bucket[v])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/python-dui-pai-xu-by-xxinjiee/">leetcode题解</a></p><p>对于 topk 问题：最大堆求topk小，最小堆求 topk 大。</p><p>topk小：构建一个 k 个数的最大堆，当读取的数小于根节点时，替换根节点，重新塑造最大堆<br>topk大：构建一个 k 个数的最小堆，当读取的数大于根节点时，替换根节点，重新塑造最小堆<br>这一题的总体思路 总体时间复杂度 O(nlogk)O(nlogk)</p><p>遍历统计元素出现频率 O(n)O(n)<br>前k个数构造 规模为 k+1 的最小堆 minheap， O(k)O(k)， 注意 +1 是因为占位节点。<br>遍历规模k之外的数据，大于堆顶则入堆，下沉维护规模为k的最小堆 minheap. O(nlogk)O(nlogk)<br>(如需按频率输出，对规模为k的堆进行排序)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span>(<span class="params">arr, root, k</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;下沉log(k),如果新的根节点&gt;子节点就一直下沉&quot;&quot;&quot;</span></span><br><span class="line">            val = arr[root] <span class="comment"># 用类似插入排序的赋值交换</span></span><br><span class="line">            <span class="keyword">while</span> root&lt;&lt;<span class="number">1</span> &lt; k:</span><br><span class="line">                child = root &lt;&lt; <span class="number">1</span></span><br><span class="line">                <span class="comment"># 选取左右孩子中小的与父节点交换</span></span><br><span class="line">                <span class="keyword">if</span> child|<span class="number">1</span> &lt; k <span class="keyword">and</span> arr[child|<span class="number">1</span>][<span class="number">1</span>] &lt; arr[child][<span class="number">1</span>]:</span><br><span class="line">                    child |= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果子节点&lt;新节点,交换,如果已经有序break</span></span><br><span class="line">                <span class="keyword">if</span> arr[child][<span class="number">1</span>] &lt; val[<span class="number">1</span>]:</span><br><span class="line">                    arr[root] = arr[child]</span><br><span class="line">                    root = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            arr[root] = val</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span>(<span class="params">arr, child</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;上浮log(k),如果新加入的节点&lt;父节点就一直上浮&quot;&quot;&quot;</span></span><br><span class="line">            val = arr[child]</span><br><span class="line">            <span class="keyword">while</span> child&gt;&gt;<span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> val[<span class="number">1</span>] &lt; arr[child&gt;&gt;<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                arr[child] = arr[child&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                child &gt;&gt;= <span class="number">1</span></span><br><span class="line">            arr[child] = val</span><br><span class="line"></span><br><span class="line">        stat = collections.Counter(nums)</span><br><span class="line">        stat = <span class="built_in">list</span>(stat.items())</span><br><span class="line">        heap = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建规模为k+1的堆,新元素加入堆尾,上浮</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            heap.append(stat[i])</span><br><span class="line">            sift_up(heap, <span class="built_in">len</span>(heap)-<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 维护规模为k+1的堆,如果新元素大于堆顶,入堆,并下沉</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(stat)):</span><br><span class="line">            <span class="keyword">if</span> stat[i][<span class="number">1</span>] &gt; heap[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                heap[<span class="number">1</span>] = stat[i]</span><br><span class="line">                sift_down(heap, <span class="number">1</span>, k+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> heap[<span class="number">1</span>:]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array (Medium)</title>
      <link href="/2022/06/09/215/"/>
      <url>/2022/06/09/215/</url>
      
        <content type="html"><![CDATA[<h1 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a>215. Kth Largest Element in an Array (Medium)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-the-kth-largest-element-in-the-array"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-the-kth-largest-element-in-the-array" class="headerlink" title="Given an integer array nums and an integer k, return the kth largest element in the array."></a>Given an integer array nums and an integer k, return the kth largest element in the array.</h2><h2 id="Note-that-it-is-the-kth-largest-element-in-the-sorted-order-not-the-kth-distinct-element"><a href="#Note-that-it-is-the-kth-largest-element-in-the-sorted-order-not-the-kth-distinct-element" class="headerlink" title="Note that it is the kth largest element in the sorted order, not the kth distinct element."></a>Note that it is the kth largest element in the sorted order, not the kth distinct element.</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/">leetcode题解</a></p><h2 id="方法一-快速排序（Quick-Sort）"><a href="#方法一-快速排序（Quick-Sort）" class="headerlink" title="方法一. 快速排序（Quick Sort）"></a>方法一. 快速排序（Quick Sort）</h2><p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔（Tony Hoare ）提出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            pivot = arr[low]                                        <span class="comment"># 选取最左边为pivot</span></span><br><span class="line"></span><br><span class="line">            left, right = low, high     <span class="comment"># 双指针</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right] &gt;= pivot:          <span class="comment"># 找到右边第一个&lt;pivot的元素</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                arr[left] = arr[right]                             <span class="comment"># 并将其移动到left处</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[left] &lt;= pivot:           <span class="comment"># 找到左边第一个&gt;pivot的元素</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                arr[right] = arr[left]                             <span class="comment"># 并将其移动到right处</span></span><br><span class="line">            </span><br><span class="line">            arr[left] = pivot           <span class="comment"># pivot放置到中间left=right处</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">randomPartition</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            pivot_idx = random.randint(low, high)                   <span class="comment"># 随机选择pivot</span></span><br><span class="line">            arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low]     <span class="comment"># pivot放置到最左边</span></span><br><span class="line">            <span class="keyword">return</span> partition(arr, low, high)                        <span class="comment"># 调用partition函数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">topKSplit</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="comment"># mid = partition(arr, low, high)                   # 以mid为分割点【非随机选择pivot】</span></span><br><span class="line">            mid = randomPartition(arr, low, high)               <span class="comment"># 以mid为分割点【随机选择pivot】</span></span><br><span class="line">            <span class="keyword">if</span> mid == k-<span class="number">1</span>:                                      <span class="comment"># 第k小元素的下标为k-1</span></span><br><span class="line">                <span class="keyword">return</span> arr[mid]                                 <span class="comment">#【找到即返回】</span></span><br><span class="line">            <span class="keyword">elif</span> mid &lt; k-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> topKSplit(arr, mid+<span class="number">1</span>, high, k)           <span class="comment"># 递归对mid右侧元素进行排序</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> topKSplit(arr, low, mid-<span class="number">1</span>, k)            <span class="comment"># 递归对mid左侧元素进行排序</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> topKSplit(nums, <span class="number">0</span>, n-<span class="number">1</span>, n-k+<span class="number">1</span>)                   <span class="comment"># 第k大元素即为第n-k+1小元素</span></span><br></pre></td></tr></table></figure><h2 id="方法二-堆排序（Heap-Sort）"><a href="#方法二-堆排序（Heap-Sort）" class="headerlink" title="方法二. 堆排序（Heap Sort）"></a>方法二. 堆排序（Heap Sort）</h2><p>堆排序（英语：Heapsort）是指利用堆（heap）这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。[摘自@维基百科]</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/">leetcode题解</a></p><p>堆与排序：</p><p>对于一个待排序的包含 nn 个元素的数组 numsnums，堆排序 通常包含以下几个基本步骤：</p><ol><li>建堆：将待排序的数组初始化为大根堆（小根堆）。此时，堆顶的元素（即根节点）即为整个数组中的最大值（最小值）。</li><li>交换和调整：将堆顶元素与末尾元素进行交换，此时末尾即为最大值（最小值）。除去末尾元素后，将其他 n-1n−1 个元素重新构造成一个大根堆（小根堆），如此便可得到原数组 nn 个元素中的次大值（次小值）。</li><li>重复步骤二，直至堆中仅剩一个元素，如此便可得到一个有序序列了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHeapify</span>(<span class="params">arr, i, end</span>):</span></span><br><span class="line">            j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[j+<span class="number">1</span>] &gt; arr[j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">                    i = j</span><br><span class="line">                    j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHepify</span>(<span class="params">arr, i, end</span>):</span>     <span class="comment"># 大顶堆</span></span><br><span class="line">            j = <span class="number">2</span>*i + <span class="number">1</span>                 <span class="comment"># j为i的左子节点【建堆时下标0表示堆顶】</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:             <span class="comment"># 自上而下进行调整</span></span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[j+<span class="number">1</span>] &gt; arr[j]:    <span class="comment"># i的左右子节点分别为j和j+1</span></span><br><span class="line">                    j += <span class="number">1</span>                              <span class="comment"># 取两者之间的较大者</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:             <span class="comment"># 若i指示的元素小于其子节点中的较大者</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]     <span class="comment"># 交换i和j的元素，并继续往下判断</span></span><br><span class="line">                    i = j                       <span class="comment"># 往下走：i调整为其子节点j</span></span><br><span class="line">                    j = <span class="number">2</span>*i + <span class="number">1</span>                 <span class="comment"># j调整为i的左子节点</span></span><br><span class="line">                <span class="keyword">else</span>:                           <span class="comment"># 否则，结束调整</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建堆【大顶堆】</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):         <span class="comment"># 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整</span></span><br><span class="line">            maxHepify(nums, i, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆</span></span><br><span class="line">        <span class="comment"># k-1次重建堆（堆顶元素），或 k次交换到尾部（倒数第k个元素）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, n-k-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[j] = nums[j], nums[<span class="number">0</span>]     <span class="comment"># 堆顶元素（当前最大值）放置到尾部j</span></span><br><span class="line">            maxHepify(nums, <span class="number">0</span>, j-<span class="number">1</span>)                 <span class="comment"># j-1变成尾部，并从堆顶0开始调整堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于快排的所有TopK问题简单python模板"><a href="#基于快排的所有TopK问题简单python模板" class="headerlink" title="基于快排的所有TopK问题简单python模板"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/ji-yu-kuai-pai-de-suo-you-topkwen-ti-jia-ylsd/">基于快排的所有TopK问题简单python模板</a></h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Heap Sort </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> topk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode03排序</title>
      <link href="/2022/06/03/LeetCode03/"/>
      <url>/2022/06/03/LeetCode03/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-排序"><a href="#Leetcode-题解-排序" class="headerlink" title="Leetcode 题解 - 排序"></a>Leetcode 题解 - 排序</h1><h2 id="1-快速选择"><a href="#1-快速选择" class="headerlink" title="1. 快速选择"></a>1. 快速选择</h2><h2 id="2-堆-Kth-Element"><a href="#2-堆-Kth-Element" class="headerlink" title="2. 堆-Kth Element"></a>2. 堆-Kth Element</h2><h2 id="3-桶排序"><a href="#3-桶排序" class="headerlink" title="3. 桶排序"></a>3. 桶排序</h2><h2 id="4-荷兰国旗问题"><a href="#4-荷兰国旗问题" class="headerlink" title="4. 荷兰国旗问题"></a>4. 荷兰国旗问题</h2><ol><li>快速选择（快速排序）</li></ol><p>用于求解 Kth Element 问题，也就是第 K 个元素的问题。</p><p>快速选择算法是基于快速排序算法思想的用于解决Top K 问题的算法</p><p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。</p><p>步骤：<br>a. 从数列中挑出一个元素，称为 “基准”（pivot）;</p><p>b. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p><p>c. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><ol start="2"><li>堆排序</li></ol><p>用于求解 TopK Elements 问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。</p><p>堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。</p><p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p><p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p><ol start="3"><li>桶排序<br>桶排序，简单来说就是将待排序序列，按照序列值的大小划分成几个桶，分别对每组进行排序，排完序之后再按照一定的顺序合并所有的桶，即排序完成。</li></ol><p>对这道题而言，设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p><p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p><ol start="4"><li>荷兰国旗问题</li></ol><p>“荷兰国旗问题” 是计算机科学中的一个经典题目，它是由Edsger Dijkstra提出的。荷兰国旗由红、白、蓝三色组成。</p><p>荷兰国旗问题：现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。</p><p>这个问题之所以叫荷兰国旗，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>524. Longest Word in Dictionary through Deleting (Medium)</title>
      <link href="/2022/05/31/524/"/>
      <url>/2022/05/31/524/</url>
      
        <content type="html"><![CDATA[<h1 id="524-Longest-Word-in-Dictionary-through-Deleting-Medium"><a href="#524-Longest-Word-in-Dictionary-through-Deleting-Medium" class="headerlink" title="524. Longest Word in Dictionary through Deleting (Medium)"></a>524. Longest Word in Dictionary through Deleting (Medium)</h1><h2 id="Given-a-string-s-and-a-string-array-dictionary-return-the-longest-string-in-the-dictionary-that-can-be-formed-by-deleting-some-of-the-given-string-characters-If-there-is-more-than-one-possible-result-return-the-longest-word-with-the-smallest-lexicographical-order-If-there-is-no-possible-result-return-the-empty-string"><a href="#Given-a-string-s-and-a-string-array-dictionary-return-the-longest-string-in-the-dictionary-that-can-be-formed-by-deleting-some-of-the-given-string-characters-If-there-is-more-than-one-possible-result-return-the-longest-word-with-the-smallest-lexicographical-order-If-there-is-no-possible-result-return-the-empty-string" class="headerlink" title="Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string."></a>Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</h2><h2 id="题目描述：删除-s-中的一些字符，使得它构成字符串列表-d-中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。"><a href="#题目描述：删除-s-中的一些字符，使得它构成字符串列表-d-中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。" class="headerlink" title="题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。"></a>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</h2><p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="1-只有双指针"><a href="#1-只有双指针" class="headerlink" title="1.只有双指针"></a>1.只有双指针</h4><p>这题还真有些难度，主要是有些问题不能一眼看到逻辑和结果。</p><p>根据题意，我们需要解决三个问题：</p><ol><li><p>给定字符串s删除一些字符后能得到数组的字符串</p></li><li><p>找最长的字符串</p></li><li><p>如果长度相同，选字典顺序最小的字符串<br>官方例子：<br>Input: s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>Output: “apple”</p></li><li><p>第一点很好理解，就是在s这个字符串里找到子串。就像在一个集合里找到子集一样，可以发现[“ale”,”apple”,”plea”]符合</p></li><li><p>最长的字符串就是比较子串长度了，[“apple”] 就比 [“ale”] 和 [“plea”]长度要长</p></li><li><p>字典顺序最小，这个就是比较在字母表上的顺序了，以 a、b、c……z 的顺序排列，a最小，假如还有个新单词 [“appla”],那和[“apple”]比较，虽然长度一样，但是a的字典顺序在e前，所以我们得选择[“appla”]</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> dictionary:</span><br><span class="line">            i = j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(t) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> t[i] == s[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(t):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(t) == <span class="built_in">len</span>(res) <span class="keyword">and</span> t &lt; res):</span><br><span class="line">                    res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>排序+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        f.append([m] * <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(s[i]) == j + <span class="number">97</span>:</span><br><span class="line">                    f[i][j] = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> dictionary:</span><br><span class="line">            match = <span class="literal">True</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">                <span class="keyword">if</span> f[j][<span class="built_in">ord</span>(t[i]) - <span class="number">97</span>] == m:</span><br><span class="line">                    match = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j = f[j][<span class="built_in">ord</span>(t[i]) - <span class="number">97</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(t) == <span class="built_in">len</span>(res) <span class="keyword">and</span> t &lt; res):</span><br><span class="line">                    res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle (Easy)</title>
      <link href="/2022/05/31/141/"/>
      <url>/2022/05/31/141/</url>
      
        <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><h2 id="Given-head-the-head-of-a-linked-list-determine-if-the-linked-list-has-a-cycle-in-it"><a href="#Given-head-the-head-of-a-linked-list-determine-if-the-linked-list-has-a-cycle-in-it" class="headerlink" title="Given head, the head of a linked list, determine if the linked list has a cycle in it."></a>Given head, the head of a linked list, determine if the linked list has a cycle in it.</h2><h2 id="There-is-a-cycle-in-a-linked-list-if-there-is-some-node-in-the-list-that-can-be-reached-again-by-continuously-following-the-next-pointer-Internally-pos-is-used-to-denote-the-index-of-the-node-that-tail’s-next-pointer-is-connected-to-Note-that-pos-is-not-passed-as-a-parameter"><a href="#There-is-a-cycle-in-a-linked-list-if-there-is-some-node-in-the-list-that-can-be-reached-again-by-continuously-following-the-next-pointer-Internally-pos-is-used-to-denote-the-index-of-the-node-that-tail’s-next-pointer-is-connected-to-Note-that-pos-is-not-passed-as-a-parameter" class="headerlink" title="There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter."></a>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</h2><h2 id="Return-true-if-there-is-a-cycle-in-the-linked-list-Otherwise-return-false"><a href="#Return-true-if-there-is-a-cycle-in-the-linked-list-Otherwise-return-false" class="headerlink" title="Return true if there is a cycle in the linked list. Otherwise, return false."></a>Return true if there is a cycle in the linked list. Otherwise, return false.</h2><p>快慢指针</p><p>官方题解：<br>「Floyd 判圈算法」（又称龟兔赛跑算法）<br>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p><p>官方解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>leetcode discussion（速度更快，但逻辑是类似的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            slow = head</span><br><span class="line">            fast = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这里有一点小不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> slow != fast:</span><br></pre></td></tr></table></figure><p>这两个的编译速度在我多次尝试后发现没什么不同，应该没有什么影响</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array (Easy)</title>
      <link href="/2022/05/29/88/"/>
      <url>/2022/05/29/88/</url>
      
        <content type="html"><![CDATA[<h1 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a>88. Merge Sorted Array (Easy)</h1><h2 id="You-are-given-two-integer-arrays-nums1-and-nums2-sorted-in-non-decreasing-order-and-two-integers-m-and-n-representing-the-number-of-elements-in-nums1-and-nums2-respectively"><a href="#You-are-given-two-integer-arrays-nums1-and-nums2-sorted-in-non-decreasing-order-and-two-integers-m-and-n-representing-the-number-of-elements-in-nums1-and-nums2-respectively" class="headerlink" title="You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively."></a>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</h2><h2 id="Merge-nums1-and-nums2-into-a-single-array-sorted-in-non-decreasing-order"><a href="#Merge-nums1-and-nums2-into-a-single-array-sorted-in-non-decreasing-order" class="headerlink" title="Merge nums1 and nums2 into a single array sorted in non-decreasing order."></a>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</h2><h2 id="The-final-sorted-array-should-not-be-returned-by-the-function-but-instead-be-stored-inside-the-array-nums1-To-accommodate-this-nums1-has-a-length-of-m-n-where-the-first-m-elements-denote-the-elements-that-should-be-merged-and-the-last-n-elements-are-set-to-0-and-should-be-ignored-nums2-has-a-length-of-n"><a href="#The-final-sorted-array-should-not-be-returned-by-the-function-but-instead-be-stored-inside-the-array-nums1-To-accommodate-this-nums1-has-a-length-of-m-n-where-the-first-m-elements-denote-the-elements-that-should-be-merged-and-the-last-n-elements-are-set-to-0-and-should-be-ignored-nums2-has-a-length-of-n" class="headerlink" title="The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n."></a>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</h2><p>python 数组技巧<br>array[n:]：打印从第n个元素（下标为n-1）到最后一个元素(包括第n个元素)<br>array[:n]：打印从第一个元素到第n个元素（下标为n-1）（包括第n个元素）</p><p>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>Output: [1,2,2,3,5,6]<br>Explanation: The arrays we are merging are [1,2,3] and [2,5,6].<br>The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m-<span class="number">1</span>] &gt;= nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m-<span class="number">1</span>] &gt;= nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>680. Valid Palindrome II (Easy)</title>
      <link href="/2022/05/28/680/"/>
      <url>/2022/05/28/680/</url>
      
        <content type="html"><![CDATA[<h1 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II(Easy)"></a>680. Valid Palindrome II(Easy)</h1><h2 id="Given-a-string-s-return-true-if-the-s-can-be-palindrome-after-deleting-at-most-one-character-from-it"><a href="#Given-a-string-s-return-true-if-the-s-can-be-palindrome-after-deleting-at-most-one-character-from-it" class="headerlink" title="Given a string s, return true if the s can be palindrome after deleting at most one character from it."></a>Given a string s, return true if the s can be palindrome after deleting at most one character from it.</h2><h2 id="官方题解：list-双指针"><a href="#官方题解：list-双指针" class="headerlink" title="官方题解：list+双指针"></a>官方题解：list+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Time: O(n)</span></span><br><span class="line">        <span class="comment"># Space: O(n)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                one, two = s[left:right], s[left + <span class="number">1</span>:right + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">return</span> one == one[::-<span class="number">1</span>] <span class="keyword">or</span> two == two[::-<span class="number">1</span>]</span><br><span class="line">            left, right = left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                delete_i = s[i+<span class="number">1</span>:j+<span class="number">1</span>]</span><br><span class="line">                delete_j = s[i:j]</span><br><span class="line">                <span class="keyword">return</span> self._isPalindrome(delete_i) <span class="keyword">or</span> self._isPalindrome(delete_j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>345. Reverse Vowels of a String (Easy)</title>
      <link href="/2022/05/28/345/"/>
      <url>/2022/05/28/345/</url>
      
        <content type="html"><![CDATA[<h1 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. Reverse Vowels of a String</h1><h2 id="Given-a-string-s-reverse-only-all-the-vowels-in-the-string-and-return-it"><a href="#Given-a-string-s-reverse-only-all-the-vowels-in-the-string-and-return-it" class="headerlink" title="Given a string s, reverse only all the vowels in the string and return it."></a>Given a string s, reverse only all the vowels in the string and return it.</h2><h2 id="The-vowels-are-‘a’-‘e’-‘i’-‘o’-and-‘u’-and-they-can-appear-in-both-cases"><a href="#The-vowels-are-‘a’-‘e’-‘i’-‘o’-and-‘u’-and-they-can-appear-in-both-cases" class="headerlink" title="The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases."></a>The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases.</h2><h2 id="官方题解：list-双指针"><a href="#官方题解：list-双指针" class="headerlink" title="官方题解：list+双指针"></a>官方题解：list+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isVowel</span>(<span class="params">ch: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">return</span> ch <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; n <span class="keyword">and</span> <span class="keyword">not</span> isVowel(s[i]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> isVowel(s[j]):</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                s[left], s[right] = s[right], s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        temp=[]<span class="comment">#存储遇到的元音</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]:</span><br><span class="line">                temp.append(s[i])</span><br><span class="line">        k=<span class="built_in">len</span>(temp)</span><br><span class="line">        s=<span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]:</span><br><span class="line">                s[i]=temp[k-<span class="number">1</span>]<span class="comment">#temp从后往前取值去覆盖</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><p>list+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        vowels = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span>]     <span class="comment"># 元音字母列表</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)                                                     <span class="comment"># 列表化输入字符串</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>                                     <span class="comment"># 初始化左右指针位置</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:                                             <span class="comment"># 如果指针位置合法</span></span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">not</span> <span class="keyword">in</span> vowels:                                   <span class="comment"># 如果左指针处字符不是元音字母</span></span><br><span class="line">                left += <span class="number">1</span>                                               <span class="comment"># 左指针右移</span></span><br><span class="line">            <span class="keyword">elif</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> vowels:                                <span class="comment"># 如果右指针处字符不是元音字母</span></span><br><span class="line">                right -= <span class="number">1</span>                                              <span class="comment"># 右指针左移</span></span><br><span class="line">            <span class="keyword">else</span>:                                                       <span class="comment"># 如果左右指针处字符都是元音字母</span></span><br><span class="line">                s[left], s[right] = s[right], s[left]                   <span class="comment"># 交换位置</span></span><br><span class="line">                left += <span class="number">1</span>                                               <span class="comment"># 左指针右移</span></span><br><span class="line">                right -= <span class="number">1</span>                                              <span class="comment"># 右指针左移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)                                               <span class="comment"># 将列表中的字符连接起来</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>633. Sum of Square Numbers (Medium)</title>
      <link href="/2022/05/28/633-Sum%20of%20Square%20Numbers/"/>
      <url>/2022/05/28/633-Sum%20of%20Square%20Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="633-Sum-of-Square-Numbers"><a href="#633-Sum-of-Square-Numbers" class="headerlink" title="633. Sum of Square Numbers"></a>633. Sum of Square Numbers</h1><h2 id="Given-a-non-negative-integer-c-decide-whether-there’re-two-integers-a-and-b-such-that-a2-b2-c"><a href="#Given-a-non-negative-integer-c-decide-whether-there’re-two-integers-a-and-b-such-that-a2-b2-c" class="headerlink" title="Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c."></a>Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c.</h2><p>同样是双指针</p><p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c</span>):</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">int</span>(c**<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="built_in">sum</span> = l*l+r*r</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; c:</span><br><span class="line">                l +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span>&gt;c:</span><br><span class="line">                r -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input array is sorted (Easy)</title>
      <link href="/2022/05/28/167-twosum-sorted/"/>
      <url>/2022/05/28/167-twosum-sorted/</url>
      
        <content type="html"><![CDATA[<h1 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a>167. Two Sum II - Input Array Is Sorted</h1><h2 id="Given-a-1-indexed-array-of-integers-numbers-that-is-already-sorted-in-non-decreasing-order-find-two-numbers-such-that-they-add-up-to-a-specific-target-number-Let-these-two-numbers-be-numbers-index1-and-numbers-index2-where-1-lt-index1-lt-index2-lt-numbers-length"><a href="#Given-a-1-indexed-array-of-integers-numbers-that-is-already-sorted-in-non-decreasing-order-find-two-numbers-such-that-they-add-up-to-a-specific-target-number-Let-these-two-numbers-be-numbers-index1-and-numbers-index2-where-1-lt-index1-lt-index2-lt-numbers-length" class="headerlink" title="Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length."></a>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.</h2><h2 id="Return-the-indices-of-the-two-numbers-index1-and-index2-added-by-one-as-an-integer-array-index1-index2-of-length-2"><a href="#Return-the-indices-of-the-two-numbers-index1-and-index2-added-by-one-as-an-integer-array-index1-index2-of-length-2" class="headerlink" title="Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2."></a>Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</h2><h2 id="The-tests-are-generated-such-that-there-is-exactly-one-solution-You-may-not-use-the-same-element-twice"><a href="#The-tests-are-generated-such-that-there-is-exactly-one-solution-You-may-not-use-the-same-element-twice" class="headerlink" title="The tests are generated such that there is exactly one solution. You may not use the same element twice."></a>The tests are generated such that there is exactly one solution. You may not use the same element twice.</h2><h2 id="Your-solution-must-use-only-constant-extra-space"><a href="#Your-solution-must-use-only-constant-extra-space" class="headerlink" title="Your solution must use only constant extra space."></a>Your solution must use only constant extra space.</h2><p>和第一题几乎可以用同样的思路，只不过这里的index从1开始，而且有序数组比第一题更简单</p><h3 id="根据第一题改的hashmap"><a href="#根据第一题改的hashmap" class="headerlink" title="根据第一题改的hashmap"></a>根据第一题改的hashmap</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        Hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            key = target - value</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> Hashmap:</span><br><span class="line">                <span class="keyword">return</span> [Hashmap[key]+<span class="number">1</span>, index+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Hashmap[value] = index</span><br></pre></td></tr></table></figure><p>Two pointers: O(n) time and O(1) space<br>Dictionary: O(n) time and O(n) space<br>Binary search: O(nlogn) time and O(1) space</p><h3 id="two-pointer"><a href="#two-pointer" class="headerlink" title="two-pointer"></a>two-pointer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            s = numbers[l] + numbers[r]</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                <span class="keyword">return</span> [l+<span class="number">1</span>, r+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[target-num]+<span class="number">1</span>, i+<span class="number">1</span>]</span><br><span class="line">            dic[num] = i</span><br><span class="line">```           </span><br><span class="line"></span><br><span class="line"><span class="comment">### binary search        </span></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(numbers)):</span><br><span class="line">        l, r = i+<span class="number">1</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        tmp = target - numbers[i]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r-l)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] == tmp:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, mid+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; tmp:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="binary-search-改进版"><a href="#binary-search-改进版" class="headerlink" title="binary search   改进版"></a>binary search   改进版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        investigatedSoFar = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> numbers[i] <span class="keyword">in</span> investigatedSoFar:</span><br><span class="line">                investigatedSoFar.append(numbers[i])</span><br><span class="line">                l, r = i + <span class="number">1</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">                tmp = target - numbers[i]</span><br><span class="line">                <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                    mid = l + (r-l) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> numbers[mid] == tmp:</span><br><span class="line">                        <span class="keyword">return</span>([i + <span class="number">1</span>, mid + <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">elif</span> numbers[mid] &lt; tmp:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = mid - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2022/05/28/1-twosum/"/>
      <url>/2022/05/28/1-twosum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="Given-an-array-of-integers-nums-and-an-integer-target-return-indices-of-the-two-numbers-such-that-they-add-up-to-target"><a href="#Given-an-array-of-integers-nums-and-an-integer-target-return-indices-of-the-two-numbers-such-that-they-add-up-to-target" class="headerlink" title="Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target."></a>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice" class="headerlink" title="You may assume that each input would have exactly one solution, and you may not use the same element twice."></a>You may assume that each input would have exactly one solution, and you may not use the same element twice.</h2><h2 id="You-can-return-the-answer-in-any-order"><a href="#You-can-return-the-answer-in-any-order" class="headerlink" title="You can return the answer in any order."></a>You can return the answer in any order.</h2><p>（无序）</p><p>hashmap<br>enumerate()(单词意思是枚举的意思)是python中的内置函数<br>enumerate(X,[start=0])<br>函数中的参数X可以是一个迭代器(iterator)或者是一个序列，start是起始计数值，默认从0开始。X可以是一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        Hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            key = target - value</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> Hashmap:</span><br><span class="line">                <span class="keyword">return</span> [Hashmap[key], index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Hashmap[value] = index</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode02  双指针</title>
      <link href="/2022/05/25/LeetCode02/"/>
      <url>/2022/05/25/LeetCode02/</url>
      
        <content type="html"><![CDATA[<p>第二篇学习笔记，换一个思路尝试学习</p><h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-双指针"><a href="#Leetcode-题解-双指针" class="headerlink" title="Leetcode 题解 - 双指针"></a>Leetcode 题解 - 双指针</h1><h2 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h2><h2 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h2><h2 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h2><h2 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h2><h2 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h2><h2 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h2><h2 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h2><h2 id="双指针类型"><a href="#双指针类型" class="headerlink" title="双指针类型"></a>双指针类型</h2><p>对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。<br>快慢指针：两个指针方向相同。适合解决数组中的移动、删除元素问题，或者链表中的判断是否有环、长度问题。<br>分离双指针：两个指针分别属于不同的数组 / 链表。适合解决有序数组合并，求交集、并集问题。</p><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><p>对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ol><li><p>Two Sum</p></li><li><p>Two Sum II - Input Array Is Sorted两数之和 II - 输入有序数组 </p></li></ol><ol start="125"><li>验证回文串</li></ol><ol start="344"><li><p>Reverse String</p></li><li><p>Remove Duplicates from Sorted Array</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 新建/启动/部署命令</title>
      <link href="/2022/05/16/hexo-usage/"/>
      <url>/2022/05/16/hexo-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新建一篇文章"><a href="#1-新建一篇文章" class="headerlink" title="1.新建一篇文章"></a>1.新建一篇文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;文章名称&quot;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post hexo_usage</span><br></pre></td></tr></table></figure><h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h2><h3 id="（1）清除缓存文件-db-json-和已生成的静态文件-public-。"><a href="#（1）清除缓存文件-db-json-和已生成的静态文件-public-。" class="headerlink" title="（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。"></a>（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>其实不需要每次都清除缓存文件，直接进行下面两步就可以</p><h3 id="（2）生成静态文件。"><a href="#（2）生成静态文件。" class="headerlink" title="（2）生成静态文件。"></a>（2）生成静态文件。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="（3）部署网站"><a href="#（3）部署网站" class="headerlink" title="（3）部署网站"></a>（3）部署网站</h3><p>部署之前预先生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="3-启动服务器。默认情况下，访问网址为："><a href="#3-启动服务器。默认情况下，访问网址为：" class="headerlink" title="3.启动服务器。默认情况下，访问网址为："></a>3.启动服务器。默认情况下，访问网址为：</h2><p><a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾尔登法环boss战</title>
      <link href="/2022/05/16/elden-ring-boss/"/>
      <url>/2022/05/16/elden-ring-boss/</url>
      
        <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>当我们褪色者重新回到交界地，第一个相遇的法环碎片持有者就是史东威尔城城主“黄金”葛瑞克，一个臭名昭著的神之后裔，黄金家族成员，在史东威尔城附近的破屋里，我们会遇到一位红帽女孩，会知道葛瑞克利用被称为接肢的技术四处劫掠褪色者，将砍下的手脚接在自己身上来增加自身的实力。这座腐朽的城池里到处都是残肢断臂，在一座大厅里我们还能见到在出生点相似的截肢贵族。在城池里我们还会遇到同样对葛瑞克所作所为十分不齿的女战士涅斐丽·露，她会在我们与葛瑞克战斗中助我们一臂之力。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8E%A5%E8%82%A2.5zgwu136oo40.webp" alt="接肢"></p><p>在我们将他击退之后，他还会砍下自己的左手，并接上一个龙头，试图再度增强自己的力量。但当我们最终击败他时，他喃喃地说到：“总有一天，我们会回到黄金树脚下的故乡……“葛瑞克作为曾经最强的一族——”黄金“一族的后人，却非常孱弱，艾尔登法环被女神玛莉卡敲碎后，群雄并起，引发了旷日持久的碎片战争，黄金树脚下的王城多次遭到进攻，葛瑞克混在女人堆里逃出王城，躲在史东薇尔城苟活，曾经想挑战女武神，却被被女武神打的满地找牙。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%85%B5%E8%B4%A5%E5%A6%82%E5%B1%B1%E5%80%92.5rvvday8fkk0.webp" alt="兵败如山倒"></p><p>他妄图通过接肢变得更强，却是想着能够有朝一日可以重现黄金一族的辉煌，当他砍下手臂接上龙头时，他会朝天怒吼：“诸位祖先，敬请见证！”只可惜乱世之中，不符合无上意志的棋子都会被抹去。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>乘着灵马特雷托一路北上，在雷亚卢卡利亚魔法学院，我们会遭遇曾经被称为“满月”女王的蕾娜菈。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%BB%A1%E6%9C%88%E5%A5%B3%E7%8E%8B%E5%A4%A7%E5%8D%A2%E6%81%A9.3jkdl5ccy3c0.webp" alt="满月女王大卢恩"><br>作为卡利亚魔法王国曾经的领导者，卡利亚魔法王国和黄金树势力曾经敌对，黄金树派出了英雄拉达冈前来讨伐，结果蕾娜菈和拉达冈在战场上相爱，双方化干戈为玉帛，喜结连理还诞下了三个子嗣。（分别是碎星将军拉塔恩，月之公主菈妮（神人），黄金树司法官拉卡德）</p><p>但好景不长，拉达冈突然抛下了自己的妻子，回到黄金树和永恒女王玛丽卡结婚。突然失去爱情支撑的蕾娜菈就此丧失了神智，成为现在这幅模样并被卡利亚王室囚禁于大书库。</p><p>她的手里怀抱着拉达冈留给她的琥珀一样的大卢恩，神志不清，不断地利用大卢恩的力量诞生没有自我意识的孩子。</p><p>在打碎女王身边的防护罩后</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E7%8E%8B.6ktlkq7hr88.webp" alt="女王"></p><p>女儿月之公主菈妮会用魔法代替她的母亲与我们战斗，重现了全盛时期的满月女王：灵魂激流一类的法术随意释放，还可以召唤巨龙巨人狼群的灵体协助战斗。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%BB%A1%E6%9C%88%E5%A5%B3%E7%8E%8B.u8tx9yd3ksw.webp" alt="满月女王"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>往东，我们进入了满目猩红腐败的盖利德地区，刚进入红狮子城的配乐极其震撼和忧伤，这么一位一等一的英雄，在盖利德和女武神的战斗中遭受猩红腐败的腐蚀后，自我放逐到恸哭山丘，即使像野狗一样啃噬着战场上的尸体，依然维持着星空的封印。他的手下红狮子军在盖利德修筑了一条熏烧火墙，用火焰同被猩红腐败腐蚀变异的巨大怪物开展永无止境的死斗。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%A1%94%E6%81%A9.6s44iqw0kyw0.webp" alt="拉塔恩"></p><p>一望无际的战场上布满了断戟残垣，只能远远看到他的庞大身躯和贯穿天空的重力大箭，这是一场战斗祭奠，拉塔恩的手下奇异骑士邀请天下豪杰群聚于此，希望能解除他的痛苦，像一位战士一样死去，如果不把战士壶亚历山大和狼哥等英雄们召唤出来，单对单战斗确实是非常困难的事。如果召唤所有英雄跟这位最强半神贴身肉搏，扑面而来的是那种英雄末路的悲壮感，大开大合的招式在战士们中杀进杀出，能坚持战斗到最后一刻的就只剩下壶哥和狼哥，终于击败拉塔恩将军后，天上静滞的星星突然开始流动，随着拉塔恩将军的逝去，群星的封印被解除，新的命运齿轮开始转动</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%A7%A3%E6%94%BE%E7%BE%A4%E6%98%9F.map0i942acw.webp" alt="解放群星"></p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>随着星空封印解除，一枚流星砸穿了地面，地下的永恒之城重现人世，充满恶意的恐怖外神，黑暗弃子艾丝缇从星空坠落，砸穿了天空城之后，又将诺克史黛拉沉入地底，这与永恒之城的种种悖逆之举有关，他们制造了可以伤害无上意志和二指的猎杀指头刀，又试图通过仿身泪滴造出新的神灵，从而引来了无上意志的惩罚。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E6%9A%97%E5%BC%83%E5%AD%90%E8%89%BE%E6%96%AF%E6%8F%90.4mk6fn5wmoe0.webp" alt="黑暗弃子艾斯提"></p><p>巨大的身躯由星星构成，面部是一张令人不寒而栗的骷髅脸，拥有通过黑洞瞬移的能力</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>当褪色者攻进王城，踏入王座大厅之时，我们会遇到一位身上长满犄角，面貌丑陋的王：噩兆王蒙葛特。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%99%A9%E5%85%86%E7%8E%8B-(3).17zez1e8xhk0.webp" alt="噩兆王-(3)"></p><p>他是一位悲剧的半神，因为长相丑陋，自出生时就和兄弟蒙格一同被扔进了王城的下水道，虽然是黄金王朝的王子过得却是老鼠一般的生活。他本应诅咒这个畸形的世界，但讽刺的是，当艾尔登法环破碎后，群雄逐鹿，王城也遭到各路人马的进攻，曾经的半神和神人们纷纷自立门户，只有这位生活在下水道里的噩兆王蒙葛特，在关键时间挑起了守城的重任，并击退了所有来犯之敌，多次保住了黄金王城，在碎片战争中，他甚至击败了有着最强半神名号的拉塔恩将军。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%99%A9%E5%85%86%E7%8E%8B.zz7mh0ns0cw.webp" alt="噩兆王"></p><p>击败蒙葛特后，他的追忆中这样描述：即使生为赐福无缘的恶兆之子，蒙葛特仍愿意为黄金树的守卫，不是因为被爱，想要回馈，而是他单纯希望去爱。似乎与这个黄金王朝的命运一样，他身后的王座只需轻轻一碰就变成了碎片。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>当“黄金”葛德文成为死王子后，古龙就待在他的好友体内，不停与死亡搏斗，在死眠少女菲雅的梦境中，我们见到了传说中的“死龙”弗尔桑克斯。</p><p>当死龙飞翔在天空手持红雷配上木星大红斑似的背景，场景混乱又充满了阴郁的美感。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%AD%BB%E9%BE%99.2o7vqe77gfq0.webp" alt="死龙"></p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>在亚坛高原西边的火山地区，这里有黄金王朝的司法官拉卡德，是一个毫无怜悯心的法官，也是众多拷问官的长官。如蛇一般，令人感到生厌的男人。</p><p>拉卡德是拉达冈和满月女王的孩子之一。对于黄金树信仰而言，“……拉卡德犯下了亵渎罪，是罪无可赦的敌人。”艾尔登法环破碎之前的拉卡德是残酷的司法官，整个牢镇随处可见被折磨虐待的白金之子。在破碎战争中，他曾是反对黄金树的霸王，反叛黄金树信仰，反对无上意志，为了追求更强的力量反抗黄金树主动被大蛇吞噬。我们会先通过小蛇女的邀请加入名为叛律者的组织。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%AB%E5%B1%B1%E5%AE%98%E9%82%B8%E5%B0%8F%E8%9B%87%E5%A5%B3.1uuo8t56o7k0.webp" alt="火山官邸小蛇女"></p><p>那些具有反对黄金树潜质的英雄们，会被邀请到火山府邸，完成一系列亵渎（反抗黄金律法）之举。但是在拉卡德变成大蛇之后，因为最终能出色完成任务的叛律者都要去谒见拉卡德，而这些叛律者最终的遭遇，就和拉卡德曾经的骑士一样被吞噬，变成大蛇的一部分。</p><p>在完成了火山官邸安排的红灵入侵任务（击杀其他褪色者）后，拉卡德的侧室塔尼斯，一个一直戴着面具替拉卡德处理日常事务的女人，终于同意我们觐见亵渎君王拉卡德。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%8D%A1%E5%BE%B7.2qqguzuqhsg0.webp" alt="拉卡德"></p><p>在大蛇前的不远处，有一把大蛇狩猎矛，与大蛇对峙时，能形成风暴似的光刃</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%8D%A1%E5%BE%B7-%E9%A3%8E%E6%9A%B4%E7%9F%9B.1x5z2bhjz51c.webp" alt="拉卡德-风暴矛"></p><p>在拉卡德被风暴之刃击败后，他的侧室会跪坐在大蛇的尸体处，不断地啃食着尸体的头部，希望借此变成蛇人继承他的意志，算是交界地的一对苦命鸳鸯了。</p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E.3kbc2m7gnqw.webp" alt="女武神"></p><p>女武神玛莲妮亚，“米凯拉的锋刃”，手下有战无不胜的尊腐骑士大军，装上义手，带上飞翼头盔，掌握那高展飞翼的技能“水鸟乱舞”。为了帮哥哥米凯拉登上王位参加碎片战争，女武神玛莲妮亚在外四处征战，鲜血君王蒙格趁虚而入将米凯拉从圣树中掳走，玛莲妮亚率领大军一路南下寻找线索，而罪魁祸首蒙格的鲜血王朝就在盖利德地区（碎星将军拉塔恩的统治区域）的地下深处。当女武神赶到盖利德时，认为是拉塔恩抢走了哥哥米凯拉，与驻守于此的碎星将军以及他的红狮子军团展开了一场惊天动地的大战，史称艾奥尼亚之战。在最终的对决中，娇艳的腐败花朵怒放，吞噬了整个艾奥尼亚。拉塔恩与玛莲妮亚战成平手。这场无人胜利的战争伴随着玛莲妮亚的昏迷和拉塔恩的疯狂落下帷幕。</p><p>昏迷的玛莲妮亚被英雄芬雷带回圣树，从那以后好像迷失了自我，安安静静坐在圣树深处，等待着哥哥回归。</p><p>在我们第一次击倒女武神之后，她再次释放了体内的猩红腐败之力</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E4%BA%8C%E9%98%B6%E6%AE%B5.4e8xbca3rrg.webp" alt="女武神二阶段"></p><p>玛莲妮亚如同一只妖艳而致命的蝴蝶飞翔在空中，展现着完全状态下女武神的恐怖力量，她重重的将刀劈向地面，一朵朵猩红腐败之花怒放。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E4%BA%8C%E9%98%B6%E6%AE%B5.5dvcazx35ag0.webp" alt="女武神二阶段"></p><p>击败女武神之后获得的大卢恩也如同她本人一样，也充满了猩红腐败的力量</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E5%A4%A7%E5%8D%A2%E6%81%A9.1zwty3tfz5q8.webp" alt="女武神大卢恩"></p><h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><p>不得不说，玛莉卡的子嗣们，也就是半神们，都有着自己的野心和理想。鲜血君王蒙格，与孪生兄弟噩兆王蒙葛特一起守卫王城之时，也期望能建立属于自己的鲜血王朝。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%B1%B3%E5%87%AF%E6%8B%89%E7%9A%84%E8%8C%A7.3mgjvu8tfwq0.webp" alt="米凯拉的茧"></p><p>在碎片战争中，蒙格绑走了神人米凯拉，神人是神的候补，在玛莉卡女王失踪之后有着成为神的资格，蒙格利用血茧培育着米凯拉，当米凯拉成神之际，自己就可以以艾尔登之王的身份君临天下。殊不知，是蒙格自己的愿望，还是米凯拉的诱惑导致的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%92%99%E6%A0%BC%E5%92%8C%E7%B1%B3%E5%87%AF%E6%8B%89.1bciyje0cckg.webp" alt="蒙格和米凯拉"><br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%92%99%E6%A0%BC.1x6uysx08ug0.webp" alt="蒙格"></p><h2 id="十"><a href="#十" class="headerlink" title="十"></a>十</h2><p>天空城里的黑剑玛利喀斯是玛莉卡女王忠诚的结拜弟弟，将命定之死寄宿在自身的剑里，令所有的半神感到畏惧。而就是因为它们明白何谓畏惧，才会是英雄。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E5%89%91%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BC%80%E5%A4%B4.2zezr2k3z8e0.webp" alt="黑剑二阶段开头"></p><p>在阴谋之夜，死亡的一部分被偷走之后，玛利喀斯把黑剑封印在自己体内，为的是不再让它失窃。</p><p>褪色者和黑剑第一次相遇是在盖利德的最北边的野兽祭祀塔，见到的是野兽祭祀模样的玛利喀斯，穿着肮脏破烂的外衣，迫切的渴望着死根，在吃了四个死根之后他甚至会陷入疯狂攻击我们，在十个死根完全收集之后，他会从祭祀塔里消失，下一次再见是在天空城。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E5%89%91.1wx0hv9col28.webp" alt="黑剑"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BE%99%E7%8E%8B.41eybrgpofo0.webp" alt="龙王"><br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%AB%E5%B1%B1%E5%B7%A8%E4%BA%BA.183gb0scvxog.webp" alt="火山巨人"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%9B%B8%E9%81%87%E5%88%9D%E4%BB%A3%E7%8E%8B.2u204qv0zhs0.webp" alt="相遇初代王"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%88%9D%E4%BB%A3%E7%8E%8B%E6%8B%A6%E8%B7%AF.7acl2a2g6xc0.webp" alt="初代王拦路"></p><p>圣树的女武神是我死亡次数最多的boss，但有猎犬步伐加上耍无赖的用了冤魂绕圈打法，其实难度并没有打只狼的一心艰难，就是得多挂几次学一下怎么躲水鸟，法师的一个问题是血太薄，被水鸟的任何一个连招中的两刀砍到就没了。王城下水道的“恶兆之子”蒙格和鲜血王朝的“碎片君王”蒙格我也没什么战斗记忆，只要记得喝滴露就可以破解他的倒计时大招。火焰巨人倒真是卡住了我一段时间，因为遍地打滚被压碎了好几次，放弃了当甘道夫的想法选择用岩石球就很容易了。龙王普拉顿桑克斯可以说是后期除了女武神之外第二强的boss，瞬移，秒人光炮，大范围龙爪aoe，黑刀姐第一次boss半血都没到就被打没了，主要是每死一次得跑一阵才能到boss房，技能也没有死龙酷炫，基本每招都能秒我，战斗体验很糟糕。然后是黑剑，黑剑二阶段的战斗身姿是最帅的，那套盔甲配上黑剑的火焰燃烧特效从天上劈下刀光非常引人入胜，但整体并不难打，因为他血很薄又没有女武神那样的吸血buff，平台上还有几根石柱，虽然不能秦王绕柱但可以躲柱子后面喝口药回回状态。初代王荷莱露说实话出场表演很一般，并没有感觉到初代艾尔登之王的逼格，猎犬步伐躲投技，跳起来躲大范围捶地aoe，二阶段撕狮子那段很惊讶，但后面鞋子的特写有点出戏（鞋带不好系啊），二阶段在骨灰和女战士（现在是史东威尔城城主）也没什么难度就过了。最终boss红毛拉达冈和艾尔登之兽在圣龙徽护符+2，螃蟹肉和祷告圣防护的buff下打了两次就过了，红毛有个问题，就是读指令的动作太明显了，属于敌不动我不动那种，没有动作游戏的体验，就像只狼里的弦一郎加一心我打了快一天才赢，但是结束以后就觉得很爽，弹刀出刀忍义手有一种见招拆招的快感，跟拉达冈打就像回合制游戏，他出招我就翻滚，等他技能后摇我再砍一剑然后继续泥地打滚或者猎犬步伐找机会。<br>战灰的加入虽然简化了战斗，但个别骨灰的强势导致我完全没有想法使用其他的骨灰，点名黑刀姐和仿身泪滴。仿身泪滴在我玩的时候已经被削，不再是大哥了，但它血厚啊。黑刀姐就更强了，战技经常放还是比例掉血，会瞬移，移动灵活。攻击欲望强，打大型怪跟战神一样，当然希望宫崎老贼的更新方式是加强其他骨灰而不是削已有的强势骨灰。</p><p>你将会在游戏里遇到以下角色：</p><p>一个姑娘告诉你她的城堡里奴隶造反了，她的城主父亲正在努力抵抗叛军，她给你一封信，让你带给他父亲，劝说他离开。于是你杀进城堡找到她父亲，结果他父亲说自己奉葛瑞克大人（这片区域的君王）抵抗叛军，不能离开，关键是镇城之剑不能落入叛军之手，于是你又杀了叛军的老大拿回了剑，你以为城主这下可以和女儿团聚了，于是高兴滴回去找姑娘，结果发现姑娘已经倒在了血泊中，旁边赫然插着奴隶们使用的大刀。你沮丧地回去找城主，却发现不知情的城主说自己的任务已经完成了，未来要为女儿而活……再回到和妹子相遇的地方，会见到这个心碎的父亲在女儿的尸体旁捶地怒吼，高喊要为了女儿复仇。后期在一间充满尸臭的破屋里，这个父亲会失智地攻击我们。复仇已经吞噬了他的心，也许倒在玩家的剑下，和女儿团聚，是对他来说最好的结局。</p><p>在魔法学院外，你会遇到一个落魄魔法师托普斯，求你给他十块钱去弄点吃的，他会教你魔法作为报酬。他教的魔法有点奇怪（比如一个可以照明用魔法，虽然没有战斗力但很实用），他说自己很有自知之明，知道自己是块朽木，很遗憾不能教给玩家好的魔法，他希望能进入魔法学院去研究。之后玩家找到魔法学院钥匙可以交给他，他会非常感谢你然后离去。在玩家探索魔法学院的时候，可以在某一个地方找到托普斯的尸体：被绑在椅子上，死前似乎依然在研究魔法。而调查他的尸体，可以发现他赌上性命研究的魔法：托普斯的立场。这个魔法的效果非常逆天，可以弹开所有魔法。物品介绍中这样描述：后世的人们会明白，那受人嘲讽的理念，其实是足以成立新教室的发现。</p><p>同样是魔法师，你会在某处遗迹地下室遇见一个女魔法师瑟廉，如果你希望她教你魔法，她会警告你自己是被魔法学院驱逐的魔女。如果玩家表示不介意的话，瑟廉会惊讶并表示愿意教我们魔法，并亲切称呼我们为徒弟。在玩家此后的征程中，老师知无不言，还会一直鼓励我们，甚至表示就算玩家一无所成，还是可以去找她，毕竟老师永远会给弟子留一个位置。然而随着剧情推进，我们会发现原来老师就是魔法学院里被称为“尸块魔女”的存在，为了探索禁忌的星星起源而杀害了无数魔法师。当玩家将两位大魔法师尸体的位置告诉老师后，老师最终会和他们融合，变成一颗恐怖的人面球，痛苦地向我们呻吟：“呜呜呜呜，徒弟，呜呜呜……”虽然探索禁忌的疯狂行为终究要付出代价，但即使是内心再怎么疯狂之人，对于那个当初不介意自己出身，愿意接纳自己的小徒弟，她依然愿意袒露内心真心相对。（也有说法人面球就是星星的雏形，老师其实是得道了）</p><p>在一座桥旁， 玩家会遇到一个长着手脚的壶被卡在地上，请求我们的帮忙。帮他脱困后，他会告诉我们自己是战士壶——铁拳亚历山大，正要去红狮子城参加战斗祭奠。他爽朗的笑声让人印象深刻。在战斗祭奠上携手壶哥一同击败半神拉塔恩将军后，壶哥会浑身裂痕趴在地上，告诉我们刚才我们的表现很棒，但自己没几下就被打趴下了，还出现了好多裂痕，壶里的内容物都漏出来了，好在这里有很多战士的尸体，可以弥补遗失的内容物。我们这才知道原来战士壶就是战士尸体的容器，他是战士们战意的承载者。为了变得更强，壶哥决定去火山官邸旁的熔岩接受高温炙烤，又去巨人雪山寻找神火锻造自己，最终他和我们在天空城相逢。每次碰面，他总是用爽朗的笑声回应我们，好像不管何种失意都不会影响他的斗志，尽管他身上的裂痕越来越多。在天空城，壶哥邀请我们作为他的一场试炼，因为我们是他认可的英雄。开打后我们发现，相比其他战士壶，壶哥强太多太多了，他不但可以喷火，甚至挥手就可以掀起火焰风暴，一双铁拳使出的火焰升龙拳甚至可以击飞曾经弑神的玩家。但是壶的承载度终归有限，壶哥还是倒下了。他告诉我们，他知道壶终归只是壶，但作为战士，他战斗到了最后一刻。最终，在爽朗的笑声中，壶哥像其他战士壶一样碎裂成了碎片。</p><p>在游戏中，你会遇到一个自称霍劳斯的骑士，说他和女仆走散了，如果你见到了可以告诉他，还说如果有人敢动他女仆他就不客气了，嘴上还说着霍劳斯以血代言（用让你出血代替用嘴逼逼），给人感觉是个狠人。后来在魔法学院前，你发现他找到了已经被杀害的女仆，他告诉你凶手是火山官邸的人，他非要复仇不可，因为霍劳斯家族以血代言。后来在大本营，他告诉你他找到了火山官邸的人，但对方竟然要拉他入伙，他表示自己气的要大开杀戒了。让人大跌眼镜的是，当玩家进入火山官邸后，竟然见到霍劳斯，他告诉你，他也加入火山官邸了，不想复仇了。他还自己找了一个理由：英雄不会刻意走干净的路，我要选择一条污秽的路来证明我的英雄气概。无数玩家在他的脚下留言：前有大便，前无马（妈），愤怒！等等来表达内心的不满。之后霍劳斯屡屡出任务失败（火山官邸以猎杀同类为任务），他向玩家诉苦自己这双手根本不适合成为英雄。玩家通过支线任务也得知原来霍劳斯有一个哥哥，由于弟弟太过没用，哥哥名正言顺当上了家主，也一直爱着弟弟，并希望弟弟不要走上霍劳斯以血代言的铁血道路。但弟弟也一直想着走出哥哥的阴影……后来在壶村，玩家发现霍劳斯逃出了火山官邸，在这里当上了维壶师，维修这里的战士壶，虽然这份工作看起来低微，但看着在自己的维护下，壶们一个个恢复健康，霍劳斯说：我从火山官邸逃了出来，从所有地方逃了出来，逃避一切。说出来你可能不信，但我在这里，才有了真正活着的感觉。一段时间后玩家回来，会发现所有的壶都碎了，只有一个小壶还完好，而霍劳斯只剩下最后一口气。原来村里遇到了偷猎者，是霍劳斯用性命击退了他们。当你告诉霍劳斯壶都没事时，他会欣慰地说，就算是自己这样没用的人，也会有派上用场的时候，并最后说出了那句他一直挂在嘴边的话：霍劳斯以血代言。在他的尸体旁，全是玩家的留言，几乎都是一样的内容：前有英雄。</p><p>在一座山洞中，你会遇到一个名为帕奇的光头，一开始他会攻击你，但如果你将他打到半血，他会跪地求饶，如果你放过他，他就开始拍你马屁。他的房间里放着一个宝箱，如果玩家去开，就会中陷阱被传送到别处，帕奇还会嘲笑我们是贪婪之徒。之后玩家可以在火山官邸遇到他，他会将自己的猎杀任务让给你（大概率是太强他自己打不过），如果你完成了任务，他会说帮你去汇报，但不会把任务奖励给你，除非你亲自问他才会不情愿地给你，但就是这样一个滑头，却在游戏里得到善终，逍遥快活。</p><p>NPC不得善终，几乎是魂系列的定律，那些坚持原则的角色，大部分落得凄惨的下场，反而是帕奇这样的角色，却能活得游刃有余，这何尝不是对现实世界的一种无情嘲弄。当然，那些明知不可为而为之的角色，虽然最终陨落，但却实实在在给玩家的心里留下了一份感动。</p><p>———3.21更新————</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾尔登法环评价</title>
      <link href="/2022/05/16/elden-ring/"/>
      <url>/2022/05/16/elden-ring/</url>
      
        <content type="html"><![CDATA[<p>说实话，作为我第一款全价购买的steam游戏，艾尔登法环就像一场盛宴，他几乎满足了我对奇幻世界和宏大史诗的全部期待。从四月一日到四月十八日，一周目耗时105小时，完成了所有的结局和几乎所有的支线，在此感谢“老戴解说”，在他的视频帮助下我成功体验到了老头环的魅力，还有全成就(^_^)。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%85%A8%E6%88%90%E5%B0%B1.4l3lk90t6qe0.webp" alt="全成就"></p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><h3 id="1-宏大史诗和庞大的世界观。"><a href="#1-宏大史诗和庞大的世界观。" class="headerlink" title="1.宏大史诗和庞大的世界观。"></a>1.宏大史诗和庞大的世界观。</h3><p>最早接触的魂类游戏是只狼，在我多周目不同的结局后，我开始体验到魂类游戏的魅力，虽然黑魂3前期打boss对我来说并不难，但有个很头疼的问题是迷路，这也是弃坑黑魂3的原因。我个人非常喜欢宏大世界观和史诗故事，看完了龙崎棒棒糖所有关于黑魂背景的介绍视频之后，我很期待乔治马丁和宫崎老贼能描绘出多么精彩的画卷，在剧情和背景的设定上，老头环达到了我对游戏的最高评价。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%87%BA%E7%94%9F%E7%82%B9.77c6cdw5yuw0.webp" alt="出生点"></p><h3 id="2-美学设计-前有绝景"><a href="#2-美学设计-前有绝景" class="headerlink" title="2.美学设计/前有绝景"></a>2.美学设计/前有绝景</h3><p>我从出生点开始，就不断的F12截图，一直到游戏结束，既是记录游戏剧情，也是对游戏画面的感叹。虽然老头环的贴图不算精细，但整体环境充满了特点，并且在老头环，不同的地区会有不同的场景描绘，不像黑魂都是黑暗阴森。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%8F%B2%E4%B8%9C%E5%A8%81%E5%B0%94%E5%9F%8E.2xo9rwygi9c0.webp" alt="史东威尔城"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%8F%B2%E4%B8%9C%E5%A8%81%E5%B0%94%E5%9F%8E-(2).50o20o1khwk0.webp" alt="史东威尔城-(2)"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%9C%B0%E4%B8%8B%E5%9F%8E-(2).7efse996mpw0.webp" alt="地下城-(2)"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%8E%8B%E5%9F%8E-%E4%BA%8C%E5%91%A8%E7%9B%AE.i8o7uazbitk.webp" alt="王城-二周目"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%9B%AA%E5%B1%B1-%E5%89%8D%E6%9C%89%E7%BB%9D%E6%99%AF.5skhjn3gcl00.webp" alt="雪山-前有绝景"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A4%A9%E7%A9%BA%E5%9F%8E.1e9s8xlcq1a8.webp" alt="天空城"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%B0%E5%9F%8E.33b3v6b97dk0.webp" alt="灰城"></p><h2 id="中性（个人看法）"><a href="#中性（个人看法）" class="headerlink" title="中性（个人看法）"></a>中性（个人看法）</h2><h3 id="1-战斗设计"><a href="#1-战斗设计" class="headerlink" title="1.战斗设计"></a>1.战斗设计</h3><p>说实话这种类似黑魂的战斗体验并没有很优秀，快慢刀加读指令还是很头痛的，个人来说还是更喜欢只狼那种偏向ACT的战斗风格，而不是满地打滚当驴学派玩家。不过法师的加入让老头环入门更加简单，作为不用灵魂激流就喜欢月光剑贴脸砍的狂战士甘道夫，虽然少部分时候在受苦，整体来说战斗体验还是不错的。</p><p>但是！后期圣树，雪山和雪原，数值膨胀的太离谱了，不刷级不行，印象深刻的是圣树罗蕾塔门口的两个魔法师，顶级法师了属于是，攻击力极高，血贼厚，没有蓝条，远比后面的罗蕾塔boss强，地方又狭窄，别说战斗了，就是跑酷都不好跑。（打到这的时候就感叹这里的每个小兵都能暴捶葛瑞克之流）</p><h3 id="2-地图设计"><a href="#2-地图设计" class="headerlink" title="2.地图设计"></a>2.地图设计</h3><p>前期洞窟和地面城池的设计算是非常巧妙，很多地方有捷径或者意想不到的到达方式，虽然依然有各种转角遇到背刺的小兵和石像鬼，但这也算是法环作为恐怖游戏的一种标签，但后期雪原非常空旷，如果不是进去的暴风雪挡住了视线，刚进去的那里什么都没有</p><h3 id="3-NPC设计"><a href="#3-NPC设计" class="headerlink" title="3.NPC设计"></a>3.NPC设计</h3><p>NPC的设计可以说是有好有坏，描写非常深刻的有战士壶亚历山大狼哥还有亲爱的老师瑟廉，但其他的就不是那么印象深刻了，其实如果可以把支线连在一起看，大部分NPC都是有血有肉（虽然绝大部分都是悲剧结局）但巧就巧在法环的内容量太大，又有接下来提到的任务指引问题，只有看攻略猛攻一个故事，才能体会深刻，就比如说海德要塞那个城主，要我来回跑图（中途还没有赐福）才能接近完成任务。还有个问题是老头环里的NPC跟投币木马似的，话总是不一次讲完，必须得不停的对话。<br>顺便一提，传说中的魂系经典人物帕奇，说实话如果没有这层buff帕奇就是个杂兵，在一周目我通过攻略经历了所有和帕奇有关的故事，包括被他在火山地区踹下悬崖。我非常不理解为什么玩家们会喜欢这样一个偷奸耍滑作奸犯科的NPC，在二周目我选择直接把他砍翻，除了几个猎杀褪色者任务，即使没有他整个故事流程也没有影响。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><h3 id="1-最垃圾：任务指引"><a href="#1-最垃圾：任务指引" class="headerlink" title="1.最垃圾：任务指引"></a>1.最垃圾：任务指引</h3><p>任务指引其实不能用垃圾来形容，应该是完全没有。碎片化叙事我可以接受，以往的魂类游戏都是在一个走廊里把剧本一张张放好（不一定按顺序），但现在，他把剧本撒在了一个六十层大楼里，需要不断地上蹿下跳去找，而且里面还有各种各样的粪坑。我不相信作为一个普通玩家能够在不看攻略的情况下做完大部分任务，甚至说，不看攻略连很多支线都不知道在哪开始接。<br>作为一个开放世界，没有任务清单意味着我根本记不住多个任务，一边在被小兵暴杀的同时我还要记下一步支线怎么走？好些NPC我一开始不看攻略一头雾水， “你谁啊就跟我搭话”<br>更别说什么商人卖的情报了，有些商人藏在什么鸟不拉屎的地方啊，举个例子，卡利亚学院传送门那里，那个商人在传送门后面的断桥处，但是，你不能通过传送门走，要沿着断桥走，断桥上全是树木和灌木丛遮挡视线，还有一片狼群，然后才能看到商人，不看攻略哪个正常人会在看到传送门的情况下往断桥里钻？<br>就算有商人的情报，米莉森的支线还有三指女巫的支线的地点就完全没有提示，本来任务流程的间隔非常大，这些支线本身体量又有限，开放世界进一步分割并加剧了任务的碎片化，你必须得在这个开放世界闲逛，才能找到他们，这样就光剩碎片没故事了。<br>主线剧情有个大问题是我把老婆当柴火烧了树以后就黑屏到天空城了？到了天空城我为什么要去揍黑剑？什么提示也没有就让我去拿命定之死？命定之死前面只提到可以干掉半神，没说干掉黑剑释放命定之死才能真正烧黄金树。<br>如果只能通过看攻略才能完成任务，那么作为一款游戏我认为法环的任务指引是极其失败的。<br>有人会洗白说这是魂系游戏的特色，“老ass一周目基本不会上网查看攻略的，最多交流下自己发现的问题。魂游戏的一周目无知探索是最有乐趣的而且这个无知不可逆。”但这是开放世界，不是以往的线性叙事，魂系游戏的前提是游戏，这么大的游戏体量难道要我一个普通玩家拿个笔记本自己记？</p><h3 id="2-部分物品获得设计"><a href="#2-部分物品获得设计" class="headerlink" title="2.部分物品获得设计"></a>2.部分物品获得设计</h3><p>故事散布在大楼里就算了，问题是底下还有粪坑，在死根深处有个传说护符，需要穿过一片黑暗的蚂蚁窝，就是在黑暗中，你得辨别蚂蚁窝的布局看着无数只巨大蚂蚁在边上进攻骑马穿梭跳跃，我是真的被恶心到了，纯粹的生理恶心，这个护符的放置地点让我不可能给这个游戏打满分，纯粹故意恶心玩家，不会有打着魂类游戏的旗号的昆虫爱好者喜欢吧，不会吧不会吧<br>更别提什么大手怪还有蚯蚓脸了，但好歹没有那种强制你盯着看的设计出现<br>还有各种各样的奇怪藏东西地点，让我感觉制作组只是故意把他们藏在玩家找不到的地点，而不是打完一场战斗后的战利品，我在收集物品时（特别是后期）完全没有那种“原来在这里”的惊喜</p><h3 id="3-跑酷设计"><a href="#3-跑酷设计" class="headerlink" title="3.跑酷设计"></a>3.跑酷设计</h3><p>在小兵和房顶穿梭的时间远远大于打boss的时间，很多无意义的堆怪耗尽耐心。印象最深的是卡利亚学院楼顶的跑酷，跳到有一处房顶的时候，本来距离就远不太好跳，还在这里布置了一个类似只狼的风筝怪，我在空中被它打下去很多次，我忍了很久才没有卸游戏。当然有人洗白说这是魂系游戏的特点，我只能说适当的恶心人可以，恶心多了就只能徒增厌恶</p><h3 id="4-剧情bug"><a href="#4-剧情bug" class="headerlink" title="4.剧情bug"></a>4.剧情bug</h3><p>黑剑和野兽祭祀，这是很多人都提到的bug了，打完黑剑野兽祭祀还在，有些人洗白说这是不同时空的黑剑，但老头环前面没有出现什么时空分割的设定，我倾向于是有个bug或者是这部分没做完就拿出来发售了。<br>吐槽一下，还有烧树后飞到天空城，这都啥啊就飞上去了？咋飞的啊，要是梅琳娜有这本事她怎么不早用呢。有人说是桂奥尔龙墓的那条大白龙带我们到天空城的，但这都只是解包推测的，本身剧情就是有断层，即使后续有更新但游戏都发售了总得先有个自圆其说的解释吧，拿个什么商人情报或者犄角旮旯里的碎片先当谜语人也行啊，但什么都没有，即使洗白有法环体量大的理由，但事实在这里，在这一段就是有剧情上的漏洞。<br>还有一个是关于火山巨人的，他不是被黄金家族干倒了吗，都被玛莉卡控制了怎么二阶段还可以通过献祭获得邪神力量啊？要是能和邪神沟通有自我意识为什么要阻止我烧树，不应该高高兴兴把黄金树给点了吗，又何必打上这一架。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode01 K Sum</title>
      <link href="/2022/04/13/LeetCode01/"/>
      <url>/2022/04/13/LeetCode01/</url>
      
        <content type="html"><![CDATA[<p>终于开始正式刷题了。这也是第一篇学习笔记，我计划用两个月的时间从头开始学习算法和leetcode，争取在秋招前刷完200题</p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>起步就是最简单的第一题，<br>英文名：1. Two Sum</p><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>没有学过算法的我第一反应就是暴力解法，直接遍历算一圈就可以完事，但通常会超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == nums[i] + nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;nums[i], nums[j]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我也是第一次接触时间复杂度和空间复杂度这两个概念</p><h6 id="具体学习链接-算法的时间与空间复杂度（一看就懂）"><a href="#具体学习链接-算法的时间与空间复杂度（一看就懂）" class="headerlink" title="具体学习链接:算法的时间与空间复杂度（一看就懂）"></a>具体学习链接:<a href="https://zhuanlan.zhihu.com/p/50479555">算法的时间与空间复杂度（一看就懂）</a></h6><h5 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h5><p>时间复杂度：执行算法花了多长时间<br>空间复杂度：执行算法花了多少内存</p><h4 id="常见的时间复杂度量级有："><a href="#常见的时间复杂度量级有：" class="headerlink" title="常见的时间复杂度量级有："></a>常见的时间复杂度量级有：</h4><h5 id="1-常数阶O-1"><a href="#1-常数阶O-1" class="headerlink" title="1. 常数阶O(1)"></a>1. 常数阶O(1)</h5><p>重点：没有循环等复杂结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><h5 id="2-对数阶O-logN"><a href="#2-对数阶O-logN" class="headerlink" title="2. 对数阶O(logN)"></a>2. 对数阶O(logN)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后i就大于n，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log<sub>2</sub>(n)<br>这里把数字设成2，当n无限大的时候，数字是多少都无所谓，所以统称为logN</p><h5 id="3-线性阶O-n"><a href="#3-线性阶O-n" class="headerlink" title="3. 线性阶O(n)"></a>3. 线性阶O(n)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的。<br>简而言之，n跟结果有关系就不是常数阶，一个循环对应一个线性阶</p><h5 id="4-线性对数阶O-nlogN"><a href="#4-线性对数阶O-nlogN" class="headerlink" title="4. 线性对数阶O(nlogN)"></a>4. 线性对数阶O(nlogN)</h5><p>线性对数阶O(nlogN) 就是把时间复杂度为O(logN)的代码外面套一个循环，循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-平方阶O-n-2"><a href="#5-平方阶O-n-2" class="headerlink" title="5. 平方阶O($n^2$)"></a>5. 平方阶O($n^2$)</h5><p>总结：两个循环或者说两个线性阶套娃 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-立方阶O-n-3"><a href="#6-立方阶O-n-3" class="headerlink" title="6. 立方阶O($n^3$)"></a>6. 立方阶O($n^3$)</h5><p>总结：三个循环或者说三个线性阶套娃 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(y=<span class="number">1</span>;y&lt;=n;y++&gt;)&#123;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="7-K次方阶O-n-k"><a href="#7-K次方阶O-n-k" class="headerlink" title="7. K次方阶O($n^k$)"></a>7. K次方阶O($n^k$)</h5><p>总结：K个循环或者说K个线性阶套娃 </p><h5 id="8-指数阶-2-n"><a href="#8-指数阶-2-n" class="headerlink" title="8. 指数阶(2^n)"></a>8. 指数阶(2^n)</h5><p>回忆一下指数的图像，随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aFunc( n ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aFunc(n - <span class="number">1</span>) + aFunc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常见的空间复杂度量级有：O-1-、O-n-、O-n²"><a href="#常见的空间复杂度量级有：O-1-、O-n-、O-n²" class="headerlink" title="常见的空间复杂度量级有：O(1)、O(n)、O(n²)"></a>常见的空间复杂度量级有：O(1)、O(n)、O(n²)</h4><h5 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h5><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h5 id="2-O-n"><a href="#2-O-n" class="headerlink" title="2. O($n$)"></a>2. O($n$)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><h5 id="3-O-n-2"><a href="#3-O-n-2" class="headerlink" title="3. O($n^2$)"></a>3. O($n^2$)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h6 id="具体学习链接-夜深人静写算法（四十四）-n-数之和"><a href="#具体学习链接-夜深人静写算法（四十四）-n-数之和" class="headerlink" title="具体学习链接:夜深人静写算法（四十四）- n 数之和"></a>具体学习链接:<a href="https://mp.weixin.qq.com/s/CE7Bz3SN2JJxLZXMw8p6Yg">夜深人静写算法（四十四）- n 数之和</a></h6><h6 id="fucking-algorithm-算法思维系列-二分查找详解-md"><a href="#fucking-algorithm-算法思维系列-二分查找详解-md" class="headerlink" title="fucking-algorithm/算法思维系列/二分查找详解.md"></a><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">fucking-algorithm/算法思维系列/二分查找详解.md</a></h6><h5 id="二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数"><a href="#二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数" class="headerlink" title="二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数"></a>二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数</h5><h4 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲回这道题</p><h5 id="1-对数组排序；"><a href="#1-对数组排序；" class="headerlink" title="1.对数组排序；"></a>1.对数组排序；</h5><h5 id="2-从前往后枚举第一个数-nums-i-；"><a href="#2-从前往后枚举第一个数-nums-i-；" class="headerlink" title="2.从前往后枚举第一个数 nums[i]；"></a>2.从前往后枚举第一个数 nums[i]；</h5><h5 id="3-由于数组是有序的，所以可以从剩下的数中，二分查找target-nums-i-，一旦找到，则返回二元组-nums-i-target-nums-i-；"><a href="#3-由于数组是有序的，所以可以从剩下的数中，二分查找target-nums-i-，一旦找到，则返回二元组-nums-i-target-nums-i-；" class="headerlink" title="3.由于数组是有序的，所以可以从剩下的数中，二分查找target - nums[i]，一旦找到，则返回二元组 { nums[i], target - nums[i] }；"></a>3.由于数组是有序的，所以可以从剩下的数中，二分查找<code>target - nums[i]</code>，一旦找到，则返回二元组 <code>&#123; nums[i], target - nums[i] &#125;；</code></h5><h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><h6 id="具体学习链接-夜深人静写算法（四十四）-n-数之和-1"><a href="#具体学习链接-夜深人静写算法（四十四）-n-数之和-1" class="headerlink" title="具体学习链接:夜深人静写算法（四十四）- n 数之和"></a>具体学习链接:<a href="https://mp.weixin.qq.com/s/CE7Bz3SN2JJxLZXMw8p6Yg">夜深人静写算法（四十四）- n 数之和</a></h6><h6 id="fucking-algorithm-算法思维系列-二分查找详解-md-1"><a href="#fucking-algorithm-算法思维系列-二分查找详解-md-1" class="headerlink" title="fucking-algorithm/算法思维系列/二分查找详解.md"></a><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">fucking-algorithm/算法思维系列/二分查找详解.md</a></h6><h6 id="具体学习链接-小白-Python-几种解法"><a href="#具体学习链接-小白-Python-几种解法" class="headerlink" title="具体学习链接:小白 Python 几种解法"></a>具体学习链接:<a href="https://leetcode-cn.com/problems/two-sum/solution/xiao-bai-pythonji-chong-jie-fa-by-lao-la-rou-yue-j/">小白 Python 几种解法</a></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i!=j:</span><br><span class="line">                <span class="keyword">return</span> [i,j]</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 46 ms, faster than 90.61% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 14.3 MB, less than 45.68% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure><p>改进版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [i,hashmap.get(target - num)]</span><br><span class="line">            hashmap[num] = i <span class="comment">#这句不能放在if语句之前，解决list中有重复值或target-num=num的情况</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 41 ms, faster than 95.66% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 14.4 MB, less than 45.68% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>解算出来的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       seen = &#123;&#125;</span><br><span class="line">       <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">           remaining = target - nums[i]</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> remaining <span class="keyword">in</span> seen:</span><br><span class="line">               <span class="keyword">return</span> [i, seen[remaining]]</span><br><span class="line">            </span><br><span class="line">           seen[value] = i </span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 68 ms, faster than 84.35% of Python3 online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 15.3 MB, less than 25.99% of Python3 online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plan</title>
      <link href="/2021/10/05/plan/"/>
      <url>/2021/10/05/plan/</url>
      
        <content type="html"><![CDATA[<h1 id="Steins-Gate"><a href="#Steins-Gate" class="headerlink" title="Steins;Gate"></a>Steins;Gate</h1>]]></content>
      
      
      
        <tags>
            
            <tag> schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2021/09/24/first-blog/"/>
      <url>/2021/09/24/first-blog/</url>
      
        <content type="html"><![CDATA[<p>这里是记录研究生生活和学习的第一篇文章，也是一切的开始。<br>生活篇分为日记，回忆，生活技巧。</p><h2 id="日记1"><a href="#日记1" class="headerlink" title="日记1"></a>日记1</h2><h3 id="2021-9-24"><a href="#2021-9-24" class="headerlink" title="2021.9.24"></a>2021.9.24</h3><p>已经是上课的第三周了，逐渐习惯了这样的学习节奏和自己做饭的生活。今天烧了一份红烧蹄膀。在华超买的蹄膀，让人出乎意料的事蹄膀居然是最便宜的肉类，真是暴殄天物啊。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/07/hello-world/"/>
      <url>/2021/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
