<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>157</title>
      <link href="/2022/10/12/157/"/>
      <url>/2022/10/12/157/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2434. Using a Robot to Print the Lexicographically Smallest String(medium)</title>
      <link href="/2022/10/12/2434/"/>
      <url>/2022/10/12/2434/</url>
      
        <content type="html"><![CDATA[<h1 id="2434-Using-a-Robot-to-Print-the-Lexicographically-Smallest-String-medium"><a href="#2434-Using-a-Robot-to-Print-the-Lexicographically-Smallest-String-medium" class="headerlink" title="2434. Using a Robot to Print the Lexicographically Smallest String(medium)"></a>2434. Using a Robot to Print the Lexicographically Smallest String(medium)</h1><h2 id="You-are-given-a-string-s-and-a-robot-that-currently-holds-an-empty-string-t-Apply-one-of-the-following-operations-until-s-and-t-are-both-empty"><a href="#You-are-given-a-string-s-and-a-robot-that-currently-holds-an-empty-string-t-Apply-one-of-the-following-operations-until-s-and-t-are-both-empty" class="headerlink" title="You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:"></a>You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:</h2><p>Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.<br>Remove the last character of a string t and give it to the robot. The robot will write this character on paper.</p><h2 id="Return-the-lexicographically-smallest-string-that-can-be-written-on-the-paper"><a href="#Return-the-lexicographically-smallest-string-that-can-be-written-on-the-paper" class="headerlink" title="Return the lexicographically smallest string that can be written on the paper."></a>Return the lexicographically smallest string that can be written on the paper.</h2><p>周赛题，一道关于栈的题 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotWithString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        </span><br><span class="line">        d, stack, ans = Counter(s), [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            </span><br><span class="line">            d[ch]-= <span class="number">1</span></span><br><span class="line">            stack.append(ch)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d[ch]: d.pop(ch)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">and</span> stack <span class="keyword">and</span> <span class="built_in">min</span>(d) &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">                ans += stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans + stack[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>359. Logger Rate Limiter(easy)</title>
      <link href="/2022/10/12/359/"/>
      <url>/2022/10/12/359/</url>
      
        <content type="html"><![CDATA[<h1 id="359-Logger-Rate-Limiter-easy"><a href="#359-Logger-Rate-Limiter-easy" class="headerlink" title="359. Logger Rate Limiter(easy)"></a>359. Logger Rate Limiter(easy)</h1><h2 id="Design-a-logger-system-that-receives-a-stream-of-messages-along-with-their-timestamps-Each-unique-message-should-only-be-printed-at-most-every-10-seconds-i-e-a-message-printed-at-timestamp-t-will-prevent-other-identical-messages-from-being-printed-until-timestamp-t-10"><a href="#Design-a-logger-system-that-receives-a-stream-of-messages-along-with-their-timestamps-Each-unique-message-should-only-be-printed-at-most-every-10-seconds-i-e-a-message-printed-at-timestamp-t-will-prevent-other-identical-messages-from-being-printed-until-timestamp-t-10" class="headerlink" title="Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10)."></a>Design a logger system that receives a stream of messages along with their timestamps. Each unique message should only be printed at most every 10 seconds (i.e. a message printed at timestamp t will prevent other identical messages from being printed until timestamp t + 10).</h2><h2 id="All-messages-will-come-in-chronological-order-Several-messages-may-arrive-at-the-same-timestamp"><a href="#All-messages-will-come-in-chronological-order-Several-messages-may-arrive-at-the-same-timestamp" class="headerlink" title="All messages will come in chronological order. Several messages may arrive at the same timestamp."></a>All messages will come in chronological order. Several messages may arrive at the same timestamp.</h2><h2 id="Implement-the-Logger-class"><a href="#Implement-the-Logger-class" class="headerlink" title="Implement the Logger class:"></a>Implement the Logger class:</h2><p>Logger() Initializes the logger object.<br>bool shouldPrintMessage(int timestamp, string message) Returns true if the message should be printed in the given timestamp, otherwise returns false.</p><p>这题的意思是message包含不同的短语，相同的短语之间间隔得大于等于10，不同的短语可以直接返回true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._msg_dict = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shouldPrintMessage</span>(<span class="params">self, timestamp: <span class="built_in">int</span>, message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns true if the message should be printed in the given timestamp, otherwise returns false.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> message <span class="keyword">not</span> <span class="keyword">in</span> self._msg_dict:</span><br><span class="line">            <span class="comment"># case 1). add the message to print</span></span><br><span class="line">            self._msg_dict[message] = timestamp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timestamp - self._msg_dict[message] &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="comment"># case 2). update the timestamp of the message</span></span><br><span class="line">            self._msg_dict[message] = timestamp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Your Logger object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Logger()</span></span><br><span class="line"><span class="comment"># param_1 = obj.shouldPrintMessage(timestamp,message)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> Data structure design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>293. Flip Game(easy)</title>
      <link href="/2022/10/12/293/"/>
      <url>/2022/10/12/293/</url>
      
        <content type="html"><![CDATA[<h1 id="293-Flip-Game-easy"><a href="#293-Flip-Game-easy" class="headerlink" title="293. Flip Game(easy)"></a>293. Flip Game(easy)</h1><h2 id="You-are-playing-a-Flip-Game-with-your-friend"><a href="#You-are-playing-a-Flip-Game-with-your-friend" class="headerlink" title="You are playing a Flip Game with your friend."></a>You are playing a Flip Game with your friend.</h2><h2 id="You-are-given-a-string-currentState-that-contains-only-‘-’-and-‘-‘-You-and-your-friend-take-turns-to-flip-two-consecutive-“-”-into-“–”-The-game-ends-when-a-person-can-no-longer-make-a-move-and-therefore-the-other-person-will-be-the-winner"><a href="#You-are-given-a-string-currentState-that-contains-only-‘-’-and-‘-‘-You-and-your-friend-take-turns-to-flip-two-consecutive-“-”-into-“–”-The-game-ends-when-a-person-can-no-longer-make-a-move-and-therefore-the-other-person-will-be-the-winner" class="headerlink" title="You are given a string currentState that contains only ‘+’ and ‘-‘. You and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move, and therefore the other person will be the winner."></a>You are given a string currentState that contains only ‘+’ and ‘-‘. You and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move, and therefore the other person will be the winner.</h2><h2 id="Return-all-possible-states-of-the-string-currentState-after-one-valid-move-You-may-return-the-answer-in-any-order-If-there-is-no-valid-move-return-an-empty-list"><a href="#Return-all-possible-states-of-the-string-currentState-after-one-valid-move-You-may-return-the-answer-in-any-order-If-there-is-no-valid-move-return-an-empty-list" class="headerlink" title="Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list []."></a>Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: currentState = &quot;++++&quot;</span><br><span class="line">Output: [&quot;--++&quot;,&quot;+--+&quot;,&quot;++--&quot;]</span><br></pre></td></tr></table></figure><p>连着的++换成–，看能输出多少个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generatePossibleNextMoves</span>(<span class="params">self, currentState: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(currentState)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> currentState[i:i+<span class="number">2</span>]==<span class="string">&quot;++&quot;</span>:</span><br><span class="line">                res.append(currentState[:i]+<span class="string">&#x27;--&#x27;</span>+currentState[i+<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>367. Valid Perfect Square(easy)</title>
      <link href="/2022/10/12/367/"/>
      <url>/2022/10/12/367/</url>
      
        <content type="html"><![CDATA[<h1 id="367-Valid-Perfect-Square-easy"><a href="#367-Valid-Perfect-Square-easy" class="headerlink" title="367. Valid Perfect Square(easy)"></a>367. Valid Perfect Square(easy)</h1><h2 id="Given-a-positive-integer-num-write-a-function-which-returns-True-if-num-is-a-perfect-square-else-False"><a href="#Given-a-positive-integer-num-write-a-function-which-returns-True-if-num-is-a-perfect-square-else-False" class="headerlink" title="Given a positive integer num, write a function which returns True if num is a perfect square else False."></a>Given a positive integer num, write a function which returns True if num is a perfect square else False.</h2><h2 id="Follow-up-Do-not-use-any-built-in-library-function-such-as-sqrt"><a href="#Follow-up-Do-not-use-any-built-in-library-function-such-as-sqrt" class="headerlink" title="Follow up: Do not use any built-in library function such as sqrt."></a>Follow up: Do not use any built-in library function such as sqrt.</h2><p>判断是否是平方数，可以通过等差数列来求，等差数列a0=1, d=2，最后求和的结果就是n^2,所以通过该等差数列来求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        d=<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> num&gt;<span class="number">0</span>:</span><br><span class="line">            num-=i</span><br><span class="line">            i+=d</span><br><span class="line">        <span class="keyword">if</span> num==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>338. Counting Bits(easy)</title>
      <link href="/2022/10/12/338/"/>
      <url>/2022/10/12/338/</url>
      
        <content type="html"><![CDATA[<h1 id="338-Counting-Bits-easy"><a href="#338-Counting-Bits-easy" class="headerlink" title="338. Counting Bits(easy)"></a>338. Counting Bits(easy)</h1><h2 id="Given-an-integer-n-return-an-array-ans-of-length-n-1-such-that-for-each-i-0-lt-i-lt-n-ans-i-is-the-number-of-1’s-in-the-binary-representation-of-i"><a href="#Given-an-integer-n-return-an-array-ans-of-length-n-1-such-that-for-each-i-0-lt-i-lt-n-ans-i-is-the-number-of-1’s-in-the-binary-representation-of-i" class="headerlink" title="Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1’s in the binary representation of i."></a>Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1’s in the binary representation of i.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: [0,1,1]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.com/problems/counting-bits/solutions/127448/counting-bits/">官方题解</a></h3><p>Use previous count results to generate the count for a new integer.</p><p>DP + Most Significant Bit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [0, b) is calculated</span></span><br><span class="line">        <span class="keyword">while</span> b &lt;= n:</span><br><span class="line">            <span class="comment"># generate [b, 2b) or [b, n) from [0, b)</span></span><br><span class="line">            <span class="keyword">while</span> x &lt; b <span class="keyword">and</span> x + b &lt;= n:</span><br><span class="line">                ans[x + b] = ans[x] + <span class="number">1</span></span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            x = <span class="number">0</span> <span class="comment"># reset x</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span> <span class="comment"># b = 2b</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans               </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>292. Nim Game(easy)</title>
      <link href="/2022/10/12/292/"/>
      <url>/2022/10/12/292/</url>
      
        <content type="html"><![CDATA[<h1 id="292-Nim-Game-easy"><a href="#292-Nim-Game-easy" class="headerlink" title="292. Nim Game(easy)"></a>292. Nim Game(easy)</h1><h2 id="You-are-playing-the-following-Nim-Game-with-your-friend"><a href="#You-are-playing-the-following-Nim-Game-with-your-friend" class="headerlink" title="You are playing the following Nim Game with your friend:"></a>You are playing the following Nim Game with your friend:</h2><p>Initially, there is a heap of stones on the table.<br>You and your friend will alternate taking turns, and you go first.<br>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.<br>The one who removes the last stone is the winner.<br>Given , the number of stones in the heap, return if you can win the game assuming both you and your friend play optimally, otherwise return .n  truefalse</p><p>总结就是让对手只能拿到4或者4的倍数，这样他拿几个我都有机会赢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>270. Closest Binary Search Tree Value(easy)</title>
      <link href="/2022/10/12/270/"/>
      <url>/2022/10/12/270/</url>
      
        <content type="html"><![CDATA[<h1 id="270-Closest-Binary-Search-Tree-Value-easy"><a href="#270-Closest-Binary-Search-Tree-Value-easy" class="headerlink" title="270. Closest Binary Search Tree Value(easy)"></a>270. Closest Binary Search Tree Value(easy)</h1><h2 id="Given-the-root-of-a-binary-search-tree-and-a-target-value-return-the-value-in-the-BST-that-is-closest-to-the-target"><a href="#Given-the-root-of-a-binary-search-tree-and-a-target-value-return-the-value-in-the-BST-that-is-closest-to-the-target" class="headerlink" title="Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target."></a>Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.</h2><p>二叉搜索树上与target最近的数字<br><a href="https://leetcode.com/problems/closest-binary-search-tree-value/solutions/70327/4-7-lines-recursive-iterative-ruby-c-java-python/">leetcode题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestValue</span>(<span class="params">self, root, target</span>):</span></span><br><span class="line">        a = root.val</span><br><span class="line">        kid = root.left <span class="keyword">if</span> target &lt; a <span class="keyword">else</span> root.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> kid: <span class="keyword">return</span> a</span><br><span class="line">        b = self.closestValue(kid, target)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>((b, a), key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(target - x))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>976. Largest Perimeter Triangle(easy)</title>
      <link href="/2022/10/12/976/"/>
      <url>/2022/10/12/976/</url>
      
        <content type="html"><![CDATA[<h1 id="976-Largest-Perimeter-Triangle-easy"><a href="#976-Largest-Perimeter-Triangle-easy" class="headerlink" title="976. Largest Perimeter Triangle(easy)"></a>976. Largest Perimeter Triangle(easy)</h1><h1 id="Given-an-integer-array-nums-return-the-largest-perimeter-of-a-triangle-with-a-non-zero-area-formed-from-three-of-these-lengths-If-it-is-impossible-to-form-any-triangle-of-a-non-zero-area-return-0"><a href="#Given-an-integer-array-nums-return-the-largest-perimeter-of-a-triangle-with-a-non-zero-area-formed-from-three-of-these-lengths-If-it-is-impossible-to-form-any-triangle-of-a-non-zero-area-return-0" class="headerlink" title="Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0."></a>Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.</h1><p>组成三角形的条件是两边之和大于第三边，先将数组排序，然后从大往小挨个算能否组成三角形，如果可以就输出，到最后都没有发现就直接return 0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestPerimeter</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;=nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]&lt;nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(nums[i:i+<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>263. Ugly Number(easy)</title>
      <link href="/2022/10/12/263/"/>
      <url>/2022/10/12/263/</url>
      
        <content type="html"><![CDATA[<h1 id="263-Ugly-Number-easy"><a href="#263-Ugly-Number-easy" class="headerlink" title="263. Ugly Number(easy)"></a>263. Ugly Number(easy)</h1><h2 id="An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5"><a href="#An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5" class="headerlink" title="An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5."></a>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</h2><h2 id="Given-an-integer-n-return-true-if-n-is-an-ugly-number"><a href="#Given-an-integer-n-return-true-if-n-is-an-ugly-number" class="headerlink" title="Given an integer n, return true if n is an ugly number."></a>Given an integer n, return true if n is an ugly number.</h2><p>这是一个系列题<br>263. 丑数（简单）</p><ol start="264"><li><p>丑数 II（中等）</p></li><li><p>丑数 III（中等）</p></li><li><p>超级丑数（中等）</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> n%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">or</span> n%<span class="number">3</span>==<span class="number">0</span> <span class="keyword">or</span> n%<span class="number">5</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n %<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                n/=<span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> n%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">                n/=<span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> n%<span class="number">5</span>==<span class="number">0</span>:</span><br><span class="line">                n/=<span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>      </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>266. Palindrome Permutation(easy)</title>
      <link href="/2022/10/12/266/"/>
      <url>/2022/10/12/266/</url>
      
        <content type="html"><![CDATA[<h1 id="266-Palindrome-Permutation-easy"><a href="#266-Palindrome-Permutation-easy" class="headerlink" title="266. Palindrome Permutation(easy)"></a>266. Palindrome Permutation(easy)</h1><h2 id="Given-a-string-s-return-true-if-a-permutation-of-the-string-could-form-a-palindrome"><a href="#Given-a-string-s-return-true-if-a-permutation-of-the-string-could-form-a-palindrome" class="headerlink" title="Given a string s, return true if a permutation of the string could form a palindrome."></a>Given a string s, return true if a permutation of the string could form a palindrome.</h2><p>这题判断string能否组成回文串，回文串的特点就是最多只能有一个字母是奇数，其他的都得是偶数，这里很巧妙的运用了set的去重特性，最多只有一个字母留在set里</p><p><a href="https://leetcode.com/problems/palindrome-permutation/solutions/1006994/python-3-hashmap-dict-sets-tc-o-n-sc-o-1/">Leetcode题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># Set: Iterate over the given string</span></span><br><span class="line">    <span class="comment"># Add the character when it is not there, Remove it when it is.</span></span><br><span class="line">    <span class="comment"># At the end, the length of the sets is lesser than 2</span></span><br><span class="line">    <span class="comment"># TC O(n) n is the number of the character of string</span></span><br><span class="line">    <span class="comment"># SC O(1) the maximum size of the set would be 128 ASCII characters</span></span><br><span class="line">    <span class="comment"># This is bounded (constant),</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPermutePalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        sets = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> sets:</span><br><span class="line">                sets.add(char)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sets.remove(char)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">len</span>(sets) &lt;= <span class="number">1</span>)          </span><br><span class="line">    </span><br><span class="line"><span class="comment">#     # Hashmap: Count the number of occurence of characters</span></span><br><span class="line"><span class="comment">#     # TC O(n) n is the number of the character of string</span></span><br><span class="line"><span class="comment">#     # SC O(1) the maximum size of the map would be 128 ASCII characters</span></span><br><span class="line"><span class="comment">#     # This is bounded (constant)</span></span><br><span class="line"><span class="comment">#     def canPermutePalindrome(self, s: str) -&gt; bool:</span></span><br><span class="line"><span class="comment">#         # Iterate over a given string</span></span><br><span class="line"><span class="comment">#         # Count the number of occurence of characters</span></span><br><span class="line"><span class="comment">#         # key: Character, value: count</span></span><br><span class="line"><span class="comment">#         maps = collections.defaultdict(int)</span></span><br><span class="line"><span class="comment">#         for char in s:</span></span><br><span class="line"><span class="comment">#             if maps.get(char):</span></span><br><span class="line"><span class="comment">#                 maps[char] += 1</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 maps[char] = 1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         # Traverse over the map to find even number</span></span><br><span class="line"><span class="comment">#         count = 0</span></span><br><span class="line"><span class="comment">#         for key in maps:</span></span><br><span class="line"><span class="comment">#             count += maps[key] %2</span></span><br><span class="line"><span class="comment">#             # if maps[key] % 2 == 1:</span></span><br><span class="line"><span class="comment">#             #     # Odd number of occuerence</span></span><br><span class="line"><span class="comment">#         # if the count is lesser than 2, it is palindrome</span></span><br><span class="line"><span class="comment">#         return (count &lt;= 1)                </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>334. Increasing Triplet Subsequence(easy)</title>
      <link href="/2022/10/11/334/"/>
      <url>/2022/10/11/334/</url>
      
        <content type="html"><![CDATA[<h1 id="334-Increasing-Triplet-Subsequence-easy"><a href="#334-Increasing-Triplet-Subsequence-easy" class="headerlink" title="334. Increasing Triplet Subsequence(easy)"></a>334. Increasing Triplet Subsequence(easy)</h1><h2 id="Given-an-integer-array-nums-return-true-if-there-exists-a-triple-of-indices-i-j-k-such-that-i-lt-j-lt-k-and-nums-i-lt-nums-j-lt-nums-k-If-no-such-indices-exists-return-false"><a href="#Given-an-integer-array-nums-return-true-if-there-exists-a-triple-of-indices-i-j-k-such-that-i-lt-j-lt-k-and-nums-i-lt-nums-j-lt-nums-k-If-no-such-indices-exists-return-false" class="headerlink" title="Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false."></a>Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.</h2><p>在一个队列里找到三个不断增大的数，不需要连续<br>float(“inf”)是一个upper bound，也就是无穷大的边界专门用来做比较用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        first_num = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        second_num = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &lt;= first_num:<span class="comment"># 第一小的数</span></span><br><span class="line">                first_num = n</span><br><span class="line">            <span class="keyword">elif</span> n &lt;= second_num:<span class="comment"># 第二小的数</span></span><br><span class="line">                second_num = n</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#最后一个数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>257. Binary Tree Paths(easy)</title>
      <link href="/2022/10/10/257/"/>
      <url>/2022/10/10/257/</url>
      
        <content type="html"><![CDATA[<h1 id="257-Binary-Tree-Paths-easy"><a href="#257-Binary-Tree-Paths-easy" class="headerlink" title="257. Binary Tree Paths(easy)"></a>257. Binary Tree Paths(easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-all-root-to-leaf-paths-in-any-order"><a href="#Given-the-root-of-a-binary-tree-return-all-root-to-leaf-paths-in-any-order" class="headerlink" title="Given the root of a binary tree, return all root-to-leaf paths in any order."></a>Given the root of a binary tree, return all root-to-leaf paths in any order.</h2><h2 id="A-leaf-is-a-node-with-no-children"><a href="#A-leaf-is-a-node-with-no-children" class="headerlink" title="A leaf is a node with no children."></a>A leaf is a node with no children.</h2><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/">https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">construct_paths</span>(<span class="params">root, path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                path += <span class="built_in">str</span>(root.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment"># 当前节点是叶子节点</span></span><br><span class="line">                    paths.append(path)  <span class="comment"># 把路径加入到答案中</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    path += <span class="string">&#x27;-&gt;&#x27;</span>  <span class="comment"># 当前节点不是叶子节点，继续递归遍历</span></span><br><span class="line">                    construct_paths(root.left, path)</span><br><span class="line">                    construct_paths(root.right, path)</span><br><span class="line">        paths = []</span><br><span class="line">        construct_paths(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>243. Shortest Word Distance(easy)</title>
      <link href="/2022/10/10/243/"/>
      <url>/2022/10/10/243/</url>
      
        <content type="html"><![CDATA[<h1 id="243-Shortest-Word-Distance-easy"><a href="#243-Shortest-Word-Distance-easy" class="headerlink" title="243. Shortest Word Distance(easy)"></a>243. Shortest Word Distance(easy)</h1><h2 id="Given-an-array-of-strings-wordsDict-and-two-different-strings-that-already-exist-in-the-array-word1-and-word2-return-the-shortest-distance-between-these-two-words-in-the-list"><a href="#Given-an-array-of-strings-wordsDict-and-two-different-strings-that-already-exist-in-the-array-word1-and-word2-return-the-shortest-distance-between-these-two-words-in-the-list" class="headerlink" title="Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest distance between these two words in the list."></a>Given an array of strings wordsDict and two different strings that already exist in the array word1 and word2, return the shortest distance between these two words in the list.</h2><p>这题先找到对应word的index，但这里有些case是word出现了很多次，所以再加循环遍历求最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span>(<span class="params">self, wordsDict: <span class="type">List</span>[<span class="built_in">str</span>], word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l=wordsDict.index(word1)</span><br><span class="line">        r=wordsDict.index(word2)</span><br><span class="line">        </span><br><span class="line">        l=[index <span class="keyword">for</span> (index,value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(wordsDict) <span class="keyword">if</span> value==word1]</span><br><span class="line">        r=[index <span class="keyword">for</span> (index,value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(wordsDict) <span class="keyword">if</span> value==word2]</span><br><span class="line">        res=<span class="built_in">abs</span>(l[<span class="number">0</span>]-r[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> r:</span><br><span class="line">                res=<span class="built_in">min</span>(res,<span class="built_in">abs</span>(i-j))</span><br><span class="line">        <span class="keyword">return</span> res           </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>232. Implement Queue using Stacks(easy)</title>
      <link href="/2022/10/10/232/"/>
      <url>/2022/10/10/232/</url>
      
        <content type="html"><![CDATA[<h1 id="232-Implement-Queue-using-Stacks-easy"><a href="#232-Implement-Queue-using-Stacks-easy" class="headerlink" title="232. Implement Queue using Stacks(easy)"></a>232. Implement Queue using Stacks(easy)</h1><h2 id="Implement-a-first-in-first-out-FIFO-queue-using-only-two-stacks-The-implemented-queue-should-support-all-the-functions-of-a-normal-queue-push-peek-pop-and-empty"><a href="#Implement-a-first-in-first-out-FIFO-queue-using-only-two-stacks-The-implemented-queue-should-support-all-the-functions-of-a-normal-queue-push-peek-pop-and-empty" class="headerlink" title="Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty)."></a>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</h2><h2 id="Implement-the-MyQueue-class"><a href="#Implement-the-MyQueue-class" class="headerlink" title="Implement the MyQueue class:"></a>Implement the MyQueue class:</h2><p>void push(int x) Pushes element x to the back of the queue.<br>int pop() Removes the element from the front of the queue and returns it.<br>int peek() Returns the element at the front of the queue.<br>boolean empty() Returns true if the queue is empty, false otherwise.<br>Notes:</p><h2 id="You-must-use-only-standard-operations-of-a-stack-which-means-only-push-to-top-peek-pop-from-top-size-and-is-empty-operations-are-valid"><a href="#You-must-use-only-standard-operations-of-a-stack-which-means-only-push-to-top-peek-pop-from-top-size-and-is-empty-operations-are-valid" class="headerlink" title="You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid."></a>You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.</h2><h2 id="Depending-on-your-language-the-stack-may-not-be-supported-natively-You-may-simulate-a-stack-using-a-list-or-deque-double-ended-queue-as-long-as-you-use-only-a-stack’s-standard-operations"><a href="#Depending-on-your-language-the-stack-may-not-be-supported-natively-You-may-simulate-a-stack-using-a-list-or-deque-double-ended-queue-as-long-as-you-use-only-a-stack’s-standard-operations" class="headerlink" title="Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations."></a>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</h2><p>这题和225. Implement Stack using Queues(easy)互为镜像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        in主要负责push，out主要负责pop</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        有新元素进来，就往in里面push</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        只要in或者out有元素，说明队列不为空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.stack_in <span class="keyword">or</span> self.stack_out)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> stack </tag>
            
            <tag> Queues </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1328. Break a Palindrome(medium)</title>
      <link href="/2022/10/10/1328/"/>
      <url>/2022/10/10/1328/</url>
      
        <content type="html"><![CDATA[<h1 id="1328-Break-a-Palindrome-medium"><a href="#1328-Break-a-Palindrome-medium" class="headerlink" title="1328. Break a Palindrome(medium)"></a>1328. Break a Palindrome(medium)</h1><h2 id="Given-a-palindromic-string-of-lowercase-English-letters-palindrome-replace-exactly-one-character-with-any-lowercase-English-letter-so-that-the-resulting-string-is-not-a-palindrome-and-that-it-is-the-lexicographically-smallest-one-possible"><a href="#Given-a-palindromic-string-of-lowercase-English-letters-palindrome-replace-exactly-one-character-with-any-lowercase-English-letter-so-that-the-resulting-string-is-not-a-palindrome-and-that-it-is-the-lexicographically-smallest-one-possible" class="headerlink" title="Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible."></a>Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.</h2><h2 id="Return-the-resulting-string-If-there-is-no-way-to-replace-a-character-to-make-it-not-a-palindrome-return-an-empty-string"><a href="#Return-the-resulting-string-If-there-is-no-way-to-replace-a-character-to-make-it-not-a-palindrome-return-an-empty-string" class="headerlink" title="Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string."></a>Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.</h2><h2 id="A-string-a-is-lexicographically-smaller-than-a-string-b-of-the-same-length-if-in-the-first-position-where-a-and-b-differ-a-has-a-character-strictly-smaller-than-the-corresponding-character-in-b-For-example-“abcc”-is-lexicographically-smaller-than-“abcd”-because-the-first-position-they-differ-is-at-the-fourth-character-and-‘c’-is-smaller-than-‘d’"><a href="#A-string-a-is-lexicographically-smaller-than-a-string-b-of-the-same-length-if-in-the-first-position-where-a-and-b-differ-a-has-a-character-strictly-smaller-than-the-corresponding-character-in-b-For-example-“abcc”-is-lexicographically-smaller-than-“abcd”-because-the-first-position-they-differ-is-at-the-fourth-character-and-‘c’-is-smaller-than-‘d’" class="headerlink" title="A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, “abcc” is lexicographically smaller than “abcd” because the first position they differ is at the fourth character, and ‘c’ is smaller than ‘d’."></a>A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, “abcc” is lexicographically smaller than “abcd” because the first position they differ is at the fourth character, and ‘c’ is smaller than ‘d’.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: palindrome = &quot;abccba&quot;</span><br><span class="line">Output: &quot;aaccba&quot;</span><br><span class="line">Explanation: There are many ways to make &quot;abccba&quot; not a palindrome, such as &quot;zbccba&quot;, &quot;aaccba&quot;, and &quot;abacba&quot;.</span><br><span class="line">Of all the ways, &quot;aaccba&quot; is the lexicographically smallest.</span><br></pre></td></tr></table></figure><p>这道题其实很简单，是个贪心<br>找回文串中，第一个大于’a’的字符，替换成’a’<br>如果没有，说明整串都是a，最后一个换成b就行。<br>所以破坏远比构建要容易</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breakPalindrome</span>(<span class="params">self, palindrome: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(palindrome)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(palindrome)//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> palindrome[i]&gt;<span class="string">&#x27;a&#x27;</span>:                </span><br><span class="line">                <span class="keyword">return</span> palindrome[:i]+<span class="string">&#x27;a&#x27;</span>+palindrome[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> palindrome[:<span class="built_in">len</span>(palindrome)-<span class="number">1</span>]+ <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>145. Binary Tree Postorder Traversal(easy)</title>
      <link href="/2022/10/09/145/"/>
      <url>/2022/10/09/145/</url>
      
        <content type="html"><![CDATA[<h1 id="145-Binary-Tree-Postorder-Traversal-easy"><a href="#145-Binary-Tree-Postorder-Traversal-easy" class="headerlink" title="145. Binary Tree Postorder Traversal(easy)"></a>145. Binary Tree Postorder Traversal(easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-postorder-traversal-of-its-nodes’-values"><a href="#Given-the-root-of-a-binary-tree-return-the-postorder-traversal-of-its-nodes’-values" class="headerlink" title="Given the root of a binary tree, return the postorder traversal of its nodes’ values."></a>Given the root of a binary tree, return the postorder traversal of its nodes’ values.</h2><p>后序遍历，和前序遍历几乎一样</p><h2 id="Leetcode官方题解"><a href="#Leetcode官方题解" class="headerlink" title="Leetcode官方题解"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">Leetcode官方题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root:TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        res=<span class="built_in">list</span>()</span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>144. Binary Tree Preorder Traversal(easy)</title>
      <link href="/2022/10/09/144/"/>
      <url>/2022/10/09/144/</url>
      
        <content type="html"><![CDATA[<h1 id="144-Binary-Tree-Preorder-Traversal-easy"><a href="#144-Binary-Tree-Preorder-Traversal-easy" class="headerlink" title="144. Binary Tree Preorder Traversal(easy)"></a>144. Binary Tree Preorder Traversal(easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-preorder-traversal-of-its-nodes’-values"><a href="#Given-the-root-of-a-binary-tree-return-the-preorder-traversal-of-its-nodes’-values" class="headerlink" title="Given the root of a binary tree, return the preorder traversal of its nodes’ values."></a>Given the root of a binary tree, return the preorder traversal of its nodes’ values.</h2><h2 id="Leetcode官方题解"><a href="#Leetcode官方题解" class="headerlink" title="Leetcode官方题解"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">Leetcode官方题解</a></h2><p>二叉树的前序遍历</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        def preorder(root:TreeNode):            if not root:                return             res.append(root.val)            preorder(root.left)            preorder(root.right)        res=list()        preorder(root)        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>258. Add Digits(easy)</title>
      <link href="/2022/10/09/258/"/>
      <url>/2022/10/09/258/</url>
      
        <content type="html"><![CDATA[<h1 id="258-Add-Digits-easy"><a href="#258-Add-Digits-easy" class="headerlink" title="258. Add Digits(easy)"></a>258. Add Digits(easy)</h1><h2 id="Given-an-integer-num-repeatedly-add-all-its-digits-until-the-result-has-only-one-digit-and-return-it"><a href="#Given-an-integer-num-repeatedly-add-all-its-digits-until-the-result-has-only-one-digit-and-return-it" class="headerlink" title="Given an integer num, repeatedly add all its digits until the result has only one digit, and return it."></a>Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/add-digits/solution/ge-wei-xiang-jia-by-leetcode-solution-u4kj/">官方题解</a></h3><p>其实是一道数学题</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span> <span class="keyword">if</span> num <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>252. Meeting Rooms(easy)</title>
      <link href="/2022/10/09/252/"/>
      <url>/2022/10/09/252/</url>
      
        <content type="html"><![CDATA[<h1 id="252-Meeting-Rooms-easy"><a href="#252-Meeting-Rooms-easy" class="headerlink" title="252. Meeting Rooms(easy)"></a>252. Meeting Rooms(easy)</h1><h2 id="Given-an-array-of-meeting-time-intervals-where-intervals-i-starti-endi-determine-if-a-person-could-attend-all-meetings"><a href="#Given-an-array-of-meeting-time-intervals-where-intervals-i-starti-endi-determine-if-a-person-could-attend-all-meetings" class="headerlink" title="Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings."></a>Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.</h2><p>安排会议的第一题，没有什么技巧，先将数组排序，然后判断后一个会议的开始时间是不是小于前一个会议的结束时间</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canAttendMeetings</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        intervals.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(intervals)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">1</span>]&gt;intervals[i+<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>246. Strobogrammatic Number（easy)</title>
      <link href="/2022/10/09/246/"/>
      <url>/2022/10/09/246/</url>
      
        <content type="html"><![CDATA[<h1 id="246-Strobogrammatic-Number（easy"><a href="#246-Strobogrammatic-Number（easy" class="headerlink" title="246. Strobogrammatic Number（easy)"></a>246. Strobogrammatic Number（easy)</h1><h2 id="Given-a-string-num-which-represents-an-integer-return-true-if-num-is-a-strobogrammatic-number"><a href="#Given-a-string-num-which-represents-an-integer-return-true-if-num-is-a-strobogrammatic-number" class="headerlink" title="Given a string num which represents an integer, return true if num is a strobogrammatic number."></a>Given a string num which represents an integer, return true if num is a strobogrammatic number.</h2><h2 id="A-strobogrammatic-number-is-a-number-that-looks-the-same-when-rotated-180-degrees-looked-at-upside-down"><a href="#A-strobogrammatic-number-is-a-number-that-looks-the-same-when-rotated-180-degrees-looked-at-upside-down" class="headerlink" title="A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down)."></a>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num = &quot;69&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>有点像求回文数的方法，双指针，但是有相同构造的数就那么几对，列出来即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStrobogrammatic</span>(<span class="params">self, num: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        pairs= <span class="built_in">set</span>([(<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>), (<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>), (<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;9&#x27;</span>), (<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;8&#x27;</span>), (<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;6&#x27;</span>)])</span><br><span class="line">        l,r=<span class="number">0</span>,<span class="built_in">len</span>(num)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;=r:</span><br><span class="line">            <span class="keyword">if</span> (num[l],num[r]) <span class="keyword">not</span> <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            l+=<span class="number">1</span></span><br><span class="line">            r-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>228. Summary Ranges(easy)</title>
      <link href="/2022/10/09/228/"/>
      <url>/2022/10/09/228/</url>
      
        <content type="html"><![CDATA[<h1 id="228-Summary-Ranges-easy"><a href="#228-Summary-Ranges-easy" class="headerlink" title="228. Summary Ranges(easy)"></a>228. Summary Ranges(easy)</h1><h2 id="You-are-given-a-sorted-unique-integer-array-nums"><a href="#You-are-given-a-sorted-unique-integer-array-nums" class="headerlink" title="You are given a sorted unique integer array nums."></a>You are given a sorted unique integer array nums.</h2><h2 id="A-range-a-b-is-the-set-of-all-integers-from-a-to-b-inclusive"><a href="#A-range-a-b-is-the-set-of-all-integers-from-a-to-b-inclusive" class="headerlink" title="A range [a,b] is the set of all integers from a to b (inclusive)."></a>A range [a,b] is the set of all integers from a to b (inclusive).</h2><h2 id="Return-the-smallest-sorted-list-of-ranges-that-cover-all-the-numbers-in-the-array-exactly-That-is-each-element-of-nums-is-covered-by-exactly-one-of-the-ranges-and-there-is-no-integer-x-such-that-x-is-in-one-of-the-ranges-but-not-in-nums"><a href="#Return-the-smallest-sorted-list-of-ranges-that-cover-all-the-numbers-in-the-array-exactly-That-is-each-element-of-nums-is-covered-by-exactly-one-of-the-ranges-and-there-is-no-integer-x-such-that-x-is-in-one-of-the-ranges-but-not-in-nums" class="headerlink" title="Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums."></a>Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.</h2><h2 id="Each-range-a-b-in-the-list-should-be-output-as"><a href="#Each-range-a-b-in-the-list-should-be-output-as" class="headerlink" title="Each range [a,b] in the list should be output as:"></a>Each range [a,b] in the list should be output as:</h2><p>“a-&gt;b” if a != b<br>“a” if a == b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            start = cur</span><br><span class="line">            <span class="keyword">while</span> cur&lt;<span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="keyword">and</span> nums[cur]+<span class="number">1</span>==nums[cur+<span class="number">1</span>]:</span><br><span class="line">                cur+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> cur!=start:</span><br><span class="line">                res.append(<span class="built_in">str</span>(nums[start]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(nums[cur]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(nums[cur]))</span><br><span class="line">            cur+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225. Implement Stack using Queues(easy)</title>
      <link href="/2022/10/09/225/"/>
      <url>/2022/10/09/225/</url>
      
        <content type="html"><![CDATA[<h1 id="225-Implement-Stack-using-Queues-easy"><a href="#225-Implement-Stack-using-Queues-easy" class="headerlink" title="225. Implement Stack using Queues(easy)"></a>225. Implement Stack using Queues(easy)</h1><h2 id="Implement-a-last-in-first-out-LIFO-stack-using-only-two-queues-The-implemented-stack-should-support-all-the-functions-of-a-normal-stack-push-top-pop-and-empty"><a href="#Implement-a-last-in-first-out-LIFO-stack-using-only-two-queues-The-implemented-stack-should-support-all-the-functions-of-a-normal-stack-push-top-pop-and-empty" class="headerlink" title="Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty)."></a>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).</h2><h2 id="Implement-the-MyStack-class"><a href="#Implement-the-MyStack-class" class="headerlink" title="Implement the MyStack class:"></a>Implement the MyStack class:</h2><p>void push(int x) Pushes element x to the top of the stack.<br>int pop() Removes the element on the top of the stack and returns it.<br>int top() Returns the element on the top of the stack.<br>boolean empty() Returns true if the stack is empty, false otherwise.</p><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h2><p>You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.<br>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // return 2</span><br><span class="line">myStack.pop(); // return 2</span><br><span class="line">myStack.empty(); // return False</span><br></pre></td></tr></table></figure><h3 id="Leetcode官方题解"><a href="#Leetcode官方题解" class="headerlink" title="Leetcode官方题解"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">Leetcode官方题解</a></h3><p>栈是一种后进先出的数据结构，元素从顶端入栈，然后从顶端出栈。</p><p>队列是一种先进先出的数据结构，元素从后端入队，然后从前端出队。</p><p>为了满足栈的特性，即最后入栈的元素最先出栈，在使用队列实现栈时，应满足队列前端的元素是最后入栈的元素。可以使用两个队列实现栈的操作，其中 queue1用于存储栈内的元素，queue2作为入栈操作的辅助队列。</p><p>入栈操作时，首先将元素入队到 queue2，然后将 queue1的全部元素依次出队并入队到 queue2，此时 queue2的前端的元素即为新入栈的元素，再将 queue1和 queue2互换，则 queue1的元素即为栈内的元素，queue1的前端和后端分别对应栈顶和栈底。</p><p>由于每次入栈操作都确保 queue1的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1的前端元素并返回即可（不移除元素）。</p><p>由于 queue1用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1是否为空即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue1 = collections.deque()</span><br><span class="line">        self.queue2 = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue2.append(x)</span><br><span class="line">        <span class="keyword">while</span> self.queue1:</span><br><span class="line">            self.queue2.append(self.queue1.popleft())</span><br><span class="line">        self.queue1, self.queue2 = self.queue2, self.queue1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue1</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> stack </tag>
            
            <tag> Queues </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits(easy)</title>
      <link href="/2022/10/09/190/"/>
      <url>/2022/10/09/190/</url>
      
        <content type="html"><![CDATA[<h2 id="Reverse-bits-of-a-given-32-bits-unsigned-integer"><a href="#Reverse-bits-of-a-given-32-bits-unsigned-integer" class="headerlink" title="Reverse bits of a given 32 bits unsigned integer."></a>Reverse bits of a given 32 bits unsigned integer.</h2><p>Note:</p><h2 id="Note-that-in-some-languages-such-as-Java-there-is-no-unsigned-integer-type-In-this-case-both-input-and-output-will-be-given-as-a-signed-integer-type-They-should-not-affect-your-implementation-as-the-integer’s-internal-binary-representation-is-the-same-whether-it-is-signed-or-unsigned"><a href="#Note-that-in-some-languages-such-as-Java-there-is-no-unsigned-integer-type-In-this-case-both-input-and-output-will-be-given-as-a-signed-integer-type-They-should-not-affect-your-implementation-as-the-integer’s-internal-binary-representation-is-the-same-whether-it-is-signed-or-unsigned" class="headerlink" title="Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned."></a>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</h2><h2 id="In-Java-the-compiler-represents-the-signed-integers-using-2’s-complement-notation-Therefore-in-Example-2-above-the-input-represents-the-signed-integer-3-and-the-output-represents-the-signed-integer-1073741825"><a href="#In-Java-the-compiler-represents-the-signed-integers-using-2’s-complement-notation-Therefore-in-Example-2-above-the-input-represents-the-signed-integer-3-and-the-output-represents-the-signed-integer-1073741825" class="headerlink" title="In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825."></a>In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure><p>二进制颠倒顺序，用位运算的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span>(<span class="params">n</span>):</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        n1=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            ans=res&lt;&lt;<span class="number">1</span></span><br><span class="line">            n1=n&amp;<span class="number">1</span>  <span class="comment"># n1=n&amp;1</span></span><br><span class="line">            res=ans|n1   <span class="comment"># 或运算：同0为0，否则为1</span></span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>  <span class="comment"># x &gt;&gt; y 右移操作，最左边用 0 填充</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>168. Excel Sheet Column Title(easy)</title>
      <link href="/2022/10/09/168/"/>
      <url>/2022/10/09/168/</url>
      
        <content type="html"><![CDATA[<h1 id="168-Excel-Sheet-Column-Title-easy"><a href="#168-Excel-Sheet-Column-Title-easy" class="headerlink" title="168. Excel Sheet Column Title(easy)"></a>168. Excel Sheet Column Title(easy)</h1><h2 id="Given-an-integer-columnNumber-return-its-corresponding-column-title-as-it-appears-in-an-Excel-sheet"><a href="#Given-an-integer-columnNumber-return-its-corresponding-column-title-as-it-appears-in-an-Excel-sheet" class="headerlink" title="Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet."></a>Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.</h2><h2 id="For-example"><a href="#For-example" class="headerlink" title="For example:"></a>For example:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnNumber = 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure><p>这道题和 171. Excel Sheet Column Number(easy)属于镜像题，可以用高中学过的十进制转二进制的思想，利用求余和除法不断求出每一位的系数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, columnNumber: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ans=[]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> columnNumber&gt;<span class="number">0</span>:</span><br><span class="line">            columnNumber-=<span class="number">1</span></span><br><span class="line">            current=columnNumber%<span class="number">26</span></span><br><span class="line">            columnNumber=columnNumber//<span class="number">26</span></span><br><span class="line">            ans.append(<span class="built_in">chr</span>(current+<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))) <span class="comment">#The chr() method converts an integer to its unicode character and returns it.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ans[::-<span class="number">1</span>])    </span><br><span class="line"><span class="comment"># [::-1] , it starts from the end towards the first taking each element. </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>342. Power of Four(easy)</title>
      <link href="/2022/10/08/342/"/>
      <url>/2022/10/08/342/</url>
      
        <content type="html"><![CDATA[<h1 id="342-Power-of-Four-easy"><a href="#342-Power-of-Four-easy" class="headerlink" title="342. Power of Four(easy)"></a>342. Power of Four(easy)</h1><h2 id="Given-an-integer-n-return-true-if-it-is-a-power-of-four-Otherwise-return-false"><a href="#Given-an-integer-n-return-true-if-it-is-a-power-of-four-Otherwise-return-false" class="headerlink" title="Given an integer n, return true if it is a power of four. Otherwise, return false."></a>Given an integer n, return true if it is a power of four. Otherwise, return false.</h2><h2 id="An-integer-n-is-a-power-of-four-if-there-exists-an-integer-x-such-that-n-4-x"><a href="#An-integer-n-is-a-power-of-four-if-there-exists-an-integer-x-such-that-n-4-x" class="headerlink" title="An integer n is a power of four, if there exists an integer x such that n == 4^x."></a>An integer n is a power of four, if there exists an integer x such that n == 4^x.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hashset1=<span class="built_in">set</span>()</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> math.<span class="built_in">pow</span>(<span class="number">4</span>,i)&lt;math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)-<span class="number">1</span>:</span><br><span class="line">            hashset1.add(math.<span class="built_in">pow</span>(<span class="number">4</span>,i))</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> hashset1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Power </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326. Power of Three(easy)</title>
      <link href="/2022/10/08/326/"/>
      <url>/2022/10/08/326/</url>
      
        <content type="html"><![CDATA[<h1 id="326-Power-of-Three-easy"><a href="#326-Power-of-Three-easy" class="headerlink" title="326. Power of Three(easy)"></a>326. Power of Three(easy)</h1><h2 id="Given-an-integer-n-return-true-if-it-is-a-power-of-three-Otherwise-return-false"><a href="#Given-an-integer-n-return-true-if-it-is-a-power-of-three-Otherwise-return-false" class="headerlink" title="Given an integer n, return true if it is a power of three. Otherwise, return false."></a>Given an integer n, return true if it is a power of three. Otherwise, return false.</h2><h2 id="An-integer-n-is-a-power-of-three-if-there-exists-an-integer-x-such-that-n-3x"><a href="#An-integer-n-is-a-power-of-three-if-there-exists-an-integer-x-such-that-n-3x" class="headerlink" title="An integer n is a power of three, if there exists an integer x such that n == 3x."></a>An integer n is a power of three, if there exists an integer x such that n == 3x.</h2><p>通用代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hashset1=<span class="built_in">set</span>()</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> math.<span class="built_in">pow</span>(<span class="number">3</span>,i)&lt;math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)-<span class="number">1</span>:</span><br><span class="line">            hashset1.add(math.<span class="built_in">pow</span>(<span class="number">3</span>,i))</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> hashset1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Power </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1380. Lucky Numbers in a Matrix(easy)</title>
      <link href="/2022/10/05/1380/"/>
      <url>/2022/10/05/1380/</url>
      
        <content type="html"><![CDATA[<h1 id="1380-Lucky-Numbers-in-a-Matrix-easy"><a href="#1380-Lucky-Numbers-in-a-Matrix-easy" class="headerlink" title="1380. Lucky Numbers in a Matrix(easy)"></a>1380. Lucky Numbers in a Matrix(easy)</h1><h2 id="Given-an-m-x-n-matrix-of-distinct-numbers-return-all-lucky-numbers-in-the-matrix-in-any-order"><a href="#Given-an-m-x-n-matrix-of-distinct-numbers-return-all-lucky-numbers-in-the-matrix-in-any-order" class="headerlink" title="Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order."></a>Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.</h2><h2 id="A-lucky-number-is-an-element-of-the-matrix-such-that-it-is-the-minimum-element-in-its-row-and-maximum-in-its-column"><a href="#A-lucky-number-is-an-element-of-the-matrix-such-that-it-is-the-minimum-element-in-its-row-and-maximum-in-its-column" class="headerlink" title="A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column."></a>A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</h2><pre><code class="python">class Solution:    def luckyNumbers(self, matrix: List[List[int]]) -&gt; List[int]:         m = len(matrix)        n = len(matrix[0])        # Calculate the strength of each row.        strengths = []        col=[]        res=[]                        for i, row in enumerate(matrix):            strength = row[0]            ind=0            for j in range(1,n):                if row[j]&lt;strength:                    ind=j                    strength=row[j]                           strengths.append((strength, ind))                for i in range(len(strengths)):            col = [sub[strengths[i][1]] for sub in matrix]            if strengths[i][0]==max(col):                res.append(strengths[i][0])        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1337. The K Weakest Rows in a Matrix(easy)</title>
      <link href="/2022/10/05/1337/"/>
      <url>/2022/10/05/1337/</url>
      
        <content type="html"><![CDATA[<h1 id="1337-The-K-Weakest-Rows-in-a-Matrix-easy"><a href="#1337-The-K-Weakest-Rows-in-a-Matrix-easy" class="headerlink" title="1337. The K Weakest Rows in a Matrix(easy)"></a>1337. The K Weakest Rows in a Matrix(easy)</h1><h2 id="You-are-given-an-m-x-n-binary-matrix-mat-of-1’s-representing-soldiers-and-0’s-representing-civilians-The-soldiers-are-positioned-in-front-of-the-civilians-That-is-all-the-1’s-will-appear-to-the-left-of-all-the-0’s-in-each-row"><a href="#You-are-given-an-m-x-n-binary-matrix-mat-of-1’s-representing-soldiers-and-0’s-representing-civilians-The-soldiers-are-positioned-in-front-of-the-civilians-That-is-all-the-1’s-will-appear-to-the-left-of-all-the-0’s-in-each-row" class="headerlink" title="You are given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row."></a>You are given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row.</h2><h2 id="A-row-i-is-weaker-than-a-row-j-if-one-of-the-following-is-true"><a href="#A-row-i-is-weaker-than-a-row-j-if-one-of-the-following-is-true" class="headerlink" title="A row i is weaker than a row j if one of the following is true:"></a>A row i is weaker than a row j if one of the following is true:</h2><h2 id="The-number-of-soldiers-in-row-i-is-less-than-the-number-of-soldiers-in-row-j"><a href="#The-number-of-soldiers-in-row-i-is-less-than-the-number-of-soldiers-in-row-j" class="headerlink" title="The number of soldiers in row i is less than the number of soldiers in row j."></a>The number of soldiers in row i is less than the number of soldiers in row j.</h2><h2 id="Both-rows-have-the-same-number-of-soldiers-and-i-lt-j"><a href="#Both-rows-have-the-same-number-of-soldiers-and-i-lt-j" class="headerlink" title="Both rows have the same number of soldiers and i &lt; j."></a>Both rows have the same number of soldiers and i &lt; j.</h2><h2 id="Return-the-indices-of-the-k-weakest-rows-in-the-matrix-ordered-from-weakest-to-strongest"><a href="#Return-the-indices-of-the-k-weakest-rows-in-the-matrix-ordered-from-weakest-to-strongest" class="headerlink" title="Return the indices of the k weakest rows in the matrix ordered from weakest to strongest."></a>Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.</h2><p>思路分成两步，第一步先求出每行1的个数，用一个二维数组储存<br>第二步再输出前K个</p><p><a href="https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/solutions/501705/the-k-weakest-rows-in-a-matrix/">leetcode题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kWeakestRows</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that there is a more conscise solution just below. This code</span></span><br><span class="line">    <span class="comment"># avoids the use of advanced language features.</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(mat)</span><br><span class="line">        n = <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate the strength of each row.</span></span><br><span class="line">        strengths = []</span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(mat):</span><br><span class="line">            strength = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> row[j] == <span class="number">0</span>: </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                strength += <span class="number">1</span></span><br><span class="line">            strengths.append((strength, i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sort all the strengths. This will sort firstly by strength</span></span><br><span class="line">    <span class="comment"># and secondly by index.</span></span><br><span class="line">        strengths.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pull out and return the indexes of the smallest k entries.</span></span><br><span class="line">        indexes = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            indexes.append(strengths[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> indexes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1351. Count Negative Numbers in a Sorted Matrix</title>
      <link href="/2022/10/04/1351/"/>
      <url>/2022/10/04/1351/</url>
      
        <content type="html"><![CDATA[<h1 id="1351-Count-Negative-Numbers-in-a-Sorted-Matrix"><a href="#1351-Count-Negative-Numbers-in-a-Sorted-Matrix" class="headerlink" title="1351. Count Negative Numbers in a Sorted Matrix"></a>1351. Count Negative Numbers in a Sorted Matrix</h1><h2 id="Given-a-m-x-n-matrix-grid-which-is-sorted-in-non-increasing-order-both-row-wise-and-column-wise-return-the-number-of-negative-numbers-in-grid"><a href="#Given-a-m-x-n-matrix-grid-which-is-sorted-in-non-increasing-order-both-row-wise-and-column-wise-return-the-number-of-negative-numbers-in-grid" class="headerlink" title="Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid."></a>Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.</h2><p>还是一样的，都是挨个遍历一遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNegatives</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(grid)</span><br><span class="line">        m=<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]&lt;<span class="number">0</span>:</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>832. Flipping an Image(easy)</title>
      <link href="/2022/10/04/832/"/>
      <url>/2022/10/04/832/</url>
      
        <content type="html"><![CDATA[<h1 id="832-Flipping-an-Image-easy"><a href="#832-Flipping-an-Image-easy" class="headerlink" title="832. Flipping an Image(easy)"></a>832. Flipping an Image(easy)</h1><h2 id="Given-an-n-x-n-binary-matrix-image-flip-the-image-horizontally-then-invert-it-and-return-the-resulting-image"><a href="#Given-an-n-x-n-binary-matrix-image-flip-the-image-horizontally-then-invert-it-and-return-the-resulting-image" class="headerlink" title="Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image."></a>Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.</h2><h2 id="To-flip-an-image-horizontally-means-that-each-row-of-the-image-is-reversed"><a href="#To-flip-an-image-horizontally-means-that-each-row-of-the-image-is-reversed" class="headerlink" title="To flip an image horizontally means that each row of the image is reversed."></a>To flip an image horizontally means that each row of the image is reversed.</h2><h2 id="For-example-flipping-1-1-0-horizontally-results-in-0-1-1"><a href="#For-example-flipping-1-1-0-horizontally-results-in-0-1-1" class="headerlink" title="For example, flipping [1,1,0] horizontally results in [0,1,1]."></a>For example, flipping [1,1,0] horizontally results in [0,1,1].</h2><h2 id="To-invert-an-image-means-that-each-0-is-replaced-by-1-and-each-1-is-replaced-by-0"><a href="#To-invert-an-image-means-that-each-0-is-replaced-by-1-and-each-1-is-replaced-by-0" class="headerlink" title="To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0."></a>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.</h2><h2 id="For-example-inverting-0-1-1-results-in-1-0-0"><a href="#For-example-inverting-0-1-1-results-in-1-0-0" class="headerlink" title="For example, inverting [0,1,1] results in [1,0,0]."></a>For example, inverting [0,1,1] results in [1,0,0].</h2><p>两次遍历，第一次遍历是10互换，第二次遍历是前后数字互换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span>(<span class="params">self, image: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n=<span class="built_in">len</span>(image)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> image[i][j]==<span class="number">1</span>:</span><br><span class="line">                    image[i][j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    image[i][j]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">                    tmp=image[i][j]</span><br><span class="line">                    image[i][j]=image[i][n-j-<span class="number">1</span>]</span><br><span class="line">                    image[i][n-j-<span class="number">1</span>]=tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">                    tmp=image[i][j]</span><br><span class="line">                    image[i][j]=image[i][n-j-<span class="number">1</span>]</span><br><span class="line">                    image[i][n-j-<span class="number">1</span>]=tmp</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><p>相对轻便的算法<br>[::-1] 顺序相反操作<br>[-1] 读取倒数第一个元素<br>[3::-1] 从下标为3（从0开始）的元素开始翻转读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span>(<span class="params">self, image: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        result=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> image:</span><br><span class="line">            result.append(i[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result[i])):</span><br><span class="line">                <span class="keyword">if</span> result[i][j]==<span class="number">0</span>:</span><br><span class="line">                    result[i][j]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result[i][j]=<span class="number">0</span></span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2373. Largest Local Values in a Matrix(easy)</title>
      <link href="/2022/10/04/2373/"/>
      <url>/2022/10/04/2373/</url>
      
        <content type="html"><![CDATA[<h1 id="2373-Largest-Local-Values-in-a-Matrix-easy"><a href="#2373-Largest-Local-Values-in-a-Matrix-easy" class="headerlink" title="2373. Largest Local Values in a Matrix(easy)"></a>2373. Largest Local Values in a Matrix(easy)</h1><h2 id="You-are-given-an-n-x-n-integer-matrix-grid"><a href="#You-are-given-an-n-x-n-integer-matrix-grid" class="headerlink" title="You are given an n x n integer matrix grid."></a>You are given an n x n integer matrix grid.</h2><h2 id="Generate-an-integer-matrix-maxLocal-of-size-n-2-x-n-2-such-that"><a href="#Generate-an-integer-matrix-maxLocal-of-size-n-2-x-n-2-such-that" class="headerlink" title="Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:"></a>Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:</h2><p>maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.</p><h2 id="In-other-words-we-want-to-find-the-largest-value-in-every-contiguous-3-x-3-matrix-in-grid"><a href="#In-other-words-we-want-to-find-the-largest-value-in-every-contiguous-3-x-3-matrix-in-grid" class="headerlink" title="In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid."></a>In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.</h2><h2 id="Return-the-generated-matrix"><a href="#Return-the-generated-matrix" class="headerlink" title="Return the generated matrix."></a>Return the generated matrix.</h2><p>二维矩阵遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestLocal</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n=<span class="built_in">len</span>(grid)</span><br><span class="line">        ans=[[<span class="number">0</span>]*(n-<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">                ans[i][j]=<span class="built_in">max</span>(grid[x][y] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(j,j+<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill11-matrix</title>
      <link href="/2022/10/04/LeetCode-skill11-matrix/"/>
      <url>/2022/10/04/LeetCode-skill11-matrix/</url>
      
        <content type="html"><![CDATA[<ol start="1672"><li>Richest Customer Wealth(easy)</li></ol><ol start="54"><li>Spiral Matrix(medium)</li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1672. Richest Customer Wealth(easy)</title>
      <link href="/2022/10/04/1672/"/>
      <url>/2022/10/04/1672/</url>
      
        <content type="html"><![CDATA[<h1 id="1672-Richest-Customer-Wealth-easy"><a href="#1672-Richest-Customer-Wealth-easy" class="headerlink" title="1672. Richest Customer Wealth(easy)"></a>1672. Richest Customer Wealth(easy)</h1><h2 id="You-are-given-an-m-x-n-integer-grid-accounts-where-accounts-i-j-is-the-amount-of-money-the-i​​​​​​​​​​​th​​​​-customer-has-in-the-j​​​​​​​​​​​th​​​​-bank-Return-the-wealth-that-the-richest-customer-has"><a href="#You-are-given-an-m-x-n-integer-grid-accounts-where-accounts-i-j-is-the-amount-of-money-the-i​​​​​​​​​​​th​​​​-customer-has-in-the-j​​​​​​​​​​​th​​​​-bank-Return-the-wealth-that-the-richest-customer-has" class="headerlink" title="You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has."></a>You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.</h2><h2 id="A-customer’s-wealth-is-the-amount-of-money-they-have-in-all-their-bank-accounts-The-richest-customer-is-the-customer-that-has-the-maximum-wealth"><a href="#A-customer’s-wealth-is-the-amount-of-money-they-have-in-all-their-bank-accounts-The-richest-customer-is-the-customer-that-has-the-maximum-wealth" class="headerlink" title="A customer’s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth."></a>A customer’s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumWealth</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(accounts)):</span><br><span class="line">            res=<span class="built_in">max</span>(res,<span class="built_in">sum</span>(accounts[i]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line">```python</span><br><span class="line">accounts = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(accounts)) <span class="comment">#2 行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(accounts[<span class="number">0</span>])) <span class="comment">#3 列</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>171. Excel Sheet Column Number(easy)</title>
      <link href="/2022/10/03/171/"/>
      <url>/2022/10/03/171/</url>
      
        <content type="html"><![CDATA[<h1 id="171-Excel-Sheet-Column-Number-easy"><a href="#171-Excel-Sheet-Column-Number-easy" class="headerlink" title="171. Excel Sheet Column Number(easy)"></a>171. Excel Sheet Column Number(easy)</h1><h2 id="Given-a-string-columnTitle-that-represents-the-column-title-as-appears-in-an-Excel-sheet-return-its-corresponding-column-number"><a href="#Given-a-string-columnTitle-that-represents-the-column-title-as-appears-in-an-Excel-sheet-return-its-corresponding-column-number" class="headerlink" title="Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number."></a>Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.</h2><h2 id="For-example"><a href="#For-example" class="headerlink" title="For example:"></a>For example:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这道题是一经典题目，相当于从26进制转换成十进制，这是一个标准算法，我们从右到左迭代数字，并将它们乘以基数到数字位置的幂。为了将字母转换为数字，我们使用ord，该方法返回字母的Unicode代码。通过将代码减去 64，我们可以将字母映射到从 1 到 26 的数字。<br>和 168. Excel Sheet Column Title(easy) 是一道镜像题目</p><p>26进制转换为十进制，相当于K*(26^(n-1))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span>(<span class="params">self, columnTitle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        val=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">reversed</span>(columnTitle)):</span><br><span class="line">            val+=(<span class="number">26</span>**i)*(<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="comment">#** 代表乘方</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill10-Data-structure-design</title>
      <link href="/2022/10/03/LeetCode-skill10-Data-structure-design/"/>
      <url>/2022/10/03/LeetCode-skill10-Data-structure-design/</url>
      
        <content type="html"><![CDATA[<ol start="170"><li><p>Two Sum III - Data structure design(easy)</p></li><li><p>Implement Stack using Queues(easy)</p></li><li><p>Logger Rate Limiter(easy)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Data structure design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>170. Two Sum III - Data structure design(easy)</title>
      <link href="/2022/10/03/170/"/>
      <url>/2022/10/03/170/</url>
      
        <content type="html"><![CDATA[<h1 id="170-Two-Sum-III-Data-structure-design-easy"><a href="#170-Two-Sum-III-Data-structure-design-easy" class="headerlink" title="170. Two Sum III - Data structure design(easy)"></a>170. Two Sum III - Data structure design(easy)</h1><h2 id="Design-a-data-structure-that-accepts-a-stream-of-integers-and-checks-if-it-has-a-pair-of-integers-that-sum-up-to-a-particular-value"><a href="#Design-a-data-structure-that-accepts-a-stream-of-integers-and-checks-if-it-has-a-pair-of-integers-that-sum-up-to-a-particular-value" class="headerlink" title="Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value."></a>Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.</h2><h2 id="Implement-the-TwoSum-class"><a href="#Implement-the-TwoSum-class" class="headerlink" title="Implement the TwoSum class:"></a>Implement the TwoSum class:</h2><p>TwoSum() Initializes the TwoSum object, with an empty array initially.<br>void add(int number) Adds number to the data structure.<br>boolean find(int value) Returns true if there exists any pair of numbers whose sum is equal to value, otherwise, it returns false.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;TwoSum&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;find&quot;, &quot;find&quot;]</span><br><span class="line">[[], [1], [3], [5], [4], [7]]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, null, true, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">TwoSum twoSum = new TwoSum();</span><br><span class="line">twoSum.add(1);   // [] --&gt; [1]</span><br><span class="line">twoSum.add(3);   // [1] --&gt; [1,3]</span><br><span class="line">twoSum.add(5);   // [1,3] --&gt; [1,3,5]</span><br><span class="line">twoSum.find(4);  // 1 + 3 = 4, return true</span><br><span class="line">twoSum.find(7);  // No two integers sum up to 7, return false</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/solutions/441899/two-sum-iii-data-structure-design/">leetcode题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nums=[]</span><br><span class="line">        self.is_sorted=<span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, number: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="comment"># Inserting while maintaining the ascending order.</span></span><br><span class="line">        <span class="comment"># for index, num in enumerate(self.nums):</span></span><br><span class="line">        <span class="comment">#     if number &lt;= num:</span></span><br><span class="line">        <span class="comment">#         self.nums.insert(index, number)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">## larger than any number</span></span><br><span class="line">        <span class="comment">#self.nums.append(number)</span></span><br><span class="line"></span><br><span class="line">        self.nums.append(number)</span><br><span class="line">        self.is_sorted = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Find if there exists any pair of numbers which sum is equal to the value.</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_sorted:</span><br><span class="line">            self.nums.sort()</span><br><span class="line">            self.is_sorted = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(self.nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            currSum = self.nums[low] + self.nums[high]</span><br><span class="line">            <span class="keyword">if</span> currSum &lt; value:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> currSum &gt; value:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># currSum == value</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your TwoSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TwoSum()</span></span><br><span class="line"><span class="comment"># obj.add(number)</span></span><br><span class="line"><span class="comment"># param_2 = obj.find(value)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> two-pointer </tag>
            
            <tag> Data structure design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1572. Matrix Diagonal Sum(easy)</title>
      <link href="/2022/10/03/1572/"/>
      <url>/2022/10/03/1572/</url>
      
        <content type="html"><![CDATA[<h1 id="1572-Matrix-Diagonal-Sum-easy"><a href="#1572-Matrix-Diagonal-Sum-easy" class="headerlink" title="1572. Matrix Diagonal Sum(easy)"></a>1572. Matrix Diagonal Sum(easy)</h1><h2 id="Given-a-square-matrix-mat-return-the-sum-of-the-matrix-diagonals"><a href="#Given-a-square-matrix-mat-return-the-sum-of-the-matrix-diagonals" class="headerlink" title="Given a square matrix mat, return the sum of the matrix diagonals."></a>Given a square matrix mat, return the sum of the matrix diagonals.</h2><h2 id="Only-include-the-sum-of-all-the-elements-on-the-primary-diagonal-and-all-the-elements-on-the-secondary-diagonal-that-are-not-part-of-the-primary-diagonal"><a href="#Only-include-the-sum-of-all-the-elements-on-the-primary-diagonal-and-all-the-elements-on-the-secondary-diagonal-that-are-not-part-of-the-primary-diagonal" class="headerlink" title="Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal."></a>Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.</h2><p>矩阵对角线之和，这题很典型</p><p>逐行取数<br>思路与算法</p><p>逐行遍历，记当前的行号为 i，对于一行我们把 (i, i)位置和 (i, n - i - 1) 加入答案。这样如果 n 是奇数的话，最中间的格子会被加入两次。所以 n 为奇数的时候，我们需要减掉矩阵最中心的那个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diagonalSum</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(mat)</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total += mat[i][i] + mat[i][n - <span class="number">1</span> - i]</span><br><span class="line">        <span class="keyword">return</span> total - mat[mid][mid] * (n &amp; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>n&amp;1是用来判断奇偶性的<br>n&amp;1   与运算      可以判断n是否为偶数     如果是偶数，n&amp;1返回0；否则返回1，为奇数。<br>一个整数 n，n&amp;1 这个表达式 可以用来 判断 a的奇偶性。<br>二进制的末位为 0表示偶数，末位为 1表是奇数。<br>使用 n%2 来判断奇偶性 和 n&amp;1 是一样的作用，但是 n&amp;1 要快好多。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> two-pointer </tag>
            
            <tag> Palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>163. Missing Ranges(easy)</title>
      <link href="/2022/10/03/163/"/>
      <url>/2022/10/03/163/</url>
      
        <content type="html"><![CDATA[<h1 id="163-Missing-Ranges-easy"><a href="#163-Missing-Ranges-easy" class="headerlink" title="163. Missing Ranges(easy)"></a>163. Missing Ranges(easy)</h1><h2 id="You-are-given-an-inclusive-range-lower-upper-and-a-sorted-unique-integer-array-nums-where-all-elements-are-in-the-inclusive-range"><a href="#You-are-given-an-inclusive-range-lower-upper-and-a-sorted-unique-integer-array-nums-where-all-elements-are-in-the-inclusive-range" class="headerlink" title="You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are in the inclusive range."></a>You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are in the inclusive range.</h2><h2 id="A-number-x-is-considered-missing-if-x-is-in-the-range-lower-upper-and-x-is-not-in-nums"><a href="#A-number-x-is-considered-missing-if-x-is-in-the-range-lower-upper-and-x-is-not-in-nums" class="headerlink" title="A number x is considered missing if x is in the range [lower, upper] and x is not in nums."></a>A number x is considered missing if x is in the range [lower, upper] and x is not in nums.</h2><h2 id="Return-the-smallest-sorted-list-of-ranges-that-cover-every-missing-number-exactly-That-is-no-element-of-nums-is-in-any-of-the-ranges-and-each-missing-number-is-in-one-of-the-ranges"><a href="#Return-the-smallest-sorted-list-of-ranges-that-cover-every-missing-number-exactly-That-is-no-element-of-nums-is-in-any-of-the-ranges-and-each-missing-number-is-in-one-of-the-ranges" class="headerlink" title="Return the smallest sorted list of ranges that cover every missing number exactly. That is, no element of nums is in any of the ranges, and each missing number is in one of the ranges."></a>Return the smallest sorted list of ranges that cover every missing number exactly. That is, no element of nums is in any of the ranges, and each missing number is in one of the ranges.</h2><h2 id="Each-range-a-b-in-the-list-should-be-output-as"><a href="#Each-range-a-b-in-the-list-should-be-output-as" class="headerlink" title="Each range [a,b] in the list should be output as:"></a>Each range [a,b] in the list should be output as:</h2><p>“a-&gt;b” if a != b<br>“a” if a == b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,3,50,75], lower = 0, upper = 99</span><br><span class="line">Output: [&quot;2&quot;,&quot;4-&gt;49&quot;,&quot;51-&gt;74&quot;,&quot;76-&gt;99&quot;]</span><br><span class="line">Explanation: The ranges are:</span><br><span class="line">[2,2] --&gt; &quot;2&quot;</span><br><span class="line">[4,49] --&gt; &quot;4-&gt;49&quot;</span><br><span class="line">[51,74] --&gt; &quot;51-&gt;74&quot;</span><br><span class="line">[76,99] --&gt; &quot;76-&gt;99&quot;</span><br></pre></td></tr></table></figure><p>这题是通过lower和upper确定上下边界，然后再挨个前后相减得到范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMissingRanges</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], lower: <span class="built_in">int</span>, upper: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">       </span><br><span class="line">        numList = nums</span><br><span class="line">        nums = [lower - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numList:</span><br><span class="line">            nums.append(num)</span><br><span class="line">        nums.append(upper + <span class="number">1</span>)</span><br><span class="line">        ranges = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            dist = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> dist &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> dist == <span class="number">2</span>:</span><br><span class="line">                    ranges.append(<span class="built_in">str</span>(nums[i] + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = nums[i] + <span class="number">1</span></span><br><span class="line">                    end = nums[i + <span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                    ranges.append(<span class="string">&quot;&#123;0:d&#125;-&gt;&#123;1:d&#125;&quot;</span>.<span class="built_in">format</span>(start, end))</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> ranges</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> two-pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1155. Number of Dice Rolls With Target Sum(medium)</title>
      <link href="/2022/10/02/1155/"/>
      <url>/2022/10/02/1155/</url>
      
        <content type="html"><![CDATA[<ol start="1155"><li>Number of Dice Rolls With Target Sum(medium)</li></ol><p>You have n dice and each die has k faces numbered from 1 to k.</p><p>Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.</p><p>这题乍一看就是dp，而且类似于爬楼梯问题，相当于一次爬K个台阶，一共爬n次爬到target的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1, k = 6, target = 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You throw one die with 6 faces.</span><br><span class="line">There is only one way to get a sum of 3.</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/solutions/2652934/python-top-down-bottom-up/">题解</a></h3><p>We are asked to figure out how many times we get target sum with n dice with values 1..k.<br>The important point is - sum of all faced-up numbers. So it cannot be a subset of n dice. It should be sum of all faced-up dice.</p><p>We are going to pick the 1st dice with value 1. Then we going to pick the 2nd dice with value 1 and so on until we ran out of dice.<br>sum([1,1,1,..1] n times) == target?</p><p>Then we are going to pick the 1st dice with value 1 and the 2nd dice with value 2 and so on.<br>sum([[1,2,1,..1] n times) == target?</p><p>…<br>sum([[3,1,5,..4] n times) == target?<br>…</p><p>…</p><p>n) sum([k,k,…k] n times) == target?<br>When we ran out of dice (n -&gt; 0) we check if the sum of all picked dice values == target. If yes, return 1, else return 0 for a specific permutation.</p><p>They want us to count [1,2] and [2,1] as 2 different sets. The order of items is important. We are working with permutations.</p><p>Find the target sum in all permutations of size n with element values ranging from 1…k.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRollsToTarget</span>(<span class="params">self, N: <span class="built_in">int</span>, k: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># [1] 2 3 4 5 6</span></span><br><span class="line">        <span class="comment"># 1 2 3 4 5 [6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bottom-up/tabulation TC: (N*k*target) SC: (N*target)</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(i, target + <span class="number">1</span>):</span><br><span class="line">                    dp[n][t] += dp[n - <span class="number">1</span>][t - i] % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[N][target] % MOD</span><br><span class="line"></span><br><span class="line"><span class="comment"># top-down</span></span><br><span class="line"><span class="comment">#         @cache</span></span><br><span class="line"><span class="comment">#         def solve(n, t):</span></span><br><span class="line"><span class="comment">#             if n == 0:</span></span><br><span class="line"><span class="comment">#                 return 1 if t == 0 else 0 # if we ran out of dice and we got our target value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#             count = 0</span></span><br><span class="line"><span class="comment">#             for j in range(1, k + 1):</span></span><br><span class="line"><span class="comment">#                 if t - j &gt;= 0:</span></span><br><span class="line"><span class="comment">#                     count += solve(n - 1, t - j)</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">#             return count</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         return solve(n, target) % MOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>119. Pascal&#39;s Triangle II(easy)</title>
      <link href="/2022/10/02/119/"/>
      <url>/2022/10/02/119/</url>
      
        <content type="html"><![CDATA[<h1 id="119-Pascal’s-Triangle-II-easy"><a href="#119-Pascal’s-Triangle-II-easy" class="headerlink" title="119. Pascal’s Triangle II(easy)"></a>119. Pascal’s Triangle II(easy)</h1><h2 id="Given-an-integer-rowIndex-return-the-rowIndexth-0-indexed-row-of-the-Pascal’s-triangle"><a href="#Given-an-integer-rowIndex-return-the-rowIndexth-0-indexed-row-of-the-Pascal’s-triangle" class="headerlink" title="Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle."></a>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle.</h2><h2 id="In-Pascal’s-triangle-each-number-is-the-sum-of-the-two-numbers-directly-above-it-as-shown"><a href="#In-Pascal’s-triangle-each-number-is-the-sum-of-the-two-numbers-directly-above-it-as-shown" class="headerlink" title="In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:"></a>In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:</h2><p>跟118几乎一模一样，只不过这道题是输出特定的某一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex==<span class="number">0</span>:<span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        res=[[<span class="number">1</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res)&lt;rowIndex+<span class="number">1</span>:</span><br><span class="line">            newRow=[a+b <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+res[-<span class="number">1</span>],res[-<span class="number">1</span>]+[<span class="number">0</span>])]</span><br><span class="line">            res.append(newRow)</span><br><span class="line">        <span class="keyword">return</span> newRow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139</title>
      <link href="/2022/10/02/139/"/>
      <url>/2022/10/02/139/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>118. Pascal&#39;s Triangle</title>
      <link href="/2022/10/02/118/"/>
      <url>/2022/10/02/118/</url>
      
        <content type="html"><![CDATA[<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h1><h2 id="Given-an-integer-numRows-return-the-first-numRows-of-Pascal’s-triangle"><a href="#Given-an-integer-numRows-return-the-first-numRows-of-Pascal’s-triangle" class="headerlink" title="Given an integer numRows, return the first numRows of Pascal’s triangle."></a>Given an integer numRows, return the first numRows of Pascal’s triangle.</h2><h2 id="In-Pascal’s-triangle-each-number-is-the-sum-of-the-two-numbers-directly-above-it-as-shown"><a href="#In-Pascal’s-triangle-each-number-is-the-sum-of-the-two-numbers-directly-above-it-as-shown" class="headerlink" title="In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:"></a>In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:</h2><p>杨辉三角,算是数学题<br>观察一下规律，发现当前一行只比上一行多了一个元素，最最关键的一点：本行元素等于上一行元素往后错一位再逐个相加：</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><a href="https://leetcode.cn/problems/pascals-triangle/solution/qu-qiao-jie-fa-cuo-yi-wei-zai-zhu-ge-xiang-jia-28m/">题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        res = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt; numRows:</span><br><span class="line">            newRow = [a+b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+res[-<span class="number">1</span>], res[-<span class="number">1</span>]+[<span class="number">0</span>])]</span><br><span class="line">            res.append(newRow)      </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/2022/10/02/125/"/>
      <url>/2022/10/02/125/</url>
      
        <content type="html"><![CDATA[<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h1><h2 id="A-phrase-is-a-palindrome-if-after-converting-all-uppercase-letters-into-lowercase-letters-and-removing-all-non-alphanumeric-characters-it-reads-the-same-forward-and-backward-Alphanumeric-characters-include-letters-and-numbers"><a href="#A-phrase-is-a-palindrome-if-after-converting-all-uppercase-letters-into-lowercase-letters-and-removing-all-non-alphanumeric-characters-it-reads-the-same-forward-and-backward-Alphanumeric-characters-include-letters-and-numbers" class="headerlink" title="A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers."></a>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</h2><h2 id="Given-a-string-s-return-true-if-it-is-a-palindrome-or-false-otherwise"><a href="#Given-a-string-s-return-true-if-it-is-a-palindrome-or-false-otherwise" class="headerlink" title="Given a string s, return true if it is a palindrome, or false otherwise."></a>Given a string s, return true if it is a palindrome, or false otherwise.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure><p>这里有个重要的函数isalnum()，用来判断是不是字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        left,right=<span class="number">0</span>,n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                <span class="keyword">if</span> s[left].lower()!=s[right].lower():</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left,right=left+<span class="number">1</span>,right-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> two-pointer </tag>
            
            <tag> Palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111. Minimum Depth of Binary Tree(easy)</title>
      <link href="/2022/10/02/111/"/>
      <url>/2022/10/02/111/</url>
      
        <content type="html"><![CDATA[<h1 id="111-Minimum-Depth-of-Binary-Tree-easy"><a href="#111-Minimum-Depth-of-Binary-Tree-easy" class="headerlink" title="111. Minimum Depth of Binary Tree(easy)"></a>111. Minimum Depth of Binary Tree(easy)</h1><h2 id="Given-a-binary-tree-find-its-minimum-depth"><a href="#Given-a-binary-tree-find-its-minimum-depth" class="headerlink" title="Given a binary tree, find its minimum depth."></a>Given a binary tree, find its minimum depth.</h2><h2 id="The-minimum-depth-is-the-number-of-nodes-along-the-shortest-path-from-the-root-node-down-to-the-nearest-leaf-node"><a href="#The-minimum-depth-is-the-number-of-nodes-along-the-shortest-path-from-the-root-node-down-to-the-nearest-leaf-node" class="headerlink" title="The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node."></a>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</h2><h2 id="Note-A-leaf-is-a-node-with-no-children"><a href="#Note-A-leaf-is-a-node-with-no-children" class="headerlink" title="Note: A leaf is a node with no children."></a>Note: A leaf is a node with no children.</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/li-jie-zhe-dao-ti-de-jie-shu-tiao-jian-by-user7208/">题解</a></p><p>根据大佬的Java代码写的python</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这道题递归条件里分为三种情况</span></span><br><span class="line">        <span class="comment">//1.左孩子和右孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.如果左孩子和右孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span></span><br><span class="line">        <span class="keyword">int</span> m1 = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> m2 = minDepth(root.right);</span><br><span class="line">        <span class="comment">//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) <span class="keyword">return</span> m1 + m2 + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(m1,m2) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#这道题递归条件里分为三种情况</span></span><br><span class="line">        <span class="comment">#1.左孩子和右孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span></span><br><span class="line">        <span class="keyword">if</span> root.left==<span class="literal">None</span> <span class="keyword">and</span> root.right==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#2.如果左孩子和右孩子其中一个为空，那么需要返回比较大的那个孩子的深度 </span></span><br><span class="line">        m1=self.minDepth(root.left)</span><br><span class="line">        m2=self.minDepth(root.right)</span><br><span class="line">        <span class="comment">#这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span></span><br><span class="line">        <span class="keyword">if</span> root.left==<span class="literal">None</span> <span class="keyword">or</span> root.right==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> m1+m2+<span class="number">1</span></span><br><span class="line">        <span class="comment">#3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(m1,m2)+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> tree </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree(easy)</title>
      <link href="/2022/10/02/108/"/>
      <url>/2022/10/02/108/</url>
      
        <content type="html"><![CDATA[<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree-easy"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-easy" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree(easy)"></a>108. Convert Sorted Array to Binary Search Tree(easy)</h1><h2 id="Given-an-integer-array-nums-where-the-elements-are-sorted-in-ascending-order-convert-it-to-a-height-balanced-binary-search-tree"><a href="#Given-an-integer-array-nums-where-the-elements-are-sorted-in-ascending-order-convert-it-to-a-height-balanced-binary-search-tree" class="headerlink" title="Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree."></a>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.</h2><h2 id="A-height-balanced-binary-tree-is-a-binary-tree-in-which-the-depth-of-the-two-subtrees-of-every-node-never-differs-by-more-than-one"><a href="#A-height-balanced-binary-tree-is-a-binary-tree-in-which-the-depth-of-the-two-subtrees-of-every-node-never-differs-by-more-than-one" class="headerlink" title="A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one."></a>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/">中序遍历</a></p><p>中序遍历，总是选择中间位置左边的数字作为根节点<br>选择中间位置左边的数字作为根节点，则根节点的下标为 \textit{mid}=(\textit{left}+\textit{right})/2mid=(left+right)/2，此处的除法为整数除法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = helper(left, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = helper(mid + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> tree </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100. Same Tree(easy)</title>
      <link href="/2022/10/02/100/"/>
      <url>/2022/10/02/100/</url>
      
        <content type="html"><![CDATA[<h1 id="100-Same-Tree-easy"><a href="#100-Same-Tree-easy" class="headerlink" title="100. Same Tree(easy)"></a>100. Same Tree(easy)</h1><h2 id="Given-the-roots-of-two-binary-trees-p-and-q-write-a-function-to-check-if-they-are-the-same-or-not"><a href="#Given-the-roots-of-two-binary-trees-p-and-q-write-a-function-to-check-if-they-are-the-same-or-not" class="headerlink" title="Given the roots of two binary trees p and q, write a function to check if they are the same or not."></a>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</h2><h2 id="Two-binary-trees-are-considered-the-same-if-they-are-structurally-identical-and-the-nodes-have-the-same-value"><a href="#Two-binary-trees-are-considered-the-same-if-they-are-structurally-identical-and-the-nodes-have-the-same-value" class="headerlink" title="Two binary trees are considered the same if they are structurally identical, and the nodes have the same value."></a>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p = [1,2,3], q = [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Recursion递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">or</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val!=q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.right,q.right) <span class="keyword">and</span> self.isSameTree(p.left,q.left)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> tree </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94. Binary Tree Inorder Traversal(easy)</title>
      <link href="/2022/10/02/94/"/>
      <url>/2022/10/02/94/</url>
      
        <content type="html"><![CDATA[<h1 id="94-Binary-Tree-Inorder-Traversal-easy"><a href="#94-Binary-Tree-Inorder-Traversal-easy" class="headerlink" title="94. Binary Tree Inorder Traversal(easy)"></a>94. Binary Tree Inorder Traversal(easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-inorder-traversal-of-its-nodes’-values"><a href="#Given-the-root-of-a-binary-tree-return-the-inorder-traversal-of-its-nodes’-values" class="headerlink" title="Given the root of a binary tree, return the inorder traversal of its nodes’ values."></a>Given the root of a binary tree, return the inorder traversal of its nodes’ values.</h2><p>二叉树的中序遍历</p><p>递归遍历</p><p>前序遍历：打印 - 左 - 右<br>中序遍历：左 - 打印 - 右<br>后序遍历：左 - 右 - 打印<br>题目要求的是中序遍历，那就按照 左-打印-右这种顺序遍历树就可以了，递归函数实现</p><p>终止条件：当前节点为空时<br>函数内：递归的调用左节点，打印当前节点，再递归调用右节点<br>时间复杂度：O(n)<br>空间复杂度：O(h)，h 是树的高度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> tree </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs(easy)</title>
      <link href="/2022/10/02/70/"/>
      <url>/2022/10/02/70/</url>
      
        <content type="html"><![CDATA[<h1 id="70-Climbing-Stairs-easy"><a href="#70-Climbing-Stairs-easy" class="headerlink" title="70. Climbing Stairs(easy)"></a>70. Climbing Stairs(easy)</h1><h2 id="You-are-climbing-a-staircase-It-takes-n-steps-to-reach-the-top"><a href="#You-are-climbing-a-staircase-It-takes-n-steps-to-reach-the-top" class="headerlink" title="You are climbing a staircase. It takes n steps to reach the top."></a>You are climbing a staircase. It takes n steps to reach the top.</h2><h2 id="Each-time-you-can-either-climb-1-or-2-steps-In-how-many-distinct-ways-can-you-climb-to-the-top"><a href="#Each-time-you-can-either-climb-1-or-2-steps-In-how-many-distinct-ways-can-you-climb-to-the-top" class="headerlink" title="Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?"></a>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p>一道经典DP题</p><p>状态转移方程：dp[i]=dp[i−1]+dp[i−2]<br>f(1) = 1  f(2) = 2  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        if n&lt;=2:</span><br><span class="line">            return n</span><br><span class="line">        before_last=1</span><br><span class="line">        last=2</span><br><span class="line">        for i in range(2,n):</span><br><span class="line">            current=before_last+last</span><br><span class="line">            before_last=last</span><br><span class="line">            last = current</span><br><span class="line">        return last</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67. Add Binary(easy)</title>
      <link href="/2022/10/02/67/"/>
      <url>/2022/10/02/67/</url>
      
        <content type="html"><![CDATA[<h1 id="67-Add-Binary-easy"><a href="#67-Add-Binary-easy" class="headerlink" title="67. Add Binary(easy)"></a>67. Add Binary(easy)</h1><h2 id="Given-two-binary-strings-a-and-b-return-their-sum-as-a-binary-string"><a href="#Given-two-binary-strings-a-and-b-return-their-sum-as-a-binary-string" class="headerlink" title="Given two binary strings a and b, return their sum as a binary string."></a>Given two binary strings a and b, return their sum as a binary string.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure><p>实现二进制加法<br><a href="https://leetcode.com/problems/add-binary/solutions/414426/add-binary/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a, b</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        n = <span class="built_in">max</span>(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br><span class="line">        a, b = a.zfill(n), b.zfill(n)</span><br><span class="line">        </span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[i] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                carry += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b[i] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                carry += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> carry % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                answer.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                answer.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            carry //= <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">            answer.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        answer.reverse()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(answer)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One(easy)</title>
      <link href="/2022/10/02/66/"/>
      <url>/2022/10/02/66/</url>
      
        <content type="html"><![CDATA[<h1 id="66-Plus-One-easy"><a href="#66-Plus-One-easy" class="headerlink" title="66. Plus One(easy)"></a>66. Plus One(easy)</h1><h2 id="You-are-given-a-large-integer-represented-as-an-integer-array-digits-where-each-digits-i-is-the-ith-digit-of-the-integer-The-digits-are-ordered-from-most-significant-to-least-significant-in-left-to-right-order-The-large-integer-does-not-contain-any-leading-0’s"><a href="#You-are-given-a-large-integer-represented-as-an-integer-array-digits-where-each-digits-i-is-the-ith-digit-of-the-integer-The-digits-are-ordered-from-most-significant-to-least-significant-in-left-to-right-order-The-large-integer-does-not-contain-any-leading-0’s" class="headerlink" title="You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s."></a>You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s.</h2><h2 id="Increment-the-large-integer-by-one-and-return-the-resulting-array-of-digits"><a href="#Increment-the-large-integer-by-one-and-return-the-resulting-array-of-digits" class="headerlink" title="Increment the large integer by one and return the resulting array of digits."></a>Increment the large integer by one and return the resulting array of digits.</h2><p>这道题可以用数学方法分类去算，但也可以先把digits转换为一整个数字，加1后，再转换回数组</p><pre><code class="python">class Solution:    def plusOne(self, digits: List[int]) -&gt; List[int]:                res=&quot;&quot;.join(str(digit) for digit in digits)        res= int(res)+1        return str(res)</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58. Length of Last Word(easy)</title>
      <link href="/2022/10/02/58/"/>
      <url>/2022/10/02/58/</url>
      
        <content type="html"><![CDATA[<h1 id="58-Length-of-Last-Word-easy"><a href="#58-Length-of-Last-Word-easy" class="headerlink" title="58. Length of Last Word(easy)"></a>58. Length of Last Word(easy)</h1><h2 id="Given-a-string-s-consisting-of-words-and-spaces-return-the-length-of-the-last-word-in-the-string"><a href="#Given-a-string-s-consisting-of-words-and-spaces-return-the-length-of-the-last-word-in-the-string" class="headerlink" title="Given a string s consisting of words and spaces, return the length of the last word in the string."></a>Given a string s consisting of words and spaces, return the length of the last word in the string.</h2><h2 id="A-word-is-a-maximal-substring-consisting-of-non-space-characters-only"><a href="#A-word-is-a-maximal-substring-consisting-of-non-space-characters-only" class="headerlink" title="A word is a maximal substring consisting of non-space characters only."></a>A word is a maximal substring consisting of non-space characters only.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l=s.split()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(l[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35. Search Insert Position(easy)</title>
      <link href="/2022/10/02/35/"/>
      <url>/2022/10/02/35/</url>
      
        <content type="html"><![CDATA[<h2 id="Given-a-sorted-array-of-distinct-integers-and-a-target-value-return-the-index-if-the-target-is-found-If-not-return-the-index-where-it-would-be-if-it-were-inserted-in-order"><a href="#Given-a-sorted-array-of-distinct-integers-and-a-target-value-return-the-index-if-the-target-is-found-If-not-return-the-index-where-it-would-be-if-it-were-inserted-in-order" class="headerlink" title="Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order."></a>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><p>基础做法，遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target&gt;nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target&gt;nums[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;=target:</span><br><span class="line">                res=i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        length=<span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = length</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = <span class="built_in">int</span>(left + (right - left) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right= mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14. Longest Common Prefix(easy)</title>
      <link href="/2022/10/02/14/"/>
      <url>/2022/10/02/14/</url>
      
        <content type="html"><![CDATA[<h1 id="14-Longest-Common-Prefix-easy"><a href="#14-Longest-Common-Prefix-easy" class="headerlink" title="14. Longest Common Prefix(easy)"></a>14. Longest Common Prefix(easy)</h1><h2 id="Write-a-function-to-find-the-longest-common-prefix-string-amongst-an-array-of-strings"><a href="#Write-a-function-to-find-the-longest-common-prefix-string-amongst-an-array-of-strings" class="headerlink" title="Write a function to find the longest common prefix string amongst an array of strings."></a>Write a function to find the longest common prefix string amongst an array of strings.</h2><h2 id="If-there-is-no-common-prefix-return-an-empty-string-“”"><a href="#If-there-is-no-common-prefix-return-an-empty-string-“”" class="headerlink" title="If there is no common prefix, return an empty string “”."></a>If there is no common prefix, return an empty string “”.</h2><p><a href="https://leetcode.cn/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/">官方题解</a></p><p>纵向扫描<br>方法一是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        length, count = <span class="built_in">len</span>(strs[<span class="number">0</span>]), <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(i == <span class="built_in">len</span>(strs[j]) <span class="keyword">or</span> strs[j][i] != c <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, count)):</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> LCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1480. Running Sum of 1d Array(easy)</title>
      <link href="/2022/10/02/1480/"/>
      <url>/2022/10/02/1480/</url>
      
        <content type="html"><![CDATA[<p>Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).</p><p>Return the running sum of nums.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4]</span><br><span class="line">Output: [1,3,6,10]</span><br><span class="line">Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</span><br></pre></td></tr></table></figure><p>其实这题就是前缀和数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def runningSum(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        res=[0]*len(nums)</span><br><span class="line">        res[0]=nums[0]</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            res[i]=nums[i]+res[i-1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>231. Power of Two(easy)</title>
      <link href="/2022/10/01/231/"/>
      <url>/2022/10/01/231/</url>
      
        <content type="html"><![CDATA[<h1 id="231-Power-of-Two-easy"><a href="#231-Power-of-Two-easy" class="headerlink" title="231. Power of Two(easy)"></a>231. Power of Two(easy)</h1><h2 id="Given-an-integer-n-return-true-if-it-is-a-power-of-two-Otherwise-return-false"><a href="#Given-an-integer-n-return-true-if-it-is-a-power-of-two-Otherwise-return-false" class="headerlink" title="Given an integer n, return true if it is a power of two. Otherwise, return false."></a>Given an integer n, return true if it is a power of two. Otherwise, return false.</h2><h2 id="An-integer-n-is-a-power-of-two-if-there-exists-an-integer-x-such-that-n-2-x"><a href="#An-integer-n-is-a-power-of-two-if-there-exists-an-integer-x-such-that-n-2-x" class="headerlink" title="An integer n is a power of two, if there exists an integer x such that n == 2^x."></a>An integer n is a power of two, if there exists an integer x such that n == 2^x.</h2><p>How to get / isolate the rightmost 1-bit : x &amp; (-x).</p><p>How to turn off (= set to 0) the rightmost 1-bit : x &amp; (x - 1).<br><a href="https://leetcode.com/problems/power-of-two/solutions/360718/power-of-two/">官方题解</a></p><p>Approach 1: Bitwise Operators : Get the Rightmost 1-bit</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>260. Single Number III(medium)</title>
      <link href="/2022/10/01/260/"/>
      <url>/2022/10/01/260/</url>
      
        <content type="html"><![CDATA[<h1 id="260-Single-Number-III-medium"><a href="#260-Single-Number-III-medium" class="headerlink" title="260. Single Number III(medium)"></a>260. Single Number III(medium)</h1><h2 id="Given-an-integer-array-nums-in-which-exactly-two-elements-appear-only-once-and-all-the-other-elements-appear-exactly-twice-Find-the-two-elements-that-appear-only-once-You-can-return-the-answer-in-any-order"><a href="#Given-an-integer-array-nums-in-which-exactly-two-elements-appear-only-once-and-all-the-other-elements-appear-exactly-twice-Find-the-two-elements-that-appear-only-once-You-can-return-the-answer-in-any-order" class="headerlink" title="Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order."></a>Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.</h2><h2 id="You-must-write-an-algorithm-that-runs-in-linear-runtime-complexity-and-uses-only-constant-extra-space"><a href="#You-must-write-an-algorithm-that-runs-in-linear-runtime-complexity-and-uses-only-constant-extra-space" class="headerlink" title="You must write an algorithm that runs in linear runtime complexity and uses only constant extra space."></a>You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br><span class="line">Explanation:  [5, 3] is also a valid answer.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/single-number-iii/solutions/366935/single-number-iii/">官方题解</a></p><p>Two bitmasks</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways(medium)</title>
      <link href="/2022/10/01/91/"/>
      <url>/2022/10/01/91/</url>
      
        <content type="html"><![CDATA[<h1 id="91-Decode-Ways-medium"><a href="#91-Decode-Ways-medium" class="headerlink" title="91. Decode Ways(medium)"></a>91. Decode Ways(medium)</h1><h2 id="A-message-containing-letters-from-A-Z-can-be-encoded-into-numbers-using-the-following-mapping"><a href="#A-message-containing-letters-from-A-Z-can-be-encoded-into-numbers-using-the-following-mapping" class="headerlink" title="A message containing letters from A-Z can be encoded into numbers using the following mapping:"></a>A message containing letters from A-Z can be encoded into numbers using the following mapping:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; &quot;1&quot;</span><br><span class="line">&#x27;B&#x27; -&gt; &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; &quot;26&quot;</span><br></pre></td></tr></table></figure><p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into:</p><p>“AAJF” with the grouping (1 1 10 6)<br>“KJF” with the grouping (11 10 6)<br>Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”.</p><p>Given a string s containing only digits, return the number of ways to decode it.</p><p>The test cases are generated so that the answer fits in a 32-bit integer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). </span><br></pre></td></tr></table></figure><h3 id="Leetcode-Solution"><a href="#Leetcode-Solution" class="headerlink" title="Leetcode Solution"></a><a href="https://leetcode.com/problems/decode-ways/solutions/525903/decode-ways/">Leetcode Solution</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">        two_back = <span class="number">1</span></span><br><span class="line">        one_back = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            current = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                current = one_back</span><br><span class="line">            two_digit = <span class="built_in">int</span>(s[i - <span class="number">1</span>: i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> two_digit &gt;= <span class="number">10</span> <span class="keyword">and</span> two_digit &lt;= <span class="number">26</span>:</span><br><span class="line">                current += two_back</span><br><span class="line">            two_back = one_back</span><br><span class="line">            one_back = current</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> one_back</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>137. Single Number II(medium)</title>
      <link href="/2022/10/01/137/"/>
      <url>/2022/10/01/137/</url>
      
        <content type="html"><![CDATA[<h1 id="137-Single-Number-medium"><a href="#137-Single-Number-medium" class="headerlink" title="137. Single Number(medium)"></a>137. Single Number(medium)</h1><h2 id="Given-an-integer-array-nums-where-every-element-appears-three-times-except-for-one-which-appears-exactly-once-Find-the-single-element-and-return-it"><a href="#Given-an-integer-array-nums-where-every-element-appears-three-times-except-for-one-which-appears-exactly-once-Find-the-single-element-and-return-it" class="headerlink" title="Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it."></a>Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.</h2><h2 id="You-must-implement-a-solution-with-a-linear-runtime-complexity-and-use-only-constant-extra-space"><a href="#You-must-implement-a-solution-with-a-linear-runtime-complexity-and-use-only-constant-extra-space" class="headerlink" title="You must implement a solution with a linear runtime complexity and use only constant extra space."></a>You must implement a solution with a linear runtime complexity and use only constant extra space.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/single-number-ii/solutions/356460/single-number-ii/">官方题解</a></p><p>这里用到了异或<br>XOR</p><p>Let’s start from XOR operator which could be used to detect the bit which appears odd number of times: 1, 3, 5, etc.</p><p>XOR of zero and a bit results in that bit</p><p>0⊕x=x</p><p>XOR of two equal bits (even if they are zeros) results in a zero</p><p>x⊕x=0</p><p>and so on and so forth, i.e. one could see the bit in a bitmask only if it appears odd number of times.<br>That’s already great, so one could detect the bit which appears once, and the bit which appears three times. The problem is to distinguish between these two situations.</p><p>AND and NOT</p><p>To separate number that appears once from a number that appears three times let’s use two bitmasks instead of one: seen_once and seen_twice.</p><p>The idea is to</p><p>change seen_once only if seen_twice is unchanged</p><p>change seen_twice only if seen_once is unchanged</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        seen_once = seen_twice = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># first appearance: </span></span><br><span class="line">            <span class="comment"># add num to seen_once </span></span><br><span class="line">            <span class="comment"># don&#x27;t add to seen_twice because of presence in seen_once</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># second appearance: </span></span><br><span class="line">            <span class="comment"># remove num from seen_once </span></span><br><span class="line">            <span class="comment"># add num to seen_twice</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># third appearance: </span></span><br><span class="line">            <span class="comment"># don&#x27;t add to seen_once because of presence in seen_twice</span></span><br><span class="line">            <span class="comment"># remove num from seen_twice</span></span><br><span class="line">            seen_once = ~seen_twice &amp; (seen_once ^ num)</span><br><span class="line">            seen_twice = ~seen_once &amp; (seen_twice ^ num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen_once</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number(easy)</title>
      <link href="/2022/09/30/136/"/>
      <url>/2022/09/30/136/</url>
      
        <content type="html"><![CDATA[<h1 id="136-Single-Number-easy"><a href="#136-Single-Number-easy" class="headerlink" title="136. Single Number(easy)"></a>136. Single Number(easy)</h1><h2 id="Given-a-non-empty-array-of-integers-nums-every-element-appears-twice-except-for-one-Find-that-single-one"><a href="#Given-a-non-empty-array-of-integers-nums-every-element-appears-twice-except-for-one-Find-that-single-one" class="headerlink" title="Given a non-empty array of integers nums, every element appears twice except for one. Find that single one."></a>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.</h2><h2 id="You-must-implement-a-solution-with-a-linear-runtime-complexity-and-use-only-constant-extra-space"><a href="#You-must-implement-a-solution-with-a-linear-runtime-complexity-and-use-only-constant-extra-space" class="headerlink" title="You must implement a solution with a linear runtime complexity and use only constant extra space."></a>You must implement a solution with a linear runtime complexity and use only constant extra space.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>这道题的关键在于异或运算，异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0</p><p>假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。<br>a1⊕a1⊕a2⊕a2⊕a3⊕a3⊕a4⊕a4⊕a5⊕a5⋯⋯⋯⊕am⊕am⊕am+1<br>=0⊕0⊕0⊕0⊕0⊕0⊕0⊕0⊕am+1=am+1<br>​</p><p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="python-reduce"><a href="#python-reduce" class="headerlink" title="python reduce"></a><a href="https://thepythonguru.com/python-builtin-functions/reduce/">python reduce</a></h3><p>The reduce() function accepts a function and a sequence and returns a single value calculated as follows:</p><p>Initially, the function is called with the first two items from the sequence and the result is returned.<br>The function is then called again with the result obtained in step 1 and the next value in the sequence. This process keeps repeating until there are items in the sequence.<br>The syntax of the reduce() function is as follows:</p><p>Syntax: reduce(function, sequence[, initial]) -&gt; value</p><p>When the initial value is provided, the function is called with the initial value and the first item from the sequence.</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits(easy)</title>
      <link href="/2022/09/30/191/"/>
      <url>/2022/09/30/191/</url>
      
        <content type="html"><![CDATA[<h1 id="191-Number-of-1-Bits-easy"><a href="#191-Number-of-1-Bits-easy" class="headerlink" title="191. Number of 1 Bits(easy)"></a>191. Number of 1 Bits(easy)</h1><h2 id="Write-a-function-that-takes-an-unsigned-integer-and-returns-the-number-of-‘1’-bits-it-has-also-known-as-the-Hamming-weight"><a href="#Write-a-function-that-takes-an-unsigned-integer-and-returns-the-number-of-‘1’-bits-it-has-also-known-as-the-Hamming-weight" class="headerlink" title="Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight)."></a>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).</h2><h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><h2 id="Note-that-in-some-languages-such-as-Java-there-is-no-unsigned-integer-type-In-this-case-the-input-will-be-given-as-a-signed-integer-type-It-should-not-affect-your-implementation-as-the-integer’s-internal-binary-representation-is-the-same-whether-it-is-signed-or-unsigned"><a href="#Note-that-in-some-languages-such-as-Java-there-is-no-unsigned-integer-type-In-this-case-the-input-will-be-given-as-a-signed-integer-type-It-should-not-affect-your-implementation-as-the-integer’s-internal-binary-representation-is-the-same-whether-it-is-signed-or-unsigned" class="headerlink" title="Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned."></a>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</h2><h2 id="In-Java-the-compiler-represents-the-signed-integers-using-2’s-complement-notation-Therefore-in-Example-3-the-input-represents-the-signed-integer-3"><a href="#In-Java-the-compiler-represents-the-signed-integers-using-2’s-complement-notation-Therefore-in-Example-3-the-input-represents-the-signed-integer-3" class="headerlink" title="In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3."></a>In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill9-bitwise</title>
      <link href="/2022/09/30/LeetCode-skill9-bitwise/"/>
      <url>/2022/09/30/LeetCode-skill9-bitwise/</url>
      
        <content type="html"><![CDATA[<p>位运算   Bit Manipulation</p><p>n &amp; 1   使用 n &amp; 1 得到二进制末尾是否为 1；<br>n &gt;&gt;= 1 把 n 右移 1 位，直至结束。</p><h1 id="bit操作"><a href="#bit操作" class="headerlink" title="bit操作"></a>bit操作</h1><p>&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算   与运算：同1为1，否则为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 0 = 0</span><br><span class="line">0 &amp; 1 = 0</span><br><span class="line">1 &amp; 0 = 0</span><br><span class="line">1 &amp; 1 = 1</span><br></pre></td></tr></table></figure><p>| 符号，x | y ，会将两个十进制数在二进制下进行或运算   或运算：同0为0，否则为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 | 0 = 0</span><br><span class="line">1 | 0 = 1</span><br><span class="line">0 | 1 = 1</span><br><span class="line">1 | 1 = 1</span><br></pre></td></tr></table></figure><p>^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算   异或：相同为0，不同为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ^ 0 = 0</span><br><span class="line">0 ^ 1 = 1</span><br><span class="line">1 ^ 0 = 1</span><br><span class="line">1 ^ 1 = 0</span><br></pre></td></tr></table></figure><p>&lt;&lt; 符号，x &lt;&lt; y 左移操作，最右边用 0 填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0011 =&gt; 0110</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>符号，x &gt;&gt; y 右移操作，最左边用 0 填充<br>~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~0 = 1</span><br></pre></td></tr></table></figure><p>x ^ 0 = x    任何数与0异或，结果都是它本身<br>x ^ x = 0    任何数与它本身异或，结果都是0<br>x ^ 1s = <del>x (1s为全1)    一个数和全1异或，相当于取反<br>x ^ (</del>x) = 1s    一个数和它取反后的结果异或，结果为全1<br>c = a ^ b =&gt; a ^ c = b, b ^ c = a    交换两个数<br>a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c    加法（异或）结合律</p><p>x &amp; (<del>0&lt;&lt;n)    将x最右边的n位清零<br>(x&gt;&gt;n) &amp; 1    获取x的第n位值（0或者1）<br>x &amp; (1&lt;&lt;n)    获取x的第n位的幂值<br>x 丨 (1&lt;&lt;n)    仅将第n位置为1<br>x &amp; ((1&lt;&lt;n) - 1)    将x最高位至第n位（包含）清零<br>x &amp; (</del>(1 &lt;&lt; n))    仅将第n位置为0</p><h1 id="整数集合set位运算"><a href="#整数集合set位运算" class="headerlink" title="整数集合set位运算"></a>整数集合set位运算</h1><h1 id="整数集合做标志时，比如回溯时的visited标志数组"><a href="#整数集合做标志时，比如回溯时的visited标志数组" class="headerlink" title="整数集合做标志时，比如回溯时的visited标志数组"></a>整数集合做标志时，比如回溯时的visited标志数组</h1><p>vstd 访问 i ：vstd | (1 &lt;&lt; i)<br>vstd 离开 i ：vstd &amp; ~(1 &lt;&lt; i)<br>vstd 不包含 i : not vstd &amp; (1 &lt;&lt; i)</p><p>并集 ：A | B<br>交集 ：A &amp; B<br>全集 ：(1 &lt;&lt; n) - 1<br>补集 ：((1 &lt;&lt; n) - 1) ^ A<br>子集 ：(A &amp; B) == B<br>判断是否是 2 的幂 ：A &amp; (A - 1) == 0<br>最低位的 1 变为 0 ：n &amp;= (n - 1)<br>最低位的 1：A &amp; (-A)，最低位的 1 一般记为 lowbit(A)</p><ol start="190"><li><p>Reverse Bits(easy)</p></li><li><p>Number of 1 Bits</p></li></ol><p>计算数字的二进制中有多少个1。</p><ol start="136"><li><p>Single Number<br>找出数组中不重复的元素。其它元素出现两次。原题</p></li><li><p>Single Number II<br>找出数组中出现一次的元素，其它元素出现三次。原题</p></li></ol><ol start="67"><li>Add Binary(easy)<br>二进制加法</li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> bitwise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>218. The Skyline Problem(hard)</title>
      <link href="/2022/09/29/218/"/>
      <url>/2022/09/29/218/</url>
      
        <content type="html"><![CDATA[<h1 id="218-The-Skyline-Problem-hard"><a href="#218-The-Skyline-Problem-hard" class="headerlink" title="218. The Skyline Problem(hard)"></a>218. The Skyline Problem(hard)</h1><h2 id="A-city’s-skyline-is-the-outer-contour-of-the-silhouette-formed-by-all-the-buildings-in-that-city-when-viewed-from-a-distance-Given-the-locations-and-heights-of-all-the-buildings-return-the-skyline-formed-by-these-buildings-collectively"><a href="#A-city’s-skyline-is-the-outer-contour-of-the-silhouette-formed-by-all-the-buildings-in-that-city-when-viewed-from-a-distance-Given-the-locations-and-heights-of-all-the-buildings-return-the-skyline-formed-by-these-buildings-collectively" class="headerlink" title="A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively."></a>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.</h2><h2 id="The-geometric-information-of-each-building-is-given-in-the-array-buildings-where-buildings-i-lefti-righti-heighti"><a href="#The-geometric-information-of-each-building-is-given-in-the-array-buildings-where-buildings-i-lefti-righti-heighti" class="headerlink" title="The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:"></a>The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:</h2><p>lefti is the x coordinate of the left edge of the ith building.<br>righti is the x coordinate of the right edge of the ith building.<br>heighti is the height of the ith building.</p><h2 id="You-may-assume-all-buildings-are-perfect-rectangles-grounded-on-an-absolutely-flat-surface-at-height-0"><a href="#You-may-assume-all-buildings-are-perfect-rectangles-grounded-on-an-absolutely-flat-surface-at-height-0" class="headerlink" title="You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0."></a>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</h2><h2 id="The-skyline-should-be-represented-as-a-list-of-“key-points”-sorted-by-their-x-coordinate-in-the-form-x1-y1-x2-y2-…-Each-key-point-is-the-left-endpoint-of-some-horizontal-segment-in-the-skyline-except-the-last-point-in-the-list-which-always-has-a-y-coordinate-0-and-is-used-to-mark-the-skyline’s-termination-where-the-rightmost-building-ends-Any-ground-between-the-leftmost-and-rightmost-buildings-should-be-part-of-the-skyline’s-contour"><a href="#The-skyline-should-be-represented-as-a-list-of-“key-points”-sorted-by-their-x-coordinate-in-the-form-x1-y1-x2-y2-…-Each-key-point-is-the-left-endpoint-of-some-horizontal-segment-in-the-skyline-except-the-last-point-in-the-list-which-always-has-a-y-coordinate-0-and-is-used-to-mark-the-skyline’s-termination-where-the-rightmost-building-ends-Any-ground-between-the-leftmost-and-rightmost-buildings-should-be-part-of-the-skyline’s-contour" class="headerlink" title="The skyline should be represented as a list of “key points” sorted by their x-coordinate in the form [[x1,y1],[x2,y2],…]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour."></a>The skyline should be represented as a list of “key points” sorted by their x-coordinate in the form [[x1,y1],[x2,y2],…]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.</h2><h2 id="Note-There-must-be-no-consecutive-horizontal-lines-of-equal-height-in-the-output-skyline-For-instance-…-2-3-4-5-7-5-11-5-12-7-…-is-not-acceptable-the-three-lines-of-height-5-should-be-merged-into-one-in-the-final-output-as-such-…-2-3-4-5-12-7-…"><a href="#Note-There-must-be-no-consecutive-horizontal-lines-of-equal-height-in-the-output-skyline-For-instance-…-2-3-4-5-7-5-11-5-12-7-…-is-not-acceptable-the-three-lines-of-height-5-should-be-merged-into-one-in-the-final-output-as-such-…-2-3-4-5-12-7-…" class="headerlink" title="Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […,[2 3],[4 5],[7 5],[11 5],[12 7],…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […,[2 3],[4 5],[12 7],…]"></a>Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […,[2 3],[4 5],[7 5],[11 5],[12 7],…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […,[2 3],[4 5],[12 7],…]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">Explanation:</span><br><span class="line">Figure A shows the buildings of the input.</span><br><span class="line">Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSkyline</span>(<span class="params">self, buildings: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="comment"># Iterate over the left and right edges of all the buildings, </span></span><br><span class="line">        <span class="comment"># If its a left edge, add (left, height) to &#x27;edges&#x27;.</span></span><br><span class="line">        <span class="comment"># Otherwise, add (right, -height) to &#x27;edges&#x27;.</span></span><br><span class="line">        edges = []</span><br><span class="line">        <span class="keyword">for</span> left, right, height <span class="keyword">in</span> buildings:</span><br><span class="line">            edges.append([left, height])</span><br><span class="line">            edges.append([right, -height])</span><br><span class="line">        edges.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Initailize two empty priority queues &#x27;live&#x27; and &#x27;past&#x27; </span></span><br><span class="line">        <span class="comment"># for the live buildings and the past buildings.</span></span><br><span class="line">        live, past = [], []</span><br><span class="line">        answer = []</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Iterate over all the sorted edges.</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(edges):</span><br><span class="line">            <span class="comment"># Since we might have multiple edges at same x,</span></span><br><span class="line">            <span class="comment"># Let the &#x27;curr_x&#x27; be the current position.</span></span><br><span class="line">            curr_x = edges[idx][<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># While we are handling the edges at &#x27;curr_x&#x27;:</span></span><br><span class="line">            <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(edges) <span class="keyword">and</span> edges[idx][<span class="number">0</span>] == curr_x:</span><br><span class="line">                height = edges[idx][<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># If &#x27;height&#x27; &gt; 0, meaning a building of height &#x27;height&#x27;</span></span><br><span class="line">                <span class="comment"># is live, push &#x27;height&#x27; to &#x27;live&#x27;. </span></span><br><span class="line">                <span class="comment"># Otherwise, a building of height &#x27;height&#x27; is passed, </span></span><br><span class="line">                <span class="comment"># push the height to &#x27;past&#x27;.</span></span><br><span class="line">                <span class="keyword">if</span> height &gt; <span class="number">0</span>:</span><br><span class="line">                    heapq.heappush(live, -height)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heapq.heappush(past, height)</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># While the top height from &#x27;live&#x27; equals to that from &#x27;past&#x27;,</span></span><br><span class="line">            <span class="comment"># Remove top height from both &#x27;live&#x27; and &#x27;past&#x27;.</span></span><br><span class="line">            <span class="keyword">while</span> past <span class="keyword">and</span> past[<span class="number">0</span>] == live[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(live)</span><br><span class="line">                heapq.heappop(past)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Get the maximum height from &#x27;live&#x27;.</span></span><br><span class="line">            max_height = -live[<span class="number">0</span>] <span class="keyword">if</span> live <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># If the height changes at &#x27;curr_x&#x27;, we add this</span></span><br><span class="line">            <span class="comment"># skyline key point [curr_x, max_height] to &#x27;answer&#x27;.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> answer <span class="keyword">or</span> answer[-<span class="number">1</span>][<span class="number">1</span>] != max_height:</span><br><span class="line">                answer.append([curr_x, max_height])</span><br><span class="line">                </span><br><span class="line">        <span class="comment"># Return &#x27;answer&#x27; as the skyline.</span></span><br><span class="line">        <span class="keyword">return</span> answer            </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> Priority Queue </tag>
            
            <tag> Sweep Line  </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. Rotate Array(medium)</title>
      <link href="/2022/09/29/189/"/>
      <url>/2022/09/29/189/</url>
      
        <content type="html"><![CDATA[<h1 id="189-Rotate-Array-medium"><a href="#189-Rotate-Array-medium" class="headerlink" title="189. Rotate Array(medium)"></a>189. Rotate Array(medium)</h1><h2 id="Given-an-array-rotate-the-array-to-the-right-by-k-steps-where-k-is-non-negative"><a href="#Given-an-array-rotate-the-array-to-the-right-by-k-steps-where-k-is-non-negative" class="headerlink" title="Given an array, rotate the array to the right by k steps, where k is non-negative."></a>Given an array, rotate the array to the right by k steps, where k is non-negative.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p>这道题其实不像是rotate，意思是把最后一个数不断的移到第一位，就跟开火车似的。<br>把这个数组分成两部分，Part1[P1] 和 Part2[P2]<br>举个例子：<br>[P1] 是最后三位数字之前的数字，[1,2,3,4]<br>[P2] 是我们要翻转的数字 [5,6,7]<br>然后分别把P1 和P2前后调转<br>P1=[4321]<br>P2=[765]<br>这样整个数组就是[4321765]<br>将最后三位与前三位互换位置就是[5,6,7,1,2,3,4]<br>[P1] is defined as the array part just before the last 3 values. What I mean is something like [1,2,3,4]<br>[P2] is defined as the array part just after remaining values which we have to rotate [5,6,7]</p><p>但是这里根据K有不同的情况，比如说k = 101, 就是说K大于整个数组长度了，但我们不需要翻转数组101次，利用K对数组长度求余就行，因为转过7次以后就是 [1,2,3,4,5,6,7]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span> (<span class="params">self, nums, i, j</span>) :</span> </span><br><span class="line">        li = i</span><br><span class="line">        ri = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> li &lt; ri:</span><br><span class="line">            temp = nums[li]</span><br><span class="line">            nums[li] = nums[ri]</span><br><span class="line">            nums[ri] = temp</span><br><span class="line">            </span><br><span class="line">            li += <span class="number">1</span></span><br><span class="line">            ri -= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        k = k % <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span> : </span><br><span class="line">            k += <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - k - <span class="number">1</span>);</span><br><span class="line">        self.reverse(nums, <span class="built_in">len</span>(nums) - k, <span class="built_in">len</span>(nums) - <span class="number">1</span>);</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>622. Design Circular Queue(medium)</title>
      <link href="/2022/09/25/622/"/>
      <url>/2022/09/25/622/</url>
      
        <content type="html"><![CDATA[<h1 id="622-Design-Circular-Queue-medium"><a href="#622-Design-Circular-Queue-medium" class="headerlink" title="622. Design Circular Queue(medium)"></a>622. Design Circular Queue(medium)</h1><h2 id="Design-your-implementation-of-the-circular-queue-The-circular-queue-is-a-linear-data-structure-in-which-the-operations-are-performed-based-on-FIFO-First-In-First-Out-principle-and-the-last-position-is-connected-back-to-the-first-position-to-make-a-circle-It-is-also-called-“Ring-Buffer”"><a href="#Design-your-implementation-of-the-circular-queue-The-circular-queue-is-a-linear-data-structure-in-which-the-operations-are-performed-based-on-FIFO-First-In-First-Out-principle-and-the-last-position-is-connected-back-to-the-first-position-to-make-a-circle-It-is-also-called-“Ring-Buffer”" class="headerlink" title="Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called “Ring Buffer”."></a>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called “Ring Buffer”.</h2><h2 id="One-of-the-benefits-of-the-circular-queue-is-that-we-can-make-use-of-the-spaces-in-front-of-the-queue-In-a-normal-queue-once-the-queue-becomes-full-we-cannot-insert-the-next-element-even-if-there-is-a-space-in-front-of-the-queue-But-using-the-circular-queue-we-can-use-the-space-to-store-new-values"><a href="#One-of-the-benefits-of-the-circular-queue-is-that-we-can-make-use-of-the-spaces-in-front-of-the-queue-In-a-normal-queue-once-the-queue-becomes-full-we-cannot-insert-the-next-element-even-if-there-is-a-space-in-front-of-the-queue-But-using-the-circular-queue-we-can-use-the-space-to-store-new-values" class="headerlink" title="One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values."></a>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</h2><h2 id="Implementation-the-MyCircularQueue-class"><a href="#Implementation-the-MyCircularQueue-class" class="headerlink" title="Implementation the MyCircularQueue class:"></a>Implementation the MyCircularQueue class:</h2><p>MyCircularQueue(k) Initializes the object with the size of the queue to be k.<br>int Front() Gets the front item from the queue. If the queue is empty, return -1.<br>int Rear() Gets the last item from the queue. If the queue is empty, return -1.<br>boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.<br>boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.<br>boolean isEmpty() Checks whether the circular queue is empty or not.<br>boolean isFull() Checks whether the circular queue is full or not.</p><h2 id="You-must-solve-the-problem-without-using-the-built-in-queue-data-structure-in-your-programming-language"><a href="#You-must-solve-the-problem-without-using-the-built-in-queue-data-structure-in-your-programming-language" class="headerlink" title="You must solve the problem without using the built-in queue data structure in your programming language."></a>You must solve the problem without using the built-in queue data structure in your programming language.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;]</span><br><span class="line">[[3], [1], [2], [3], [4], [], [], [], [4], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, true, true, false, 3, true, true, true, 4]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MyCircularQueue myCircularQueue = new MyCircularQueue(3);</span><br><span class="line">myCircularQueue.enQueue(1); // return True</span><br><span class="line">myCircularQueue.enQueue(2); // return True</span><br><span class="line">myCircularQueue.enQueue(3); // return True</span><br><span class="line">myCircularQueue.enQueue(4); // return False</span><br><span class="line">myCircularQueue.Rear();     // return 3</span><br><span class="line">myCircularQueue.isFull();   // return True</span><br><span class="line">myCircularQueue.deQueue();  // return True</span><br><span class="line">myCircularQueue.enQueue(4); // return True</span><br><span class="line">myCircularQueue.Rear();     // return 4</span><br></pre></td></tr></table></figure><p>循环队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。</p><p>在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是front=（rear+1)%MaxSize。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/design-circular-queue/solution/she-ji-xun-huan-dui-lie-by-leetcode-solu-1w0a/">Solution</a></h3><p>对于一个固定大小的数组，只要知道队尾 rear 与队首 front，即可计算出队列当前的长度：<br>front=（rear+1)%capacity</p><p>循环队列的属性如下:<br>elements：一个固定大小的数组，用于保存循环队列的元素。<br>capacity：循环队列的容量，即队列中最多可以容纳的元素数量。<br>front：队列首元素对应的数组的索引。<br>rear：队列尾元素对应的索引的下一个索引。<br>循环队列的接口方法如下：</p><p>MyCircularQueue(int k): 初始化队列，同时base 数组的空间初始化大小为 k + 1。front,rear 全部初始化为 0。<br>enQueue(int value)：在队列的尾部插入一个元素，并同时将队尾的索引 rear 更新为 (rear+1)%capacity。<br>deQueue()：从队首取出一个元素，并同时将队首的索引 front 更新为 (front+1)% capacity。<br>Front()：返回队首的元素，需要检测队列是否为空。<br>Rear()：返回队尾的元素，需要检测队列是否为空。<br>isEmpty()：检测队列是否为空，根据之前的定义只需判断 rear 是否等于 front。<br>isFull()：检测队列是否已满，根据之前的定义只需判断 front 是否等于 (rear+1)% capacity。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, k: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.front=self.rear=<span class="number">0</span></span><br><span class="line">        self.elements=[<span class="number">0</span>]*(k+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.elements[self.rear]=value</span><br><span class="line">        self.rear=(self.rear+<span class="number">1</span>)%<span class="built_in">len</span>(self.elements)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.front=(self.front+<span class="number">1</span>)%<span class="built_in">len</span>(self.elements)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> self.isEmpty() <span class="keyword">else</span> self.elements[self.front]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> self.isEmpty() <span class="keyword">else</span> self.elements[(self.rear - <span class="number">1</span>) % <span class="built_in">len</span>(self.elements)]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.rear==self.front</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear+<span class="number">1</span>)%<span class="built_in">len</span>(self.elements)==self.front</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyCircularQueue(k)</span></span><br><span class="line"><span class="comment"># param_1 = obj.enQueue(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deQueue()</span></span><br><span class="line"><span class="comment"># param_3 = obj.Front()</span></span><br><span class="line"><span class="comment"># param_4 = obj.Rear()</span></span><br><span class="line"><span class="comment"># param_5 = obj.isEmpty()</span></span><br><span class="line"><span class="comment"># param_6 = obj.isFull()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> string </tag>
            
            <tag> Circular Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1002. Find Common Characters(easy)</title>
      <link href="/2022/09/25/1002/"/>
      <url>/2022/09/25/1002/</url>
      
        <content type="html"><![CDATA[<h1 id="1002-Find-Common-Characters-easy"><a href="#1002-Find-Common-Characters-easy" class="headerlink" title="1002. Find Common Characters(easy)"></a>1002. Find Common Characters(easy)</h1><h2 id="Given-a-string-array-words-return-an-array-of-all-characters-that-show-up-in-all-strings-within-the-words-including-duplicates-You-may-return-the-answer-in-any-order"><a href="#Given-a-string-array-words-return-an-array-of-all-characters-that-show-up-in-all-strings-within-the-words-including-duplicates-You-may-return-the-answer-in-any-order" class="headerlink" title="Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order."></a>Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure><p>这个就是利用hashmap判断数量和是否存在，然后用&amp;=判断相同值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commonChars</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        res = collections.Counter(words[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            res &amp;=collections.Counter(word)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res.elements())    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1081. Smallest Subsequence of Distinct Characters(medium)</title>
      <link href="/2022/09/24/1081/"/>
      <url>/2022/09/24/1081/</url>
      
        <content type="html"><![CDATA[<h1 id="1081-Smallest-Subsequence-of-Distinct-Characters-medium"><a href="#1081-Smallest-Subsequence-of-Distinct-Characters-medium" class="headerlink" title="1081. Smallest Subsequence of Distinct Characters(medium)"></a>1081. Smallest Subsequence of Distinct Characters(medium)</h1><h2 id="Given-a-string-s-return-the-lexicographically-smallest-subsequence-of-s-that-contains-all-the-distinct-characters-of-s-exactly-once"><a href="#Given-a-string-s-return-the-lexicographically-smallest-subsequence-of-s-that-contains-all-the-distinct-characters-of-s-exactly-once" class="headerlink" title="Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once."></a>Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.</h2><p>相似题型<br>316. 去除重复字母(困难)<br>321. 拼接最大数(困难)<br>402. 移掉 K 位数字(中等)<br>1081. 不同字符的最小子序列（中等）</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/">Solution</a></h2><p>这题和316一模一样，代码不需要更改</p><pre><code>class Solution:    def smallestSubsequence(self, s: str) -&gt; str:        stack=[]        remain_counter=collections.Counter(s)        for c in s:            if c not in stack:                while stack and c&lt;stack[-1] and remain_counter[stack[-1]]&gt;0:                    stack.pop()                stack.append(c)            remain_counter[c]-=1        return &#39;&#39;.join(stack)</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>321. Create Maximum Number(hard)</title>
      <link href="/2022/09/24/321/"/>
      <url>/2022/09/24/321/</url>
      
        <content type="html"><![CDATA[<h1 id="321-Create-Maximum-Number-hard"><a href="#321-Create-Maximum-Number-hard" class="headerlink" title="321. Create Maximum Number(hard)"></a>321. Create Maximum Number(hard)</h1><h2 id="You-are-given-two-integer-arrays-nums1-and-nums2-of-lengths-m-and-n-respectively-nums1-and-nums2-represent-the-digits-of-two-numbers-You-are-also-given-an-integer-k"><a href="#You-are-given-two-integer-arrays-nums1-and-nums2-of-lengths-m-and-n-respectively-nums1-and-nums2-represent-the-digits-of-two-numbers-You-are-also-given-an-integer-k" class="headerlink" title="You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k."></a>You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.</h2><h2 id="Create-the-maximum-number-of-length-k-lt-m-n-from-digits-of-the-two-numbers-The-relative-order-of-the-digits-from-the-same-array-must-be-preserved"><a href="#Create-the-maximum-number-of-length-k-lt-m-n-from-digits-of-the-two-numbers-The-relative-order-of-the-digits-from-the-same-array-must-be-preserved" class="headerlink" title="Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved."></a>Create the maximum number of length k &lt;= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.</h2><h2 id="Return-an-array-of-the-k-digits-representing-the-answer"><a href="#Return-an-array-of-the-k-digits-representing-the-answer" class="headerlink" title="Return an array of the k digits representing the answer."></a>Return an array of the k digits representing the answer.</h2><p>相似题型<br>316. 去除重复字母(困难)<br>321. 拼接最大数(困难)<br>402. 移掉 K 位数字(中等)<br>1081. 不同字符的最小子序列（中等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5</span><br><span class="line">Output: [9,8,6,5,3]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/">Solution</a></h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li>分治</li><li>数学<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>和316. 去除重复字母 类似，只不不过这一次是两个数组，而不是一个，并且是求最大数。</li></ol><p>最大最小是无关紧要的，关键在于是两个数组，并且要求从两个数组选取的元素个数加起来一共是 k。</p><p>然而在一个数组中取 k 个数字，并保持其最小（或者最大），我们已经会了。但是如果问题扩展到两个，会有什么变化呢？</p><p>实际上，问题本质并没有发生变化。 假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 = k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。</p><p>假如 k1 和 k2 个数字，已经取出来了。那么剩下要做的就是将这个长度分别为 k1 和 k2 的数字，合并成一个长度为 k 的数组合并成一个最大的数组。</p><p>以题目的 nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 为例。 假如我们从 num1 中取出 1 个数字，那么就要从 nums2 中取出 4 个数字。</p><p>运用第一题的方法，我们计算出应该取 nums1 的 [6]，并取 nums2 的 [9,5,8,3]。 如何将 [6] 和 [9,5,8,3]，使得数字尽可能大，并且保持相对位置不变呢？</p><p>实际上这个过程有点类似归并排序中的治，而上面我们分别计算 num1 和 num2 的最大数的过程类似归并排序中的分。</p><p>我们将从 num1 中挑选的 k1 个数组成的数组称之为 A，将从 num2 中挑选的 k2 个数组成的数组称之为 B，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">        bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">        ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">        bigger.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这里需要说明一下。 在很多编程语言中：如果 A 和 B 是两个数组，当前仅当 A 的首个元素字典序大于 B 的首个元素，A &gt; B 返回 true，否则返回 false。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = [1,2]</span><br><span class="line">B = [2]</span><br><span class="line">A &lt; B # True</span><br><span class="line"></span><br><span class="line">A = [1,2]</span><br><span class="line">B = [1,2,3]</span><br><span class="line">A &lt; B # False</span><br></pre></td></tr></table></figure><h3 id="具体算法："><a href="#具体算法：" class="headerlink" title="具体算法："></a>具体算法：</h3><p>从 nums1 中 取 min(i, len(nums1)) 个数形成新的数组 A（取的逻辑同第一题），其中 i 等于 0,1,2, … k。<br>从 nums2 中 对应取 min(j, len(nums2)) 个数形成新的数组 B（取的逻辑同第一题），其中 j 等于 k - i。<br>将 A 和 B 按照上面的 merge 方法合并<br>上面我们暴力了 k 种组合情况，我们只需要将 k 种情况取出最大值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumber</span>(<span class="params">self, nums1, nums2, k</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pick_max</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">            stack = []</span><br><span class="line">            drop = <span class="built_in">len</span>(nums) - k</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &lt; num:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    drop -= <span class="number">1</span></span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">return</span> stack[:k]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">A, B</span>):</span></span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">                bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">                ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">                bigger.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(merge(pick_max(nums1, i), pick_max(nums2, k-i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>) <span class="keyword">if</span> i &lt;= <span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i &lt;= <span class="built_in">len</span>(nums2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：pick_max 的时间复杂度为 O(M + N)O(M+N) ，其中 MM 为 nums1 的长度，NN 为 nums2 的长度。 merge 的时间复杂度为 O(k)O(k)，再加上外层遍历所有的 k 中可能性。因此总的时间复杂度为 O(k^2 * (M + N))O(k^2 ∗(M+N))。<br>空间复杂度：我们使用了额外的 stack 和 ans 数组，因此空间复杂度为 O(max(M, N, k))，其中 MM 为 nums1 的长度，NN 为 nums2 的长度。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>316. Remove Duplicate Letters</title>
      <link href="/2022/09/24/316/"/>
      <url>/2022/09/24/316/</url>
      
        <content type="html"><![CDATA[<h1 id="316-Remove-Duplicate-Letters-medium"><a href="#316-Remove-Duplicate-Letters-medium" class="headerlink" title="316. Remove Duplicate Letters(medium)"></a>316. Remove Duplicate Letters(medium)</h1><h2 id="Given-a-string-s-remove-duplicate-letters-so-that-every-letter-appears-once-and-only-once-You-must-make-sure-your-result-is-the-smallest-in-lexicographical-order-among-all-possible-results"><a href="#Given-a-string-s-remove-duplicate-letters-so-that-every-letter-appears-once-and-only-once-You-must-make-sure-your-result-is-the-smallest-in-lexicographical-order-among-all-possible-results" class="headerlink" title="Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results."></a>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;bcabc&quot;</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>相似题型<br>316. 去除重复字母(困难)<br>321. 拼接最大数(困难)<br>402. 移掉 K 位数字(中等)<br>1081. 不同字符的最小子序列（中等）</p><p>这道题和402. 移掉 K 位数字(中等)差不多，也是利用栈的特性减少时间复杂度</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/">Solution</a></h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>哈希表在python中可以用collections.Counter计数来体现。<br>该方法用于统计某序列中每个元素出现的次数，以键值对的方式存在字典中。但类型其实是Counter。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">counts = collections.Counter(nums)</span><br><span class="line"><span class="built_in">print</span>(counts)</span><br><span class="line"><span class="comment">## Counter(&#123;1: 3, 2: 2, 3: 1&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>凭借这个结构，可以计算出某个序列中出现次数最多的某个元素。也即在得到了counts之后求max即可。但这个max需要给依据索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(counts)) <span class="comment"># 3，这里只是求得最大的键值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(counts.keys(), key=counts.get)) <span class="comment"># 1，这里是按照key方法求最大</span></span><br></pre></td></tr></table></figure><p>这里max是两个参数，前一个代表要max的是什么，也就是要返回最大键，后面的key代表要返回的最大的依据是什么，默认是本身，但这里给了key方法，count.get也就是求值，所以该方法就是说返回一个最大键，但这个最大的依据是值。如果某个键值对的值是最大的，那就返回其键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = <span class="built_in">dict</span>(counts)</span><br><span class="line"><span class="built_in">print</span>(dic.get(<span class="number">1</span>)) <span class="comment"># 4 get在字典中就是传一个键，根据键求对应的值。</span></span><br></pre></td></tr></table></figure><p>前面是一种理解，但max的两个参数也可以理解为key后面的方法是要将前面的第一个参数作为参数，也就是counts.keys()要作为counts.get的参数，然后求max。即get键对应的值，然后返回最大的值对应的键（感觉python中存在很多这种情况，比如lambda表达式，后面也是传一个func来将前面的参数带入）</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>字典序<br>数学<br>思路<br>与上面题目不同，这道题没有一个全局的删除次数 k。而是对于每一个在字符串 s 中出现的字母 c 都有一个 k 值。这个 k 是 c 出现次数 - 1。</p><p>沿用上面的知识的话，我们首先要做的就是计算每一个字符的 k，可以用一个字典来描述这种关系，其中 key 为 字符 c，value 为其出现的次数。</p><h3 id="具体算法："><a href="#具体算法：" class="headerlink" title="具体算法："></a>具体算法：</h3><p>建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。<br>从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1.<br>对于每一个字符，如果其对应的剩余出现次数大于 1，我们可以选择丢弃（也可以选择不丢弃），否则不可以丢弃。<br>是否丢弃的标准和上面题目类似。如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。<br>还记得上面题目的边界条件么？如果栈中剩下的元素大于 n - kn−k，我们选择截取前 n - kn−k 个数字。然而本题中的 k 是分散在各个字符中的，因此这种思路不可行的。</p><p>不过不必担心。由于题目是要求只出现一次。我们可以在遍历的时候简单地判断其是否在栈上即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：由于判断当前字符是否在栈上存在需要 O(N)的时间，因此总的时间复杂度就是 O(N^2)，其中 N 为字符串长度。<br>空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 O(N)，其中 N 为字符串长度。</p><p>优化：<br>利用hashset空间换时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[-<span class="number">1</span>] <span class="keyword">and</span>  remain_counter[stack[-<span class="number">1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    seen.discard(stack.pop())</span><br><span class="line">                seen.add(c)</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(N)，其中 N 为字符串长度。<br>空间复杂度：我们使用了额外的栈和 hashset，因此空间复杂度为 O(N)，其中 N 为字符串长度。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>985. Sum of Even Numbers After Queries(medium)</title>
      <link href="/2022/09/21/985/"/>
      <url>/2022/09/21/985/</url>
      
        <content type="html"><![CDATA[<h1 id="985-Sum-of-Even-Numbers-After-Queries-medium"><a href="#985-Sum-of-Even-Numbers-After-Queries-medium" class="headerlink" title="985. Sum of Even Numbers After Queries(medium)"></a>985. Sum of Even Numbers After Queries(medium)</h1><h2 id="You-are-given-an-integer-array-nums-and-an-array-queries-where-queries-i-vali-indexi"><a href="#You-are-given-an-integer-array-nums-and-an-array-queries-where-queries-i-vali-indexi" class="headerlink" title="You are given an integer array nums and an array queries where queries[i] = [vali, indexi]."></a>You are given an integer array nums and an array queries where queries[i] = [vali, indexi].</h2><h2 id="For-each-query-i-first-apply-nums-indexi-nums-indexi-vali-then-print-the-sum-of-the-even-values-of-nums"><a href="#For-each-query-i-first-apply-nums-indexi-nums-indexi-vali-then-print-the-sum-of-the-even-values-of-nums" class="headerlink" title="For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums."></a>For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.</h2><h2 id="Return-an-integer-array-answer-where-answer-i-is-the-answer-to-the-ith-query"><a href="#Return-an-integer-array-answer-where-answer-i-is-the-answer-to-the-ith-query" class="headerlink" title="Return an integer array answer where answer[i] is the answer to the ith query."></a>Return an integer array answer where answer[i] is the answer to the ith query.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: At the beginning, the array is [1,2,3,4].</span><br><span class="line">After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure><p>这道题的思路很有特点，维护一个数组，先把原数组的偶数和求出来，接下来根据queries不断调整 S，即每一步操作之后整个数组的偶数和。操作数组中的某一个元素 A[index] 的时候，数组 A 其他位置的元素都应保持不变。如果 A[index] 是偶数，我们就从 S 中减去它，然后计算 A[index] + val 对 S 的影响（如果是偶数则在 S 中加上它）。相当于再计算前先把这个value减去（如果是偶数），算上新加入的index再计算对整个和的影响（如果是偶数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumEvenAfterQueries</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        even_sum=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                even_sum+=num</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> val,i <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> nums[i]%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                even_sum-=nums[i]</span><br><span class="line">            nums[i]+=val</span><br><span class="line">            <span class="keyword">if</span> nums[i]%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                even_sum+=nums[i]</span><br><span class="line">            ans.append(even_sum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>402. Remove K Digits(medium)</title>
      <link href="/2022/09/21/402/"/>
      <url>/2022/09/21/402/</url>
      
        <content type="html"><![CDATA[<h1 id="402-Remove-K-Digits-medium"><a href="#402-Remove-K-Digits-medium" class="headerlink" title="402. Remove K Digits(medium)"></a>402. Remove K Digits(medium)</h1><h2 id="Given-string-num-representing-a-non-negative-integer-num-and-an-integer-k-return-the-smallest-possible-integer-after-removing-k-digits-from-num"><a href="#Given-string-num-representing-a-non-negative-integer-num-and-an-integer-k-return-the-smallest-possible-integer-after-removing-k-digits-from-num" class="headerlink" title="Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num."></a>Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.</h2><p>相似题型<br>316. 去除重复字母(困难)<br>321. 拼接最大数(困难)<br>402. 移掉 K 位数字(中等)<br>1081. 不同字符的最小子序列（中等）</p><p>给定一个以字符串表示的非负整数  num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:<br>num 的长度小于 10002 且  ≥ k。<br>num 不会包含任何前导零。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入: num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br><span class="line">示例 2 :</span><br><span class="line"></span><br><span class="line">输入: num = &quot;10200&quot;, k = 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br><span class="line">示例 3 :</span><br><span class="line"></span><br><span class="line">输入: num = &quot;10&quot;, k = 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是 0。</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. strip():- This method is used to delete all the leading and trailing characters mentioned in its argument.</span><br><span class="line">2. lstrip():- This method is used to delete all the leading characters mentioned in its argument.</span><br><span class="line">3. rstrip():- This method is used to delete all the trailing characters mentioned in its argument.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code to demonstrate working of</span></span><br><span class="line"><span class="comment"># strip(), lstrip() and rstrip()</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;---geeksforgeeks---&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using strip() to delete all &#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot; String after stripping all &#x27;-&#x27; is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ( <span class="built_in">str</span>.strip(<span class="string">&#x27;-&#x27;</span>) )</span><br><span class="line"><span class="comment"># String after stripping all &#x27;-&#x27; is : geeksforgeeks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using lstrip() to delete all trailing &#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot; String after stripping all leading &#x27;-&#x27; is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ( <span class="built_in">str</span>.lstrip(<span class="string">&#x27;-&#x27;</span>) )</span><br><span class="line"><span class="comment"># String after stripping all leading &#x27;-&#x27; is : geeksforgeeks---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using rstrip() to delete all leading &#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot; String after stripping all trailing &#x27;-&#x27; is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ( <span class="built_in">str</span>.rstrip(<span class="string">&#x27;-&#x27;</span>) )</span><br><span class="line"><span class="comment"># String after stripping all trailing &#x27;-&#x27; is : ---geeksforgeeks</span></span><br></pre></td></tr></table></figure><p>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。<br>str.join(sequence) sequence – 要连接的元素序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;-&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;&quot;</span></span><br><span class="line">seq = (<span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;b&quot;</span>) <span class="comment"># 字符串序列</span></span><br><span class="line"><span class="built_in">print</span> (s1.join( seq )) <span class="comment">#r-u-n-o-o-b</span></span><br><span class="line"><span class="built_in">print</span> (s2.join( seq )) <span class="comment">#runoob</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">类似于<span class="keyword">if</span> 判断</span><br><span class="line"><span class="keyword">if</span> variable_1:</span><br><span class="line">  x = variable_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  x = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/remove-k-digits/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-5/">Solution</a></h2><p>因此我们的思路就是：</p><p>从左到右遍历<br>对于遍历到的元素，我们选择保留。<br>但是我们可以选择性丢弃前面相邻的元素。<br>丢弃与否的依据如上面的前置知识中阐述中的方法。</p><p>然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远选择不丢弃。这个题目中要求的，我们要永远确保丢弃 k 个矛盾。</p><p>一个简单的思路就是：</p><p>每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。<br>而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</p><p>我们需要把思路逆转过来。刚才我的关注点一直是丢弃，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 n - kn−k 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前n - k个元素即可。</p><p>按照上面的思路，我们来选择数据结构。由于我们需要保留和丢弃相邻的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        stack=[]</span><br><span class="line">        remain= <span class="built_in">len</span>(num)-k</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>]&gt;digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>718</title>
      <link href="/2022/09/21/718/"/>
      <url>/2022/09/21/718/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. Daily Temperatures(medium)</title>
      <link href="/2022/09/20/739/"/>
      <url>/2022/09/20/739/</url>
      
        <content type="html"><![CDATA[<h1 id="739-Daily-Temperatures-medium"><a href="#739-Daily-Temperatures-medium" class="headerlink" title="739. Daily Temperatures(medium)"></a>739. Daily Temperatures(medium)</h1><h2 id="Given-an-array-of-integers-temperatures-represents-the-daily-temperatures-return-an-array-answer-such-that-answer-i-is-the-number-of-days-you-have-to-wait-after-the-ith-day-to-get-a-warmer-temperature-If-there-is-no-future-day-for-which-this-is-possible-keep-answer-i-0-instead"><a href="#Given-an-array-of-integers-temperatures-represents-the-daily-temperatures-return-an-array-answer-such-that-answer-i-is-the-number-of-days-you-have-to-wait-after-the-ith-day-to-get-a-warmer-temperature-If-there-is-no-future-day-for-which-this-is-possible-keep-answer-i-0-instead" class="headerlink" title="Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead."></a>Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a><a href="https://leetcode.cn/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/">单调栈</a></h3><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p><p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 temperatures[i] 一定是 temperatures[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><p>以下用一个具体的例子帮助读者理解单调栈。对于温度列表 [73,74,75,71,69,72,76,73]，单调栈 stack 的初始状态为空，答案 ans 的初始状态是 [0,0,0,0,0,0,0,0]，按照以下步骤更新单调栈和答案，其中单调栈内的元素都是下标，括号内的数字表示下标在温度列表中对应的温度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/438101">KMP</a></p><p>这是评论里的解法，相对更好理解一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, T: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n=<span class="built_in">len</span>(T)</span><br><span class="line">        ans=[<span class="number">0</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            now=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> T[now]&lt;=T[i]:</span><br><span class="line">                <span class="keyword">if</span> ans[now]:</span><br><span class="line">                    now+=ans[now]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[i]=now-i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>496. Next Greater Element I(easy)</title>
      <link href="/2022/09/20/496/"/>
      <url>/2022/09/20/496/</url>
      
        <content type="html"><![CDATA[<h1 id="496-Next-Greater-Element-I-easy"><a href="#496-Next-Greater-Element-I-easy" class="headerlink" title="496. Next Greater Element I(easy)"></a>496. Next Greater Element I(easy)</h1><h2 id="The-next-greater-element-of-some-element-x-in-an-array-is-the-first-greater-element-that-is-to-the-right-of-x-in-the-same-array"><a href="#The-next-greater-element-of-some-element-x-in-an-array-is-the-first-greater-element-that-is-to-the-right-of-x-in-the-same-array" class="headerlink" title="The next greater element of some element x in an array is the first greater element that is to the right of x in the same array."></a>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</h2><h2 id="You-are-given-two-distinct-0-indexed-integer-arrays-nums1-and-nums2-where-nums1-is-a-subset-of-nums2"><a href="#You-are-given-two-distinct-0-indexed-integer-arrays-nums1-and-nums2-where-nums1-is-a-subset-of-nums2" class="headerlink" title="You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2."></a>You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.</h2><h2 id="For-each-0-lt-i-lt-nums1-length-find-the-index-j-such-that-nums1-i-nums2-j-and-determine-the-next-greater-element-of-nums2-j-in-nums2-If-there-is-no-next-greater-element-then-the-answer-for-this-query-is-1"><a href="#For-each-0-lt-i-lt-nums1-length-find-the-index-j-such-that-nums1-i-nums2-j-and-determine-the-next-greater-element-of-nums2-j-in-nums2-If-there-is-no-next-greater-element-then-the-answer-for-this-query-is-1" class="headerlink" title="For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1."></a>For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.</h2><h2 id="Return-an-array-ans-of-length-nums1-length-such-that-ans-i-is-the-next-greater-element-as-described-above"><a href="#Return-an-array-ans-of-length-nums1-length-such-that-ans-i-is-the-next-greater-element-as-described-above" class="headerlink" title="Return an array ans of length nums1.length such that ans[i] is the next greater element as described above."></a>Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,1,2], nums2 = [1,3,4,2]</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation: The next greater element for each value of nums1 is as follows:</span><br><span class="line">- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.</span><br><span class="line">- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.</span><br><span class="line">- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.</span><br></pre></td></tr></table></figure><h3 id="单调栈-哈希表"><a href="#单调栈-哈希表" class="headerlink" title="单调栈 + 哈希表"></a><a href="https://leetcode.cn/problems/next-greater-element-i/solution/xia-yi-ge-geng-da-yuan-su-i-by-leetcode-bfcoj/">单调栈 + 哈希表</a></h3><p>思路</p><p>我们可以先预处理 nums2 ，使查询 nums1中的每个元素在 nums2中对应位置的右边的第一个更大的元素值时不需要再遍历 nums2。于是，我们将题目分解为两个子问题：</p><p>第 1 个子问题：如何更高效地计算 nums2中每个元素右边的第一个更大的值；</p><p>第 2 个子问题：如何存储第 1 个子问题的结果。</p><p>算法</p><p>我们可以使用单调栈来解决第 1 个子问题。倒序遍历 nums2，并用单调栈中维护当前位置右边的更大的元素列表，从栈底到栈顶的元素是单调递减的。</p><p>具体地，每次我们移动到数组中一个新的位置 i，就将当前单调栈中所有小于 nums2[i]的元素弹出单调栈，当前位置右边的第一个更大的元素即为栈顶元素，如果栈为空则说明当前位置右边没有更大的元素。随后我们将位置 i 的元素入栈。</p><p>可以结合以下例子来理解。</p><p>因为题目规定了 nums2是没有重复元素的，所以我们可以使用哈希表来解决第 22 个子问题，将元素值与其右边第一个更大的元素值的对应关系存入哈希表。</p><p>细节</p><p>因为在这道题中我们只需要用到 nums2中元素的顺序而不需要用到下标，所以栈中直接存储 nums2中元素的值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            res[num] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(num)</span><br><span class="line">        <span class="keyword">return</span> [res[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>380. Insert Delete GetRandom O(1)(medium)</title>
      <link href="/2022/09/13/380/"/>
      <url>/2022/09/13/380/</url>
      
        <content type="html"><![CDATA[<h1 id="380-Insert-Delete-GetRandom-O-1-medium"><a href="#380-Insert-Delete-GetRandom-O-1-medium" class="headerlink" title="380. Insert Delete GetRandom O(1)(medium)"></a>380. Insert Delete GetRandom O(1)(medium)</h1><h2 id="Implement-the-RandomizedSet-class"><a href="#Implement-the-RandomizedSet-class" class="headerlink" title="Implement the RandomizedSet class:"></a>Implement the RandomizedSet class:</h2><p>RandomizedSet() Initializes the RandomizedSet object.<br>bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.<br>bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.<br>int getRandom() Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.</p><h2 id="You-must-implement-the-functions-of-the-class-such-that-each-function-works-in-average-O-1-time-complexity"><a href="#You-must-implement-the-functions-of-the-class-such-that-each-function-works-in-average-O-1-time-complexity" class="headerlink" title="You must implement the functions of the class such that each function works in average O(1) time complexity."></a>You must implement the functions of the class such that each function works in average O(1) time complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomizedSet.remove(2); // Returns false as 2 does not exist in the set.</span><br><span class="line">randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.</span><br><span class="line">randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomizedSet.insert(2); // 2 was already in the set, so return false.</span><br><span class="line">randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://labuladong.github.io/algo/2/20/33/">Solution</a></h3><p>本题的难点在于两点：</p><p>1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)。</p><p>2、getRandom 方法返回的元素必须等概率返回随机元素，也就是说，如果集合里面有 n 个元素，每个元素被返回的概率必须是 1/n。</p><p>我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？</p><p>HashSet 肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。</p><p>那么请问对于这样一个标准的 HashSet，你能否在 O(1) 的时间内实现 getRandom 函数？</p><p>其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，所以做不到 O(1) 时间「等概率」随机获取元素。</p><p>除了 HashSet，还有一些类似的数据结构，比如哈希链表 LinkedHashSet，我们后文 手把手实现LRU算法 和 手把手实现LFU算法 讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中。</p><p>但是，LinkedHashSet 只是给 HashSet 增加了有序性，依然无法按要求实现我们的 getRandom 函数，因为底层用链表结构存储元素的话，是无法在 O(1) 的时间内访问某一个元素的。</p><p>根据上面的分析，对于 getRandom 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：底层用数组实现，且数组必须是紧凑的。</p><p>这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。</p><p>但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢？</p><p>可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。</p><p>所以，如果我们想在 O(1) 的时间删除数组中的某一个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。</p><p>交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 valToIndex 来记录每个元素值对应的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 存储元素的值</span></span><br><span class="line">        self.nums=[]</span><br><span class="line">        <span class="comment"># 记录每个元素对应在 nums 中的索引</span></span><br><span class="line">        self.valToIndex=&#123;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#若 val 已存在，不用再插入</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.valToIndex:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#若 val 不存在，插入到 nums 尾部，</span></span><br><span class="line">        <span class="comment">#并记录 val 对应的索引值</span></span><br><span class="line">        self.valToIndex[val]=<span class="built_in">len</span>(self.nums)</span><br><span class="line">        self.nums.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#若 val 不存在，不用再删除</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.valToIndex:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#先拿到 val 的索引</span></span><br><span class="line">        index= self.valToIndex[val]</span><br><span class="line">        <span class="comment">#将最后一个元素对应的索引修改为 index</span></span><br><span class="line">        self.nums[index]=self.nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#交换 val 和最后一个元素</span></span><br><span class="line">        self.valToIndex[self.nums[index]]=index</span><br><span class="line">        <span class="comment">#在数组中删除元素 val</span></span><br><span class="line">        self.nums.pop()</span><br><span class="line">        <span class="comment">#删除元素 val 对应的索引(hashmap)</span></span><br><span class="line">        <span class="keyword">del</span> self.valToIndex[val]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 随机获取 nums 中的一个元素</span></span><br><span class="line">        <span class="keyword">return</span> choice(self.nums)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RandomizedSet()</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> Sliding-Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647. Palindromic Substrings(medium)</title>
      <link href="/2022/09/13/647/"/>
      <url>/2022/09/13/647/</url>
      
        <content type="html"><![CDATA[<h1 id="647-Palindromic-Substrings-medium"><a href="#647-Palindromic-Substrings-medium" class="headerlink" title="647. Palindromic Substrings(medium)"></a>647. Palindromic Substrings(medium)</h1><h2 id="Given-a-string-s-return-the-number-of-palindromic-substrings-in-it"><a href="#Given-a-string-s-return-the-number-of-palindromic-substrings-in-it" class="headerlink" title="Given a string s, return the number of palindromic substrings in it."></a>Given a string s, return the number of palindromic substrings in it.</h2><h2 id="A-string-is-a-palindrome-when-it-reads-the-same-backward-as-forward"><a href="#A-string-is-a-palindrome-when-it-reads-the-same-backward-as-forward" class="headerlink" title="A string is a palindrome when it reads the same backward as forward."></a>A string is a palindrome when it reads the same backward as forward.</h2><h2 id="A-substring-is-a-contiguous-sequence-of-characters-within-the-string"><a href="#A-substring-is-a-contiguous-sequence-of-characters-within-the-string" class="headerlink" title="A substring is a contiguous sequence of characters within the string."></a>A substring is a contiguous sequence of characters within the string.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    L, r = <span class="built_in">len</span>(s), <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">    <span class="keyword">for</span> a,b <span class="keyword">in</span> [(i,i),(i,i+<span class="number">1</span>)]:</span><br><span class="line">    <span class="keyword">while</span> a &gt;= <span class="number">0</span> <span class="keyword">and</span> b &lt; L <span class="keyword">and</span> s[a] == s[b]: a -= <span class="number">1</span>; b += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">    r += (b-a)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>870. Advantage Shuffle(medium)</title>
      <link href="/2022/09/12/870/"/>
      <url>/2022/09/12/870/</url>
      
        <content type="html"><![CDATA[<h1 id="870-Advantage-Shuffle-medium"><a href="#870-Advantage-Shuffle-medium" class="headerlink" title="870. Advantage Shuffle(medium)"></a>870. Advantage Shuffle(medium)</h1><h2 id="You-are-given-two-integer-arrays-nums1-and-nums2-both-of-the-same-length-The-advantage-of-nums1-with-respect-to-nums2-is-the-number-of-indices-i-for-which-nums1-i-gt-nums2-i"><a href="#You-are-given-two-integer-arrays-nums1-and-nums2-both-of-the-same-length-The-advantage-of-nums1-with-respect-to-nums2-is-the-number-of-indices-i-for-which-nums1-i-gt-nums2-i" class="headerlink" title="You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] &gt; nums2[i]."></a>You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] &gt; nums2[i].</h2><h2 id="Return-any-permutation-of-nums1-that-maximizes-its-advantage-with-respect-to-nums2"><a href="#Return-any-permutation-of-nums1-that-maximizes-its-advantage-with-respect-to-nums2" class="headerlink" title="Return any permutation of nums1 that maximizes its advantage with respect to nums2."></a>Return any permutation of nums1 that maximizes its advantage with respect to nums2.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure><p>类似于田忌赛马的故事，排序nums2使得nums2比nums1有优势</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/advantage-shuffle/solution/by-qingfengpython-mvix/">Solution</a></h2><p>按照上面的思路，可以考虑贪心的思维模式。</p><p>首先需要将nums2按照[value,index]的模式加入保存至数组中，最终按照value值逆序生成一个二维数组<br>之后对nums1进行排序<br>分配left、right指针指向nums1的头尾节点<br>创建一个长度为nums1的初始化数组ret，开始循环二维数组<br>按照上面的思路<br>如果right节点比nums2当前的下表数字大，那就是强强对碰，正面硬刚<br>如果不敌则用left节点的小兵以次充好<br>不论1、2如何选择，都将left或right对应的num，根据二维数组的index将value保存至ret数组<br>最终返回ret数组即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advantageCount</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        sortedA = <span class="built_in">sorted</span>(A)</span><br><span class="line">        sortedB = <span class="built_in">sorted</span>(B)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># assigned[b] = list of a that are assigned to beat b</span></span><br><span class="line">        <span class="comment"># remaining = list of a that are not assigned to any b</span></span><br><span class="line">        assigned = &#123;b: [] <span class="keyword">for</span> b <span class="keyword">in</span> B&#125;</span><br><span class="line">        remaining = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># populate (assigned, remaining) appropriately</span></span><br><span class="line">        <span class="comment"># sortedB[j] is always the smallest unassigned element in B</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> sortedA:</span><br><span class="line">            <span class="keyword">if</span> a &gt; sortedB[j]:</span><br><span class="line">                assigned[sortedB[j]].append(a)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                remaining.append(a)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reconstruct the answer from annotations (assigned, remaining)</span></span><br><span class="line">        <span class="keyword">return</span> [assigned[b].pop() <span class="keyword">if</span> assigned[b] <span class="keyword">else</span> remaining.pop()</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> B]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> prefix sum </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>528. Random Pick with Weight(medium)</title>
      <link href="/2022/09/12/528/"/>
      <url>/2022/09/12/528/</url>
      
        <content type="html"><![CDATA[<h1 id="528-Random-Pick-with-Weight-medium"><a href="#528-Random-Pick-with-Weight-medium" class="headerlink" title="528. Random Pick with Weight(medium)"></a>528. Random Pick with Weight(medium)</h1><h2 id="You-are-given-a-0-indexed-array-of-positive-integers-w-where-w-i-describes-the-weight-of-the-ith-index"><a href="#You-are-given-a-0-indexed-array-of-positive-integers-w-where-w-i-describes-the-weight-of-the-ith-index" class="headerlink" title="You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index."></a>You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.</h2><h2 id="You-need-to-implement-the-function-pickIndex-which-randomly-picks-an-index-in-the-range-0-w-length-1-inclusive-and-returns-it-The-probability-of-picking-an-index-i-is-w-i-sum-w"><a href="#You-need-to-implement-the-function-pickIndex-which-randomly-picks-an-index-in-the-range-0-w-length-1-inclusive-and-returns-it-The-probability-of-picking-an-index-i-is-w-i-sum-w" class="headerlink" title="You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w)."></a>You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).</h2><h2 id="For-example-if-w-1-3-the-probability-of-picking-index-0-is-1-1-3-0-25-i-e-25-and-the-probability-of-picking-index-1-is-3-1-3-0-75-i-e-75"><a href="#For-example-if-w-1-3-the-probability-of-picking-index-0-is-1-1-3-0-25-i-e-25-and-the-probability-of-picking-index-1-is-3-1-3-0-75-i-e-75" class="headerlink" title="For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%)."></a>For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).</h2><p>前缀和数组加二分搜索的题目</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><a href="https://leetcode.cn/problems/random-pick-with-weight/solution/an-quan-zhong-sui-ji-xuan-ze-by-leetcode-h13t/">Solution</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, w: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.pre = <span class="built_in">list</span>(accumulate(w))</span><br><span class="line">        self.total = <span class="built_in">sum</span>(w)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        x = random.randint(<span class="number">1</span>, self.total)</span><br><span class="line">        <span class="keyword">return</span> bisect_left(self.pre, x)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(w)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pickIndex()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> prefix sum </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>567. Permutation in String(medium)</title>
      <link href="/2022/09/11/567/"/>
      <url>/2022/09/11/567/</url>
      
        <content type="html"><![CDATA[<h1 id="567-Permutation-in-String-medium"><a href="#567-Permutation-in-String-medium" class="headerlink" title="567. Permutation in String(medium)"></a>567. Permutation in String(medium)</h1><h2 id="Given-two-strings-s1-and-s2-return-true-if-s2-contains-a-permutation-of-s1-or-false-otherwise"><a href="#Given-two-strings-s1-and-s2-return-true-if-s2-contains-a-permutation-of-s1-or-false-otherwise" class="headerlink" title="Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise."></a>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.</h2><h2 id="In-other-words-return-true-if-one-of-s1’s-permutations-is-the-substring-of-s2"><a href="#In-other-words-return-true-if-one-of-s1’s-permutations-is-the-substring-of-s2" class="headerlink" title="In other words, return true if one of s1’s permutations is the substring of s2."></a>In other words, return true if one of s1’s permutations is the substring of s2.</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> Sliding-Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1356. Sort Integers by The Number of 1 Bits(easy)</title>
      <link href="/2022/09/11/1356/"/>
      <url>/2022/09/11/1356/</url>
      
        <content type="html"><![CDATA[<h1 id="1356-Sort-Integers-by-The-Number-of-1-Bits-easy"><a href="#1356-Sort-Integers-by-The-Number-of-1-Bits-easy" class="headerlink" title="1356. Sort Integers by The Number of 1 Bits(easy)"></a>1356. Sort Integers by The Number of 1 Bits(easy)</h1><h2 id="You-are-given-an-integer-array-arr-Sort-the-integers-in-the-array-in-ascending-order-by-the-number-of-1’s-in-their-binary-representation-and-in-case-of-two-or-more-integers-have-the-same-number-of-1’s-you-have-to-sort-them-in-ascending-order"><a href="#You-are-given-an-integer-array-arr-Sort-the-integers-in-the-array-in-ascending-order-by-the-number-of-1’s-in-their-binary-representation-and-in-case-of-two-or-more-integers-have-the-same-number-of-1’s-you-have-to-sort-them-in-ascending-order" class="headerlink" title="You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order."></a>You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order.</h2><h2 id="Return-the-array-after-sorting-it"><a href="#Return-the-array-after-sorting-it" class="headerlink" title="Return the array after sorting it."></a>Return the array after sorting it.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [0,1,2,3,4,5,6,7,8]</span><br><span class="line">Output: [0,1,2,4,8,3,5,6,7]</span><br><span class="line">Explantion: [0] is the only integer with 0 bits.</span><br><span class="line">[1,2,4,8] all have 1 bit.</span><br><span class="line">[3,5,6] have 2 bits.</span><br><span class="line">[7] has 3 bits.</span><br><span class="line">The sorted array by bits is [0,1,2,4,8,3,5,6,7]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="python">class Solution:    def sortByBits(self, arr: List[int]) -&gt; List[int]:        return sorted(arr, key = lambda num : (sum((num &gt;&gt; i) &amp; 1 for i in range(32)), num))</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring(hard)</title>
      <link href="/2022/09/11/76/"/>
      <url>/2022/09/11/76/</url>
      
        <content type="html"><![CDATA[<h1 id="76-Minimum-Window-Substring-hard"><a href="#76-Minimum-Window-Substring-hard" class="headerlink" title="76. Minimum Window Substring(hard)"></a>76. Minimum Window Substring(hard)</h1><h2 id="Given-two-strings-s-and-t-of-lengths-m-and-n-respectively-return-the-minimum-window-substring-of-s-such-that-every-character-in-t-including-duplicates-is-included-in-the-window-If-there-is-no-such-substring-return-the-empty-string-“”"><a href="#Given-two-strings-s-and-t-of-lengths-m-and-n-respectively-return-the-minimum-window-substring-of-s-such-that-every-character-in-t-including-duplicates-is-included-in-the-window-If-there-is-no-such-substring-return-the-empty-string-“”" class="headerlink" title="Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string “”."></a>Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string “”.</h2><h2 id="The-testcases-will-be-generated-such-that-the-answer-is-unique"><a href="#The-testcases-will-be-generated-such-that-the-answer-is-unique" class="headerlink" title="The testcases will be generated such that the answer is unique."></a>The testcases will be generated such that the answer is unique.</h2><h2 id="A-substring-is-a-contiguous-sequence-of-characters-within-the-string"><a href="#A-substring-is-a-contiguous-sequence-of-characters-within-the-string" class="headerlink" title="A substring is a contiguous sequence of characters within the string."></a>A substring is a contiguous sequence of characters within the string.</h2><p>这道题是滑动窗口的经典题目，滑动窗口算法的思路是这样：</p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。</li></ol><p>PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</p><ol start="2"><li><p>我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p></li><li><p>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p></li><li><p>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p></li></ol><p>这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p><p>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和「窗口」中的相应字符的出现次数。</p><h4 id="C-解法"><a href="#C-解法" class="headerlink" title="C++解法"></a><a href="https://labuladong.github.io/algo/2/20/27/">C++解法</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最小覆盖子串的起始索引及长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> (need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (valid == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ?</span><br><span class="line">        <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python解法"><a href="#python解法" class="headerlink" title="python解法"></a><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26804/12-lines-Python/1079619">python解法</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># hash table to store the required char frequency</span></span><br><span class="line">        need = collections.Counter(t)            </span><br><span class="line"></span><br><span class="line">        <span class="comment"># total character count we need to care about</span></span><br><span class="line">        missing = <span class="built_in">len</span>(t)                         </span><br><span class="line"></span><br><span class="line">        <span class="comment"># windowStart and windowEnd to be</span></span><br><span class="line">        windowStart, windowEnd = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># iterate over s starting over index 1</span></span><br><span class="line">        <span class="keyword">for</span> j, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s, <span class="number">1</span>): <span class="comment"># j is index,char is value         </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># if char is required then decrease missing</span></span><br><span class="line">            <span class="keyword">if</span> need[char] &gt; <span class="number">0</span>:                   </span><br><span class="line">                missing -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># decrease the freq of char from need (maybe be negative - which basically denotes</span></span><br><span class="line">            <span class="comment">#   that we have few extra characters which are not required but present in between current window)</span></span><br><span class="line">            need[char] -= <span class="number">1</span>                      </span><br><span class="line"></span><br><span class="line">            <span class="comment"># we found a valid window</span></span><br><span class="line">            <span class="keyword">if</span> missing == <span class="number">0</span>:                     </span><br><span class="line">                <span class="comment"># chars from start to find the real windowStart</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> need[s[i]] &lt; <span class="number">0</span>:  </span><br><span class="line">                    need[s[i]] += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># if it&#x27;s only one char case or curr window is smaller, then update window</span></span><br><span class="line">                <span class="keyword">if</span> windowEnd == <span class="number">0</span> <span class="keyword">or</span> j-i &lt; windowEnd-windowStart:  </span><br><span class="line">                    windowStart, windowEnd = i, j</span><br><span class="line"></span><br><span class="line">                <span class="comment"># now resetting the window to make it invalid</span></span><br><span class="line">                <span class="comment"># sure the first appearing char satisfies need[char]&gt;0</span></span><br><span class="line">                need[s[i]] += <span class="number">1</span>          </span><br><span class="line"></span><br><span class="line">                <span class="comment"># missed this first char, so add missing by 1</span></span><br><span class="line">                missing += <span class="number">1</span>                     </span><br><span class="line"></span><br><span class="line">                <span class="comment">#update i to windowStart+1 for next window</span></span><br><span class="line">                i += <span class="number">1</span>                          </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[windowStart:windowEnd]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> Sliding-Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill8-two_pointers</title>
      <link href="/2022/09/11/LeetCode-skill8-two-pointers/"/>
      <url>/2022/09/11/LeetCode-skill8-two-pointers/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slidingWindow</span>(<span class="params">string s</span>):</span></span><br><span class="line">    </span><br><span class="line">    window=&#123;&#125;</span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment">#c 是将移入窗口的字符</span></span><br><span class="line">        c=s[right]</span><br><span class="line">        <span class="comment"># 增大窗口</span></span><br><span class="line">        right+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">#*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right)</span><br><span class="line">        <span class="comment">#********************/</span></span><br><span class="line">        <span class="comment"># 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) </span><br><span class="line">            <span class="comment">#d 是将移出窗口的字符</span></span><br><span class="line">            d = s[left]</span><br><span class="line">            <span class="comment">#缩小窗口</span></span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> Sliding-Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1360. Number of Days Between Two Dates</title>
      <link href="/2022/09/09/1360/"/>
      <url>/2022/09/09/1360/</url>
      
        <content type="html"><![CDATA[<h1 id="1360-Number-of-Days-Between-Two-Dates-easy"><a href="#1360-Number-of-Days-Between-Two-Dates-easy" class="headerlink" title="1360. Number of Days Between Two Dates(easy)"></a>1360. Number of Days Between Two Dates(easy)</h1><h2 id="Write-a-program-to-count-the-number-of-days-between-two-dates"><a href="#Write-a-program-to-count-the-number-of-days-between-two-dates" class="headerlink" title="Write a program to count the number of days between two dates."></a>Write a program to count the number of days between two dates.</h2><h2 id="The-two-dates-are-given-as-strings-their-format-is-YYYY-MM-DD-as-shown-in-the-examples"><a href="#The-two-dates-are-given-as-strings-their-format-is-YYYY-MM-DD-as-shown-in-the-examples" class="headerlink" title="The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples."></a>The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode.com/problems/number-of-days-between-two-dates/discuss/517582/Python-Magical-Formula">官方题解</a>:</h3><p>When m=1 or m=2 (January or February), we let m=13 or m=14 and let y decreased by 1. Imagine it is 13th or 14th month of the last year. By doing that, we let the magical formula also work for those two months. (153 * m + 8) // 5 is just a carefully designed way to record the days of each month. More specifically, it is designed to record the difference of days between two months. Suppose we have March 1st and April 1st, (153 * 3 + 8) // 5 = 93 while (153 * 4 + 8) // 5 = 124, the difference is 31 which is the number of days in March. Suppose we have April 1st to May 1st, (153 * 4 + 8) // 5 = 124 and (153 * 5 + 8) // 5 = 154, the difference is now 30 which is the number of days in April. You can also check other months.</p><p>I learned this formula somewhere else before. It is not something to come up with in minutes.<br>首先把1月2月加12当作13和14月，这样使得他们也可以套用公式<br>这里有一个关键的函数(153 * m + 8) // 5，通过前后月代入以后的相减，可以区分不同月份的长度，确实是非常神奇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">daysBetweenDates</span>(<span class="params">self, date1: <span class="built_in">str</span>, date2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">date</span>):</span></span><br><span class="line">            y, m, d = <span class="built_in">map</span>(<span class="built_in">int</span>, date.split(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> m &lt; <span class="number">3</span>:</span><br><span class="line">                m += <span class="number">12</span></span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">365</span> * y + y // <span class="number">4</span> + y // <span class="number">400</span> - y // <span class="number">100</span> + d + (<span class="number">153</span> * m + <span class="number">8</span>) // <span class="number">5</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(f(date1) - f(date2))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>practicecodesignal4</title>
      <link href="/2022/09/05/practicecodesignal4/"/>
      <url>/2022/09/05/practicecodesignal4/</url>
      
        <content type="html"><![CDATA[<p>def samesign(a,b):<br>    if a/abs(a) == b/abs(b):<br>        return True<br>    else:<br>        return False</p><p>def countSawSubarrays(arr):<br>    n = len(arr)</p><pre><code>if n&lt;2:    return 0s = 0e = 1count = 0while(e&lt;n):    sign = arr[e] - arr[s]    while(e&lt;n and arr[e] != arr[e-1] and samesign(arr[e] - arr[e-1], sign)):        sign = -1*sign        e+=1    size = e-s    if (size==1):        e+=1    count += (size*(size-1))//2    s = e-1    e = s+1return count</code></pre><p>arr1 = [9,8,7,6,5]<br>print(countSawSubarrays(arr1))<br>arr2 = [1,2,1,3,4,-2]<br>print(countSawSubarrays(arr2))<br>arr3 = [1,2,1,2,1]<br>print(countSawSubarrays(arr3))<br>arr4 = [10,10,10]<br>print(countSawSubarrays(arr4))</p><p>def solution(matrix, a, b):<br>    if a + b - 1 &gt; min(len(matrix), len(matrix[0])):<br>        return 0</p><pre><code>ret = 0for w, h in ((a, b), (b, a)):    # for every possible leftmost axb/bxa rectangle...    for start in range(min(len(matrix), len(matrix[0])) - (a + b - 1) + 1):        i = start        cur = 0        deques = []        j1 = j2 = w - 1        # build the rectangle         while j1 &lt;= j2:            for k in range(j1, j2 + 1):                cur += matrix[i][k]            deques.append((j1, j2))             j1 += (-1 if i - start &lt; w - 1 else 1)            j2 += (1 if i - start &lt; h - 1 else -1)            i += 1                stop = False        # slide it to the right until you can&#39;t anymore        while True:            ret = max(ret, cur)                        for ind, tup in enumerate(deques):                j1, j2 = tup                i = start + ind                if j2 == len(matrix[0]) - 1:                    stop = True                    break                j2 += 1                cur += matrix[i][j2] - matrix[i][j1]                j1 += 1                deques[ind] = (j1, j2)            if stop:                breakreturn ret</code></pre><p>You are given an array of integers numbers and two integers left and right. You task is to calculate a boolean array result, where result[i] = true if there exists an integer x, such that numbers[i] = (i + 1) * x and left ≤ x ≤ right. Otherwise, result[i] should be set to false.</p><p>You are given two strings - pattern and source. The first string pattern contains only the symbols 0 and 1, and the second string source contains only lowercase English letters.</p><p>Let’s say that pattern matches a substring source[l..r] of source if the following three conditions are met:<br>they have equal length,<br>for each 0 in pattern the corresponding letter in the substring is a vowel,<br>for each 1 in pattern the corresponding letter is a consonant.<br>Your task is to calculate the number of substrings of source that match pattern.</p><p>Note: In this task we define the vowels as ‘a’, ‘e’, ‘i’, ‘o’, ‘u’, and ‘y’. All other letters are consonants.</p><p>Given a matrix of integers, we’d like to consider the sum of the elements within the area of a 45° rotated rectangle. More formally, the area is bounded by two diagonals parallel to the main diagonal and two diagonals parallel to the secondary diagonal. The dimensions of the rotated rectangle are defined by the number of elements along the borders of the rectangle.</p><p>A sawtooth sequence is a sequence of numbers that alternate between increasing and decreasing. In other words, each element is either strictly greater than its neighbouring elements or strictly less than its neighbouring elements.</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> prefix sum </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill7-box_blur</title>
      <link href="/2022/09/03/LeetCode-skill7-box-blur/"/>
      <url>/2022/09/03/LeetCode-skill7-box-blur/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_matrix</span>(<span class="params">square</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; This function will calculate the value x</span></span><br><span class="line"><span class="string">(i.e. blurred pixel value) for each 3 * 3 blur image.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">tot_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate sum of all the pixels in 3 * 3 matrix</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">tot_sum += square[i][j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tot_sum // <span class="number">9</span> <span class="comment"># return the average of the sum of pixels</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boxBlur</span>(<span class="params">image</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This function will calculate the blurred</span></span><br><span class="line"><span class="string">image for given n * n image.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">square = [] <span class="comment"># This will store the 3 * 3 matrix</span></span><br><span class="line"><span class="comment"># which will be used to find its blurred pixel</span></span><br><span class="line"></span><br><span class="line">square_row = [] <span class="comment"># This will store one row of a 3 * 3 matrix and</span></span><br><span class="line"><span class="comment"># will be appended in square</span></span><br><span class="line"></span><br><span class="line">blur_row = [] <span class="comment"># Here we will store the resulting blurred</span></span><br><span class="line"><span class="comment"># pixels possible in one row</span></span><br><span class="line"><span class="comment"># and will append this in the blur_img</span></span><br><span class="line"></span><br><span class="line">blur_img = [] <span class="comment"># This is the resulting blurred image</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># number of rows in the given image</span></span><br><span class="line">n_rows = <span class="built_in">len</span>(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># number of columns in the given image</span></span><br><span class="line">n_col = <span class="built_in">len</span>(image[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># rp is row pointer and cp is column pointer</span></span><br><span class="line">rp, cp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This while loop will be used to</span></span><br><span class="line"><span class="comment"># calculate all the blurred pixel in the first row</span></span><br><span class="line"><span class="keyword">while</span> rp &lt;= n_rows - <span class="number">3</span>:</span><br><span class="line"><span class="keyword">while</span> cp &lt;= n_col-<span class="number">3</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rp, rp + <span class="number">3</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cp, cp + <span class="number">3</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># append all the pixels in a row of 3 * 3 matrix</span></span><br><span class="line">square_row.append(image[i][j])</span><br><span class="line"></span><br><span class="line"><span class="comment"># append the row in the square i.e. 3 * 3 matrix</span></span><br><span class="line">square.append(square_row)</span><br><span class="line">square_row = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate the blurred pixel for given 3 * 3 matrix</span></span><br><span class="line"><span class="comment"># i.e. square and append it in blur_row</span></span><br><span class="line">blur_row.append(square_matrix(square))</span><br><span class="line">square = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># increase the column pointer</span></span><br><span class="line">cp = cp + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># append the blur_row in blur_image</span></span><br><span class="line">blur_img.append(blur_row)</span><br><span class="line">blur_row = []</span><br><span class="line">rp = rp + <span class="number">1</span> <span class="comment"># increase row pointer</span></span><br><span class="line">cp = <span class="number">0</span> <span class="comment"># start column pointer from 0 again</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the resulting pixel matrix</span></span><br><span class="line"><span class="keyword">return</span> blur_img</span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code</span></span><br><span class="line">image = [[<span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">[<span class="number">6</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(boxBlur(image))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codesignal-reverseInParentheses</title>
      <link href="/2022/09/02/codesignal-reverseInParentheses/"/>
      <url>/2022/09/02/codesignal-reverseInParentheses/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">inputString</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Reverse the strings contained in each pair of matching parentheses,</span></span><br><span class="line"><span class="string">    starting from the innermost pair. The results string should not contain</span></span><br><span class="line"><span class="string">    any parentheses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; reverse_parentheses(&#x27;a(bc)de&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;acbde&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; reverse_parentheses(</span></span><br><span class="line"><span class="string">    ...     &#x27;The ((quick (brown) (fox) jumps over the lazy) dog)&#x27;</span></span><br><span class="line"><span class="string">    ... )</span></span><br><span class="line"><span class="string">    &#x27;The god quick nworb xof jumps over the lazy&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    chars = <span class="built_in">list</span>(inputString)</span><br><span class="line">    open_bracket_indexes = []</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(chars):</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            open_bracket_indexes.append(i)</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            j = open_bracket_indexes.pop()</span><br><span class="line">            chars[j:i] = chars[i:j:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> open_bracket_indexes:</span><br><span class="line">        <span class="keyword">raise</span> ArgumentError(<span class="string">&#x27;Unclosed parenthesis&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> chars <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;()&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> python function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>485. Max Consecutive Ones(easy)</title>
      <link href="/2022/09/01/485/"/>
      <url>/2022/09/01/485/</url>
      
        <content type="html"><![CDATA[<h1 id="485-Max-Consecutive-Ones-easy"><a href="#485-Max-Consecutive-Ones-easy" class="headerlink" title="485. Max Consecutive Ones(easy)"></a>485. Max Consecutive Ones(easy)</h1><h2 id="Given-a-binary-array-nums-return-the-maximum-number-of-consecutive-1’s-in-the-array"><a href="#Given-a-binary-array-nums-return-the-maximum-number-of-consecutive-1’s-in-the-array" class="headerlink" title="Given a binary array nums, return the maximum number of consecutive 1’s in the array."></a>Given a binary array nums, return the maximum number of consecutive 1’s in the array.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,0,1,1,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.</span><br></pre></td></tr></table></figure><p>这题没什么好说的，比较简单，设置两个独立变量然后遍历就行了</p><pre><code class="python">class Solution:    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:        cnt=0        ans=0        for num in nums:            if num==1:                cnt+=1                ans = max(ans,cnt)            elif num==0:                cnt=0        return ans</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1909. Remove One Element to Make the Array Strictly Increasing(easy)</title>
      <link href="/2022/09/01/1909/"/>
      <url>/2022/09/01/1909/</url>
      
        <content type="html"><![CDATA[<h1 id="1909-Remove-One-Element-to-Make-the-Array-Strictly-Increasing-easy"><a href="#1909-Remove-One-Element-to-Make-the-Array-Strictly-Increasing-easy" class="headerlink" title="1909. Remove One Element to Make the Array Strictly Increasing(easy)"></a>1909. Remove One Element to Make the Array Strictly Increasing(easy)</h1><h2 id="Given-a-0-indexed-integer-array-nums-return-true-if-it-can-be-made-strictly-increasing-after-removing-exactly-one-element-or-false-otherwise-If-the-array-is-already-strictly-increasing-return-true"><a href="#Given-a-0-indexed-integer-array-nums-return-true-if-it-can-be-made-strictly-increasing-after-removing-exactly-one-element-or-false-otherwise-If-the-array-is-already-strictly-increasing-return-true" class="headerlink" title="Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true."></a>Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.</h2><h2 id="The-array-nums-is-strictly-increasing-if-nums-i-1-lt-nums-i-for-each-index-1-lt-i-lt-nums-length"><a href="#The-array-nums-is-strictly-increasing-if-nums-i-1-lt-nums-i-for-each-index-1-lt-i-lt-nums-length" class="headerlink" title="The array nums is strictly increasing if nums[i - 1] &lt; nums[i] for each index (1 &lt;= i &lt; nums.length)."></a>The array nums is strictly increasing if nums[i - 1] &lt; nums[i] for each index (1 &lt;= i &lt; nums.length).</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,10,5,7]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].</span><br><span class="line">[1,2,5,7] is strictly increasing, so return true.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canBeIncreasing</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 检查数组 nums 在删去下标为 idx 的元素后是否严格递增</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                prev, curr = i - <span class="number">1</span>, i</span><br><span class="line">                <span class="keyword">if</span> prev &gt;= idx:</span><br><span class="line">                    prev += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> curr &gt;= idx:</span><br><span class="line">                    curr += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[curr] &lt;= nums[prev]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 寻找非递增相邻下标对</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> check(i) <span class="keyword">or</span> check(i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution/shan-chu-yi-ge-yuan-su-shi-shu-zu-yan-ge-tnr7/">https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution/shan-chu-yi-ge-yuan-su-shi-shu-zu-yan-ge-tnr7/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>59. Spiral Matrix II(medium)</title>
      <link href="/2022/08/31/59/"/>
      <url>/2022/08/31/59/</url>
      
        <content type="html"><![CDATA[<h1 id="59-Spiral-Matrix-II-medium"><a href="#59-Spiral-Matrix-II-medium" class="headerlink" title="59. Spiral Matrix II(medium)"></a>59. Spiral Matrix II(medium)</h1><h2 id="Given-a-positive-integer-n-generate-an-n-x-n-matrix-filled-with-elements-from-1-to-n2-in-spiral-order"><a href="#Given-a-positive-integer-n-generate-an-n-x-n-matrix-filled-with-elements-from-1-to-n2-in-spiral-order" class="headerlink" title="Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order."></a>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</h2><p>这道题和54. Spiral Matrix(medium)几乎一模一样<br><a href="https://leetcode.cn/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/">leetcode官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> top &lt;= bottom:</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                matrix[top][col] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(top + <span class="number">1</span>, bottom + <span class="number">1</span>):</span><br><span class="line">                matrix[row][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right <span class="keyword">and</span> top &lt; bottom:</span><br><span class="line">                <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(right - <span class="number">1</span>, left, -<span class="number">1</span>):</span><br><span class="line">                    matrix[bottom][col] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top, -<span class="number">1</span>):</span><br><span class="line">                    matrix[row][left] = num</span><br><span class="line">                    num += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">            bottom -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Spiral </tag>
            
            <tag> Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>151. Reverse Words in a String(medium)</title>
      <link href="/2022/08/31/151/"/>
      <url>/2022/08/31/151/</url>
      
        <content type="html"><![CDATA[<h1 id="151-Reverse-Words-in-a-String-medium"><a href="#151-Reverse-Words-in-a-String-medium" class="headerlink" title="151. Reverse Words in a String(medium)"></a>151. Reverse Words in a String(medium)</h1><h2 id="Given-an-input-string-s-reverse-the-order-of-the-words"><a href="#Given-an-input-string-s-reverse-the-order-of-the-words" class="headerlink" title="Given an input string s, reverse the order of the words."></a>Given an input string s, reverse the order of the words.</h2><h2 id="A-word-is-defined-as-a-sequence-of-non-space-characters-The-words-in-s-will-be-separated-by-at-least-one-space"><a href="#A-word-is-defined-as-a-sequence-of-non-space-characters-The-words-in-s-will-be-separated-by-at-least-one-space" class="headerlink" title="A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space."></a>A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.</h2><h2 id="Return-a-string-of-the-words-in-reverse-order-concatenated-by-a-single-space"><a href="#Return-a-string-of-the-words-in-reverse-order-concatenated-by-a-single-space" class="headerlink" title="Return a string of the words in reverse order concatenated by a single space."></a>Return a string of the words in reverse order concatenated by a single space.</h2><h2 id="Note-that-s-may-contain-leading-or-trailing-spaces-or-multiple-spaces-between-two-words-The-returned-string-should-only-have-a-single-space-separating-the-words-Do-not-include-any-extra-spaces"><a href="#Note-that-s-may-contain-leading-or-trailing-spaces-or-multiple-spaces-between-two-words-The-returned-string-should-only-have-a-single-space-separating-the-words-Do-not-include-any-extra-spaces" class="headerlink" title="Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces."></a>Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/">官方题解</a></h3><p>很多语言对字符串提供了 split（拆分），reverse（翻转）和 join（连接）等方法，因此我们可以简单的调用内置的 API 完成操作：</p><p>使用 split 将字符串按空格分割成字符串数组；<br>使用 reverse 将字符串数组进行反转；<br>使用 join 方法将字符串数组拼成一个字符串。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">reversed</span>(s.split()))</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 为输入字符串的长度。</p><p>空间复杂度：O(n)O(n)，用来存储字符串分割之后的结果。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix(medium)</title>
      <link href="/2022/08/31/54/"/>
      <url>/2022/08/31/54/</url>
      
        <content type="html"><![CDATA[<h1 id="54-Spiral-Matrix-medium"><a href="#54-Spiral-Matrix-medium" class="headerlink" title="54. Spiral Matrix(medium)"></a>54. Spiral Matrix(medium)</h1><h2 id="Given-an-m-x-n-matrix-return-all-elements-of-the-matrix-in-spiral-order"><a href="#Given-an-m-x-n-matrix-return-all-elements-of-the-matrix-in-spiral-order" class="headerlink" title="Given an m x n matrix, return all elements of the matrix in spiral order."></a>Given an m x n matrix, return all elements of the matrix in spiral order.</h2><h3 id="leetcode官方题解"><a href="#leetcode官方题解" class="headerlink" title="leetcode官方题解"></a><a href="https://leetcode.cn/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/">leetcode官方题解</a></h3><p>方法二：按层模拟<br>可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p><p>定义矩阵的第 kk 层是到最近边界距离为 kk 的所有顶点。例如，下图矩阵最外层元素都是第 11 层，次外层元素都是第 22 层，剩下的元素都是第 33 层。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1, 1, 1, 1, 1, 1, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 2, 3, 3, 3, 2, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 1, 1, 1, 1, 1, 1]]</span><br></pre></td></tr></table></figure><p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 (top,left)，右下角位于 (bottom,right)，按照如下顺序遍历当前层的元素。</p><p>从左到右遍历上侧元素，依次为 (top,left) 到 (top,right)。</p><p>从上到下遍历右侧元素，依次为 (top+1,right) 到 (bottom,right)。</p><p>如果 left &lt; right 且 top &lt; bottom，则从右到左遍历下侧元素，依次为 (bottom,right−1) 到 (bottom,left+1)，以及从下到上遍历左侧元素，依次为 (bottom,left) 到 (top+1,left)。</p><p>遍历完当前层的元素之后，将 left 和 top 分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。<br><img src="https://assets.leetcode-cn.com/solution-static/54/54_fig1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        order = <span class="built_in">list</span>()</span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, columns - <span class="number">1</span>, <span class="number">0</span>, rows - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> top &lt;= bottom:</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                order.append(matrix[top][column])</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(top + <span class="number">1</span>, bottom + <span class="number">1</span>):</span><br><span class="line">                order.append(matrix[row][right])</span><br><span class="line">            <span class="keyword">if</span> left &lt; right <span class="keyword">and</span> top &lt; bottom:</span><br><span class="line">                <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(right - <span class="number">1</span>, left, -<span class="number">1</span>):</span><br><span class="line">                    order.append(matrix[bottom][column])</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top, -<span class="number">1</span>):</span><br><span class="line">                    order.append(matrix[row][left])</span><br><span class="line">            left, right, top, bottom = left + <span class="number">1</span>, right - <span class="number">1</span>, top + <span class="number">1</span>, bottom - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Spiral </tag>
            
            <tag> Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku(medium)</title>
      <link href="/2022/08/31/36/"/>
      <url>/2022/08/31/36/</url>
      
        <content type="html"><![CDATA[<h1 id="36-Valid-Sudoku-medium"><a href="#36-Valid-Sudoku-medium" class="headerlink" title="36. Valid Sudoku(medium)"></a>36. Valid Sudoku(medium)</h1><h2 id="Determine-if-a-9-x-9-Sudoku-board-is-valid-Only-the-filled-cells-need-to-be-validated-according-to-the-following-rules"><a href="#Determine-if-a-9-x-9-Sudoku-board-is-valid-Only-the-filled-cells-need-to-be-validated-according-to-the-following-rules" class="headerlink" title="Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:"></a>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</h2><ol><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3></li></ol><h4 id="A-Sudoku-board-partially-filled-could-be-valid-but-is-not-necessarily-solvable"><a href="#A-Sudoku-board-partially-filled-could-be-valid-but-is-not-necessarily-solvable" class="headerlink" title="A Sudoku board (partially filled) could be valid but is not necessarily solvable."></a>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</h4><h4 id="Only-the-filled-cells-need-to-be-validated-according-to-the-mentioned-rules"><a href="#Only-the-filled-cells-need-to-be-validated-according-to-the-mentioned-rules" class="headerlink" title="Only the filled cells need to be validated according to the mentioned rules."></a>Only the filled cells need to be validated according to the mentioned rules.</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        N = <span class="number">9</span></span><br><span class="line">        <span class="comment"># Use binary number to check previous occurrence</span></span><br><span class="line">        rows = [<span class="number">0</span>] * N</span><br><span class="line">        cols = [<span class="number">0</span>] * N</span><br><span class="line">        boxes = [<span class="number">0</span>] * N</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="comment"># Check if the position is filled with number</span></span><br><span class="line">                <span class="keyword">if</span> board[r][c] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                pos = <span class="built_in">int</span>(board[r][c]) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check the row</span></span><br><span class="line">                <span class="keyword">if</span> rows[r] &amp; (<span class="number">1</span> &lt;&lt; pos):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                rows[r] |= (<span class="number">1</span> &lt;&lt; pos)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check the column</span></span><br><span class="line">                <span class="keyword">if</span> cols[c] &amp; (<span class="number">1</span> &lt;&lt; pos):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                cols[c] |= (<span class="number">1</span> &lt;&lt; pos)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Check the box</span></span><br><span class="line">                idx = (r // <span class="number">3</span>) * <span class="number">3</span> + c // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> boxes[idx] &amp; (<span class="number">1</span> &lt;&lt; pos):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                boxes[idx] |= (<span class="number">1</span> &lt;&lt; pos)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/valid-sudoku/solution/er-xu-cheng-ming-jiu-xu-zui-python3ha-xi-szko/">leetcode题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        row = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        col = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        block = [[<span class="number">0</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    num = <span class="built_in">int</span>(board[i][j]) - <span class="number">1</span></span><br><span class="line">                    b = (i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                    <span class="keyword">if</span> row[i][num] <span class="keyword">or</span> col[j][num] <span class="keyword">or</span> block[b][num]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    row[i][num] = col[j][num] = block[b][num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image(medium)</title>
      <link href="/2022/08/30/48/"/>
      <url>/2022/08/30/48/</url>
      
        <content type="html"><![CDATA[<h1 id="48-Rotate-Image-medium"><a href="#48-Rotate-Image-medium" class="headerlink" title="48. Rotate Image(medium)"></a>48. Rotate Image(medium)</h1><h2 id="You-are-given-an-n-x-n-2D-matrix-representing-an-image-rotate-the-image-by-90-degrees-clockwise"><a href="#You-are-given-an-n-x-n-2D-matrix-representing-an-image-rotate-the-image-by-90-degrees-clockwise" class="headerlink" title="You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise)."></a>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).</h2><h2 id="You-have-to-rotate-the-image-in-place-which-means-you-have-to-modify-the-input-2D-matrix-directly-DO-NOT-allocate-another-2D-matrix-and-do-the-rotation"><a href="#You-have-to-rotate-the-image-in-place-which-means-you-have-to-modify-the-input-2D-matrix-directly-DO-NOT-allocate-another-2D-matrix-and-do-the-rotation" class="headerlink" title="You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation."></a>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p>这题有一个非常巧妙的用翻转代替旋转的方法，<br>作为例子，<br>$$<br> \begin{bmatrix}<br>   1 &amp; 2 &amp; 3 \<br>   4 &amp; 5 &amp; 6 \<br>   7 &amp; 8 &amp; 9<br>  \end{bmatrix} \tag{1}<br>$$<br>先将其通过水平轴翻转得到：</p><p>$$<br> \begin{bmatrix}<br>   7 &amp; 8 &amp; 9 \<br>   4 &amp; 5 &amp; 6 \<br>   1 &amp; 2 &amp; 3<br>  \end{bmatrix} \tag{2}<br>$$  </p><p>再根据主对角线翻转得到：<br>$$<br> \begin{bmatrix}<br>   7 &amp; 4 &amp; 1 \<br>   8 &amp; 5 &amp; 2 \<br>   9 &amp; 6 &amp; 3<br>  \end{bmatrix} \tag{3}<br>$$  </p><p>这样就可以看出来了，clockwise旋转90°就相当于先水平翻转再根据主对角线翻转</p><p><a href="https://leetcode.cn/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[i][j],matrix[n-i-<span class="number">1</span>][j]=matrix[n-i-<span class="number">1</span>][j],matrix[i][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j],matrix[j][i]=matrix[j][i],matrix[i][j]   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> difference array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1094. Car Pooling(medium)</title>
      <link href="/2022/08/30/1094/"/>
      <url>/2022/08/30/1094/</url>
      
        <content type="html"><![CDATA[<h1 id="1094-Car-Pooling-medium"><a href="#1094-Car-Pooling-medium" class="headerlink" title="1094. Car Pooling(medium)"></a>1094. Car Pooling(medium)</h1><h2 id="There-is-a-car-with-capacity-empty-seats-The-vehicle-only-drives-east-i-e-it-cannot-turn-around-and-drive-west"><a href="#There-is-a-car-with-capacity-empty-seats-The-vehicle-only-drives-east-i-e-it-cannot-turn-around-and-drive-west" class="headerlink" title="There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west)."></a>There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).</h2><h2 id="You-are-given-the-integer-capacity-and-an-array-trips-where-trips-i-numPassengersi-fromi-toi-indicates-that-the-ith-trip-has-numPassengersi-passengers-and-the-locations-to-pick-them-up-and-drop-them-off-are-fromi-and-toi-respectively-The-locations-are-given-as-the-number-of-kilometers-due-east-from-the-car’s-initial-location"><a href="#You-are-given-the-integer-capacity-and-an-array-trips-where-trips-i-numPassengersi-fromi-toi-indicates-that-the-ith-trip-has-numPassengersi-passengers-and-the-locations-to-pick-them-up-and-drop-them-off-are-fromi-and-toi-respectively-The-locations-are-given-as-the-number-of-kilometers-due-east-from-the-car’s-initial-location" class="headerlink" title="You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car’s initial location."></a>You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car’s initial location.</h2><h2 id="Return-true-if-it-is-possible-to-pick-up-and-drop-off-all-passengers-for-all-the-given-trips-or-false-otherwise"><a href="#Return-true-if-it-is-possible-to-pick-up-and-drop-off-all-passengers-for-all-the-given-trips-or-false-otherwise" class="headerlink" title="Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise."></a>Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>差分数组经典题</p><h3 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/car-pooling/solution/1094-pin-che-python-chai-fen-shu-zu-by-f-yvh7/">leetcode题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">carPooling</span>(<span class="params">self, trips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], capacity: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 确定最多有几站-&gt;数组长度</span></span><br><span class="line">        stations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> change_list <span class="keyword">in</span> trips:</span><br><span class="line">            <span class="keyword">if</span> change_list[<span class="number">2</span>]+<span class="number">1</span> &gt; stations:</span><br><span class="line">                stations = change_list[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 原数组，不接客时每站人数</span></span><br><span class="line">        ori = [<span class="number">0</span>] * stations </span><br><span class="line">        <span class="comment"># 核心步骤1. 构造差分数组</span></span><br><span class="line">        diff = [<span class="number">0</span>] * stations</span><br><span class="line">        <span class="comment"># 核心步骤2. 差分数组记录修改</span></span><br><span class="line">        <span class="keyword">for</span> cnt, start, end <span class="keyword">in</span> trips:</span><br><span class="line">            diff[start] += cnt</span><br><span class="line">            <span class="comment"># diff下标为区间终点+1，因为修改区间为[start, end-1]，所以diff下表为end</span></span><br><span class="line">            <span class="keyword">if</span> end &lt; stations:</span><br><span class="line">                diff[end] -= cnt</span><br><span class="line">        <span class="comment"># 核心步骤3. 差分数组推出修改后的数组，并判断修改后的数组中是否有超载的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(stations):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                res_i_1 = <span class="number">0</span></span><br><span class="line">            res_i = res_i_1 + diff[i]   <span class="comment"># 第i站人数</span></span><br><span class="line">            res_i_1 = res_i</span><br><span class="line">            <span class="keyword">if</span> res_i &gt; capacity:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> difference array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1109. Corporate Flight Bookings(medium)</title>
      <link href="/2022/08/30/1109/"/>
      <url>/2022/08/30/1109/</url>
      
        <content type="html"><![CDATA[<h1 id="1109-Corporate-Flight-Bookings-medium"><a href="#1109-Corporate-Flight-Bookings-medium" class="headerlink" title="1109. Corporate Flight Bookings(medium)"></a>1109. Corporate Flight Bookings(medium)</h1><h2 id="There-are-n-flights-that-are-labeled-from-1-to-n"><a href="#There-are-n-flights-that-are-labeled-from-1-to-n" class="headerlink" title="There are n flights that are labeled from 1 to n."></a>There are n flights that are labeled from 1 to n.</h2><h2 id="You-are-given-an-array-of-flight-bookings-bookings-where-bookings-i-firsti-lasti-seatsi-represents-a-booking-for-flights-firsti-through-lasti-inclusive-with-seatsi-seats-reserved-for-each-flight-in-the-range"><a href="#You-are-given-an-array-of-flight-bookings-bookings-where-bookings-i-firsti-lasti-seatsi-represents-a-booking-for-flights-firsti-through-lasti-inclusive-with-seatsi-seats-reserved-for-each-flight-in-the-range" class="headerlink" title="You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range."></a>You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.</h2><h2 id="Return-an-array-answer-of-length-n-where-answer-i-is-the-total-number-of-seats-reserved-for-flight-i"><a href="#Return-an-array-answer-of-length-n-where-answer-i-is-the-total-number-of-seats-reserved-for-flight-i" class="headerlink" title="Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i."></a>Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.</h2><p>这道题又是一个标准的差分数组题，与370题几乎一模一样，差别在于length是0-4还是1-5</p><pre><code class="python">class Solution:    def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]:        res = [0]*(n+1)        for booking in bookings:            start,end,v = booking            s=start-1            e=end-1                        res[s]+=v            res[e+1]-=v        for i in range(1,n):            res[i] += res[i-1]        return res[:-1]</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> difference array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>370. Range Addition(medium)</title>
      <link href="/2022/08/30/370/"/>
      <url>/2022/08/30/370/</url>
      
        <content type="html"><![CDATA[<h1 id="370-Range-Addition-medium"><a href="#370-Range-Addition-medium" class="headerlink" title="370. Range Addition(medium)"></a>370. Range Addition(medium)</h1><h2 id="You-are-given-an-integer-length-and-an-array-updates-where-updates-i-startIdxi-endIdxi-inci"><a href="#You-are-given-an-integer-length-and-an-array-updates-where-updates-i-startIdxi-endIdxi-inci" class="headerlink" title="You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci]."></a>You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].</h2><h2 id="You-have-an-array-arr-of-length-length-with-all-zeros-and-you-have-some-operation-to-apply-on-arr-In-the-ith-operation-you-should-increment-all-the-elements-arr-startIdxi-arr-startIdxi-1-…-arr-endIdxi-by-inci"><a href="#You-have-an-array-arr-of-length-length-with-all-zeros-and-you-have-some-operation-to-apply-on-arr-In-the-ith-operation-you-should-increment-all-the-elements-arr-startIdxi-arr-startIdxi-1-…-arr-endIdxi-by-inci" class="headerlink" title="You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], …, arr[endIdxi] by inci."></a>You have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], …, arr[endIdxi] by inci.</h2><h2 id="Return-arr-after-applying-all-the-updates"><a href="#Return-arr-after-applying-all-the-updates" class="headerlink" title="Return arr after applying all the updates."></a>Return arr after applying all the updates.</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]</span><br><span class="line">Output: [-2,0,3,5,3]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/range-addition/discuss/84220/O(n%2Bk)-Python-Solution">leetcode题解</a></p><p>差分数组经典题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = [<span class="number">0</span>]*length</span><br><span class="line">        <span class="keyword">for</span> update <span class="keyword">in</span> updates:</span><br><span class="line">            start, end, inc = update</span><br><span class="line">            res[start]+=inc</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> end+<span class="number">1</span>&lt;=length -<span class="number">1</span>:<span class="comment">#if endIdx + 1 is not out of range. If it is out of range, we don&#x27;t do anything</span></span><br><span class="line">                res[end+<span class="number">1</span>]-=inc</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="built_in">sum</span>+= res[i]</span><br><span class="line">            res[i]=<span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>其实这个方法并不是差分数组，还是前缀和数组，也就是说差分数组和前缀和数组可以相互替换？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getModifiedArray</span>(<span class="params">self, length: <span class="built_in">int</span>, updates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = [<span class="number">0</span>] * (length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> s, e, v <span class="keyword">in</span> updates:</span><br><span class="line">            res[s] += v</span><br><span class="line">            res[e+<span class="number">1</span>] -= v</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):<span class="comment">#加上前面的数字</span></span><br><span class="line">            res[i] += res[i-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[:-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
            <tag> difference array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill6-stack</title>
      <link href="/2022/08/30/LeetCode-skill6-stack/"/>
      <url>/2022/08/30/LeetCode-skill6-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1. 栈的定义"></a>1. 栈的定义</h1><p>栈是一种先进后出（FILO: First In Last Out,）的线性结构，即压栈和弹栈均在栈的尾部完成。<br>压栈：即栈添加成员，在栈的尾部完成<br>弹栈：即栈删除成员，在栈的尾部完成<br>在创建栈时，如果以数组的数据结构为基础时，以数组的尾部为栈的尾部；<br>在创建栈时，如果以链表的数据结构为基础时，以链表的头部为栈的尾部；</p><h1 id="2-栈的功能成员函数"><a href="#2-栈的功能成员函数" class="headerlink" title="2. 栈的功能成员函数"></a>2. 栈的功能成员函数</h1><p>push(): 在栈的尾部添加成员<br>pop(): 在栈的尾部删除成员<br>top(): 返回栈的头部成员<br>is_Empty(): 检测栈是否为空，若为空，则返回True， 否则返回False<br>length(): 返回栈的成员数量<br>travel(): 遍历栈的所有成员</p><h2 id="常见栈的函数操作包括"><a href="#常见栈的函数操作包括" class="headerlink" title="常见栈的函数操作包括"></a>常见栈的函数操作包括</h2><p>empty() – 返回栈是否为空 – Time Complexity : O(1)</p><p>size() – 返回栈的长度 – Time Complexity : O(1)</p><p>top() – 查看栈顶元素 – Time Complexity : O(1)</p><p>push(g) – 向栈顶添加元素 – Time Complexity : O(1)</p><p>pop() – 删除栈顶元素 – Time Complexity : O(1)</p><p>python中栈可以用以下三种方法实现：</p><p>１)list</p><p>２)collections.deque</p><p>３)queue.LifoQueue</p><p>使用列表实现栈</p><p>python的内置数据结构list可以用来实现栈，用append()向栈顶添加元素, pop() 可以以后进先出的顺序删除元素</p><p>但是列表本身有一些缺点，主要问题就是当列表不断扩大的时候会遇到速度瓶颈．列表是动态数组，因此往其中添加新元素而没有空间保存新的元素时，它会自动重新分配内存块，并将原来的内存中的值复制到新的内存块中．这就导致了一些append()操作会消耗更多的时间</p><p>使用collections.deque实现栈</p><p>python中栈也可以用deque类实现，当我们想要在实现在容器两端更快速地进行append和pop操作时，deque比列表更合适．deque可以提供O(1)时间的append和pop操作，而列表则需要O(n)时间.</p><p>使用queue module实现栈</p><p>Queue模块有LIFO queue，也就是栈结构．用put()和get()操作从Queue中添加和获得数据</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> prefix sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses(easy)</title>
      <link href="/2022/08/30/20/"/>
      <url>/2022/08/30/20/</url>
      
        <content type="html"><![CDATA[<h1 id="20-Valid-Parentheses-easy"><a href="#20-Valid-Parentheses-easy" class="headerlink" title="20. Valid Parentheses(easy)"></a>20. Valid Parentheses(easy)</h1><h2 id="Given-a-string-s-containing-just-the-characters-‘-‘-‘-’-‘-‘-‘-’-‘-‘-and-‘-’-determine-if-the-input-string-is-valid"><a href="#Given-a-string-s-containing-just-the-characters-‘-‘-‘-’-‘-‘-‘-’-‘-‘-and-‘-’-determine-if-the-input-string-is-valid" class="headerlink" title="Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid."></a>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</h2><h2 id="An-input-string-is-valid-if"><a href="#An-input-string-is-valid-if" class="headerlink" title="An input string is valid if:"></a>An input string is valid if:</h2><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></li></ol><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/">官方题解</a></h3><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><p><a href="https://leetcode.cn/problems/valid-parentheses/solution/valid-parentheses-fu-zhu-zhan-fa-by-jin407891080/">题解1</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        dic = &#123;<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,  <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> dic[stack.pop()] != c: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/">题解2</a>        </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pairs = &#123;</span><br><span class="line">            <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">            <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != pairs[ch]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill5-difference-array</title>
      <link href="/2022/08/29/LeetCode-skill5-difference-array/"/>
      <url>/2022/08/29/LeetCode-skill5-difference-array/</url>
      
        <content type="html"><![CDATA[<p>本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</p><p>比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给…</p><p>一通操作猛如虎，然后问你，最后 nums 数组的值是什么？</p><p>常规的思路很容易，你让我给区间 nums[i..j] 加上 val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改非常频繁，所以效率会很低下。</p><p>这里就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这个 diff 差分数组是可以反推出原始数组 nums 的，代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了？</p><p>只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果。</p><p>现在我们把差分数组抽象成一个类，包含 increment 方法和 result 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.diff = self.make_diff(self.nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_diff</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        diff = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            diff[i] = nums[i] - nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> diff</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给闭区间[i,j]增加val</span></span><br><span class="line">    <span class="comment"># 原理很简单，回想diff数组反推nums数组的过程，diff[i] += 3意味着给nums[i..]所有的元素都加了 3，然后diff[j+1] -= 3又意味着对于nums[j+1..]所有元素再减 3，那综合起来，是不是就是对nums[i..j]中的所有元素都加 3 了？</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span>(<span class="params">self, i, j, val</span>):</span></span><br><span class="line">        self.diff[i] += val</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt; <span class="built_in">len</span>(self.diff):</span><br><span class="line">            self.diff[j + <span class="number">1</span>] -= val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span>(<span class="params">self</span>):</span></span><br><span class="line">        rdiff = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.diff))]</span><br><span class="line">        rdiff[<span class="number">0</span>] = self.diff[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(self.nums)):</span><br><span class="line">            rdiff[i] = rdiff[i-<span class="number">1</span>] + self.diff[i]</span><br><span class="line">        <span class="keyword">return</span> rdiff</span><br></pre></td></tr></table></figure><p>difference = Difference([8,5,9,6,1])<br>print(difference.diff)<br>rdiff = difference.recover()<br>print(rdiff)<br>difference.increment(2,3,1)<br>print(difference.diff)<br>rdiff = difference.recover()<br>print(rdiff)</p><hr><p>【python刷题】差分数组<br><a href="https://blog.51cto.com/u_15127632/3275175">https://blog.51cto.com/u_15127632/3275175</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> difference array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode15-DFS</title>
      <link href="/2022/08/29/LeetCode15-DFS/"/>
      <url>/2022/08/29/LeetCode15-DFS/</url>
      
        <content type="html"><![CDATA[<p>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。</p><p>本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。</p><p>在 LeetCode 中，「岛屿问题」是一个系列系列问题，比如：</p><p>L200. 岛屿数量 （Easy）<br>463. 岛屿的周长 （Easy）<br>695. 岛屿的最大面积 （Medium）<br>827. 最大人工岛 （Hard）</p><p>作者：nettee<br>链接：<a href="https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode14-BFS</title>
      <link href="/2022/08/29/LeetCode14-BFS/"/>
      <url>/2022/08/29/LeetCode14-BFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring(medium)</title>
      <link href="/2022/08/29/5/"/>
      <url>/2022/08/29/5/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Longest-Palindromic-Substring-medium"><a href="#5-Longest-Palindromic-Substring-medium" class="headerlink" title="5. Longest Palindromic Substring(medium)"></a>5. Longest Palindromic Substring(medium)</h1><h2 id="Given-a-string-s-return-the-longest-palindromic-substring-in-s"><a href="#Given-a-string-s-return-the-longest-palindromic-substring-in-s" class="headerlink" title="Given a string s, return the longest palindromic substring in s."></a>Given a string s, return the longest palindromic substring in s.</h2><p>substring和subsequence：<br>substring是子串。例如，‘wee’ 是 ‘helloween’的substring，‘hwn’ 不是 ‘helloween’的substring。取子串的时候不能隔着字符取。<br>subsequence是子序列。例如，‘wee’ 和 ‘hwn’ 都是 ‘helloween’的subsequence。取子序列的时候可以隔着字符取。<br>palindromic substring 是回文子串，例如‘soebeos’ 是 ‘absoebeostge’ 的回文子串。回文的意思是正过来念和反过来念都一样的字符串，比如“上海自来水来自海上”。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            left1, right1 = self.expandAroundCenter(s, i, i)</span><br><span class="line">            left2, right2 = self.expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> right1 - left1 &gt; end - start:</span><br><span class="line">                start, end = left1, right1</span><br><span class="line">            <span class="keyword">if</span> right2 - left2 &gt; end - start:</span><br><span class="line">                start, end = left2, right2</span><br><span class="line">        <span class="keyword">return</span> s[start: end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344. Reverse String(easy)</title>
      <link href="/2022/08/29/344/"/>
      <url>/2022/08/29/344/</url>
      
        <content type="html"><![CDATA[<h1 id="344-Reverse-String-easy"><a href="#344-Reverse-String-easy" class="headerlink" title="344. Reverse String(easy)"></a>344. Reverse String(easy)</h1><h2 id="Write-a-function-that-reverses-a-string-The-input-string-is-given-as-an-array-of-characters-s"><a href="#Write-a-function-that-reverses-a-string-The-input-string-is-given-as-an-array-of-characters-s" class="headerlink" title="Write a function that reverses a string. The input string is given as an array of characters s."></a>Write a function that reverses a string. The input string is given as an array of characters s.</h2><h2 id="You-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory"><a href="#You-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory" class="headerlink" title="You must do this by modifying the input array in-place with O(1) extra memory."></a>You must do this by modifying the input array in-place with O(1) extra memory.</h2><p>反转字符串，其实还是反转数组，双指针一左一右来回替换就行了，要注意的是在本体上变换</p><pre><code class="python">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        left = 0        right = len(s)-1        while left&lt;right:            tmp =s[left]            s[left]=s[right]            s[right]=tmp            left+=1            right-=1</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. Binary Search(easy)</title>
      <link href="/2022/08/29/704/"/>
      <url>/2022/08/29/704/</url>
      
        <content type="html"><![CDATA[<h1 id="704-Binary-Search-easy"><a href="#704-Binary-Search-easy" class="headerlink" title="704. Binary Search(easy)"></a>704. Binary Search(easy)</h1><h2 id="Given-an-array-of-integers-nums-which-is-sorted-in-ascending-order-and-an-integer-target-write-a-function-to-search-target-in-nums-If-target-exists-then-return-its-index-Otherwise-return-1"><a href="#Given-an-array-of-integers-nums-which-is-sorted-in-ascending-order-and-an-integer-target-write-a-function-to-search-target-in-nums-If-target-exists-then-return-its-index-Otherwise-return-1" class="headerlink" title="Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1."></a>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 9 exists in nums and its index is 4</span><br></pre></td></tr></table></figure><p>二分查找模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left =<span class="number">0</span></span><br><span class="line">        right=<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right):</span><br><span class="line">            mid =left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">                right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode13-Array</title>
      <link href="/2022/08/29/LeetCode13-Array/"/>
      <url>/2022/08/29/LeetCode13-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="Python3-二维数组，三维数组，多维数组的创建"><a href="#Python3-二维数组，三维数组，多维数组的创建" class="headerlink" title="Python3 二维数组，三维数组，多维数组的创建"></a>Python3 二维数组，三维数组，多维数组的创建</h1><h3 id="二维数组的创建："><a href="#二维数组的创建：" class="headerlink" title="二维数组的创建："></a>二维数组的创建：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3行10列的二维数组的创建：</span></span><br><span class="line">m = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">m = [[<span class="number">0</span>] * <span class="number">3</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们来检查一下数组创建的对不对</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] != <span class="number">0</span>):  <span class="built_in">print</span>(i, j)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(i, j, <span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="comment">#没有输出error有关的东西，正确！</span></span><br></pre></td></tr></table></figure><h3 id="三维数组的创建："><a href="#三维数组的创建：" class="headerlink" title="三维数组的创建："></a>三维数组的创建：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#4行3列，Z = 2的三维数组的创建：</span></span><br><span class="line">m = [[[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">m = [[[<span class="number">0</span>] * <span class="number">2</span>] * <span class="number">3</span>] * <span class="number">4</span></span><br><span class="line"><span class="comment">#检查：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> (m[i][j][k] != <span class="number">0</span>):   <span class="built_in">print</span>(i, j, k);</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(i, j, k, <span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="comment">#没有输出error有关的东西，正确！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来多维数组的创建也就很简单了</span></span><br><span class="line"><span class="comment">#m = [.....[[0] * q] * w] * e]*r]*t]*y]*u]*.........]</span></span><br></pre></td></tr></table></figure><h1 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1. 快慢指针"></a>1. 快慢指针</h1><h1 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2. 左右指针"></a>2. 左右指针</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h1 id="Leetcode-题解-二分查找"><a href="#Leetcode-题解-二分查找" class="headerlink" title="Leetcode 题解 - 二分查找"></a>Leetcode 题解 - 二分查找</h1><h2 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h2><h2 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h2><h2 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h2><h2 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h2><h2 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h2><h2 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h2><p>二分查找 binary search algorithm</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="m-计算"><a href="#m-计算" class="headerlink" title="m 计算"></a>m 计算</h2><p>有两种计算中值 m 的方式：</p><p>m = (l + h) / 2<br>m = l + (h - l) / 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p><h2 id="未成功查找的返回值"><a href="#未成功查找的返回值" class="headerlink" title="未成功查找的返回值"></a>未成功查找的返回值</h2><p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p><p>-1：以一个错误码表示没有查找到 key<br>l：将 key 插入到 nums 中的正确位置</p><p>模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left =<span class="number">0</span></span><br><span class="line">        right=<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right):</span><br><span class="line">            mid =left+(right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;target:</span><br><span class="line">                left=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&gt;target:</span><br><span class="line">                right = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1:</span><br><span class="line">   执行语句1……</span><br><span class="line">elif 判断条件2:</span><br><span class="line">   执行语句2……</span><br><span class="line">elif 判断条件3:</span><br><span class="line">   执行语句3……</span><br><span class="line">else:</span><br><span class="line">   执行语句4……</span><br></pre></td></tr></table></figure><p>print(a[0:-1])<br>python array:<br>从位置0到位置-1之前的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面两个结果一样</span></span><br><span class="line">a = <span class="string">&#x27;1234568910’</span></span><br><span class="line"><span class="string">print(a[:-1])   </span></span><br><span class="line"><span class="string">print(a[0:-1])</span></span><br><span class="line"><span class="string">#result:a = &#x27;</span><span class="number">123456891</span>’</span><br><span class="line"><span class="comment">#result:a = &#x27;123456891’</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. Move Zeroes(easy)</title>
      <link href="/2022/08/29/283/"/>
      <url>/2022/08/29/283/</url>
      
        <content type="html"><![CDATA[<h1 id="283-Move-Zeroes-easy"><a href="#283-Move-Zeroes-easy" class="headerlink" title="283. Move Zeroes(easy)"></a>283. Move Zeroes(easy)</h1><h2 id="Given-an-integer-array-nums-move-all-0’s-to-the-end-of-it-while-maintaining-the-relative-order-of-the-non-zero-elements"><a href="#Given-an-integer-array-nums-move-all-0’s-to-the-end-of-it-while-maintaining-the-relative-order-of-the-non-zero-elements" class="headerlink" title="Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements."></a>Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</h2><h2 id="Note-that-you-must-do-this-in-place-without-making-a-copy-of-the-array"><a href="#Note-that-you-must-do-this-in-place-without-making-a-copy-of-the-array" class="headerlink" title="Note that you must do this in-place without making a copy of the array."></a>Note that you must do this in-place without making a copy of the array.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p>这道题和26. Remove Duplicates from Sorted Array(easy) 差不多，还是双指针，重复数字改成了0，把非零数字写入数组前面，然后空位补0</p><pre><code class="python">class Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        slow = 0        fast = 0        while fast&lt;len(nums):            if nums[fast]!=0:                nums[slow]=nums[fast]                slow+=1                            fast+=1        if slow&lt;len(nums):            for i in range(slow,len(nums)):                nums[i]=0        return nums</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. Remove Element(easy)</title>
      <link href="/2022/08/29/27/"/>
      <url>/2022/08/29/27/</url>
      
        <content type="html"><![CDATA[<h1 id="27-Remove-Element-easy"><a href="#27-Remove-Element-easy" class="headerlink" title="27. Remove Element(easy)"></a>27. Remove Element(easy)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-val-remove-all-occurrences-of-val-in-nums-in-place-The-relative-order-of-the-elements-may-be-changed"><a href="#Given-an-integer-array-nums-and-an-integer-val-remove-all-occurrences-of-val-in-nums-in-place-The-relative-order-of-the-elements-may-be-changed" class="headerlink" title="Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed."></a>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.</h2><h2 id="Since-it-is-impossible-to-change-the-length-of-the-array-in-some-languages-you-must-instead-have-the-result-be-placed-in-the-first-part-of-the-array-nums-More-formally-if-there-are-k-elements-after-removing-the-duplicates-then-the-first-k-elements-of-nums-should-hold-the-final-result-It-does-not-matter-what-you-leave-beyond-the-first-k-elements"><a href="#Since-it-is-impossible-to-change-the-length-of-the-array-in-some-languages-you-must-instead-have-the-result-be-placed-in-the-first-part-of-the-array-nums-More-formally-if-there-are-k-elements-after-removing-the-duplicates-then-the-first-k-elements-of-nums-should-hold-the-final-result-It-does-not-matter-what-you-leave-beyond-the-first-k-elements" class="headerlink" title="Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements."></a>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</h2><h2 id="Return-k-after-placing-the-final-result-in-the-first-k-slots-of-nums"><a href="#Return-k-after-placing-the-final-result-in-the-first-k-slots-of-nums" class="headerlink" title="Return k after placing the final result in the first k slots of nums."></a>Return k after placing the final result in the first k slots of nums.</h2><h2 id="Do-not-allocate-extra-space-for-another-array-You-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory"><a href="#Do-not-allocate-extra-space-for-another-array-You-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory" class="headerlink" title="Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."></a>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</h2><h2 id="Custom-Judge"><a href="#Custom-Judge" class="headerlink" title="Custom Judge:"></a>Custom Judge:</h2><h2 id="The-judge-will-test-your-solution-with-the-following-code"><a href="#The-judge-will-test-your-solution-with-the-following-code" class="headerlink" title="The judge will test your solution with the following code:"></a>The judge will test your solution with the following code:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // Input array</span><br><span class="line">int[] expectedNums = [...]; // The expected answer with correct length</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // Calls your implementation</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="If-all-assertions-pass-then-your-solution-will-be-accepted"><a href="#If-all-assertions-pass-then-your-solution-will-be-accepted" class="headerlink" title="If all assertions pass, then your solution will be accepted."></a>If all assertions pass, then your solution will be accepted.</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2,_,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 2.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>这道题和26. Remove Duplicates from Sorted Array(easy)几乎一模一样，其实数组是否有序没有任何影响，所以设置快慢指针可解决问题，慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不相同的元素就赋值给 slow 并让 slow 前进一步。这样，就保证了 nums[0..slow] 都是不相同的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组不相同val之后的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        slow, fast=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast]!=val:</span><br><span class="line">                nums[slow]=nums[fast]</span><br><span class="line">                slow+=<span class="number">1</span></span><br><span class="line">            fast+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. Remove Duplicates from Sorted Array(easy)</title>
      <link href="/2022/08/29/26/"/>
      <url>/2022/08/29/26/</url>
      
        <content type="html"><![CDATA[<h1 id="26-Remove-Duplicates-from-Sorted-Array-easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-easy" class="headerlink" title="26. Remove Duplicates from Sorted Array(easy)"></a>26. Remove Duplicates from Sorted Array(easy)</h1><h2 id="Given-an-integer-array-nums-sorted-in-non-decreasing-order-remove-the-duplicates-in-place-such-that-each-unique-element-appears-only-once-The-relative-order-of-the-elements-should-be-kept-the-same"><a href="#Given-an-integer-array-nums-sorted-in-non-decreasing-order-remove-the-duplicates-in-place-such-that-each-unique-element-appears-only-once-The-relative-order-of-the-elements-should-be-kept-the-same" class="headerlink" title="Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same."></a>Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.</h2><h2 id="Since-it-is-impossible-to-change-the-length-of-the-array-in-some-languages-you-must-instead-have-the-result-be-placed-in-the-first-part-of-the-array-nums-More-formally-if-there-are-k-elements-after-removing-the-duplicates-then-the-first-k-elements-of-nums-should-hold-the-final-result-It-does-not-matter-what-you-leave-beyond-the-first-k-elements"><a href="#Since-it-is-impossible-to-change-the-length-of-the-array-in-some-languages-you-must-instead-have-the-result-be-placed-in-the-first-part-of-the-array-nums-More-formally-if-there-are-k-elements-after-removing-the-duplicates-then-the-first-k-elements-of-nums-should-hold-the-final-result-It-does-not-matter-what-you-leave-beyond-the-first-k-elements" class="headerlink" title="Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements."></a>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</h2><h2 id="Return-k-after-placing-the-final-result-in-the-first-k-slots-of-nums"><a href="#Return-k-after-placing-the-final-result-in-the-first-k-slots-of-nums" class="headerlink" title="Return k after placing the final result in the first k slots of nums."></a>Return k after placing the final result in the first k slots of nums.</h2><h2 id="Do-not-allocate-extra-space-for-another-array-You-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory"><a href="#Do-not-allocate-extra-space-for-another-array-You-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory" class="headerlink" title="Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."></a>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</h2><h2 id="Custom-Judge"><a href="#Custom-Judge" class="headerlink" title="Custom Judge:"></a>Custom Judge:</h2><h2 id="The-judge-will-test-your-solution-with-the-following-code"><a href="#The-judge-will-test-your-solution-with-the-following-code" class="headerlink" title="The judge will test your solution with the following code:"></a>The judge will test your solution with the following code:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // Input array</span><br><span class="line">int[] expectedNums = [...]; // The expected answer with correct length</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // Calls your implementation</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="If-all-assertions-pass-then-your-solution-will-be-accepted"><a href="#If-all-assertions-pass-then-your-solution-will-be-accepted" class="headerlink" title="If all assertions pass, then your solution will be accepted."></a>If all assertions pass, then your solution will be accepted.</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: 2, nums = [1,2,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>这道题并不难，因为只能在原数组上操作，所以设置快慢指针可解决问题，慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让 slow 前进一步。这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果</p><pre><code class="python">class Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        if len(nums)==0:            return 0        slow = 0        fast = 0        while fast&lt;len(nums):            if nums[fast]!=nums[slow]:                slow+=1                nums[slow]=nums[fast]            fast+=1        return slow+1</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill4-python-loop</title>
      <link href="/2022/08/28/LeetCode-skill4-python-loop/"/>
      <url>/2022/08/28/LeetCode-skill4-python-loop/</url>
      
        <content type="html"><![CDATA[<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>for i in range(n)</p><p>range(n)输出的区间为 [ 0 , n − 1 ]，代码如下</p><p>for i in range(5):<br>    print(i)</p><p>输出结果为：0, 1, 2, 3, 4</p><p>for i in range(m, n)</p><p>range(m, n)输出的区间为 [ m , n − 1 ] [m, n - 1][m,n−1]，代码如下</p><p>for i in range(2, 5):<br>    print(i)</p><p>输出结果为： 2, 3, 4</p><p>for i in range(m, n, s)</p><p>参数m,n为左右边界，s为步长<br>range(m, n, s)输出的区间为 ( m , m + s , m + 2 s , ⋯   , n − k s ) (m, m + s, m + 2s, \cdots , n - ks)(m,m+s,m+2s,⋯,n−ks)，代码如下</p><p>for i in range(1,7,2):<br>    print(i)</p><p>输出结果为：1, 3，5</p><p>for _ in range()</p><p>_是一个变量（因为Python中的变量命名能够以下划线开始，单独的下划线也是一个变量），跟i一样，不同点在于，i会在后续的循环体中运用到，而_只是用来实现循环的次数。（因为基本上不会使用单独的下划线来用作变量传值）</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. Reverse Nodes in k-Group(hard)</title>
      <link href="/2022/08/28/25/"/>
      <url>/2022/08/28/25/</url>
      
        <content type="html"><![CDATA[<h1 id="25-Reverse-Nodes-in-k-Group-hard"><a href="#25-Reverse-Nodes-in-k-Group-hard" class="headerlink" title="25. Reverse Nodes in k-Group(hard)"></a>25. Reverse Nodes in k-Group(hard)</h1><h2 id="Given-the-head-of-a-linked-list-reverse-the-nodes-of-the-list-k-at-a-time-and-return-the-modified-list"><a href="#Given-the-head-of-a-linked-list-reverse-the-nodes-of-the-list-k-at-a-time-and-return-the-modified-list" class="headerlink" title="Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list."></a>Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.</h2><h2 id="k-is-a-positive-integer-and-is-less-than-or-equal-to-the-length-of-the-linked-list-If-the-number-of-nodes-is-not-a-multiple-of-k-then-left-out-nodes-in-the-end-should-remain-as-it-is"><a href="#k-is-a-positive-integer-and-is-less-than-or-equal-to-the-length-of-the-linked-list-If-the-number-of-nodes-is-not-a-multiple-of-k-then-left-out-nodes-in-the-end-should-remain-as-it-is" class="headerlink" title="k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is."></a>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</h2><h2 id="You-may-not-alter-the-values-in-the-list’s-nodes-only-nodes-themselves-may-be-changed"><a href="#You-may-not-alter-the-values-in-the-list’s-nodes-only-nodes-themselves-may-be-changed" class="headerlink" title="You may not alter the values in the list’s nodes, only nodes themselves may be changed."></a>You may not alter the values in the list’s nodes, only nodes themselves may be changed.</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], k = 2</span><br><span class="line">Output: [2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.github.io/algo/images/kgroup/8.gif"></p><p>我们要实现一个 reverse 函数反转一个区间之内的元素。在此之前我们再简化一下，给定链表头结点，如何反转整个链表？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转以 a 为头结点的链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode a)</span> </span>&#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="keyword">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        <span class="comment">// 逐个结点反转</span></span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="comment">// 更新指针位置</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次使用迭代思路来实现的，借助动画理解应该很容易。</p><p>「反转以 a 为头结点的链表」其实就是「反转 a 到 null 之间的结点」，那么如果让你「反转 a 到 b 之间的结点」，你会不会？</p><p>只要更改函数签名，并把上面的代码中 null 改成 b 即可：<br>Java原版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 反转区间 [a, b) 的元素，注意是左闭右开 */</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">    ListNode pre, cur, nxt;</span><br><span class="line">    pre = <span class="keyword">null</span>; cur = a; nxt = a;</span><br><span class="line">    <span class="comment">// while 终止的条件改一下就行了</span></span><br><span class="line">    <span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">        nxt = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 改版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    pre= <span class="literal">None</span></span><br><span class="line">    current =a</span><br><span class="line">    nxt=a</span><br><span class="line">    <span class="keyword">while</span> (current!=b):</span><br><span class="line">        nxt = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = current</span><br><span class="line">        current = nxt</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们迭代实现了反转部分链表的功能，接下来就按照之前的逻辑编写 reverseKGroup 函数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    ListNode newHead = reverse(a, b);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 完整版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">a,b</span>):</span></span><br><span class="line">            pre= <span class="literal">None</span></span><br><span class="line">            current =a</span><br><span class="line">            nxt=a</span><br><span class="line">            <span class="keyword">while</span> (current!=b):</span><br><span class="line">                nxt = current.<span class="built_in">next</span></span><br><span class="line">                current.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = current</span><br><span class="line">                current = nxt</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        a= head</span><br><span class="line">        b = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">if</span> b ==<span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            b=b.<span class="built_in">next</span></span><br><span class="line">        newHead = reverse(a,b)</span><br><span class="line">        a.<span class="built_in">next</span> = self.reverseKGroup(b,k)</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>92. Reverse Linked List II(medium)</title>
      <link href="/2022/08/27/92/"/>
      <url>/2022/08/27/92/</url>
      
        <content type="html"><![CDATA[<h1 id="92-Reverse-Linked-List-II-medium"><a href="#92-Reverse-Linked-List-II-medium" class="headerlink" title="92. Reverse Linked List II(medium)"></a>92. Reverse Linked List II(medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-and-two-integers-left-and-right-where-left-lt-right-reverse-the-nodes-of-the-list-from-position-left-to-position-right-and-return-the-reversed-list"><a href="#Given-the-head-of-a-singly-linked-list-and-two-integers-left-and-right-where-left-lt-right-reverse-the-nodes-of-the-list-from-position-left-to-position-right-and-return-the-reversed-list" class="headerlink" title="Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list."></a>Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        dummy_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>第一步<br><img src="https://pic.leetcode-cn.com/1615105296-bmiPxl-image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步<br><img src="https://pic.leetcode-cn.com/1615105340-UBnTBZ-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. Linked List Cycle II(medium)</title>
      <link href="/2022/08/27/142/"/>
      <url>/2022/08/27/142/</url>
      
        <content type="html"><![CDATA[<h1 id="142-Linked-List-Cycle-II-medium"><a href="#142-Linked-List-Cycle-II-medium" class="headerlink" title="142. Linked List Cycle II(medium)"></a>142. Linked List Cycle II(medium)</h1><h3 id="快慢指针-leetcode题解"><a href="#快慢指针-leetcode题解" class="headerlink" title="快慢指针-leetcode题解"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">快慢指针-leetcode题解</a></h3><p><img src="https://cdn.staticaly.com/gh/upuphero/image-hosting@master/142_fig1.4mi7jkj5o2g0.webp" alt="142"></p><p>思路与算法</p><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 bb 的距离与 fast 相遇。此时，fast 指针已经走完了环的 nn 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。</p><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有</p><p>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)</p><p>a=c+(n−1)(b+c)<br>有了 a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                ptr = head</span><br><span class="line">                <span class="keyword">while</span> ptr!=slow:</span><br><span class="line">                    ptr=ptr.<span class="built_in">next</span></span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> ptr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill3-python-if</title>
      <link href="/2022/08/27/LeetCode-skill3-python-if/"/>
      <url>/2022/08/27/LeetCode-skill3-python-if/</url>
      
        <content type="html"><![CDATA[<h1 id="if基本语句"><a href="#if基本语句" class="headerlink" title="if基本语句"></a>if基本语句</h1><h2 id="if-语句的判断条件可以用-gt-（大于）、-lt-小于-、-（等于）、-gt-（大于等于）、-lt-（小于等于）来表示其关系"><a href="#if-语句的判断条件可以用-gt-（大于）、-lt-小于-、-（等于）、-gt-（大于等于）、-lt-（小于等于）来表示其关系" class="headerlink" title="if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系"></a>if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> 判断条件：</span><br><span class="line">   执行语句……</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">   执行语句……</span><br><span class="line">‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’</span><br><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">   执行语句<span class="number">1</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">   执行语句<span class="number">2</span>……</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">   执行语句<span class="number">3</span>……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   执行语句<span class="number">4</span>……</span><br></pre></td></tr></table></figure><h1 id="if-or-and"><a href="#if-or-and" class="headerlink" title="if or/and"></a>if or/and</h1><h2 id="如果判断需要多个条件需同时判断时，可以使用-or-（或），表示两个条件有一个成立时判断条件成功；使用-and-（与）时，表示只有两个条件同时成立的情况下，判断条件才成功"><a href="#如果判断需要多个条件需同时判断时，可以使用-or-（或），表示两个条件有一个成立时判断条件成功；使用-and-（与）时，表示只有两个条件同时成立的情况下，判断条件才成功" class="headerlink" title="如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功"></a>如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.detail_image_tip.exists() <span class="keyword">or</span> self.open_long_atlas.exists():</span><br><span class="line">  logger.info(<span class="string">&#x27;当前作品不支持相关推荐展示&#x27;</span>)</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;up&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line">  logger.info(<span class="string">&#x27;上滑一个作品&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  logger.info(<span class="string">&#x27;当前作品支持相关推荐展示&#x27;</span>)</span><br><span class="line"><span class="comment">#or 两个元素只要有一个为True 那么这个判断就为True 两个元素判断都为Flase才为False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.link_icon.exists() <span class="keyword">and</span> self.hot_live.exists():</span><br><span class="line">  logger.info(<span class="string">&#x27;当前作品不是普通作品&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  logger.info(<span class="string">&#x27;当前作品普通作品&#x27;</span>)</span><br><span class="line"><span class="comment">#and 当前两个元素都存在为True时 if判断为True  一个为False 那么if判断就为False</span></span><br></pre></td></tr></table></figure><h1 id="not"><a href="#not" class="headerlink" title="not"></a>not</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.comment_frame.exists() <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#is not True的意思是当元素判断不为True的时候 if的判断为True 走True的部分不走else的部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> number &gt; <span class="number">6</span>:</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;down&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;up&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#not的意思是 if判断当number不大于6时(也就是&lt;=6) 那么走if的True的部分</span></span><br><span class="line"><span class="comment">#这样的好处就是不用去特地写else的部分</span></span><br><span class="line"><span class="comment">#如下：</span></span><br><span class="line"><span class="keyword">if</span>  number &gt; <span class="number">6</span>:</span><br><span class="line">  <span class="built_in">print</span>(‘当前number大于<span class="number">6</span>’)</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;down&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;up&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#有的同学就会说那我写&lt;=6不行吗</span></span><br><span class="line"><span class="keyword">if</span>  number &lt;= <span class="number">6</span>:</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;down&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line">  self.swipeByCount(<span class="string">&quot;up&quot;</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#也可以这么写 但是我在定义这个函数的时候实际目的是找大于6条的评论 所以not number &gt; 6会更清晰 看个人习惯了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">number_of_folds</span>(<span class="params">self</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  判断折叠评论数量大于6条</span></span><br><span class="line"><span class="string">  :return:</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="if-缩写"><a href="#if-缩写" class="headerlink" title="if 缩写"></a>if 缩写</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> A:</span><br><span class="line">    A =A.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    A= headB</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> if </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876. Middle of the Linked List(easy)</title>
      <link href="/2022/08/27/876/"/>
      <url>/2022/08/27/876/</url>
      
        <content type="html"><![CDATA[<h1 id="876-Middle-of-the-Linked-List-easy"><a href="#876-Middle-of-the-Linked-List-easy" class="headerlink" title="876. Middle of the Linked List(easy)"></a>876. Middle of the Linked List(easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-return-the-middle-node-of-the-linked-list"><a href="#Given-the-head-of-a-singly-linked-list-return-the-middle-node-of-the-linked-list" class="headerlink" title="Given the head of a singly linked list, return the middle node of the linked list."></a>Given the head of a singly linked list, return the middle node of the linked list.</h2><h2 id="If-there-are-two-middle-nodes-return-the-second-middle-node"><a href="#If-there-are-two-middle-nodes-return-the-second-middle-node" class="headerlink" title="If there are two middle nodes, return the second middle node."></a>If there are two middle nodes, return the second middle node.</h2><p>我们让两个指针 slow 和 fast 分别指向链表头结点 head。</p><p>每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。</p><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        slow = head        fast =head        while fast and fast.next:            slow = slow.next            fast = fast.next.next        return slow</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>86. Partition List(medium)</title>
      <link href="/2022/08/27/86/"/>
      <url>/2022/08/27/86/</url>
      
        <content type="html"><![CDATA[<h1 id="86-Partition-List-medium"><a href="#86-Partition-List-medium" class="headerlink" title="86. Partition List(medium)"></a>86. Partition List(medium)</h1><h2 id="Given-the-head-of-a-linked-list-and-a-value-x-partition-it-such-that-all-nodes-less-than-x-come-before-nodes-greater-than-or-equal-to-x"><a href="#Given-the-head-of-a-linked-list-and-a-value-x-partition-it-such-that-all-nodes-less-than-x-come-before-nodes-greater-than-or-equal-to-x" class="headerlink" title="Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x."></a>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</h2><h2 id="You-should-preserve-the-original-relative-order-of-the-nodes-in-each-of-the-two-partitions"><a href="#You-should-preserve-the-original-relative-order-of-the-nodes-in-each-of-the-two-partitions" class="headerlink" title="You should preserve the original relative order of the nodes in each of the two partitions."></a>You should preserve the original relative order of the nodes in each of the two partitions.</h2><p>链表的基本操作，但是这里创立了两个链表,两个 dummy node 来持有两个分割出来的子链表，分别存储比x大和小的，最后在将数字小的那部分链接到大数字上</p><p><a href="https://leetcode.cn/problems/partition-list/solution/fen-ge-lian-biao-by-leetcode-solution-7ade/">官方说明</a></p><p>直观来说我们只需维护两个链表 small 和 large 即可，small 链表按顺序存储所有小于 x 的节点，large 链表按顺序存储所有大于等于 x 的节点。遍历完原链表后，我们只要将 small 链表尾节点指向 large 链表的头节点即能完成对链表的分隔。</p><p>为了实现上述思路，我们设 smallHead 和 largeHead 分别为两个链表的哑节点，即它们的 next 指针指向链表的头节点，这样做的目的是为了更方便地处理头节点为空的边界条件。同时设 small 和 large 节点指向当前链表的末尾节点。开始时 smallHead=small,largeHead=large。随后，从前往后遍历链表，判断当前链表的节点值是否小于 x，如果小于就将 small 的 next 指针指向该节点，否则将 large 的 next 指针指向该节点。</p><p>遍历结束后，我们将 large 的 next 指针置空，这是因为当前节点复用的是原链表的节点，而其 next 指针可能指向一个小于 x 的节点，我们需要切断这个引用。同时将 small 的 next 指针指向 largeHead 的 next 指针指向的节点，即真正意义上的 large 链表的头节点。最后返回 smallHead 的 next 指针即为我们要求的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        smallhead = small =ListNode(<span class="number">0</span>)</span><br><span class="line">        largehead = large =ListNode(<span class="number">0</span>)        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val&lt;x:</span><br><span class="line">                small.<span class="built_in">next</span> = head</span><br><span class="line">                small = small.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                large.<span class="built_in">next</span> = head</span><br><span class="line">                large = large.<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        large.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        small.<span class="built_in">next</span> = largehead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> smallhead.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203. Remove Linked List Elements(easy)</title>
      <link href="/2022/08/26/203/"/>
      <url>/2022/08/26/203/</url>
      
        <content type="html"><![CDATA[<h1 id="203-Remove-Linked-List-Elements-easy"><a href="#203-Remove-Linked-List-Elements-easy" class="headerlink" title="203. Remove Linked List Elements(easy)"></a>203. Remove Linked List Elements(easy)</h1><h2 id="Given-the-head-of-a-linked-list-and-an-integer-val-remove-all-the-nodes-of-the-linked-list-that-has-Node-val-val-and-return-the-new-head"><a href="#Given-the-head-of-a-linked-list-and-an-integer-val-remove-all-the-nodes-of-the-linked-list-that-has-Node-val-val-and-return-the-new-head" class="headerlink" title="Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head."></a>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>这题是一个简单题，但可以学习如何添加dummy node</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">pre.<span class="built_in">next</span> = head</span><br><span class="line">current = pre</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        pre = ListNode(-1)        pre.next = head        current = pre        while current.next!=None:            if current.next.val== val:                current.next= current.next.next            else:                current = current.next        return pre.next</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill2-python_funciton</title>
      <link href="/2022/08/24/LeetCode-skill2-python-funciton/"/>
      <url>/2022/08/24/LeetCode-skill2-python-funciton/</url>
      
        <content type="html"><![CDATA[<h1 id="python-常用函数"><a href="#python-常用函数" class="headerlink" title="python 常用函数"></a>python 常用函数</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Python 的列表 List 基本就是其它语言的 Array.</p><h3 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization 初始化"></a>Initialization 初始化</h3><p>List 的初始化一般用 List comprehension，往往能一行解决问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1d array</span><br><span class="line">l = [0 for _ in range(len(array)]</span><br><span class="line"></span><br><span class="line"># 2d</span><br><span class="line">l = [[0 for i in range(cols)] for j in range(rows)]</span><br></pre></td></tr></table></figure><h3 id="Start-from-the-behind"><a href="#Start-from-the-behind" class="headerlink" title="Start from the behind"></a>Start from the behind</h3><p>你可以轻松从后往前访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lastElement = l[-1]</span><br><span class="line"></span><br><span class="line">lastTwo = l[-2:]</span><br><span class="line"></span><br><span class="line">for i in range(0, -10, -1)</span><br><span class="line"># 0, -1, -2, -3, -4, -5, -6, -7, -8, -9</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="copy-复制"><a href="#copy-复制" class="headerlink" title="copy 复制"></a>copy 复制</h3><h3 id="shallow-copy-浅拷贝"><a href="#shallow-copy-浅拷贝" class="headerlink" title="shallow copy 浅拷贝"></a>shallow copy 浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l2 = l1[:]</span><br><span class="line"># or</span><br><span class="line">l2 = l1.copy()</span><br></pre></td></tr></table></figure><p>浅复制的问题在于，如果 l1 内部还有 list，那么这种嵌套的索引不能被复制，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, [3, 4]]</span><br><span class="line">b = a[:]</span><br><span class="line">a[2].append(5)</span><br><span class="line">print(b)</span><br><span class="line"># [1, 2, [3, 4, 5]]</span><br></pre></td></tr></table></figure><h3 id="deep-copy-深拷贝"><a href="#deep-copy-深拷贝" class="headerlink" title="deep copy 深拷贝"></a>deep copy 深拷贝</h3><p>所以如果要做深拷贝，要节制自带库 copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">copy.deepcopy()</span><br></pre></td></tr></table></figure><h3 id="enumerate-枚举"><a href="#enumerate-枚举" class="headerlink" title="enumerate 枚举"></a>enumerate 枚举</h3><p>当我们需要枚举一个数组并同时获得值与 index 的时候可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">for i, v in enumerate(l):</span><br><span class="line">    print(i, v)</span><br><span class="line"># 0 a</span><br><span class="line"># 1 b</span><br><span class="line"># 2 c</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip 本意就是拉链，可以想象成将两个数组像拉链一样挨个聚合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 可以分别对相邻元素使用同一种计算规则，同时每一步结果作为下一步的参数，很典型的函数式编程用法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># importing functools for reduce()</span><br><span class="line">import functools</span><br><span class="line"># initializing list</span><br><span class="line">lis = [ 1, 3, 5, 6, 2, ]</span><br><span class="line"></span><br><span class="line"># using reduce to compute sum of list</span><br><span class="line">print (&quot;The sum of the list elements is : &quot;,end=&quot;&quot;)</span><br><span class="line">print (functools.reduce(lambda a,b : a+b,lis))</span><br><span class="line"></span><br><span class="line"># The sum of the list elements is : 17</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>可以将参数一一映射来计算， 比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date = &quot;2019-8-15&quot;</span><br><span class="line">Y, M, D = map(int, date.split(&#x27;-&#x27;))</span><br><span class="line"># Y = 2019, M = 8, D = 15</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>list 删除末尾的操作是O(1)的，但是删除头操作就是O(n)，这时候我们就需要一个双端队列 deque。<br>首尾的常规操作为：</p><p>append，添加到末尾<br>appendleft, 添加到开头<br>pop, 剔除末尾<br>popleft，移除开头</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>list 自身有自带的 sort(), 但是它不返回新的 list.可以加reverse使结果倒序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vowels list</span></span><br><span class="line">a= [<span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#[8, 6, 3, 2]</span></span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>list 自身有自带的 sort(), 但是它不返回新的 list. sorted 能返回一个新的 list, 并且支持传入参数reverse。</p><p>比如我们有一个 tuple 的数组，我们想按照 tuple 的第一个元素进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1 = [(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">10</span>) ]</span><br><span class="line"></span><br><span class="line">l2 = <span class="built_in">sorted</span>(l1, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># l2 = [(0, 1), (1, 2), (3, 10)]</span></span><br></pre></td></tr></table></figure><p>这里的 key 允许传入一个自定义参数，也可以用自带函数进行比较，比如在一个 string 数组里只想比较小写，可以传入key=str.lower</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>]</span><br><span class="line">l2 = <span class="built_in">sorted</span>(l1, key=<span class="built_in">str</span>.lower)</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;APPLE&#x27;, &#x27;banana&#x27;, &#x27;Watermelon&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;paper&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(word)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pie&#x27;</span>, <span class="string">&#x27;Washington&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(words, key=<span class="built_in">len</span>)</span><br><span class="line">[<span class="string">&#x27;pie&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;Washington&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tree=<span class="built_in">sorted</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x!=-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 这个很神奇，把除了-1以外的数排序</span></span><br><span class="line"><span class="comment">#tree=[150, 160, 170, 180, 190]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>你注意到我们在上面使用了 lambda 来定义一个匿名函数，十分方便。如果你熟悉其它语言类似 JS 的话，可以把它理解成一个 callback 函数，参数名一一对应就行。</p><h3 id="cmp-to-key"><a href="#cmp-to-key" class="headerlink" title="cmp_to_key"></a>cmp_to_key</h3><p>在 python3 中，sorted 函数取消了自带的cmp函数，需要借助functools 库中的 cmp_to_key来做比较。<br>比如如果要按照数组元素的绝对值来排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from functools import cmp_to_key</span><br><span class="line">def absSort(arr):</span><br><span class="line">    newarr = sorted(arr, key = cmp_to_key(sortfunc))</span><br><span class="line">    return newarr</span><br><span class="line">def sortfunc(a, b):</span><br><span class="line">    if abs(a) &lt; abs(b):</span><br><span class="line">      return -1</span><br><span class="line">    elif abs(a) &gt; abs(b):</span><br><span class="line">      return 1</span><br><span class="line">    else:</span><br><span class="line">      return a - b</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 的查找操作复杂度为O(1)，有时候可以替代dict 来存储中间过程。</p><p>add : set 的添加是 add 不是append</p><p>remove vs discard: 都是删除操作，区别在于remove不存在的元素会报错，discard不会。</p><p>union, intersection: 快速获得并集和交集，方便一些去重操作。</p><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>字典，相当于其它语言中的map, hashtable, hashmap之类的，读取操作也是O(1) 复杂度</p><h3 id="keys-values-items"><a href="#keys-values-items" class="headerlink" title="keys(), values(), items()"></a>keys(), values(), items()</h3><p>这三个方法可以分别获得key, value, {key: value}的数组。</p><h3 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault"></a>setdefault</h3><p>这个函数经常在初始化字典时候使用，如果某个key在字典中存在，返回它的value, 否则返回你给的 default 值。比如在建一个 trie 树的时候</p><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>OrderedDict 能记录你 key 和 value 插入的顺序，底层其实是一个双向链表加哈希表的实现。我们甚至可以使用move_to_end这样的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = OrderedDict.fromkeys(&#x27;abcde&#x27;)</span><br><span class="line">&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;)</span><br><span class="line">&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())</span><br><span class="line">&#x27;acdeb&#x27;</span><br><span class="line"># 放开头</span><br><span class="line">&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;, last=False)</span><br><span class="line">&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())</span><br><span class="line">&#x27;bacde&#x27;</span><br></pre></td></tr></table></figure><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>defaultdict可以很好地来解决一些初始化的问题，比如 value 是一个 list，每次需要判断 key 是否存在的情况。这时我们可以直接定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(list)</span><br><span class="line"></span><br><span class="line">s = [(&#x27;yellow&#x27;, 1), (&#x27;blue&#x27;, 2), (&#x27;yellow&#x27;, 3), (&#x27;blue&#x27;, 4), (&#x27;red&#x27;, 1)]</span><br><span class="line">for k, v in s:</span><br><span class="line">     d[k].append(v)</span><br><span class="line">sorted(d.items())</span><br><span class="line"># [(&#x27;blue&#x27;, [2, 4]), (&#x27;red&#x27;, [1]), (&#x27;yellow&#x27;, [1, 3])]</span><br></pre></td></tr></table></figure><h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><p>heapq 就是 python 的 priority queue，heapq[0]即为堆顶元素。</p><p>heapq 的实现是小顶堆，如果需要一个大顶堆，常规的一个做法是把值取负存入，取出时再反转。<br>以下是借助 heapq 来实现 heapsort 的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def heapsort(iterable):</span><br><span class="line">...     h = []</span><br><span class="line">...     for value in iterable:</span><br><span class="line">...         heappush(h, value)</span><br><span class="line">...     return [heappop(h) for i in range(len(h))]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>python 自带二分查找的库，在一些不要求实现 binary search，但是借助它能加速的场景下可以直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect(a, x, lo=0, hi=len(a))</span><br><span class="line">这里的参数分别为 数组，要查找的数，范围起始点，范围结束点</span><br></pre></td></tr></table></figure><p>相似函数还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left</span><br><span class="line">bisect.bisect_right</span><br></pre></td></tr></table></figure><p>分别返回可以插入 x 的最左和最右 index</p><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>Counter 接受的参数可以是一个 string, 或者一个 list, mapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = Counter()                           # a new, empty counter</span><br><span class="line">&gt;&gt;&gt; c = Counter(&#x27;gallahad&#x27;)                 # a new counter from an iterable</span><br><span class="line">&gt;&gt;&gt; c = Counter(&#123;&#x27;red&#x27;: 4, &#x27;blue&#x27;: 2&#125;)      # a new counter from a mapping</span><br><span class="line">&gt;&gt;&gt; c = Counter(cats=4, dogs=8)             # a new counter from keyword args</span><br></pre></td></tr></table></figure><p>most_common(n)<br>可以得到出现次数最多的 n 个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Counter(&#x27;abracadabra&#x27;).most_common(3)  # doctest: +SKIP</span><br><span class="line">[(&#x27;a&#x27;, 5), (&#x27;r&#x27;, 2), (&#x27;b&#x27;, 2)]</span><br></pre></td></tr></table></figure><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><h3 id="ord-char"><a href="#ord-char" class="headerlink" title="ord, char"></a>ord, char</h3><p>ord 返回单个字符的 unicode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&#x27;a&#x27;)</span><br><span class="line">97</span><br></pre></td></tr></table></figure><p>char 则是反向操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(100)</span><br><span class="line">&#x27;d&#x27;</span><br></pre></td></tr></table></figure><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>移除 string 前后的字符串，默认来移除空格，但是也可以给一个字符串，然后会移除含有这个字符串的部分：</p><p>``</p><blockquote><blockquote><blockquote><p>‘   spacious   ‘.strip()<br>‘spacious’<br>‘<a href="http://www.example.com&/#39;.strip(&#39;cmowz.&#39;)">www.example.com&#39;.strip(&#39;cmowz.&#39;)</a><br>‘example’<br>``</p></blockquote></blockquote></blockquote><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>按照某个字符串来切分，返回一个 list, 可以传入一个参数maxsplit来限定分离数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;)</span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;, maxsplit=1)</span><br><span class="line">[&#x27;1&#x27;, &#x27;2,3&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;1,2,,3,&#x27;.split(&#x27;,&#x27;)</span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;&#x27;]</span><br></pre></td></tr></table></figure><h2 id="int-float"><a href="#int-float" class="headerlink" title="int/ float"></a>int/ float</h2><h3 id="最大-最小-number"><a href="#最大-最小-number" class="headerlink" title="最大, 最小 number"></a>最大, 最小 number</h3><p>有时候初始化我们需要设定 Math.max() 和 Math.min(), 在 python 中分别以 float(‘inf’) 和 float(‘-inf’)表示</p><p>或者也可以用math库里的 math.inf 和 math.inf</p><p>在 python2 中我们也可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#maxint</span><br><span class="line">Max = sys.maxint</span><br></pre></td></tr></table></figure><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>在 python3 中， / 会保留浮点，相当于 float 相除，如果需要做到像 pyhton2 中的 int 相除，需要 //：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 / 2</span><br><span class="line">1.5</span><br><span class="line">&gt;&gt;&gt; 3 // 2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p>在 python 中为 **:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 ** 10</span><br><span class="line">1024</span><br></pre></td></tr></table></figure><h2 id="conditions"><a href="#conditions" class="headerlink" title="conditions"></a>conditions</h2><p>在 python 的三项表达式(ternary operation) 与其它语言不太一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = a if condition else b</span><br></pre></td></tr></table></figure><p>它表示如果 condition 满足，那么 res = a, 不然 res = b，在类 c 的语言里即为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = condition ? a : b;</span><br></pre></td></tr></table></figure><h2 id="strip-1"><a href="#strip-1" class="headerlink" title="strip()"></a>strip()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. strip():- This method is used to delete all the leading and trailing characters mentioned in its argument.</span><br><span class="line">2. lstrip():- This method is used to delete all the leading characters mentioned in its argument.</span><br><span class="line">3. rstrip():- This method is used to delete all the trailing characters mentioned in its argument.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code to demonstrate working of</span></span><br><span class="line"><span class="comment"># strip(), lstrip() and rstrip()</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;---geeksforgeeks---&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using strip() to delete all &#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot; String after stripping all &#x27;-&#x27; is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ( <span class="built_in">str</span>.strip(<span class="string">&#x27;-&#x27;</span>) )</span><br><span class="line"><span class="comment"># String after stripping all &#x27;-&#x27; is : geeksforgeeks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using lstrip() to delete all trailing &#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot; String after stripping all leading &#x27;-&#x27; is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ( <span class="built_in">str</span>.lstrip(<span class="string">&#x27;-&#x27;</span>) )</span><br><span class="line"><span class="comment"># String after stripping all leading &#x27;-&#x27; is : geeksforgeeks---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using rstrip() to delete all leading &#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span> ( <span class="string">&quot; String after stripping all trailing &#x27;-&#x27; is : &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> ( <span class="built_in">str</span>.rstrip(<span class="string">&#x27;-&#x27;</span>) )</span><br><span class="line"><span class="comment"># String after stripping all trailing &#x27;-&#x27; is : ---geeksforgeeks</span></span><br></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join()<br>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。<br>str.join(sequence) sequence – 要连接的元素序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;-&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;&quot;</span></span><br><span class="line">seq = (<span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;b&quot;</span>) <span class="comment"># 字符串序列</span></span><br><span class="line"><span class="built_in">print</span> (s1.join( seq )) <span class="comment">#r-u-n-o-o-b</span></span><br><span class="line"><span class="built_in">print</span> (s2.join( seq )) <span class="comment">#runoob</span></span><br></pre></td></tr></table></figure><h2 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum()"></a>isalnum()</h2><p>isalnum()<br>用来判断是不是字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># string contains either alphabet or number </span></span><br><span class="line">name1 = <span class="string">&quot;Python3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name1.isalnum()) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># string contains whitespace</span></span><br><span class="line">name2 = <span class="string">&quot;Python 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name2.isalnum()) <span class="comment">#False</span></span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://hzhao.me/2019/08/16/python-leetcode-trick/#heapq">https://hzhao.me/2019/08/16/python-leetcode-trick/#heapq</a></p><p><a href="https://xdren69.github.io/2021/03/31/leetcode-python/">https://xdren69.github.io/2021/03/31/leetcode-python/</a></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> python function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>304. Range Sum Query 2D - Immutable(medium)</title>
      <link href="/2022/08/24/304/"/>
      <url>/2022/08/24/304/</url>
      
        <content type="html"><![CDATA[<h1 id="304-Range-Sum-Query-2D-Immutable-medium"><a href="#304-Range-Sum-Query-2D-Immutable-medium" class="headerlink" title="304. Range Sum Query 2D - Immutable(medium)"></a>304. Range Sum Query 2D - Immutable(medium)</h1><h2 id="Given-a-2D-matrix-matrix-handle-multiple-queries-of-the-following-type"><a href="#Given-a-2D-matrix-matrix-handle-multiple-queries-of-the-following-type" class="headerlink" title="Given a 2D matrix matrix, handle multiple queries of the following type:"></a>Given a 2D matrix matrix, handle multiple queries of the following type:</h2><h2 id="Calculate-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2"><a href="#Calculate-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2" class="headerlink" title="Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2)."></a>Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</h2><h2 id="Implement-the-NumMatrix-class"><a href="#Implement-the-NumMatrix-class" class="headerlink" title="Implement the NumMatrix class:"></a>Implement the NumMatrix class:</h2><h3 id="NumMatrix-int-matrix-Initializes-the-object-with-the-integer-matrix-matrix"><a href="#NumMatrix-int-matrix-Initializes-the-object-with-the-integer-matrix-matrix" class="headerlink" title="NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix."></a>NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.</h3><h3 id="int-sumRegion-int-row1-int-col1-int-row2-int-col2-Returns-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2"><a href="#int-sumRegion-int-row1-int-col1-int-row2-int-col2-Returns-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2" class="headerlink" title="int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2)."></a>int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</h3><h2 id="You-must-design-an-algorithm-where-sumRegion-works-on-O-1-time-complexity"><a href="#You-must-design-an-algorithm-where-sumRegion-works-on-O-1-time-complexity" class="headerlink" title="You must design an algorithm where sumRegion works on O(1) time complexity."></a>You must design an algorithm where sumRegion works on O(1) time complexity.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/">官方题解</a></h3><p>这道题是303题的升级版，从一维数组升级成二维矩阵，同样是前缀和数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), (<span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="keyword">if</span> matrix <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        self.sums = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        _sums = self.sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                _sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = _sums[i][j + <span class="number">1</span>] + _sums[i + <span class="number">1</span>][j] - _sums[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        _sums = self.sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - _sums[row1][col2 + <span class="number">1</span>] - _sums[row2 + <span class="number">1</span>][col1] + _sums[row1][col1]</span><br></pre></td></tr></table></figure><p>作者：LeetCode-Solution<br>链接：<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> prefix sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>303. Range Sum Query - Immutable(easy)</title>
      <link href="/2022/08/24/303/"/>
      <url>/2022/08/24/303/</url>
      
        <content type="html"><![CDATA[<h1 id="303-Range-Sum-Query-Immutable-easy"><a href="#303-Range-Sum-Query-Immutable-easy" class="headerlink" title="303. Range Sum Query - Immutable(easy)"></a>303. Range Sum Query - Immutable(easy)</h1><h2 id="Given-an-integer-array-nums-handle-multiple-queries-of-the-following-type"><a href="#Given-an-integer-array-nums-handle-multiple-queries-of-the-following-type" class="headerlink" title="Given an integer array nums, handle multiple queries of the following type:"></a>Given an integer array nums, handle multiple queries of the following type:</h2><h2 id="Calculate-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive-where-left-lt-right"><a href="#Calculate-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive-where-left-lt-right" class="headerlink" title="Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right."></a>Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.</h2><h2 id="Implement-the-NumArray-class"><a href="#Implement-the-NumArray-class" class="headerlink" title="Implement the NumArray class:"></a>Implement the NumArray class:</h2><h2 id="NumArray-int-nums-Initializes-the-object-with-the-integer-array-nums"><a href="#NumArray-int-nums-Initializes-the-object-with-the-integer-array-nums" class="headerlink" title="NumArray(int[] nums) Initializes the object with the integer array nums."></a>NumArray(int[] nums) Initializes the object with the integer array nums.</h2><h2 id="int-sumRange-int-left-int-right-Returns-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive"><a href="#int-sumRange-int-left-int-right-Returns-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive" class="headerlink" title="int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive"></a>int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive</h2><h2 id="i-e-nums-left-nums-left-1-…-nums-right"><a href="#i-e-nums-left-nums-left-1-…-nums-right" class="headerlink" title="(i.e. nums[left] + nums[left + 1] + … + nums[right])."></a>(i.e. nums[left] + nums[left + 1] + … + nums[right]).</h2><p>最基础的前缀和问题<br><a href="https://leetcode.cn/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.sums = [<span class="number">0</span>]</span><br><span class="line">        _sums = self.sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            _sums.append(_sums[-<span class="number">1</span>] + num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        _sums = self.sums</span><br><span class="line">        <span class="keyword">return</span> _sums[j + <span class="number">1</span>] - _sums[i]</span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(left,right)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span>  <span class="comment"># 68 ms, faster than 97.72%</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.preSum = nums  <span class="comment"># pass by pointer!</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            self.preSum[i+<span class="number">1</span>] += self.preSum[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> self.preSum[right]</span><br><span class="line">        <span class="keyword">return</span> self.preSum[right] - self.preSum[left-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> prefix sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-skill1-prefix_sum</title>
      <link href="/2022/08/24/LeetCode-skill1-prefix-sum/"/>
      <url>/2022/08/24/LeetCode-skill1-prefix-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="前缀和（prefix-sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现-“子数组和”-或者-“连续的子数组”-既可以考虑使用前缀和来求解会得到不错的效果。"><a href="#前缀和（prefix-sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现-“子数组和”-或者-“连续的子数组”-既可以考虑使用前缀和来求解会得到不错的效果。" class="headerlink" title="前缀和（prefix sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现 “子数组和” 或者 “连续的子数组” 既可以考虑使用前缀和来求解会得到不错的效果。"></a>前缀和（prefix sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现 “子数组和” 或者 “连续的子数组” 既可以考虑使用前缀和来求解会得到不错的效果。</h2><p>303题</p><p>304题</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> prefix sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>518. Coin Change 2(medium)</title>
      <link href="/2022/08/23/518/"/>
      <url>/2022/08/23/518/</url>
      
        <content type="html"><![CDATA[<h1 id="518-Coin-Change-2-medium"><a href="#518-Coin-Change-2-medium" class="headerlink" title="518. Coin Change 2(medium)"></a>518. Coin Change 2(medium)</h1><h2 id="You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money"><a href="#You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money" class="headerlink" title="You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money."></a>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</h2><h2 id="Return-the-number-of-combinations-that-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-0"><a href="#Return-the-number-of-combinations-that-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-0" class="headerlink" title="Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0."></a>Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.</h2><h2 id="You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin"><a href="#You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin" class="headerlink" title="You may assume that you have an infinite number of each kind of coin."></a>You may assume that you have an infinite number of each kind of coin.</h2><h2 id="The-answer-is-guaranteed-to-fit-into-a-signed-32-bit-integer"><a href="#The-answer-is-guaranteed-to-fit-into-a-signed-32-bit-integer" class="headerlink" title="The answer is guaranteed to fit into a signed 32-bit integer."></a>The answer is guaranteed to fit into a signed 32-bit integer.</h2><h3 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/">leetcode题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]   <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>    <span class="comment"># 合法的初始化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完全背包：优化后的状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):         <span class="comment"># 第一层循环：遍历硬币</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):   <span class="comment"># 第二层循环：遍历背包</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; coins[i-<span class="number">1</span>]:      <span class="comment"># 容量有限，无法选择第i个硬币</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 可选择第i个硬币</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-coins[i-<span class="number">1</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></table></figure><p>作者：flix<br>链接：<a href="https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/">https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change(medium)</title>
      <link href="/2022/08/23/322/"/>
      <url>/2022/08/23/322/</url>
      
        <content type="html"><![CDATA[<h1 id="322-Coin-Change-medium"><a href="#322-Coin-Change-medium" class="headerlink" title="322. Coin Change(medium)"></a>322. Coin Change(medium)</h1><h2 id="You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money"><a href="#You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money" class="headerlink" title="You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money."></a>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</h2><h2 id="Return-the-fewest-number-of-coins-that-you-need-to-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-1"><a href="#Return-the-fewest-number-of-coins-that-you-need-to-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-1" class="headerlink" title="Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1."></a>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</h2><h2 id="You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin"><a href="#You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin" class="headerlink" title="You may assume that you have an infinite number of each kind of coin."></a>You may assume that you have an infinite number of each kind of coin.</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>253. Meeting Rooms II</title>
      <link href="/2022/08/23/253/"/>
      <url>/2022/08/23/253/</url>
      
        <content type="html"><![CDATA[<h1 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a>253. Meeting Rooms II</h1><h2 id="Given-an-array-of-meeting-time-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-conference-rooms-required"><a href="#Given-an-array-of-meeting-time-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-conference-rooms-required" class="headerlink" title="Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required."></a>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</h2><h2 id="思想："><a href="#思想：" class="headerlink" title="思想："></a><a href="https://labuladong.github.io/algo/3/29/100/">思想：</a></h2><p>红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。<br>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 count 加一，每遇到绿色的点，计数器 count 减一：<br>这样一来，每个时刻有多少个会议在同时进行，就是计数器 count 的值，count 的最大值，就是需要申请的会议室数量。</p><p>对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。</p><p>代码实现<br>那么，如何写代码实现这个扫描的过程呢？</p><p>首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序<br>然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器 count 的最大值就是答案：<br>这里使用的是 双指针技巧，根据 i, j 的相对位置模拟扫描线前进的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n= <span class="built_in">len</span>(intervals)</span><br><span class="line">        begin =[]</span><br><span class="line">        end = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res,c,j=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            begin.append(intervals[i][<span class="number">0</span>])</span><br><span class="line">            end.append(intervals[i][<span class="number">1</span>])    </span><br><span class="line">        begin.sort()</span><br><span class="line">        end.sort()</span><br><span class="line">        <span class="keyword">while</span> (c&lt;n <span class="keyword">and</span> j&lt;n):</span><br><span class="line">            <span class="keyword">if</span> begin[c]&lt;end[j]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                c+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count-=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,count)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">int</span> minMeetingRooms(<span class="built_in">int</span>[][] meetings) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = meetings.length;</span><br><span class="line">    <span class="built_in">int</span>[] begin = new <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="built_in">int</span>[] end = new <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        begin[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(begin);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line"></span><br><span class="line">    // 扫描过程中的计数器</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    // 双指针技巧</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin[i] &lt; end[j]) &#123;</span><br><span class="line">            // 扫描到一个红点</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // 扫描到一个绿点</span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录扫描过程中的最大值</span><br><span class="line">        res = Math.<span class="built_in">max</span>(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1207. Unique Number of Occurrences(easy)</title>
      <link href="/2022/08/22/1207/"/>
      <url>/2022/08/22/1207/</url>
      
        <content type="html"><![CDATA[<h1 id="1207-Unique-Number-of-Occurrences-easy"><a href="#1207-Unique-Number-of-Occurrences-easy" class="headerlink" title="1207. Unique Number of Occurrences(easy)"></a>1207. Unique Number of Occurrences(easy)</h1><h2 id="Given-an-array-of-integers-arr-return-true-if-the-number-of-occurrences-of-each-value-in-the-array-is-unique-or-false-otherwise"><a href="#Given-an-array-of-integers-arr-return-true-if-the-number-of-occurrences-of-each-value-in-the-array-is-unique-or-false-otherwise" class="headerlink" title="Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise."></a>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,2,1,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</span><br></pre></td></tr></table></figure><p>这道题相对比较简单，判断hashmap的value是否都是unique的，通过set的无重复性很容易就能判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniqueOccurrences(self, arr: List[int]) -&gt; bool:</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res=[]</span><br><span class="line">        for i in arr:</span><br><span class="line">            if i not in hashmap:</span><br><span class="line">                hashmap[i]=1</span><br><span class="line">            else:</span><br><span class="line">                hashmap[i]+=1</span><br><span class="line">        for i in hashmap.keys():</span><br><span class="line">            res.append(hashmap[i])</span><br><span class="line">        return len(set(res))==len(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache(medium)</title>
      <link href="/2022/08/22/146/"/>
      <url>/2022/08/22/146/</url>
      
        <content type="html"><![CDATA[<h1 id="146-LRU-Cache-medium"><a href="#146-LRU-Cache-medium" class="headerlink" title="146. LRU Cache(medium)"></a>146. LRU Cache(medium)</h1><h2 id="Design-a-data-structure-that-follows-the-constraints-of-a-Least-Recently-Used-LRU-cache"><a href="#Design-a-data-structure-that-follows-the-constraints-of-a-Least-Recently-Used-LRU-cache" class="headerlink" title="Design a data structure that follows the constraints of a Least Recently Used (LRU) cache."></a>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</h2><h2 id="Implement-the-LRUCache-class"><a href="#Implement-the-LRUCache-class" class="headerlink" title="Implement the LRUCache class:"></a>Implement the LRUCache class:</h2><h3 id="LRUCache-int-capacity-Initialize-the-LRU-cache-with-positive-size-capacity"><a href="#LRUCache-int-capacity-Initialize-the-LRU-cache-with-positive-size-capacity" class="headerlink" title="LRUCache(int capacity) Initialize the LRU cache with positive size capacity."></a>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</h3><h3 id="int-get-int-key-Return-the-value-of-the-key-if-the-key-exists-otherwise-return-1"><a href="#int-get-int-key-Return-the-value-of-the-key-if-the-key-exists-otherwise-return-1" class="headerlink" title="int get(int key) Return the value of the key if the key exists, otherwise return -1."></a>int get(int key) Return the value of the key if the key exists, otherwise return -1.</h3><h3 id="void-put-int-key-int-value-Update-the-value-of-the-key-if-the-key-exists-Otherwise-add-the-key-value-pair-to-the-cache-If-the-number-of-keys-exceeds-the-capacity-from-this-operation-evict-the-least-recently-used-key"><a href="#void-put-int-key-int-value-Update-the-value-of-the-key-if-the-key-exists-Otherwise-add-the-key-value-pair-to-the-cache-If-the-number-of-keys-exceeds-the-capacity-from-this-operation-evict-the-least-recently-used-key" class="headerlink" title="void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key."></a>void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</h3><h2 id="The-functions-get-and-put-must-each-run-in-O-1-average-time-complexity"><a href="#The-functions-get-and-put-must-each-run-in-O-1-average-time-complexity" class="headerlink" title="The functions get and put must each run in O(1) average time complexity."></a>The functions get and put must each run in O(1) average time complexity.</h2><h2 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a><a href="https://leetcode.cn/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/">官方答案</a></h2><p>这道题是hashmap频率第一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>290. Word Pattern(easy)</title>
      <link href="/2022/08/21/290/"/>
      <url>/2022/08/21/290/</url>
      
        <content type="html"><![CDATA[<h1 id="290-Word-Pattern-easy"><a href="#290-Word-Pattern-easy" class="headerlink" title="290. Word Pattern(easy)"></a>290. Word Pattern(easy)</h1><h2 id="Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern"><a href="#Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern" class="headerlink" title="Given a pattern and a string s, find if s follows the same pattern."></a>Given a pattern and a string s, find if s follows the same pattern.</h2><h2 id="Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s"><a href="#Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s" class="headerlink" title="Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s."></a>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>这道题与<a href="https://leetcode-cn.com/problems/isomorphic-strings/">205.同构字符串</a>几乎一样，区别在于：<br>1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况</p><p>2.本题需要将s分隔成单个单词</p><p>常规做法是，根据pattern和s的对应关系建立一个hashmap，然后再遍历s与hashmap的映射做比较，有不一样就返回false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s=s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern))!=<span class="built_in">len</span>(<span class="built_in">set</span>(s)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> pattern[i] <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[pattern[i]]=s[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pattern)):</span><br><span class="line">            <span class="keyword">if</span> hashmap[pattern[i]]!=s[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>优雅的python解法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s = s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pattern) != <span class="built_in">len</span>(s): </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern)) == <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(pattern,s)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350. Intersection of Two Arrays II(easy)</title>
      <link href="/2022/08/21/350/"/>
      <url>/2022/08/21/350/</url>
      
        <content type="html"><![CDATA[<h1 id="350-Intersection-of-Two-Arrays-II-easy"><a href="#350-Intersection-of-Two-Arrays-II-easy" class="headerlink" title="350. Intersection of Two Arrays II(easy)"></a>350. Intersection of Two Arrays II(easy)</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</h2><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii">https://leetcode.cn/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">官方题解</a><br>用的是heap 加hashmap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.intersect(nums2, nums1)</span><br><span class="line">        </span><br><span class="line">        m = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            m[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        intersection = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> (count := m.get(num, <span class="number">0</span>)) &gt; <span class="number">0</span>:</span><br><span class="line">                intersection.append(num)</span><br><span class="line">                m[num] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m[num] == <span class="number">0</span>:</span><br><span class="line">                    m.pop(num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intersection</span><br></pre></td></tr></table></figure><p>这个方法用的是python一些独特的函数 Counter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        num1 = collections.Counter(nums1)</span><br><span class="line">        num2 = collections.Counter(nums2)</span><br><span class="line">        num = num1 &amp; num2</span><br><span class="line">        <span class="keyword">return</span> num.elements()</span><br></pre></td></tr></table></figure><p>链接：<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349. Intersection of Two Arrays(easy)</title>
      <link href="/2022/08/21/349/"/>
      <url>/2022/08/21/349/</url>
      
        <content type="html"><![CDATA[<h1 id="349-Intersection-of-Two-Arrays-easy"><a href="#349-Intersection-of-Two-Arrays-easy" class="headerlink" title="349. Intersection of Two Arrays(easy)"></a>349. Intersection of Two Arrays(easy)</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p>这题相对比较简单，就是找到nums1 和nums2相同的数字，并且输出hashset（不能输出重复数字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hashmap:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>299. Bulls and Cows</title>
      <link href="/2022/08/21/299/"/>
      <url>/2022/08/21/299/</url>
      
        <content type="html"><![CDATA[<h1 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a>299. Bulls and Cows</h1><h2 id="You-are-playing-the-Bulls-and-Cows-game-with-your-friend"><a href="#You-are-playing-the-Bulls-and-Cows-game-with-your-friend" class="headerlink" title="You are playing the Bulls and Cows game with your friend."></a>You are playing the Bulls and Cows game with your friend.</h2><h2 id="You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info"><a href="#You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info" class="headerlink" title="You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:"></a>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</h2><h2 id="The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position"><a href="#The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position" class="headerlink" title="The number of “bulls”, which are digits in the guess that are in the correct position."></a>The number of “bulls”, which are digits in the guess that are in the correct position.</h2><h2 id="The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls"><a href="#The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls" class="headerlink" title="The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls."></a>The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</h2><h2 id="Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess"><a href="#Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess" class="headerlink" title="Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess."></a>Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess.</h2><h2 id="The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits"><a href="#The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits" class="headerlink" title="The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits."></a>The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.</h2><p>原理：<br>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），<br>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>264. Ugly Number II(medium)</title>
      <link href="/2022/08/20/264/"/>
      <url>/2022/08/20/264/</url>
      
        <content type="html"><![CDATA[<h1 id="264-Ugly-Number-II-medium"><a href="#264-Ugly-Number-II-medium" class="headerlink" title="264. Ugly Number II(medium)"></a>264. Ugly Number II(medium)</h1><h2 id="An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5"><a href="#An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5" class="headerlink" title="An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5."></a>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</h2><h1 id="Given-an-integer-n-return-the-nth-ugly-number"><a href="#Given-an-integer-n-return-the-nth-ugly-number" class="headerlink" title="Given an integer n, return the nth ugly number."></a>Given an integer n, return the nth ugly number.</h1><p>这是一个系列题<br>263. 丑数（简单）</p><ol start="264"><li><p>丑数 II（中等）</p></li><li><p>丑数 III（中等）</p></li><li><p>超级丑数（中等）</p></li></ol><p>“prime factor”是质因子，质因子是所有因子中是质数的</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125;</span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            curr = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := curr * factor) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nxt)</span><br><span class="line">                    heapq.heappush(heap, nxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution">https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ugly = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment"># pointers that point to the last element 2, 3 or 5 was multiplied to</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ugly) &lt; n:</span><br><span class="line">            u2 = <span class="number">2</span> * ugly[p2]</span><br><span class="line">            u3 = <span class="number">3</span> * ugly[p3]</span><br><span class="line">            u5 = <span class="number">5</span> * ugly[p5]</span><br><span class="line">            </span><br><span class="line">            u = <span class="built_in">min</span>(u2, u3, u5) </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u2: <span class="comment"># if the minimum result was result of multiplying the element(ugly[p2]) by 2</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u3: <span class="comment"># if minimum was result of multiplying the element(ugly[p3]) by 3</span></span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> u == u5: <span class="comment"># if minimus was result of multiplying the element(ugly[p5]) by 5</span></span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">ugly.append(u)</span><br><span class="line"><span class="keyword">return</span> ugly[-<span class="number">1</span>] <span class="comment"># return the last element of ugly list</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/2022/08/20/268/"/>
      <url>/2022/08/20/268/</url>
      
        <content type="html"><![CDATA[<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><h2 id="Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array"><a href="#Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array" class="headerlink" title="Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array."></a>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</h2><p>题目是说给了n个数，找到0-n之间缺的那个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p>思路：<br>本质上与242. Valid AnagramZ(easy) 没有什么区别，相当于是两个hashmap的比较，这里有个隐性的比较，分别是nums建成的hashmap，还有一个是完整的0-n这样的list建成的hashmap，所以第一步是建造一个包含0-n数字的list，然后以nums建成的hasmap为基础，拿完整版进行比较，这样可以得到缺失的数字</p><pre><code class="python">class Solution:    def missingNumber(self, nums: List[int]) -&gt; int:        hashmap=&#123;&#125;        n=len(nums)        list = []        for i in nums:            if i not in hashmap:                hashmap[i]=1            else:                hashmap[i]+=1                for i in range(n+1):            list.append(i)        for i in list:            if i not in hashmap:                a = i        return a</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram(easy)</title>
      <link href="/2022/08/20/242/"/>
      <url>/2022/08/20/242/</url>
      
        <content type="html"><![CDATA[<h1 id="242-Valid-AnagramZ-easy"><a href="#242-Valid-AnagramZ-easy" class="headerlink" title="242. Valid AnagramZ(easy)"></a>242. Valid AnagramZ(easy)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise" class="headerlink" title="Given two strings s and t, return true if t is an anagram of s, and false otherwise."></a>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</h2><h2 id="An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once"><a href="#An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once" class="headerlink" title="An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once."></a>An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once.</h2><p>这道题和 205. Isomorphic Strings 有点像，但这道题更简单。这道题最容易想到的方法就是直接对字符串排序比较得到结果，首先字符串长度不同肯定输出false，接下来再对字符串排序，如果排序后相同就输出true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(s)==<span class="built_in">sorted</span>(t)</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line"><span class="comment">### [但是！](htps://leetcode.cn/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/)</span></span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlogn+n)=O(nlogn)。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(logn)。排序需要 O(logn) 的空间复杂度。注意，在某些语言（比如 Java &amp; JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：</span><br><span class="line"></span><br><span class="line">这依赖于语言的细节；</span><br><span class="line">这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以，有第二种方法，也就是hashmap：</span><br><span class="line">从另一个角度考虑，t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <span class="number">26</span> 个小写字母，因此我们可以维护一个长度为 <span class="number">26</span> 的频次数组 table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现 table[i]&lt;<span class="number">0</span>，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。</span><br><span class="line"></span><br><span class="line">其实简单点想，就是建两个hashmap，最后比较是否相同就完事了。</span><br><span class="line">比较的函数</span><br><span class="line">```python</span><br><span class="line">operator.eq(hashmap1,hashmap2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>        </span><br><span class="line">        hashmap1=&#123;&#125;</span><br><span class="line">        hashmap2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c1 <span class="keyword">not</span> <span class="keyword">in</span> hashmap1:</span><br><span class="line">                hashmap1[c1]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap1[c1]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c2 <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> c2 <span class="keyword">not</span> <span class="keyword">in</span> hashmap2:</span><br><span class="line">                hashmap2[c2]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap2[c2]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> operator.eq(hashmap1,hashmap2)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br>对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 Unicode 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和 UTF−16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。</p><p>回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#Using Hashmaps: (O(s+t) time and space)</span></span><br><span class="line">        s_map = &#123;&#125;</span><br><span class="line">        t_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> s:</span><br><span class="line">            s_map[leter] = s_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> t:</span><br><span class="line">            t_map[leter] = t_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s_map == t_map</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>229. Majority Element II(easy)</title>
      <link href="/2022/08/20/229/"/>
      <url>/2022/08/20/229/</url>
      
        <content type="html"><![CDATA[<h1 id="229-Majority-Element-II-easy"><a href="#229-Majority-Element-II-easy" class="headerlink" title="229. Majority Element II(easy)"></a>229. Majority Element II(easy)</h1><h2 id="Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times"><a href="#Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times" class="headerlink" title="Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times."></a>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</h2><p>这道题有点像TOP K问题，看到all elements里的遍历想到hashmap</p><p>把top K 的代码和Majority Element I的放在一起就可以解决这个问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hashmap.keys():</span><br><span class="line">            <span class="keyword">if</span> hashmap[i]&gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line">这里需要注意的是，在输出所有有可能的数组时，TOP K 问题用的是extend，而这里用的是append</span><br><span class="line">append可以追加一个<span class="built_in">list</span>，一个对象；</span><br><span class="line">extend则是把两个<span class="built_in">list</span>连接起来，类似matlab的cat函数        </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">NumList1.append(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2append到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, [‘a’, ‘b’, ‘c’]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第四个元素为&#x27;</span>,NumList1[<span class="number">3</span>]) <span class="comment">#[‘a’, ‘b’, ‘c’]</span></span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList1.extend(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2extend到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, ‘a’, ‘b’, ‘c’]</span></span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">列表2append到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [‘a’, ‘b’, ‘c’]]</span><br><span class="line">第四个元素为 [‘a’, ‘b’, ‘c’]</span><br><span class="line">列表2extend到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ‘a’, ‘b’, ‘c’]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>219. Contains Duplicate II(easy)</title>
      <link href="/2022/08/20/219/"/>
      <url>/2022/08/20/219/</url>
      
        <content type="html"><![CDATA[<h1 id="219-Contains-Duplicate-II-easy"><a href="#219-Contains-Duplicate-II-easy" class="headerlink" title="219. Contains Duplicate II(easy)"></a>219. Contains Duplicate II(easy)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k" class="headerlink" title="Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k."></a>Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode-kluvk/">官方题解</a></h3><p>可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 nums，当遍历到下标 i 时，进行如下操作：</p><p>如果哈希表中已经存在和 nums[i] 相等的元素且该元素在哈希表中记录的下标 j 满足 i−j≤k，返回 true；</p><p>将 nums[i] 和下标 i 存入哈希表，此时 i 是 nums[i] 的最大下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> pos <span class="keyword">and</span> i - pos[num] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pos[num] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>205. Isomorphic Strings(easy)</title>
      <link href="/2022/08/20/205/"/>
      <url>/2022/08/20/205/</url>
      
        <content type="html"><![CDATA[<h1 id="205-Isomorphic-Strings-easy"><a href="#205-Isomorphic-Strings-easy" class="headerlink" title="205. Isomorphic Strings(easy)"></a>205. Isomorphic Strings(easy)</h1><h2 id="Given-two-strings-s-and-t-determine-if-they-are-isomorphic"><a href="#Given-two-strings-s-and-t-determine-if-they-are-isomorphic" class="headerlink" title="Given two strings s and t, determine if they are isomorphic."></a>Given two strings s and t, determine if they are isomorphic.</h2><h2 id="Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t"><a href="#Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t" class="headerlink" title="Two strings s and t are isomorphic if the characters in s can be replaced to get t."></a>Two strings s and t are isomorphic if the characters in s can be replaced to get t.</h2><h2 id="All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself"><a href="#All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself" class="headerlink" title="All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself."></a>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/">官方题解</a></h3><p>此题是「290. 单词规律」的简化版，需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</p><p>总结一下就是得一一对应，并且是互相对应。<br>所以第一种方法可以用两个hashmap互相存储对应关系，再往后进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hashmap1 = &#123;&#125;</span><br><span class="line">        hashmap2 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">            <span class="comment">#The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it.</span></span><br><span class="line">            <span class="keyword">if</span> hashmap1.get(c1, c2) != c2 <span class="keyword">or</span> hashmap2.get(c2, c1) != c1:   </span><br><span class="line">                <span class="comment">#The get() method returns the value for the specified key if the key is in the dictionary.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            hashmap1[c1] = c2</span><br><span class="line">            hashmap2[c2] = c1</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法也是评论里的很有意思的方法，利用set的无重复特性来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(t)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(s, t)))</span><br></pre></td></tr></table></figure><p>zip 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(a,b)     <span class="comment"># 返回一个对象</span></span><br><span class="line"><span class="built_in">list</span>(zipped)  <span class="comment"># list() 转换为列表  [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(a,c))  <span class="comment"># 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> hashset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number(easy)</title>
      <link href="/2022/08/19/202/"/>
      <url>/2022/08/19/202/</url>
      
        <content type="html"><![CDATA[<h1 id="202-Happy-Number-easy"><a href="#202-Happy-Number-easy" class="headerlink" title="202. Happy Number(easy)"></a>202. Happy Number(easy)</h1><h2 id="Write-an-algorithm-to-determine-if-a-number-n-is-happy"><a href="#Write-an-algorithm-to-determine-if-a-number-n-is-happy" class="headerlink" title="Write an algorithm to determine if a number n is happy."></a>Write an algorithm to determine if a number n is happy.</h2><h2 id="A-happy-number-is-a-number-defined-by-the-following-process"><a href="#A-happy-number-is-a-number-defined-by-the-following-process" class="headerlink" title="A happy number is a number defined by the following process:"></a>A happy number is a number defined by the following process:</h2><h2 id="Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits"><a href="#Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits" class="headerlink" title="Starting with any positive integer, replace the number by the sum of the squares of its digits."></a>Starting with any positive integer, replace the number by the sum of the squares of its digits.</h2><h2 id="Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1"><a href="#Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1" class="headerlink" title="Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1."></a>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</h2><h2 id="Those-numbers-for-which-this-process-ends-in-1-are-happy"><a href="#Those-numbers-for-which-this-process-ends-in-1-are-happy" class="headerlink" title="Those numbers for which this process ends in 1 are happy."></a>Those numbers for which this process ends in 1 are happy.</h2><h2 id="Return-true-if-n-is-a-happy-number-and-false-if-not"><a href="#Return-true-if-n-is-a-happy-number-and-false-if-not" class="headerlink" title="Return true if n is a happy number, and false if not."></a>Return true if n is a happy number, and false if not.</h2><p>又是一个奇怪的数，叫做happy number</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">官方题解</a></h3><p>总结一下，数字每一位的平方和后的结果有两种可能性</p><ol><li>变成1</li><li>变成循环</li></ol><p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限增大的选择。</p><p>算法</p><p>算法分为两部分，我们需要设计和编写代码。</p><p>给一个数字 nn，它的下一个数字是什么？<br>按照一系列的数字来判断我们是否进入了一个循环。</p><ol><li><p>我们按照题目的要求做数位分离，求平方和。</p></li><li><p>可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p></li></ol><p>如果它不在哈希集合中，我们应该添加它。<br>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</p><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p>Hashmap解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n_history=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                n_history[n]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                n_history[n]=<span class="number">0</span></span><br><span class="line">                digit_li=[<span class="built_in">str</span>(n)[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(n)))]</span><br><span class="line">                n=<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="built_in">int</span>(x))**<span class="number">2</span>,digit_li)))</span><br><span class="line">                <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">```                </span><br><span class="line">相当于把数字n转换成字符串，再进行平方和运算                </span><br><span class="line">```python                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            seen.add(n)</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">str</span>(n)</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> num:</span><br><span class="line">                temp += <span class="built_in">int</span>(ch)**<span class="number">2</span></span><br><span class="line">            n = temp            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hashset解法</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)   <span class="comment">#divmod求余数</span></span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>() <span class="comment"># python里hashset的本质就是set</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = get_next(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> hashset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element(easy)</title>
      <link href="/2022/08/19/169/"/>
      <url>/2022/08/19/169/</url>
      
        <content type="html"><![CDATA[<h1 id="169-Majority-Element-easy"><a href="#169-Majority-Element-easy" class="headerlink" title="169. Majority Element(easy)"></a>169. Majority Element(easy)</h1><h2 id="Given-an-array-nums-of-size-n-return-the-majority-element"><a href="#Given-an-array-nums-of-size-n-return-the-majority-element" class="headerlink" title="Given an array nums of size n, return the majority element."></a>Given an array nums of size n, return the majority element.</h2><h2 id="The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array"><a href="#The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array" class="headerlink" title="The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array."></a>The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h4 id="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"><a href="#堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。" class="headerlink" title="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"></a>堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。</h4><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        hashmap = &#123;&#125;        n=len(nums)        for ans in nums:            if ans not in hashmap:                hashmap[ans]=1            else:                hashmap[ans]+=1        for ans in hashmap:            if hashmap[ans]&gt;n//2:                return ans</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101. Symmetric Tree (Easy)</title>
      <link href="/2022/08/17/101/"/>
      <url>/2022/08/17/101/</url>
      
        <content type="html"><![CDATA[<h1 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a>101. Symmetric Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center"><a href="#Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center" class="headerlink" title="Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center)."></a>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type root: TreeNode</span></span><br><span class="line"><span class="string">:rtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left,right</span>):</span></span><br><span class="line"><span class="comment"># 递归的终止条件是两个节点都为空</span></span><br><span class="line"><span class="comment"># 或者两个节点中有一个为空</span></span><br><span class="line"><span class="comment"># 或者两个节点的值不相等</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> left.val!=right.val:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> dfs(left.left,right.right) <span class="keyword">and</span> dfs(left.right,right.left)</span><br><span class="line"><span class="comment"># 用递归函数，比较左节点，右节点</span></span><br><span class="line"><span class="keyword">return</span> dfs(root.left,root.right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572. Subtree of Another Tree (Easy)</title>
      <link href="/2022/08/17/572/"/>
      <url>/2022/08/17/572/</url>
      
        <content type="html"><![CDATA[<h1 id="572-Subtree-of-Another-Tree-Easy"><a href="#572-Subtree-of-Another-Tree-Easy" class="headerlink" title="572. Subtree of Another Tree (Easy)"></a>572. Subtree of Another Tree (Easy)</h1><h2 id="Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise"><a href="#Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise" class="headerlink" title="Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise."></a>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</h2><h2 id="A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself"><a href="#A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself" class="headerlink" title="A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself."></a>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root, subRoot</span>) :</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> curr.val == subRoot.val :</span><br><span class="line">                <span class="keyword">if</span> self.compare(curr,subRoot):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> curr.right:</span><br><span class="line">                queue.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                queue.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self,curr,subRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr.val == subRoot.val :</span><br><span class="line">            r_flag = self.compare(curr.right,subRoot.right)</span><br><span class="line">            l_flag = self.compare(curr.left,subRoot.left)</span><br><span class="line">            <span class="keyword">if</span> r_flag <span class="keyword">and</span> l_flag:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>437. Path Sum III (Easy)</title>
      <link href="/2022/08/17/437/"/>
      <url>/2022/08/17/437/</url>
      
        <content type="html"><![CDATA[<h1 id="437-Path-Sum-III-Easy"><a href="#437-Path-Sum-III-Easy" class="headerlink" title="437. Path Sum III (Easy)"></a>437. Path Sum III (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</h2><h2 id="The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes"><a href="#The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes" class="headerlink" title="The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes)."></a>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><h3 id="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。"><a href="#我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。" class="headerlink" title="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。"></a>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。</h3><h3 id="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。"><a href="#对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。" class="headerlink" title="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。"></a>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。</h3><h3 id="假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p"><a href="#假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p" class="headerlink" title="假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p"></a>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p</h3><p>1<br>​<br> →p<br>2<br>​<br> →…→p<br>k<br>​<br> →node，此时我们可以已经保存了节点 p_1, p_2, p_3, \ldots, p_kp<br>1<br>​<br> ,p<br>2<br>​<br> ,p<br>3<br>​<br> ,…,p<br>k<br>​<br>  的前缀和，并且计算出了节点 node 的前缀和。</p><p>假设当前从根节点 root 到节点 node 的前缀和为 \textit{curr}curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 \textit{curr} - curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 p_ip<br>i<br>​<br>  到根节点 root 的前缀和为 \textit{curr} - curr−targetSum，则节点 p_{i+1}p<br>i+1<br>​<br>  到 node 的路径上所有节点的和一定为 targetSum。</p><p>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112. Path Sum (Easy)</title>
      <link href="/2022/08/16/112/"/>
      <url>/2022/08/16/112/</url>
      
        <content type="html"><![CDATA[<h1 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a>112. Path Sum (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</h2><h2 id="A-leaf-is-a-node-with-no-children"><a href="#A-leaf-is-a-node-with-no-children" class="headerlink" title="A leaf is a node with no children."></a>A leaf is a node with no children.</h2><p><a href="https://leetcode.cn/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">官方题解</a></p><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p><p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p><p>复杂度分析</p><p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617. Merge Two Binary Trees (Easy)</title>
      <link href="/2022/08/15/617/"/>
      <url>/2022/08/15/617/</url>
      
        <content type="html"><![CDATA[<h1 id="617-Merge-Two-Binary-Trees-Easy"><a href="#617-Merge-Two-Binary-Trees-Easy" class="headerlink" title="617. Merge Two Binary Trees (Easy)"></a>617. Merge Two Binary Trees (Easy)</h1><h2 id="You-are-given-two-binary-trees-root1-and-root2"><a href="#You-are-given-two-binary-trees-root1-and-root2" class="headerlink" title="You are given two binary trees root1 and root2."></a>You are given two binary trees root1 and root2.</h2><h2 id="Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree"><a href="#Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree" class="headerlink" title="Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree."></a>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</h2><h2 id="Return-the-merged-tree"><a href="#Return-the-merged-tree" class="headerlink" title="Return the merged tree."></a>Return the merged tree.</h2><h2 id="Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees"><a href="#Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees" class="headerlink" title="Note: The merging process must start from the root nodes of both trees."></a>Note: The merging process must start from the root nodes of both trees.</h2><h3 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/">参考解析</a></h3><p>对于二叉树来说，如果我们像遍历数组那样，挨个遍历两颗二叉树中的每个节点，再把他们相加，那问题就比较容易解决了。</p><p>遍历二叉树很简单，用 前序 遍历就可以了，再依次把访问到的节点值相加，因为题目没有说不能改变树的值和结构，我们不用再创建新的节点了，直接将树2合并到树1上再返回就可以了。<br>需要注意：这两颗树并不是长得完全一样，有的树可能有左节点，但有的树没有。</p><p>总结下递归的条件：</p><p>终止条件：树 1 的节点为 null，或者树 2 的节点为 null<br>递归函数内：将两个树的节点相加后，再赋给树 1 的节点。再递归的执行两个树的左节点，递归执行两个树的右节点</p><p>总结一下就是把root2的值复制到root1上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root1,root2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root1 <span class="keyword">and</span> root2):</span><br><span class="line">                <span class="keyword">return</span> root1 <span class="keyword">if</span> root1 <span class="keyword">else</span> root2</span><br><span class="line">            root1.val += root2.val</span><br><span class="line">            root1.left = dfs(root1.left,root2.left)</span><br><span class="line">            root1.right = dfs(root1.right,root2.right)</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">return</span> dfs(root1,root2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226. Invert Binary Tree (Easy)</title>
      <link href="/2022/08/15/226/"/>
      <url>/2022/08/15/226/</url>
      
        <content type="html"><![CDATA[<h1 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a>226. Invert Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root"><a href="#Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root" class="headerlink" title="Given the root of a binary tree, invert the tree, and return its root."></a>Given the root of a binary tree, invert the tree, and return its root.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode-solution/">官方题解</a></h3><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if not root:            return root        left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left = right        root.right = left        return root</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543. Diameter of Binary Tree (Easy)</title>
      <link href="/2022/08/14/543/"/>
      <url>/2022/08/14/543/</url>
      
        <content type="html"><![CDATA[<h1 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a>543. Diameter of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree"><a href="#Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree" class="headerlink" title="Given the root of a binary tree, return the length of the diameter of the tree."></a>Given the root of a binary tree, return the length of the diameter of the tree.</h2><h2 id="The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root"><a href="#The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root" class="headerlink" title="The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root."></a>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</h2><h2 id="The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them"><a href="#The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them" class="headerlink" title="The length of a path between two nodes is represented by the number of edges between them."></a>The length of a path between two nodes is represented by the number of edges between them.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/">官方题解</a></h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>其实我看到这道题感觉和<a href="https://upuphero.github.io/2022/08/14/110/">110. Balanced Binary Tree (Easy)</a>很像，可以在求高度的基础上稍微改一下<br>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p><p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p><p>我们记节点node 为起点的路径经过节点数的最大值为 d<sub>node</sub>，那么二叉树的直径就是所有节点 d<sub>node</sub>的最大值减一。</p><p>最后的算法流程为：我们定义一个递归函数 depth(node) 计算 d<sub>node</sub>，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为max(L,R)+1</p><p>该节点的 d<sub>node</sub> 值为L+R+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="comment"># 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 左儿子为根的子树的深度</span></span><br><span class="line">            L = depth(root.left)</span><br><span class="line">            <span class="comment"># 右儿子为根的子树的深度</span></span><br><span class="line">            R = depth(root.right)</span><br><span class="line">            <span class="comment"># 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, L + R + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 返回该节点为根的子树的深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        depth(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110. Balanced Binary Tree (Easy)</title>
      <link href="/2022/08/14/110/"/>
      <url>/2022/08/14/110/</url>
      
        <content type="html"><![CDATA[<h1 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a>110. Balanced Binary Tree (Easy)</h1><h2 id="Given-a-binary-tree-determine-if-it-is-height-balanced"><a href="#Given-a-binary-tree-determine-if-it-is-height-balanced" class="headerlink" title="Given a binary tree, determine if it is height-balanced."></a>Given a binary tree, determine if it is height-balanced.</h2><h2 id="For-this-problem-a-height-balanced-binary-tree-is-defined-as"><a href="#For-this-problem-a-height-balanced-binary-tree-is-defined-as" class="headerlink" title="For this problem, a height-balanced binary tree is defined as:"></a>For this problem, a height-balanced binary tree is defined as:</h2><h2 id="a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1"><a href="#a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1" class="headerlink" title="a binary tree in which the left and right subtrees of every node differ in height by no more than 1."></a>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">两种办法</a></p><h3 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h3><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：<br>height(p)=max(height(p.left),height(p.right))+1 P是非空节点</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(height(root.left), height(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><h3 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h3><p>方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftHeight = height(root.left)</span><br><span class="line">            rightHeight = height(root.right)</span><br><span class="line">            <span class="keyword">if</span> leftHeight == -<span class="number">1</span> <span class="keyword">or</span> rightHeight == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_depth = helper(node.left)</span><br><span class="line">            right_depth = helper(node.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(left_depth - right_depth) &gt; <span class="number">1</span>:</span><br><span class="line">                flag[<span class="number">0</span>] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span></span><br><span class="line">        flag = [<span class="literal">True</span>]</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> flag[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这里为什么要用flag[0]而不是一个变量呢？<br>直接一个变量需要加self关键字，否则传不进递归函数里，因为变量的赋值和初始化都是一个语法会导致歧义，所以递归里修改flag的值会当成定义一个新的flag变量，而这个变量只在递归里生效，所以递归外部定义的flag无法被修改，大概类似局部变量和全局变量的区别，而列表、字典等，初始化和赋值的方法不同，因此不会导致歧义，所以函数对其修改也会改变调用代码中的值，结论如下:</p><p>列表、字典、集合：总是会按引用传入函数，函数代码组中对变量数据结构的任何改变都会反映到调用代码中。<br>字符串、整数 、元组：总是会按值传入函数，函数中对变量的任何修改是这个函数私有的，不会反映到调用代码中。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree (Easy)</title>
      <link href="/2022/08/14/104/"/>
      <url>/2022/08/14/104/</url>
      
        <content type="html"><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a>104. Maximum Depth of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-its-maximum-depth"><a href="#Given-the-root-of-a-binary-tree-return-its-maximum-depth" class="headerlink" title="Given the root of a binary tree, return its maximum depth."></a>Given the root of a binary tree, return its maximum depth.</h2><h2 id="A-binary-tree’s-maximum-depth-is-the-number-of-nodes-along-the-longest-path-from-the-root-node-down-to-the-farthest-leaf-node"><a href="#A-binary-tree’s-maximum-depth-is-the-number-of-nodes-along-the-longest-path-from-the-root-node-down-to-the-farthest-leaf-node" class="headerlink" title="A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node."></a>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><p>这道题是求二叉树的深度，可以用深度优先搜索。<br>算法思想： 一个节点的高度=max(左孩子的高度,右孩子的高度)+1。 进行先序遍历搜索，每次递归返回的时候统计其左右孩子中最大的深度。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root is None:            return 0        else:            left_height = self.maxDepth(root.left)            right_height = self.maxDepth(root.right)            return max(left_height,right_height)+1</code></pre>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>328. Odd Even Linked List (Medium)</title>
      <link href="/2022/08/06/328/"/>
      <url>/2022/08/06/328/</url>
      
        <content type="html"><![CDATA[<h1 id="328-Odd-Even-Linked-List-Medium"><a href="#328-Odd-Even-Linked-List-Medium" class="headerlink" title="328. Odd Even Linked List (Medium)"></a>328. Odd Even Linked List (Medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-group-all-the-nodes-with-odd-indices-together-followed-by-the-nodes-with-even-indices-and-return-the-reordered-list"><a href="#Given-the-head-of-a-singly-linked-list-group-all-the-nodes-with-odd-indices-together-followed-by-the-nodes-with-even-indices-and-return-the-reordered-list" class="headerlink" title="Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list."></a>Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.</h2><h2 id="The-first-node-is-considered-odd-and-the-second-node-is-even-and-so-on"><a href="#The-first-node-is-considered-odd-and-the-second-node-is-even-and-so-on" class="headerlink" title="The first node is considered odd, and the second node is even, and so on."></a>The first node is considered odd, and the second node is even, and so on.</h2><h2 id="Note-that-the-relative-order-inside-both-the-even-and-odd-groups-should-remain-as-it-was-in-the-input"><a href="#Note-that-the-relative-order-inside-both-the-even-and-odd-groups-should-remain-as-it-was-in-the-input" class="headerlink" title="Note that the relative order inside both the even and odd groups should remain as it was in the input."></a>Note that the relative order inside both the even and odd groups should remain as it was in the input.</h2><h2 id="You-must-solve-the-problem-in-O-1-extra-space-complexity-and-O-n-time-complexity"><a href="#You-must-solve-the-problem-in-O-1-extra-space-complexity-and-O-n-time-complexity" class="headerlink" title="You must solve the problem in O(1) extra space complexity and O(n) time complexity."></a>You must solve the problem in O(1) extra space complexity and O(n) time complexity.</h2><p>总结是把奇数节点串一块儿，再把偶数节点串一起，然后把两个连成一条链表</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/odd-even-linked-list/solution/qi-ou-lian-biao-by-leetcode-solution/">官方题解</a></h3><p><img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        evenHead = head.<span class="built_in">next</span> <span class="comment">#新建一个链表头</span></span><br><span class="line">        odd, even = head, evenHead</span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">            odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">            odd = odd.<span class="built_in">next</span></span><br><span class="line">            even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">            even = even.<span class="built_in">next</span></span><br><span class="line">        odd.<span class="built_in">next</span> = evenHead</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>725. Split Linked List in Parts(Medium)</title>
      <link href="/2022/08/06/725/"/>
      <url>/2022/08/06/725/</url>
      
        <content type="html"><![CDATA[<h1 id="725-Split-Linked-List-in-Parts-Medium"><a href="#725-Split-Linked-List-in-Parts-Medium" class="headerlink" title="725. Split Linked List in Parts(Medium)"></a>725. Split Linked List in Parts(Medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-and-an-integer-k-split-the-linked-list-into-k-consecutive-linked-list-parts"><a href="#Given-the-head-of-a-singly-linked-list-and-an-integer-k-split-the-linked-list-into-k-consecutive-linked-list-parts" class="headerlink" title="Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts."></a>Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.</h2><h2 id="The-length-of-each-part-should-be-as-equal-as-possible-no-two-parts-should-have-a-size-differing-by-more-than-one-This-may-lead-to-some-parts-being-null"><a href="#The-length-of-each-part-should-be-as-equal-as-possible-no-two-parts-should-have-a-size-differing-by-more-than-one-This-may-lead-to-some-parts-being-null" class="headerlink" title="The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null."></a>The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.</h2><h2 id="The-parts-should-be-in-the-order-of-occurrence-in-the-input-list-and-parts-occurring-earlier-should-always-have-a-size-greater-than-or-equal-to-parts-occurring-later"><a href="#The-parts-should-be-in-the-order-of-occurrence-in-the-input-list-and-parts-occurring-earlier-should-always-have-a-size-greater-than-or-equal-to-parts-occurring-later" class="headerlink" title="The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later."></a>The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.</h2><h2 id="Return-an-array-of-the-k-parts"><a href="#Return-an-array-of-the-k-parts" class="headerlink" title="Return an array of the k parts."></a>Return an array of the k parts.</h2><h3 id="题目描述：把链表分隔成-k-部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。"><a href="#题目描述：把链表分隔成-k-部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。" class="headerlink" title="题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。"></a>题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</h3><p>其实就是n个数分成m组，前面一些组多一个，n/m+1，后面的组数量是n/m</p><p><a href="https://leetcode.cn/problems/split-linked-list-in-parts/solution/fen-ge-lian-biao-by-leetcode-solution-wevt/">代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[ListNode]:</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node: <span class="comment">#一次遍历得到长度</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        quotient, remainder = L // k, L % k</span><br><span class="line"></span><br><span class="line">        parts = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]  <span class="comment">#create lists of size n and initialize with None</span></span><br><span class="line">        i, curr = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> i &lt; k <span class="keyword">and</span> curr:</span><br><span class="line">            parts[i] = curr</span><br><span class="line">            <span class="keyword">if</span> i&lt;remainder:</span><br><span class="line">                part_size = quotient + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                part_size = quotient</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(part_size - <span class="number">1</span>):</span><br><span class="line">                <span class="comment">#for _ in range:When you are not interested in some values returned by a function we use underscore in place of variable name . Basically it means you are not interested in how many times the loop is run till now just that it should run some specific number of times overall.</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> parts</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List (Easy)</title>
      <link href="/2022/08/04/234/"/>
      <url>/2022/08/04/234/</url>
      
        <content type="html"><![CDATA[<h1 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a>234. Palindrome Linked List (Easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-return-true-if-it-is-a-palindrome"><a href="#Given-the-head-of-a-singly-linked-list-return-true-if-it-is-a-palindrome" class="headerlink" title="Given the head of a singly linked list, return true if it is a palindrome."></a>Given the head of a singly linked list, return true if it is a palindrome.</h2><p>这道题的关键在于如何控制空间复杂度。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/">官方题解</a></h3><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n):"></a>O(n):</h3><p>简单来说就是把链表的数值全都存到数组里，然后再进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        vals = []</span><br><span class="line">        current_node = head</span><br><span class="line">        <span class="keyword">while</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            vals.append(current_node.val)</span><br><span class="line">            current_node = current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1):"></a>O(1):</h3><p>避免使用 O(n)额外空间的方法就是改变输入。</p><p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p><p>该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p><p>算法</p><p>整个流程可以分为以下五个步骤：</p><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        first_half_end = self.end_of_first_half(head)</span><br><span class="line">        second_half_start = self.reverse_list(first_half_end.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否回文</span></span><br><span class="line">        result = <span class="literal">True</span></span><br><span class="line">        first_position = head</span><br><span class="line">        second_position = second_half_start</span><br><span class="line">        <span class="keyword">while</span> result <span class="keyword">and</span> second_position <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> first_position.val != second_position.val:</span><br><span class="line">                result = <span class="literal">False</span></span><br><span class="line">            first_position = first_position.<span class="built_in">next</span></span><br><span class="line">            second_position = second_position.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 还原链表并返回结果</span></span><br><span class="line">        first_half_end.<span class="built_in">next</span> = self.reverse_list(second_half_start)</span><br><span class="line">        <span class="keyword">return</span> result    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_of_first_half</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = next_node</span><br><span class="line">        <span class="keyword">return</span> previous</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://labuladong.github.io/algo/2/19/21/">回文链表</a></h3><p>这里运用到一个非常有趣的方法，借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表</p><p>实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已<br><img src="https://labuladong.github.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/1.gif"></p><p>首先，寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。对于单链表，无法直接倒序遍历，可以造一条新的反转链表，可以利用链表的后序遍历，也可以用栈结构倒序处理单链表。</p><p>具体到回文链表的判断问题，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到 O(1)。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="1-先通过-双指针技巧-中的快慢指针来找到链表的中点："><a href="#1-先通过-双指针技巧-中的快慢指针来找到链表的中点：" class="headerlink" title="1. 先通过 双指针技巧 中的快慢指针来找到链表的中点："></a>1. 先通过 双指针技巧 中的快慢指针来找到链表的中点：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode slow, fast;</span><br><span class="line">slow = fast = head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// slow 指针现在指向链表中点</span></span><br></pre></td></tr></table></figure><h5 id="2-如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步："><a href="#2-如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步：" class="headerlink" title="2. 如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步："></a>2. 如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fast != <span class="keyword">null</span>)</span><br><span class="line">    slow = slow.next;</span><br></pre></td></tr></table></figure><h5 id="3-从slow开始反转后面的链表，现在就可以开始比较回文串了："><a href="#3-从slow开始反转后面的链表，现在就可以开始比较回文串了：" class="headerlink" title="3. 从slow开始反转后面的链表，现在就可以开始比较回文串了："></a>3. 从slow开始反转后面的链表，现在就可以开始比较回文串了：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode left = head;</span><br><span class="line">ListNode right = reverse(slow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    left = left.next;</span><br><span class="line">    right = right.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><h5 id="4-总代码"><a href="#4-总代码" class="headerlink" title="4. 总代码"></a>4. 总代码</h5><p>java 原版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow, fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>)</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    </span><br><span class="line">    ListNode left = head;</span><br><span class="line">    ListNode right = reverse(slow);</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>, cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python 改版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            current = head</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                nxt = current.<span class="built_in">next</span></span><br><span class="line">                current.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = current </span><br><span class="line">                current = nxt</span><br><span class="line">            <span class="keyword">return</span> pre        </span><br><span class="line">        slow =head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        left = head</span><br><span class="line">        right = reverse(slow)</span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val!=right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left= left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>445. Add Two Numbers II (Medium)</title>
      <link href="/2022/08/04/445/"/>
      <url>/2022/08/04/445/</url>
      
        <content type="html"><![CDATA[<h1 id="445-Add-Two-Numbers-II-Medium"><a href="#445-Add-Two-Numbers-II-Medium" class="headerlink" title="445. Add Two Numbers II (Medium)"></a>445. Add Two Numbers II (Medium)</h1><h2 id="You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-most-significant-digit-comes-first-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list"><a href="#You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-most-significant-digit-comes-first-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list" class="headerlink" title="You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list."></a>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</h2><h2 id="You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself"><a href="#You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself" class="headerlink" title="You may assume the two numbers do not contain any leading zero, except the number 0 itself."></a>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">Output: [7,8,0,7]</span><br></pre></td></tr></table></figure><p>这个例子想讲的其实就是7243+564=7807</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/">官方题解</a></h2><p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p><h3 id="对于逆序处理应该首先想到栈"><a href="#对于逆序处理应该首先想到栈" class="headerlink" title="对于逆序处理应该首先想到栈"></a>对于逆序处理应该首先想到栈</h3><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/zhang-by-kind-i3lackburnmaf-aamu/">代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s1 <span class="keyword">else</span> s1.pop()</span><br><span class="line">            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">else</span> s2.pop()</span><br><span class="line">            cur = a + b + carry</span><br><span class="line">            carry = cur // <span class="number">10</span></span><br><span class="line">            cur %= <span class="number">10</span></span><br><span class="line">            curnode = ListNode(cur)</span><br><span class="line">            curnode.<span class="built_in">next</span> = ans</span><br><span class="line">            ans = curnode</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. Swap Nodes in Pairs (Medium)</title>
      <link href="/2022/08/04/24/"/>
      <url>/2022/08/04/24/</url>
      
        <content type="html"><![CDATA[<h1 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a>24. Swap Nodes in Pairs (Medium)</h1><h2 id="Given-a-linked-list-swap-every-two-adjacent-nodes-and-return-its-head-You-must-solve-the-problem-without-modifying-the-values-in-the-list’s-nodes-i-e-only-nodes-themselves-may-be-changed"><a href="#Given-a-linked-list-swap-every-two-adjacent-nodes-and-return-its-head-You-must-solve-the-problem-without-modifying-the-values-in-the-list’s-nodes-i-e-only-nodes-themselves-may-be-changed" class="headerlink" title="Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)"></a>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(newHead.<span class="built_in">next</span>)</span><br><span class="line">        newHead.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List (medium)</title>
      <link href="/2022/08/01/19/"/>
      <url>/2022/08/01/19/</url>
      
        <content type="html"><![CDATA[<h1 id="19-Remove-Nth-Node-From-End-of-List-medium"><a href="#19-Remove-Nth-Node-From-End-of-List-medium" class="headerlink" title="19. Remove Nth Node From End of List (medium)"></a>19. Remove Nth Node From End of List (medium)</h1><h2 id="Given-the-head-of-a-linked-list-remove-the-nth-node-from-the-end-of-the-list-and-return-its-head"><a href="#Given-the-head-of-a-linked-list-remove-the-nth-node-from-the-end-of-the-list-and-return-its-head" class="headerlink" title="Given the head of a linked list, remove the nth node from the end of the list and return its head."></a>Given the head of a linked list, remove the nth node from the end of the list and return its head.</h2><p>移除倒序的第n个节点</p><p>第一反应是两次遍历，第一次遍历先判断链表长度L，然后再遍历第二次算出应该删除的L−n+1节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">head: ListNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 添加哑结点dummy</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        length = getLength(head)</span><br><span class="line">        current = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - n + <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>方法二</p><h3 id="双指针解决问题思路："><a href="#双指针解决问题思路：" class="headerlink" title="双指针解决问题思路："></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/dong-hua-tu-jie-leetcode-di-19-hao-wen-ti-shan-chu/">双指针解决问题思路</a>：</h3><p>我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。</p><ol><li>设置虚拟节点 dummyHead 指向 head</li><li>设定双指针 p 和 q，初始都指向虚拟节点 dummyHead</li><li>移动 q，直到 p 与 q 之间相隔的元素个数为 n</li><li>同时移动 p 与 q，直到 q 指向的为 NULL</li><li>将 p 的下一个节点指向下下个节点</li></ol><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/">代码</a>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        first = head</span><br><span class="line">        second = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first:</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">            second = second.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加哑节点："><a href="#添加哑节点：" class="headerlink" title="添加哑节点："></a>添加哑节点：</h3><p>添加一个哑节点（dummy node），让它的next 指针指向链表的头节点。这样一来，头节点的前驱节点就是哑节点本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(0,head)  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findNth</span>(<span class="params">head,n</span>):</span></span><br><span class="line">            p1=head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = head</span><br><span class="line">            <span class="keyword">while</span> p1:</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">                p1= p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> p2</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        x = findNth(dummy,n+<span class="number">1</span>)</span><br><span class="line">        x.<span class="built_in">next</span> = x.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83. Remove Duplicates from Sorted List (Easy)</title>
      <link href="/2022/08/01/83/"/>
      <url>/2022/08/01/83/</url>
      
        <content type="html"><![CDATA[<h1 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List (Easy)"></a>83. Remove Duplicates from Sorted List (Easy)</h1><h2 id="Given-the-head-of-a-sorted-linked-list-delete-all-duplicates-such-that-each-element-appears-only-once-Return-the-linked-list-sorted-as-well"><a href="#Given-the-head-of-a-sorted-linked-list-delete-all-duplicates-such-that-each-element-appears-only-once-Return-the-linked-list-sorted-as-well" class="headerlink" title="Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well."></a>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</h2><p>删除重复节点<br>因为是有序节点，经过一遍遍历，把重复的删除就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:            </span><br><span class="line">            <span class="keyword">if</span> current.val== current.<span class="built_in">next</span>.val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head     </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List(easy)</title>
      <link href="/2022/07/20/206/"/>
      <url>/2022/07/20/206/</url>
      
        <content type="html"><![CDATA[<h1 id="206-Reverse-Linked-List-easy"><a href="#206-Reverse-Linked-List-easy" class="headerlink" title="206. Reverse Linked List(easy)"></a>206. Reverse Linked List(easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-reverse-the-list-and-return-the-reversed-list"><a href="#Given-the-head-of-a-singly-linked-list-reverse-the-list-and-return-the-reversed-list" class="headerlink" title="Given the head of a singly linked list, reverse the list, and return the reversed list."></a>Given the head of a singly linked list, reverse the list, and return the reversed list.</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p><p>反转数组，还是用双指针，另外设置了一个临时变量tmp记录current的下一个值<br>图例可以看这个<a href="https://leetcode.cn/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">回答</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current !=<span class="literal">None</span>:</span><br><span class="line">            tmp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists (Easy)</title>
      <link href="/2022/07/20/160/"/>
      <url>/2022/07/20/160/</url>
      
        <content type="html"><![CDATA[<h1 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a>160. Intersection of Two Linked Lists (Easy)</h1><h2 id="Given-the-heads-of-two-singly-linked-lists-headA-and-headB-return-the-node-at-which-the-two-lists-intersect-If-the-two-linked-lists-have-no-intersection-at-all-return-null"><a href="#Given-the-heads-of-two-singly-linked-lists-headA-and-headB-return-the-node-at-which-the-two-lists-intersect-If-the-two-linked-lists-have-no-intersection-at-all-return-null" class="headerlink" title="Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null."></a>Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.</h2><h2 id="For-example-the-following-two-linked-lists-begin-to-intersect-at-node-c1"><a href="#For-example-the-following-two-linked-lists-begin-to-intersect-at-node-c1" class="headerlink" title="For example, the following two linked lists begin to intersect at node c1:"></a>For example, the following two linked lists begin to intersect at node c1:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p><h2 id="The-test-cases-are-generated-such-that-there-are-no-cycles-anywhere-in-the-entire-linked-structure"><a href="#The-test-cases-are-generated-such-that-there-are-no-cycles-anywhere-in-the-entire-linked-structure" class="headerlink" title="The test cases are generated such that there are no cycles anywhere in the entire linked structure."></a>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</h2><h2 id="Note-that-the-linked-lists-must-retain-their-original-structure-after-the-function-returns"><a href="#Note-that-the-linked-lists-must-retain-their-original-structure-after-the-function-returns" class="headerlink" title="Note that the linked lists must retain their original structure after the function returns."></a>Note that the linked lists must retain their original structure after the function returns.</h2><h2 id="Custom-Judge"><a href="#Custom-Judge" class="headerlink" title="Custom Judge:"></a>Custom Judge:</h2><h2 id="The-inputs-to-the-judge-are-given-as-follows-your-program-is-not-given-these-inputs"><a href="#The-inputs-to-the-judge-are-given-as-follows-your-program-is-not-given-these-inputs" class="headerlink" title="The inputs to the judge are given as follows (your program is not given these inputs):"></a>The inputs to the judge are given as follows (your program is not given these inputs):</h2><h4 id="intersectVal-The-value-of-the-node-where-the-intersection-occurs-This-is-0-if-there-is-no-intersected-node"><a href="#intersectVal-The-value-of-the-node-where-the-intersection-occurs-This-is-0-if-there-is-no-intersected-node" class="headerlink" title="intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node."></a>intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.</h4><h4 id="listA-The-first-linked-list"><a href="#listA-The-first-linked-list" class="headerlink" title="listA - The first linked list."></a>listA - The first linked list.</h4><h4 id="listB-The-second-linked-list"><a href="#listB-The-second-linked-list" class="headerlink" title="listB - The second linked list."></a>listB - The second linked list.</h4><h4 id="skipA-The-number-of-nodes-to-skip-ahead-in-listA-starting-from-the-head-to-get-to-the-intersected-node"><a href="#skipA-The-number-of-nodes-to-skip-ahead-in-listA-starting-from-the-head-to-get-to-the-intersected-node" class="headerlink" title="skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node."></a>skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.</h4><h4 id="skipB-The-number-of-nodes-to-skip-ahead-in-listB-starting-from-the-head-to-get-to-the-intersected-node"><a href="#skipB-The-number-of-nodes-to-skip-ahead-in-listB-starting-from-the-head-to-get-to-the-intersected-node" class="headerlink" title="skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node."></a>skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.</h4><h3 id="The-judge-will-then-create-the-linked-structure-based-on-these-inputs-and-pass-the-two-heads-headA-and-headB-to-your-program-If-you-correctly-return-the-intersected-node-then-your-solution-will-be-accepted"><a href="#The-judge-will-then-create-the-linked-structure-based-on-these-inputs-and-pass-the-two-heads-headA-and-headB-to-your-program-If-you-correctly-return-the-intersected-node-then-your-solution-will-be-accepted" class="headerlink" title="The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted."></a>The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.</h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><p>这道题可以通过双指针的方法解决，一开始想的是通过两个链表的公共部分从后往前，但是该题题解里有个思路很好：<br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/">160. 相交链表（双指针，清晰图解）</a></p><p>ListA 头节点 headA 到 公共node 前，共有 a - c 个节点；<br>ListB 头节点 headB 到 公共node 前，共有 b - c 个节点；</p><p>考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：</p><p>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 公共node 时，共走步数为：<br>a + (b - c) = a + b - c</p><p>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 公共node 时，共走步数为：<br>b + (a - c) = a + b - c</p><p>所以这就有可以操作的地方了</p><p>如下式所示，此时指针 A , B 重合，并有两种情况：</p><p>a + (b - c) = b + (a - c)</p><p>若两链表 有 公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node 。<br>若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。</p><p>其实就是两边互相换家走一遍，相当于从一开始的头结点开始，指针A,B都走一遍list A和list B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A != B:</span><br><span class="line">            A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.<span class="built_in">next</span> <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br></pre></td></tr></table></figure><p>其实没看懂实现逻辑（基础不牢固），后来搜了一下是python的一个条件表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">It&#x27;s a conditional expression:</span><br><span class="line"></span><br><span class="line">A if PREDICATE else B</span><br><span class="line">A is yielded if PREDICATE is true, otherwise B is yielded.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#x27;A&#x27; if 1 &lt; 2 else &#x27;B&#x27;</span><br><span class="line">&#x27;A&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;A&#x27; if 1 &gt; 2 else &#x27;B&#x27;</span><br><span class="line">&#x27;B&#x27;</span><br></pre></td></tr></table></figure><p>换成完整版就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 1 &lt; 2:</span><br><span class="line">    &#x27;A&#x27;</span><br><span class="line">else: &#x27;B&#x27;</span><br></pre></td></tr></table></figure><p>所以题解里的写法其实可以写成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        a,b= headA,headB</span><br><span class="line">        <span class="keyword">while</span> a!=b:</span><br><span class="line">            <span class="keyword">if</span> a:</span><br><span class="line">                a =a.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: a= headB</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> b:</span><br><span class="line">                b =b.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: b = headA</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode12-Tree</title>
      <link href="/2022/07/20/LeetCode12-Tree/"/>
      <url>/2022/07/20/LeetCode12-Tree/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><h2 id="Leetcode-题解-链表"><a href="#Leetcode-题解-链表" class="headerlink" title="Leetcode 题解 - 链表"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md">Leetcode 题解 - 链表</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/linked-list/">leetcode tag</a></h2><p>如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。</p><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers(medium)</title>
      <link href="/2022/07/15/2/"/>
      <url>/2022/07/15/2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers-medium"><a href="#2-Add-Two-Numbers-medium" class="headerlink" title="2. Add Two Numbers(medium)"></a>2. Add Two Numbers(medium)</h1><h2 id="You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list"><a href="#You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list" class="headerlink" title="You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list."></a>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</h2><h2 id="You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself"><a href="#You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself" class="headerlink" title="You may assume the two numbers do not contain any leading zero, except the number 0 itself."></a>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">Output: [7,0,8]</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">        current = pre</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1!=<span class="literal">None</span> <span class="keyword">or</span> l2!= <span class="literal">None</span> <span class="keyword">or</span> carry!=<span class="number">0</span>:</span><br><span class="line">            l1val= l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l2val= l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span> </span><br><span class="line">            columnSum = l1val+l2val+carry</span><br><span class="line">            carry = columnSum //<span class="number">10</span></span><br><span class="line">            newNode = ListNode(columnSum%<span class="number">10</span>)</span><br><span class="line">            current.<span class="built_in">next</span> = newNode</span><br><span class="line">            current = newNode</span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> pre.<span class="built_in">next</span>            </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode11-Linked list</title>
      <link href="/2022/07/15/LeetCode11-Linked%20list/"/>
      <url>/2022/07/15/LeetCode11-Linked%20list/</url>
      
        <content type="html"><![CDATA[<p>链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。</p><p>参考：</p><h2 id="Leetcode-题解-链表"><a href="#Leetcode-题解-链表" class="headerlink" title="Leetcode 题解 - 链表"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md">Leetcode 题解 - 链表</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/linked-list/">leetcode tag</a></h2><p>如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。</p><h2 id="Labuladong"><a href="#Labuladong" class="headerlink" title="Labuladong"></a><a href="https://labuladong.github.io/algo/2/19/18/">Labuladong</a></h2><p>本文就总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：</p><p>1、合并两个有序链表</p><p>2、链表的分解</p><p>3、合并 k 个有序链表</p><p>4、寻找单链表的倒数第 k 个节点</p><p>5、寻找单链表的中点</p><p>6、判断单链表是否包含环并找出环起点</p><p>7、判断两个单链表是否相交并找出交点</p><p>这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。</p><p>学习如何添加dummy node</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">pre.<span class="built_in">next</span> = head</span><br><span class="line">current = pre</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="141"><li>Linked List Cycle</li></ol><ol start="142"><li><p>Linked List Cycle II(medium)</p></li><li><p>Intersection of Two Linked Lists (Easy)</p></li><li><p>Remove Nth Node From End of List</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findNth</span>(<span class="params">head,n</span>):</span></span><br><span class="line">            p1=head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = head</span><br><span class="line">            <span class="keyword">while</span> p1:</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">                p1= p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> p2</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        x = findNth(dummy,n+<span class="number">1</span>)</span><br><span class="line">        x.<span class="built_in">next</span> = x.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="21"><li>Merge Two Sorted Lists(easy)</li></ol><pre><code class="python">class Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        current = pre =ListNode()        while list1 and list2:            if list1.val&lt;list2.val:                current.next = list1                list1, current = list1.next, list1                #list1 = list1.next                #current = list1                            else:                current.next = list2                list2, current = list2.next, list2                #list2=list2.next                #current = list2        if list1 or list2:            current.next=list1 if list1 else list2        return pre.next</code></pre><p>23</p><p>86</p><ol start="876"><li>Middle of the Linked List(easy)</li></ol><ol start="234"><li>Palindrome Linked List<br>回文链表<br>这里运用到一个非常有趣的方法，借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表</li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode10-Backtracking</title>
      <link href="/2022/07/14/LeetCode10-Backtracking/"/>
      <url>/2022/07/14/LeetCode10-Backtracking/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯题目总结："><a href="#回溯题目总结：" class="headerlink" title="回溯题目总结："></a>回溯题目总结：</h1><h2 id="Backtracking-Python-problems-solutions-interview-prep"><a href="#Backtracking-Python-problems-solutions-interview-prep" class="headerlink" title="Backtracking Python problems+ solutions- interview prep"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/780232/Backtracking-Python-problems%2B-solutions-interview-prep">Backtracking Python problems+ solutions- interview prep</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/backtracking/">leetcode tag</a></h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number(medium)</title>
      <link href="/2022/07/14/17/"/>
      <url>/2022/07/14/17/</url>
      
        <content type="html"><![CDATA[<h1 id="17-Letter-Combinations-of-a-Phone-Number-medium"><a href="#17-Letter-Combinations-of-a-Phone-Number-medium" class="headerlink" title="17. Letter Combinations of a Phone Number(medium)"></a>17. Letter Combinations of a Phone Number(medium)</h1><h2 id="Given-a-string-containing-digits-from-2-9-inclusive-return-all-possible-letter-combinations-that-the-number-could-represent-Return-the-answer-in-any-order"><a href="#Given-a-string-containing-digits-from-2-9-inclusive-return-all-possible-letter-combinations-that-the-number-could-represent-Return-the-answer-in-any-order" class="headerlink" title="Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order."></a>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</h2><h2 id="A-mapping-of-digits-to-letters-just-like-on-the-telephone-buttons-is-given-below-Note-that-1-does-not-map-to-any-letters"><a href="#A-mapping-of-digits-to-letters-just-like-on-the-telephone-buttons-is-given-below-Note-that-1-does-not-map-to-any-letters" class="headerlink" title="A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters."></a>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phone = &#123;&#x27;2&#x27;:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">                 &#x27;3&#x27;:[&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;],</span><br><span class="line">                 &#x27;4&#x27;:[&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;],</span><br><span class="line">                 &#x27;5&#x27;:[&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;],</span><br><span class="line">                 &#x27;6&#x27;:[&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;],</span><br><span class="line">                 &#x27;7&#x27;:[&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;],</span><br><span class="line">                 &#x27;8&#x27;:[&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;],</span><br><span class="line">                 &#x27;9&#x27;:[&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]&#125;</span><br><span class="line">                </span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>这题属于是hashmap记录数字和字母的对应关系，然后再用回溯的方法解决</p><h2 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/">leetcode题解</a></h2><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: </span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        phone = &#123;<span class="string">&#x27;2&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;3&#x27;</span>:[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;4&#x27;</span>:[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;5&#x27;</span>:[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;6&#x27;</span>:[<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;7&#x27;</span>:[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;8&#x27;</span>:[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;9&#x27;</span>:[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]&#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">conbination,nextdigit</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nextdigit) == <span class="number">0</span>:</span><br><span class="line">                res.append(conbination)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phone[nextdigit[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(conbination + letter,nextdigit[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="string">&#x27;&#x27;</span>,digits)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> mapping </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. Integer to Roman(medium)</title>
      <link href="/2022/07/13/12/"/>
      <url>/2022/07/13/12/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman-medium"><a href="#12-Integer-to-Roman-medium" class="headerlink" title="12. Integer to Roman(medium)"></a>12. Integer to Roman(medium)</h1><h2 id="Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M"><a href="#Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M" class="headerlink" title="Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M."></a>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><h2 id="For-example-2-is-written-as-II-in-Roman-numeral-just-two-one’s-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II"><a href="#For-example-2-is-written-as-II-in-Roman-numeral-just-two-one’s-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II" class="headerlink" title="For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II."></a>For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</h2><h2 id="Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used"><a href="#Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used" class="headerlink" title="Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:"></a>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I can be placed before V (5) and X (10) to make 4 and 9. </span><br><span class="line">X can be placed before L (50) and C (100) to make 40 and 90. </span><br><span class="line">C can be placed before D (500) and M (1000) to make 400 and 900.</span><br><span class="line">Given an integer, convert it to a roman numeral.</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>这题和接下来的13题是完全相反的思路，本题（12题）是整数转罗马数字，13题是罗马数字转整数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: num = 3</span><br><span class="line">Output: &quot;III&quot;</span><br><span class="line">Explanation: 3 is represented as 3 ones.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: num = 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: num = 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><p>罗马数字由 77 个不同的单字母符号组成，每个符号对应一个具体的数值。此外，减法规则（如问题描述中所述）给出了额外的 66 个复合符号。这给了我们总共 1313 个独特的符号（每个符号由 11 个或 22 个字母组成），如下图所示。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/integer-to-roman/solution/zheng-shu-zhuan-luo-ma-shu-zi-by-leetcod-75rs/">官方题解</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/12/1.png"></p><p>罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。</p><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>根据罗马数字的唯一表示法，为了表示一个给定的整数 num，我们寻找不超过 num 的最大符号值，将 num 减去该符号值，然后继续寻找不超过 num 的最大符号值，将该符号拼接在上一个找到的符号之后，循环直至 num 为 0。最后得到的字符串即为 num 的罗马数字表示。</p><p>编程时，可以建立一个数值-符号对的列表 valueSymbols，按数值从大到小排列。遍历 valueSymbols 中的每个数值-符号对，若当前数值 value 不超过 num，则从 num 中不断减去 value，直至 num 小于 value，然后遍历下一个数值-符号对。若遍历中 num 为 0 则跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    VALUE_SYMBOLS = [</span><br><span class="line">        (<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>),</span><br><span class="line">        (<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>),</span><br><span class="line">        (<span class="number">500</span>, <span class="string">&quot;D&quot;</span>),</span><br><span class="line">        (<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>),</span><br><span class="line">        (<span class="number">100</span>, <span class="string">&quot;C&quot;</span>),</span><br><span class="line">        (<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>),</span><br><span class="line">        (<span class="number">50</span>, <span class="string">&quot;L&quot;</span>),</span><br><span class="line">        (<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>),</span><br><span class="line">        (<span class="number">10</span>, <span class="string">&quot;X&quot;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&quot;V&quot;</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;I&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        roman = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> value, symbol <span class="keyword">in</span> Solution.VALUE_SYMBOLS:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= value:</span><br><span class="line">                num -= value</span><br><span class="line">                roman.append(symbol)</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(roman)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># 使用哈希表，按照从大到小顺序排列</span></span><br><span class="line">        hashmap = &#123;<span class="number">1000</span>:<span class="string">&#x27;M&#x27;</span>, <span class="number">900</span>:<span class="string">&#x27;CM&#x27;</span>, <span class="number">500</span>:<span class="string">&#x27;D&#x27;</span>, <span class="number">400</span>:<span class="string">&#x27;CD&#x27;</span>, <span class="number">100</span>:<span class="string">&#x27;C&#x27;</span>, <span class="number">90</span>:<span class="string">&#x27;XC&#x27;</span>, <span class="number">50</span>:<span class="string">&#x27;L&#x27;</span>, <span class="number">40</span>:<span class="string">&#x27;XL&#x27;</span>, <span class="number">10</span>:<span class="string">&#x27;X&#x27;</span>, <span class="number">9</span>:<span class="string">&#x27;IX&#x27;</span>, <span class="number">5</span>:<span class="string">&#x27;V&#x27;</span>, <span class="number">4</span>:<span class="string">&#x27;IV&#x27;</span>, <span class="number">1</span>:<span class="string">&#x27;I&#x27;</span>&#125;</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">if</span> num // key != <span class="number">0</span>:</span><br><span class="line">                count = num // key  <span class="comment"># 比如输入4000，count 为 4</span></span><br><span class="line">                res += hashmap[key] * count </span><br><span class="line">                num %= key</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists(easy)</title>
      <link href="/2022/07/04/21/"/>
      <url>/2022/07/04/21/</url>
      
        <content type="html"><![CDATA[<h1 id="21-Merge-Two-Sorted-Lists-easy"><a href="#21-Merge-Two-Sorted-Lists-easy" class="headerlink" title="21. Merge Two Sorted Lists(easy)"></a>21. Merge Two Sorted Lists(easy)</h1><h2 id="You-are-given-the-heads-of-two-sorted-linked-lists-list1-and-list2"><a href="#You-are-given-the-heads-of-two-sorted-linked-lists-list1-and-list2" class="headerlink" title="You are given the heads of two sorted linked lists list1 and list2."></a>You are given the heads of two sorted linked lists list1 and list2.</h2><h2 id="Merge-the-two-lists-in-a-one-sorted-list-The-list-should-be-made-by-splicing-together-the-nodes-of-the-first-two-lists"><a href="#Merge-the-two-lists-in-a-one-sorted-list-The-list-should-be-made-by-splicing-together-the-nodes-of-the-first-two-lists" class="headerlink" title="Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists."></a>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</h2><h2 id="Return-the-head-of-the-merged-linked-list"><a href="#Return-the-head-of-the-merged-linked-list" class="headerlink" title="Return the head of the merged linked list."></a>Return the head of the merged linked list.</h2><p>我们判断 list1 和 list2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）</p><h2 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/">leetcode题解</a></h2><p>递归的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1: <span class="keyword">return</span> list2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt;= list2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>,list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1,list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="leetcode题解-1"><a href="#leetcode题解-1" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/discuss/1826693/Python3-MERGING-Explained">leetcode题解</a></h2><p>这个更好理解一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        cur = dummy = ListNode()</span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:               </span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = list1</span><br><span class="line">                list1, cur = list1.<span class="built_in">next</span>, list1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = list2</span><br><span class="line">                list2, cur = list2.<span class="built_in">next</span>, list2</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">or</span> list2:</span><br><span class="line">            cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer(easy)</title>
      <link href="/2022/07/01/13/"/>
      <url>/2022/07/01/13/</url>
      
        <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-easy"><a href="#13-Roman-to-Integer-easy" class="headerlink" title="13. Roman to Integer(easy)"></a>13. Roman to Integer(easy)</h1><h2 id="Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M"><a href="#Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M" class="headerlink" title="Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M."></a>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</h2><h2 id="For-example-2-is-written-as-II-in-Roman-numeral-just-two-ones-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II"><a href="#For-example-2-is-written-as-II-in-Roman-numeral-just-two-ones-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II" class="headerlink" title="For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II."></a>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</h2><h2 id="Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used"><a href="#Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used" class="headerlink" title="Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:"></a>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</h2><h2 id="I-can-be-placed-before-V-5-and-X-10-to-make-4-and-9"><a href="#I-can-be-placed-before-V-5-and-X-10-to-make-4-and-9" class="headerlink" title="I can be placed before V (5) and X (10) to make 4 and 9."></a>I can be placed before V (5) and X (10) to make 4 and 9.</h2><h2 id="X-can-be-placed-before-L-50-and-C-100-to-make-40-and-90"><a href="#X-can-be-placed-before-L-50-and-C-100-to-make-40-and-90" class="headerlink" title="X can be placed before L (50) and C (100) to make 40 and 90."></a>X can be placed before L (50) and C (100) to make 40 and 90.</h2><h2 id="C-can-be-placed-before-D-500-and-M-1000-to-make-400-and-900"><a href="#C-can-be-placed-before-D-500-and-M-1000-to-make-400-and-900" class="headerlink" title="C can be placed before D (500) and M (1000) to make 400 and 900."></a>C can be placed before D (500) and M (1000) to make 400 and 900.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/">官方题解</a></p><p>这题的特点<br>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p><p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</p><p>例如 XIV 可视作 X−I+V=10−1+5=14。</p><h3 id="但是评论里有超神思路："><a href="#但是评论里有超神思路：" class="headerlink" title="但是评论里有超神思路："></a>但是评论里有超神思路：</h3><p><a href="https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/1060752">从右到左遍历，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减，更好理解吧</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        highestLevel = <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s[::-<span class="number">1</span>]:</span><br><span class="line">            level = mapping[ch]</span><br><span class="line">            <span class="keyword">if</span> level &gt;= highestLevel:</span><br><span class="line">                result += level</span><br><span class="line">                highestLevel = level</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result -= level</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
            <tag> mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. Palindrome Number(easy)</title>
      <link href="/2022/07/01/9/"/>
      <url>/2022/07/01/9/</url>
      
        <content type="html"><![CDATA[<h1 id="9-Palindrome-Number-easy"><a href="#9-Palindrome-Number-easy" class="headerlink" title="9. Palindrome Number(easy)"></a>9. Palindrome Number(easy)</h1><h2 id="Given-an-integer-x-return-true-if-x-is-palindrome-integer"><a href="#Given-an-integer-x-return-true-if-x-is-palindrome-integer" class="headerlink" title="Given an integer x, return true if x is palindrome integer."></a>Given an integer x, return true if x is palindrome integer.</h2><h2 id="An-integer-is-a-palindrome-when-it-reads-the-same-backward-as-forward"><a href="#An-integer-is-a-palindrome-when-it-reads-the-same-backward-as-forward" class="headerlink" title="An integer is a palindrome when it reads the same backward as forward."></a>An integer is a palindrome when it reads the same backward as forward.</h2><h2 id="For-example-121-is-a-palindrome-while-123-is-not"><a href="#For-example-121-is-a-palindrome-while-123-is-not" class="headerlink" title="For example, 121 is a palindrome while 123 is not."></a>For example, 121 is a palindrome while 123 is not.</h2><p>找到回文数</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/">官方题解</a></h2><p>反转一半数字<br>思路</p><p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。</p><p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p><p>根据官方题解改的python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        revertedNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; revertedNumber:</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber <span class="keyword">or</span> x == revertedNumber // <span class="number">10</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Palindrome Number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum(medium)</title>
      <link href="/2022/07/01/15/"/>
      <url>/2022/07/01/15/</url>
      
        <content type="html"><![CDATA[<h1 id="15-3Sum-medium"><a href="#15-3Sum-medium" class="headerlink" title="15. 3Sum(medium)"></a>15. 3Sum(medium)</h1><h2 id="Given-an-integer-array-nums-return-all-the-triplets-nums-i-nums-j-nums-k-such-that-i-j-i-k-and-j-k-and-nums-i-nums-j-nums-k-0"><a href="#Given-an-integer-array-nums-return-all-the-triplets-nums-i-nums-j-nums-k-such-that-i-j-i-k-and-j-k-and-nums-i-nums-j-nums-k-0" class="headerlink" title="Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0."></a>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</h2><h2 id="Notice-that-the-solution-set-must-not-contain-duplicate-triplets"><a href="#Notice-that-the-solution-set-must-not-contain-duplicate-triplets" class="headerlink" title="Notice that the solution set must not contain duplicate triplets."></a>Notice that the solution set must not contain duplicate triplets.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>): <span class="comment"># renamed this to left because this will always be the leftmost pointer in the triplet</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]: <span class="comment"># this step makes sure that we do not have any duplicates in our result output</span></span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">        mid = left + <span class="number">1</span> <span class="comment"># renamed this to mid because this is the pointer that is between the left and right pointers</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> mid &lt; right:</span><br><span class="line">            curr_sum = nums[left] + nums[mid] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> curr_sum &lt; <span class="number">0</span>:</span><br><span class="line">                mid += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">elif</span> curr_sum &gt; <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append([nums[left], nums[mid], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> mid &lt; right <span class="keyword">and</span> nums[mid] == nums[mid + <span class="number">1</span>]: <span class="comment"># Another conditional for not calculating duplicates</span></span><br><span class="line">                    mid += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> mid &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]: <span class="comment"># Avoiding duplicates check</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                mid += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water(medium)</title>
      <link href="/2022/07/01/11/"/>
      <url>/2022/07/01/11/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water-medium"><a href="#11-Container-With-Most-Water-medium" class="headerlink" title="11. Container With Most Water(medium)"></a>11. Container With Most Water(medium)</h1><h2 id="You-are-given-an-integer-array-height-of-length-n-There-are-n-vertical-lines-drawn-such-that-the-two-endpoints-of-the-ith-line-are-i-0-and-i-height-i"><a href="#You-are-given-an-integer-array-height-of-length-n-There-are-n-vertical-lines-drawn-such-that-the-two-endpoints-of-the-ith-line-are-i-0-and-i-height-i" class="headerlink" title="You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i])."></a>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</h2><h2 id="Find-two-lines-that-together-with-the-x-axis-form-a-container-such-that-the-container-contains-the-most-water"><a href="#Find-two-lines-that-together-with-the-x-axis-form-a-container-such-that-the-container-contains-the-most-water" class="headerlink" title="Find two lines that together with the x-axis form a container, such that the container contains the most water."></a>Find two lines that together with the x-axis form a container, such that the container contains the most water.</h2><h2 id="Return-the-maximum-amount-of-water-a-container-can-store"><a href="#Return-the-maximum-amount-of-water-a-container-can-store" class="headerlink" title="Return the maximum amount of water a container can store."></a>Return the maximum amount of water a container can store.</h2><h2 id="Notice-that-you-may-not-slant-the-container"><a href="#Notice-that-you-may-not-slant-the-container" class="headerlink" title="Notice that you may not slant the container."></a>Notice that you may not slant the container.</h2><p>看了题解，双指针，从两头开始内卷，先卷矮的那头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            area = <span class="built_in">min</span>(height[l],height[r])*(r-l)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,area)</span><br><span class="line">            l=</span><br><span class="line">            <span class="keyword">if</span> height[l]&lt;height[r]:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height</span>):</span></span><br><span class="line">        L, R, width, res = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(width, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment">#range(start, stop, step)</span></span><br><span class="line">            <span class="keyword">if</span> height[L] &lt; height[R]:</span><br><span class="line">                res, L = <span class="built_in">max</span>(res, height[L] * w), L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res, R = <span class="built_in">max</span>(res, height[R] * w), R - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters(medium)</title>
      <link href="/2022/07/01/3/"/>
      <url>/2022/07/01/3/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters-medium"><a href="#3-Longest-Substring-Without-Repeating-Characters-medium" class="headerlink" title="3. Longest Substring Without Repeating Characters(medium)"></a>3. Longest Substring Without Repeating Characters(medium)</h1><h2 id="Given-a-string-s-find-the-length-of-the-longest-substring-without-repeating-characters"><a href="#Given-a-string-s-find-the-length-of-the-longest-substring-without-repeating-characters" class="headerlink" title="Given a string s, find the length of the longest substring without repeating characters."></a>Given a string s, find the length of the longest substring without repeating characters.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>这道题第一反应是双指针，通过滑动窗口来解决，但有个需要解决的问题是如果判断substring的字母有重复的。</p><p>利用hashmap查找重复字母<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/376956">leetcode评论</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        k, res, c_dict = -<span class="number">1</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> c_dict <span class="keyword">and</span> c_dict[c] &gt; k:  <span class="comment"># 字符c在字典中 且 上次出现的下标大于当前长度的起始下标</span></span><br><span class="line">                k = c_dict[c]</span><br><span class="line">                c_dict[c] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c_dict[c] = i</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用队列查找字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        lst = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> lst:</span><br><span class="line">                <span class="keyword">del</span> lst[<span class="number">0</span>]  <span class="comment"># 队首元素出队</span></span><br><span class="line">            lst.append(s[i]) <span class="comment"># 排除重复元素后 新元素入队</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(lst))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode09-hashmap</title>
      <link href="/2022/06/28/LeetCode09-hashmap/"/>
      <url>/2022/06/28/LeetCode09-hashmap/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><h2 id="Leetcode-题解-目录-md"><a href="#Leetcode-题解-目录-md" class="headerlink" title="Leetcode 题解 - 目录.md"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md">Leetcode 题解 - 目录.md</a></h2><p>hashmap</p><p><a href="https://leetcode.com/tag/hash-table/">官方hashmaptag</a></p><ol start="12"><li>Integer to Roman(medium)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># 使用哈希表，按照从大到小顺序排列</span></span><br><span class="line">        hashmap = &#123;<span class="number">1000</span>:<span class="string">&#x27;M&#x27;</span>, <span class="number">900</span>:<span class="string">&#x27;CM&#x27;</span>, <span class="number">500</span>:<span class="string">&#x27;D&#x27;</span>, <span class="number">400</span>:<span class="string">&#x27;CD&#x27;</span>, <span class="number">100</span>:<span class="string">&#x27;C&#x27;</span>, <span class="number">90</span>:<span class="string">&#x27;XC&#x27;</span>, <span class="number">50</span>:<span class="string">&#x27;L&#x27;</span>, <span class="number">40</span>:<span class="string">&#x27;XL&#x27;</span>, <span class="number">10</span>:<span class="string">&#x27;X&#x27;</span>, <span class="number">9</span>:<span class="string">&#x27;IX&#x27;</span>, <span class="number">5</span>:<span class="string">&#x27;V&#x27;</span>, <span class="number">4</span>:<span class="string">&#x27;IV&#x27;</span>, <span class="number">1</span>:<span class="string">&#x27;I&#x27;</span>&#125;</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">if</span> num // key != <span class="number">0</span>:</span><br><span class="line">                count = num // key  <span class="comment"># 比如输入4000，count 为 4</span></span><br><span class="line">                res += hashmap[key] * count </span><br><span class="line">                num %= key</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    VALUE_SYMBOLS = [</span><br><span class="line">        (<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>),</span><br><span class="line">        (<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>),</span><br><span class="line">        (<span class="number">500</span>, <span class="string">&quot;D&quot;</span>),</span><br><span class="line">        (<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>),</span><br><span class="line">        (<span class="number">100</span>, <span class="string">&quot;C&quot;</span>),</span><br><span class="line">        (<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>),</span><br><span class="line">        (<span class="number">50</span>, <span class="string">&quot;L&quot;</span>),</span><br><span class="line">        (<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>),</span><br><span class="line">        (<span class="number">10</span>, <span class="string">&quot;X&quot;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&quot;V&quot;</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;I&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        roman = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> value, symbol <span class="keyword">in</span> Solution.VALUE_SYMBOLS:</span><br><span class="line">            <span class="keyword">while</span> num &gt;= value:</span><br><span class="line">                num -= value</span><br><span class="line">                roman.append(symbol)</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(roman)</span><br></pre></td></tr></table></figure><ol start="13"><li>Roman to Integer(easy)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        highestLevel = <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s[::-<span class="number">1</span>]:</span><br><span class="line">            level = mapping[ch]</span><br><span class="line">            <span class="keyword">if</span> level &gt;= highestLevel:</span><br><span class="line">                result += level</span><br><span class="line">                highestLevel = level</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result -= level</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>从这两题我们可以看出hashmap的基础写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mapping = &#123;</span><br><span class="line">            <span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">VALUE_SYMBOLS = [</span><br><span class="line">        (<span class="number">1000</span>, <span class="string">&quot;M&quot;</span>),</span><br><span class="line">        (<span class="number">900</span>, <span class="string">&quot;CM&quot;</span>),</span><br><span class="line">        (<span class="number">500</span>, <span class="string">&quot;D&quot;</span>),</span><br><span class="line">        (<span class="number">400</span>, <span class="string">&quot;CD&quot;</span>),</span><br><span class="line">        (<span class="number">100</span>, <span class="string">&quot;C&quot;</span>),</span><br><span class="line">        (<span class="number">90</span>, <span class="string">&quot;XC&quot;</span>),</span><br><span class="line">        (<span class="number">50</span>, <span class="string">&quot;L&quot;</span>),</span><br><span class="line">        (<span class="number">40</span>, <span class="string">&quot;XL&quot;</span>),</span><br><span class="line">        (<span class="number">10</span>, <span class="string">&quot;X&quot;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&quot;IX&quot;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&quot;V&quot;</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="string">&quot;IV&quot;</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;I&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">hashmap = &#123;<span class="number">1000</span>:<span class="string">&#x27;M&#x27;</span>, <span class="number">900</span>:<span class="string">&#x27;CM&#x27;</span>, <span class="number">500</span>:<span class="string">&#x27;D&#x27;</span>, <span class="number">400</span>:<span class="string">&#x27;CD&#x27;</span>, <span class="number">100</span>:<span class="string">&#x27;C&#x27;</span>, <span class="number">90</span>:<span class="string">&#x27;XC&#x27;</span>, <span class="number">50</span>:<span class="string">&#x27;L&#x27;</span>, <span class="number">40</span>:<span class="string">&#x27;XL&#x27;</span>, <span class="number">10</span>:<span class="string">&#x27;X&#x27;</span>, <span class="number">9</span>:<span class="string">&#x27;IX&#x27;</span>, <span class="number">5</span>:<span class="string">&#x27;V&#x27;</span>, <span class="number">4</span>:<span class="string">&#x27;IV&#x27;</span>, <span class="number">1</span>:<span class="string">&#x27;I&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode08-动态规划</title>
      <link href="/2022/06/28/LeetCode08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/06/28/LeetCode08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-动态规划"><a href="#Leetcode-题解-动态规划" class="headerlink" title="Leetcode 题解 - 动态规划"></a>Leetcode 题解 - 动态规划</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>914. X of a Kind in a Deck of Cards</title>
      <link href="/2022/06/27/914/"/>
      <url>/2022/06/27/914/</url>
      
        <content type="html"><![CDATA[<h1 id="914-X-of-a-Kind-in-a-Deck-of-Cards"><a href="#914-X-of-a-Kind-in-a-Deck-of-Cards" class="headerlink" title="914. X of a Kind in a Deck of Cards"></a>914. X of a Kind in a Deck of Cards</h1><h2 id="In-a-deck-of-cards-each-card-has-an-integer-written-on-it"><a href="#In-a-deck-of-cards-each-card-has-an-integer-written-on-it" class="headerlink" title="In a deck of cards, each card has an integer written on it."></a>In a deck of cards, each card has an integer written on it.</h2><h2 id="Return-true-if-and-only-if-you-can-choose-X-gt-2-such-that-it-is-possible-to-split-the-entire-deck-into-1-or-more-groups-of-cards-where"><a href="#Return-true-if-and-only-if-you-can-choose-X-gt-2-such-that-it-is-possible-to-split-the-entire-deck-into-1-or-more-groups-of-cards-where" class="headerlink" title="Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:"></a>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:</h2><h2 id="Each-group-has-exactly-X-cards"><a href="#Each-group-has-exactly-X-cards" class="headerlink" title="Each group has exactly X cards."></a>Each group has exactly X cards.</h2><h2 id="All-the-cards-in-each-group-have-the-same-integer"><a href="#All-the-cards-in-each-group-have-the-same-integer" class="headerlink" title="All the cards in each group have the same integer."></a>All the cards in each group have the same integer.</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Greatest common divisor  </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. Count Primes (Easy)</title>
      <link href="/2022/06/27/204/"/>
      <url>/2022/06/27/204/</url>
      
        <content type="html"><![CDATA[<h1 id="204-Count-Primes-Easy"><a href="#204-Count-Primes-Easy" class="headerlink" title="204. Count Primes (Easy)"></a>204. Count Primes (Easy)</h1><h2 id="Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n"><a href="#Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n" class="headerlink" title="Given an integer n, return the number of prime numbers that are strictly less than n."></a>Given an integer n, return the number of prime numbers that are strictly less than n.</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/">官方题解</a></h2><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><h3 id="方法二：埃氏筛"><a href="#方法二：埃氏筛" class="headerlink" title="方法二：埃氏筛"></a>方法二：埃氏筛</h3><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 yy 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 xx 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><h4 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.com/problems/count-primes/discuss/153528/Python3-99-112-ms-Explained%3A-The-Sieve-of-Eratosthenes-with-optimizations">leetcode题解</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Sieve of Eratosthenes埃氏筛</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We are only interested in numbers LESS than the input number</span></span><br><span class="line">        <span class="comment"># exit early for numbers LESS than 2; (two is prime)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create strike list for the input range, initializing all indices to</span></span><br><span class="line">        <span class="comment"># prime (1).</span></span><br><span class="line">        strikes = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we know that 0 and 2 are not prime</span></span><br><span class="line">        strikes[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        strikes[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Now set multiples of remaining numbers that are marked as prime to</span></span><br><span class="line">        <span class="comment"># not prime.  It is safe ignore numbers alreay marked as not prime</span></span><br><span class="line">        <span class="comment"># because there are factor(s) that divide evenly into this number and</span></span><br><span class="line">        <span class="comment"># all its multiples.  Use upper limit of (n**0.5)+1, because:</span></span><br><span class="line">        <span class="comment">#  (a) the smallest factor of a non-prime number will not be &gt; sqrt(n).</span></span><br><span class="line">        <span class="comment">#      Ex. non-prime = 100, </span></span><br><span class="line">        <span class="comment">#           5*20</span></span><br><span class="line">        <span class="comment">#           10*10, </span></span><br><span class="line">        <span class="comment">#           20*5   # !! we have seen 5 before.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>  strikes[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># slow:</span></span><br><span class="line">                <span class="comment">#for j in range(i*i, n, i):</span></span><br><span class="line">                <span class="comment">#    strikes[j] = 0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 3x faster:</span></span><br><span class="line">                <span class="comment"># strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)</span></span><br><span class="line">                <span class="comment"># n = 11</span></span><br><span class="line">                <span class="comment"># i = 2</span></span><br><span class="line">                <span class="comment"># (n-1-i*i)//i + 1</span></span><br><span class="line">                <span class="comment"># (n-1)               # get total # of indicies for n (non-inclusive)</span></span><br><span class="line">                <span class="comment">#     -i*i            # shift to get # of slots in range of interest</span></span><br><span class="line">                <span class="comment">#          //i        # get number of groups</span></span><br><span class="line">                <span class="comment">#              + 1    # get number of slots</span></span><br><span class="line">                <span class="comment"># strikes[2*2:11:2]  = [0] * ((11-1-2*2)//2 + 1</span></span><br><span class="line">                <span class="comment"># strikes[4:11:2]    = [0] * 4</span></span><br><span class="line">                <span class="comment"># s[4], s[6], s[8], s10] = 0, 0, 0, 0</span></span><br><span class="line">                strikes[i*i:n:i] = [<span class="number">0</span>] * ((n-<span class="number">1</span>-i*i)//i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(strikes)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]=primes[<span class="number">1</span>]=<span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]= primes[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> prime number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode07-数学</title>
      <link href="/2022/06/26/LeetCode07-%E6%95%B0%E5%AD%A6/"/>
      <url>/2022/06/26/LeetCode07-%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-数学"><a href="#Leetcode-题解-数学" class="headerlink" title="Leetcode 题解 - 数学"></a>Leetcode 题解 - 数学</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p><h3 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h3><h3 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h3><h3 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h3><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h3><h3 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h3><h3 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h3><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h3><h2 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h2><h3 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h3><h3 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h3><h2 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h2><h3 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h3><h2 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h2><h3 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h3><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h3><h3 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h3><h3 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h3><h3 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h3>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode06-搜索</title>
      <link href="/2022/06/23/LeetCode06-%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/06/23/LeetCode06-%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-搜索"><a href="#Leetcode-题解-搜索" class="headerlink" title="Leetcode 题解 - 搜索"></a>Leetcode 题解 - 搜索</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="1-计算在网格中从原点到特定点的最短路径长度"><a href="#1-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="1. 计算在网格中从原点到特定点的最短路径长度"></a>1. 计算在网格中从原点到特定点的最短路径长度</h3><h3 id="2-组成整数的最小平方数数量"><a href="#2-组成整数的最小平方数数量" class="headerlink" title="2. 组成整数的最小平方数数量"></a>2. 组成整数的最小平方数数量</h3><h3 id="3-最短单词路径"><a href="#3-最短单词路径" class="headerlink" title="3. 最短单词路径"></a>3. 最短单词路径</h3><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="1-查找最大的连通面积"><a href="#1-查找最大的连通面积" class="headerlink" title="1. 查找最大的连通面积"></a>1. 查找最大的连通面积</h3><h3 id="2-矩阵中的连通分量数目"><a href="#2-矩阵中的连通分量数目" class="headerlink" title="2. 矩阵中的连通分量数目"></a>2. 矩阵中的连通分量数目</h3><h3 id="3-好友关系的连通分量数目"><a href="#3-好友关系的连通分量数目" class="headerlink" title="3. 好友关系的连通分量数目"></a>3. 好友关系的连通分量数目</h3><h3 id="4-填充封闭区域"><a href="#4-填充封闭区域" class="headerlink" title="4. 填充封闭区域"></a>4. 填充封闭区域</h3><h3 id="5-能到达的太平洋和大西洋的区域"><a href="#5-能到达的太平洋和大西洋的区域" class="headerlink" title="5. 能到达的太平洋和大西洋的区域"></a>5. 能到达的太平洋和大西洋的区域</h3><h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h3 id="1-数字键盘组合"><a href="#1-数字键盘组合" class="headerlink" title="1. 数字键盘组合"></a>1. 数字键盘组合</h3><h3 id="2-IP-地址划分"><a href="#2-IP-地址划分" class="headerlink" title="2. IP 地址划分"></a>2. IP 地址划分</h3><h3 id="3-在矩阵中寻找字符串"><a href="#3-在矩阵中寻找字符串" class="headerlink" title="3. 在矩阵中寻找字符串"></a>3. 在矩阵中寻找字符串</h3><h3 id="4-输出二叉树中所有从根到叶子的路径"><a href="#4-输出二叉树中所有从根到叶子的路径" class="headerlink" title="4. 输出二叉树中所有从根到叶子的路径"></a>4. 输出二叉树中所有从根到叶子的路径</h3><h3 id="5-排列"><a href="#5-排列" class="headerlink" title="5. 排列"></a>5. 排列</h3><h3 id="6-含有相同元素求排列"><a href="#6-含有相同元素求排列" class="headerlink" title="6. 含有相同元素求排列"></a>6. 含有相同元素求排列</h3><h3 id="7-组合"><a href="#7-组合" class="headerlink" title="7. 组合"></a>7. 组合</h3><h3 id="8-组合求和"><a href="#8-组合求和" class="headerlink" title="8. 组合求和"></a>8. 组合求和</h3><h3 id="9-含有相同元素的组合求和"><a href="#9-含有相同元素的组合求和" class="headerlink" title="9. 含有相同元素的组合求和"></a>9. 含有相同元素的组合求和</h3><h3 id="10-1-9-数字的组合求和"><a href="#10-1-9-数字的组合求和" class="headerlink" title="10. 1-9 数字的组合求和"></a>10. 1-9 数字的组合求和</h3><h3 id="11-子集"><a href="#11-子集" class="headerlink" title="11. 子集"></a>11. 子集</h3><h3 id="12-含有相同元素求子集"><a href="#12-含有相同元素求子集" class="headerlink" title="12. 含有相同元素求子集"></a>12. 含有相同元素求子集</h3><h3 id="13-分割字符串使得每个部分都是回文数"><a href="#13-分割字符串使得每个部分都是回文数" class="headerlink" title="13. 分割字符串使得每个部分都是回文数"></a>13. 分割字符串使得每个部分都是回文数</h3><h3 id="14-数独"><a href="#14-数独" class="headerlink" title="14. 数独"></a>14. 数独</h3><h3 id="15-N-皇后"><a href="#15-N-皇后" class="headerlink" title="15. N 皇后"></a>15. N 皇后</h3><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>bfs是按一层一层来访问的，所以适合有目标求最短路的步数，你想想层层搜索每次层就代表了一步。bfs优先访问的是兄弟节点，只有这一层全部访问完才能访问下一层，也就是说bfs第几层就代表当前可以走到的位置(结点).而dfs是按递归来实现的，它优先搜索深度，再回溯，优先访问的是没有访问过的子节点<br>DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。<br>总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易”控制”)，BFS通过控制队列可以很好解决”爆队列”风险。<br>它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>95. Unique Binary Search Trees II (Medium)</title>
      <link href="/2022/06/21/95/"/>
      <url>/2022/06/21/95/</url>
      
        <content type="html"><![CDATA[<h1 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a>95. Unique Binary Search Trees II (Medium)</h1><h2 id="Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order"><a href="#Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order" class="headerlink" title="Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order."></a>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><h2 id="官方leetcode-题解"><a href="#官方leetcode-题解" class="headerlink" title="官方leetcode 题解"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">官方leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>,]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):  <span class="comment"># 枚举可行根节点</span></span><br><span class="line">                <span class="comment"># 获得所有可行的左子树集合</span></span><br><span class="line">                leftTrees = generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获得所有可行的右子树集合</span></span><br><span class="line">                rightTrees = generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        currTree = TreeNode(i)</span><br><span class="line">                        currTree.left = l</span><br><span class="line">                        currTree.right = r</span><br><span class="line">                        allTrees.append(currTree)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>241. Different Ways to Add Parentheses (Medium)</title>
      <link href="/2022/06/21/241/"/>
      <url>/2022/06/21/241/</url>
      
        <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses-Medium"><a href="#241-Different-Ways-to-Add-Parentheses-Medium" class="headerlink" title="241. Different Ways to Add Parentheses (Medium)"></a>241. Different Ways to Add Parentheses (Medium)</h1><h2 id="Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order"><a href="#Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order" class="headerlink" title="Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order."></a>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</h2><h2 id="The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4"><a href="#The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4" class="headerlink" title="The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4."></a>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;2-1-1&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">Explanation:</span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure><h2 id="分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"><a href="#分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。" class="headerlink" title="分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"></a>分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</h2><h2 id="分治法解题的一般步骤（如图1）："><a href="#分治法解题的一般步骤（如图1）：" class="headerlink" title="分治法解题的一般步骤（如图1）："></a>分治法解题的一般步骤（如图1）：</h2><h3 id="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"><a href="#（1）分解，将要解决的问题划分成若干规模较小的同类问题；" class="headerlink" title="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"></a>（1）分解，将要解决的问题划分成若干规模较小的同类问题；</h3><h3 id="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"><a href="#（2）求解，当子问题划分得足够小时，用较简单的方法解决；" class="headerlink" title="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"></a>（2）求解，当子问题划分得足够小时，用较简单的方法解决；</h3><h3 id="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"><a href="#（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。" class="headerlink" title="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"></a>（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</h3><h2 id="leetcode-题解"><a href="#leetcode-题解" class="headerlink" title="leetcode 题解"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/">leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2022/06/20/34/"/>
      <url>/2022/06/20/34/</url>
      
        <content type="html"><![CDATA[<h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a>34. Find First and Last Position of Element in Sorted Array (Medium)</h1><h2 id="Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value"><a href="#Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value" class="headerlink" title="Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value."></a>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</h2><h2 id="If-target-is-not-found-in-the-array-return-1-1"><a href="#If-target-is-not-found-in-the-array-return-1-1" class="headerlink" title="If target is not found in the array, return [-1, -1]."></a>If target is not found in the array, return [-1, -1].</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/837944">Solution</a>:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        start = binarysearchleft(nums, target)</span><br><span class="line">        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start, end]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array (Medium)</title>
      <link href="/2022/06/20/153/"/>
      <url>/2022/06/20/153/</url>
      
        <content type="html"><![CDATA[<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a>153. Find Minimum in Rotated Sorted Array (Medium)</h1><h2 id="Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become"><a href="#Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become" class="headerlink" title="Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:"></a>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</h2><h2 id="4-5-6-7-0-1-2-if-it-was-rotated-4-times"><a href="#4-5-6-7-0-1-2-if-it-was-rotated-4-times" class="headerlink" title="[4,5,6,7,0,1,2] if it was rotated 4 times."></a>[4,5,6,7,0,1,2] if it was rotated 4 times.</h2><h2 id="0-1-2-4-5-6-7-if-it-was-rotated-7-times"><a href="#0-1-2-4-5-6-7-if-it-was-rotated-7-times" class="headerlink" title="[0,1,2,4,5,6,7] if it was rotated 7 times."></a>[0,1,2,4,5,6,7] if it was rotated 7 times.</h2><h2 id="Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2"><a href="#Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2" class="headerlink" title="Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]."></a>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].</h2><h2 id="Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array"><a href="#Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array" class="headerlink" title="Given the sorted rotated array nums of unique elements, return the minimum element of this array."></a>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</h2><h2 id="You-must-write-an-algorithm-that-runs-in-O-log-n-time"><a href="#You-must-write-an-algorithm-that-runs-in-O-log-n-time" class="headerlink" title="You must write an algorithm that runs in O(log n) time."></a>You must write an algorithm that runs in O(log n) time.</h2><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[last] :                </span><br><span class="line">                last = mid         </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[first]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278. First Bad Version (Easy)</title>
      <link href="/2022/06/20/278/"/>
      <url>/2022/06/20/278/</url>
      
        <content type="html"><![CDATA[<h1 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a>278. First Bad Version (Easy)</h1><h2 id="You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad"><a href="#You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad" class="headerlink" title="You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad."></a>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</h2><h2 id="Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad"><a href="#Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad" class="headerlink" title="Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad."></a>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</h2><h2 id="You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API"><a href="#You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API" class="headerlink" title="You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."></a>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/">官方题解</a></h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p><p>具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><p>solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):                </span><br><span class="line">                last= mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">               </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>540. Single Element in a Sorted Array (Medium)</title>
      <link href="/2022/06/20/540/"/>
      <url>/2022/06/20/540/</url>
      
        <content type="html"><![CDATA[<h1 id="540-Single-Element-in-a-Sorted-Array-Medium"><a href="#540-Single-Element-in-a-Sorted-Array-Medium" class="headerlink" title="540. Single Element in a Sorted Array (Medium)"></a>540. Single Element in a Sorted Array (Medium)</h1><h2 id="You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once"><a href="#You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once" class="headerlink" title="You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once."></a>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</h2><h2 id="Return-the-single-element-that-appears-only-once"><a href="#Return-the-single-element-that-appears-only-once" class="headerlink" title="Return the single element that appears only once."></a>Return the single element that appears only once.</h2><h2 id="Your-solution-must-run-in-O-log-n-time-and-O-1-space"><a href="#Your-solution-must-run-in-O-log-n-time-and-O-1-space" class="headerlink" title="Your solution must run in O(log n) time and O(1) space."></a>Your solution must run in O(log n) time and O(1) space.</h2><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。<br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-y8gh/">官方题解</a></h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>这道题的特点在于比较的不是数字本身的大小，而是下标的奇偶性。因为只有一个数只出现一次，所以这个数字的下标就只能是偶数。</p><p>由于数组是有序的，因此数组中相同的元素一定相邻。对于下标 x 左边的下标 y，如果 nums[y]=nums[y+1]，则 y 一定是偶数；对于下标 x 右边的下标 z，如果 nums[z]=nums[z+1]，则 z 一定是奇数。由于下标 x 是相同元素的开始下标的奇偶性的分界，因此可以使用二分查找的方法寻找下标 x。</p><p>初始时，二分查找的左边界是 0，右边界是数组的最大下标。每次取左右边界的平均值 mid 作为待判断的下标，根据 mid 的奇偶性决定和左边或右边的相邻元素比较：</p><p>如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；</p><p>如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。</p><p>如果上述比较相邻元素的结果是相等，则 mid&lt;x, 调整左边界。否则 mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 x 的值。</p><p>得到下标 x 的值之后，nums[x] 即为只出现一次的元素。</p><p>⊕ 是按位异或运算符</p><p>当 mid 是偶数时， mid+1=mid⊕1；</p><p>当 mid 是奇数时， mid−1=mid⊕1。</p><h2 id="注：按位异或-按位或-按位与-amp"><a href="#注：按位异或-按位或-按位与-amp" class="headerlink" title="注：按位异或 ^ ,按位或 | ,按位与 &amp;"></a>注：按位异或 ^ ,按位或 | ,按位与 &amp;</h2><p>也就是说判断奇偶性是靠异或运算</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid ^ <span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16. 3Sum Closest(medium)</title>
      <link href="/2022/06/16/16/"/>
      <url>/2022/06/16/16/</url>
      
        <content type="html"><![CDATA[<h1 id="16-3Sum-Closest-medium"><a href="#16-3Sum-Closest-medium" class="headerlink" title="16. 3Sum Closest(medium)"></a>16. 3Sum Closest(medium)</h1><h2 id="Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target"><a href="#Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target" class="headerlink" title="Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target."></a>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</h2><h2 id="Return-the-sum-of-the-three-integers"><a href="#Return-the-sum-of-the-three-integers" class="headerlink" title="Return the sum of the three integers."></a>Return the sum of the three integers.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution" class="headerlink" title="You may assume that each input would have exactly one solution."></a>You may assume that each input would have exactly one solution.</h2><p><a href="https://leetcode.cn/problems/3sum-closest/solution/pythonshuang-zhi-zhen-you-hua-ji-bai-999-by-hardca/">排序 + 双指针</a><br>这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。</p><p>优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()         <span class="comment"># 排序</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):        <span class="comment"># 枚举第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]: <span class="keyword">continue</span>     <span class="comment"># 保证first不会有重复</span></span><br><span class="line"></span><br><span class="line">            second, third = first + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            max_sum = nums[first] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>]</span><br><span class="line">            min_sum = nums[first] + nums[first + <span class="number">1</span>] + nums[first + <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> max_sum &lt;= target:    <span class="comment"># 最大的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(max_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = max_sum</span><br><span class="line">                <span class="keyword">continue</span>              </span><br><span class="line">            <span class="keyword">elif</span> min_sum &gt;= target:  <span class="comment"># 最小的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(min_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = min_sum      </span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                two_sum_target = target - nums[first]</span><br><span class="line">                s = nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s + nums[first] - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = s + nums[first]</span><br><span class="line">                <span class="keyword">if</span> s &gt; two_sum_target:  <span class="comment"># 当前数值太大 右指针左移</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third + <span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; two_sum_target:  <span class="comment"># 当前数值太小 左指针右移</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 刚好等于 直接返回target即可</span></span><br><span class="line">                    <span class="keyword">return</span> target </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target (Easy)</title>
      <link href="/2022/06/16/744/"/>
      <url>/2022/06/16/744/</url>
      
        <content type="html"><![CDATA[<h1 id="744-Find-Smallest-Letter-Greater-Than-Target-Easy"><a href="#744-Find-Smallest-Letter-Greater-Than-Target-Easy" class="headerlink" title="744. Find Smallest Letter Greater Than Target (Easy)"></a>744. Find Smallest Letter Greater Than Target (Easy)</h1><h2 id="Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target"><a href="#Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target" class="headerlink" title="Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target."></a>Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;d&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;k&quot;</span><br><span class="line">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure><p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution/xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7/">官方题解</a></h2><h2 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h2><p>由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。</p><p>如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>((letter <span class="keyword">for</span> letter <span class="keyword">in</span> letters <span class="keyword">if</span> letter &gt; target), letters[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。</p><p>初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> letters[bisect_right(letters, target)] <span class="keyword">if</span> target &lt; letters[-<span class="number">1</span>] <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h3 id="自己写的完全版"><a href="#自己写的完全版" class="headerlink" title="自己写的完全版"></a>自己写的完全版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        first,last=<span class="number">0</span>,<span class="built_in">len</span>(letters)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意如果目标值大于或等于有序列表的最后一项，返回值为首元素</span></span><br><span class="line">        <span class="comment">#letters[-1]是列表最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> target&gt;=letters[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+ (last-first)//<span class="number">2</span> <span class="comment">#1//2=0,向下取整</span></span><br><span class="line">            <span class="keyword">if</span> letters[mid]&lt;=target:</span><br><span class="line">                first=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = mid</span><br><span class="line">        <span class="keyword">return</span> letters[first]                </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x) (Easy)</title>
      <link href="/2022/06/16/69/"/>
      <url>/2022/06/16/69/</url>
      
        <content type="html"><![CDATA[<h1 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h1><h2 id="Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x"><a href="#Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x" class="headerlink" title="Given a non-negative integer x, compute and return the square root of x."></a>Given a non-negative integer x, compute and return the square root of x.</h2><h2 id="Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned"><a href="#Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned" class="headerlink" title="Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned."></a>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</h2><h2 id="Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5"><a href="#Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5" class="headerlink" title="Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5"></a>Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5</h2><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: </span><br><span class="line">            first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(left-right)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="comment">#mid = (left + right) // 2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="方法二：牛顿迭代"><a href="#方法二：牛顿迭代" class="headerlink" title="方法二：牛顿迭代"></a>方法二：牛顿迭代</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode05- 二分查找</title>
      <link href="/2022/06/16/Leetcode05-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/06/16/Leetcode05-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-二分查找"><a href="#Leetcode-题解-二分查找" class="headerlink" title="Leetcode 题解 - 二分查找"></a>Leetcode 题解 - 二分查找</h1><h2 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h2><h2 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h2><h2 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h2><h2 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h2><h2 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h2><h2 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h2><p>二分查找 binary search algorithm</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="m-计算"><a href="#m-计算" class="headerlink" title="m 计算"></a>m 计算</h2><p>有两种计算中值 m 的方式：</p><p>m = (l + h) / 2<br>m = l + (h - l) / 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p><h2 id="未成功查找的返回值"><a href="#未成功查找的返回值" class="headerlink" title="未成功查找的返回值"></a>未成功查找的返回值</h2><p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p><p>-1：以一个错误码表示没有查找到 key<br>l：将 key 插入到 nums 中的正确位置</p><p>模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. Partition Labels (Medium)</title>
      <link href="/2022/06/13/763/"/>
      <url>/2022/06/13/763/</url>
      
        <content type="html"><![CDATA[<h1 id="763-Partition-Labels-Medium"><a href="#763-Partition-Labels-Medium" class="headerlink" title="763. Partition Labels (Medium)"></a>763. Partition Labels (Medium)</h1><h2 id="You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part"><a href="#You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part" class="headerlink" title="You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part."></a>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</h2><h2 id="Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s"><a href="#Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s" class="headerlink" title="Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s."></a>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</h2><h2 id="Return-a-list-of-integers-representing-the-size-of-these-parts"><a href="#Return-a-list-of-integers-representing-the-size-of-these-parts" class="headerlink" title="Return a list of integers representing the size of these parts."></a>Return a list of integers representing the size of these parts.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-labels/solution/python-jiu-zhe-quan-guo-zui-cai-you-hua-dai-ma-by-/">思路</a>:<br>其实思路很简单，<br>1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。<br>2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或一段的最后位置大。<br>如果没有刚才的last或一段的最后位置大，无视它继续往后找。<br>如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或一段的最后位置更新为当前的字母的最后位置。<br>3，肯定到有一个时间，这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。<br>注意题目要分隔后的长度，我们就用last - startindex + 1。<br>4，找到一个分割位，更新一下起始位置，同理搜索就行了。</p><p>用字典的好处就是不用每次都搜索位置了。直接用字典存所有字符的最后位置就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;<span class="built_in">list</span>[<span class="built_in">int</span>]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end) <span class="comment">#如果最后位置比刚才的大，就更新最后位置</span></span><br><span class="line">            <span class="keyword">if</span> i == end: <span class="comment">#这里就是找到这一段的结束了，就说明当前位置的index和这个字母在字典里的最后位置应该是相同的。</span></span><br><span class="line">                ans.append(end - start + <span class="number">1</span>) <span class="comment"># 加入result</span></span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray (Easy)</title>
      <link href="/2022/06/13/53/"/>
      <url>/2022/06/13/53/</url>
      
        <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a>53. Maximum Subarray (Easy)</h1><h2 id="Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum"><a href="#Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum" class="headerlink" title="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."></a>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</h2><h1 id="A-subarray-is-a-contiguous-part-of-an-array"><a href="#A-subarray-is-a-contiguous-part-of-an-array" class="headerlink" title="A subarray is a contiguous part of an array."></a>A subarray is a contiguous part of an array.</h1><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>这题第一眼非常像买股票第一弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure><h2 id="本质上是动态规划问题："><a href="#本质上是动态规划问题：" class="headerlink" title="本质上是动态规划问题："></a>本质上是动态规划问题：</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">leetcode题解</a></p><p>方法一：动态规划<br>「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。</p><p>本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。</p><h2 id="关键-1：理解题意"><a href="#关键-1：理解题意" class="headerlink" title="关键 1：理解题意"></a>关键 1：理解题意</h2><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><h2 id="关键-2：如何定义子问题（如何定义状态）"><a href="#关键-2：如何定义子问题（如何定义状态）" class="headerlink" title="关键 2：如何定义子问题（如何定义状态）"></a>关键 2：如何定义子问题（如何定义状态）</h2><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><p>子问题 1：经过 -2 的连续子数组的最大和是多少；<br>子问题 2：经过 1 的连续子数组的最大和是多少；<br>子问题 3：经过 -3 的连续子数组的最大和是多少；<br>子问题 4：经过 4 的连续子数组的最大和是多少；<br>子问题 5：经过 -1 的连续子数组的最大和是多少；<br>子问题 6：经过 2 的连续子数组的最大和是多少；<br>子问题 7：经过 1 的连续子数组的最大和是多少；<br>子问题 8：经过 -5 的连续子数组的最大和是多少；<br>子问题 9：经过 4 的连续子数组的最大和是多少。<br>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 -3 的连续子数组的最大和是多少。</p><p>「经过 -3 的连续子数组」我们任意举出几个：</p><p>[-2,1,-3,4] ，-3 是这个连续子数组的第 3 个元素；<br>[1,-3,4,-1] ，-3 是这个连续子数组的第 2 个元素；<br>……<br>我们不确定的是：-3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>子问题 3：以 -3 结尾的连续子数组的最大和是多少；<br>子问题 4：以 4 结尾的连续子数组的最大和是多少；<br>子问题 5：以 -1 结尾的连续子数组的最大和是多少；<br>子问题 6：以 2 结尾的连续子数组的最大和是多少；<br>子问题 7：以 1 结尾的连续子数组的最大和是多少；<br>子问题 8：以 -5 结尾的连续子数组的最大和是多少；<br>子问题 9：以 4 结尾的连续子数组的最大和是多少。<br>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>以 -2 结尾的连续子数组是 [-2]，因此最大和就是 -2。</p><p>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 1。</p><p>大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：</p><p>一个数 a 加上负数的结果比 a 更小；<br>一个数 a 加上 0 的结果不会比 a 更大；<br>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。<br>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><h2 id="定义状态（定义子问题）"><a href="#定义状态（定义子问题）" class="headerlink" title="定义状态（定义子问题）"></a>定义状态（定义子问题）</h2><p>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</p><p>说明：「结尾」和「连续」是关键字。</p><h2 id="状态转移方程（描述子问题之间的联系）"><a href="#状态转移方程（描述子问题之间的联系）" class="headerlink" title="状态转移方程（描述子问题之间的联系）"></a>状态转移方程（描述子问题之间的联系）</h2><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 dp[i] = dp[i - 1] + nums[i]。</p><p>可是 dp[i - 1] 有可能是负数，于是分类讨论：</p><p>如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；<br>如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</p><h2 id="思考初始值"><a href="#思考初始值" class="headerlink" title="思考初始值"></a>思考初始值</h2><p>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</p><h2 id="思考输出"><a href="#思考输出" class="headerlink" title="思考输出"></a>思考输出</h2><p>注意：</p><h3 id="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"><a href="#这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；" class="headerlink" title="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"></a>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>665. Non-decreasing Array(medium)</title>
      <link href="/2022/06/13/665/"/>
      <url>/2022/06/13/665/</url>
      
        <content type="html"><![CDATA[<h1 id="665-Non-decreasing-Array-medium"><a href="#665-Non-decreasing-Array-medium" class="headerlink" title="665. Non-decreasing Array(medium)"></a>665. Non-decreasing Array(medium)</h1><h2 id="Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element"><a href="#Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element" class="headerlink" title="Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element."></a>Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.</h2><h2 id="We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2"><a href="#We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2" class="headerlink" title="We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2)."></a>We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).</h2><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p>这道题的关键在于修改哪个数，本题在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><p>思路:<br>nums[i] &lt; nums[i - 1]:<br>    nums[i - 1] = nums[i]<br>nums[i] &lt; nums[i - 2]:<br>    nums[i] = nums[i - 1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">2</span>] <span class="keyword">and</span> i-<span class="number">2</span>&gt;=<span class="number">0</span> :</span><br><span class="line">                nums[i]=nums[i-<span class="number">1</span>]</span><br><span class="line">                cnt+=<span class="number">1</span>              </span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[i-<span class="number">1</span>]= nums[i]</span><br><span class="line">                cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392. Is Subsequence (Medium)</title>
      <link href="/2022/06/13/392/"/>
      <url>/2022/06/13/392/</url>
      
        <content type="html"><![CDATA[<h1 id="392-Is-Subsequence-Medium"><a href="#392-Is-Subsequence-Medium" class="headerlink" title="392. Is Subsequence (Medium)"></a>392. Is Subsequence (Medium)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise" class="headerlink" title="Given two strings s and t, return true if s is a subsequence of t, or false otherwise."></a>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</h2><h2 id="A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not"><a href="#A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not" class="headerlink" title="A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not)."></a>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</h2><p>本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。</p><p>而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。</p><p>这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。</p><p>最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i]==t[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自己写的双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)&gt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        resultword= <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="keyword">if</span> resultword&lt;= <span class="built_in">len</span>(s)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> s[resultword] == t[i]:</span><br><span class="line">                    resultword+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> resultword == <span class="built_in">len</span>(s)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>605. Can Place Flowers (Easy)</title>
      <link href="/2022/06/11/605/"/>
      <url>/2022/06/11/605/</url>
      
        <content type="html"><![CDATA[<h1 id="605-Can-Place-Flowers-Easy"><a href="#605-Can-Place-Flowers-Easy" class="headerlink" title="605. Can Place Flowers (Easy)"></a>605. Can Place Flowers (Easy)</h1><h2 id="You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots"><a href="#You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots" class="headerlink" title="You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots."></a>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.</h2><h2 id="Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule"><a href="#Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule" class="headerlink" title="Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule."></a>Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</h2><p><a href="https://leetcode.cn/problems/can-place-flowers/solution/chong-hua-wen-ti-by-leetcode-solution-sojr/728529">leetcode官解评论</a></p><p>非常巧妙的方法，用数学归纳法很容易推出来公式</p><p>统计连续的0的区间，分别有多少个连续的0即可。对于每一段0区间，都可以根据公式直接算出可以种几朵花。</p><p>公式可以通过数学归纳法推出来，很简单：</p><ol><li>对于中间的0区间：</li></ol><p>1~2个0：可种0朵；</p><p>3~4个：可种1朵；</p><p>5~6个：可种2朵；</p><p>…</p><p>count个：可种 (count-1)/2 朵</p><ol start="2"><li>对于两头的0区间，由于左边、右边分别没有1的限制，可种花朵数稍有不同。</li></ol><p>为了代码流程的统一，可以在数组最左边、数组最右边分别补1个0，意味着花坛左边、右边没有花。</p><p>这样公式就跟1相同了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flowerbed:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        countofZero = <span class="number">1</span> <span class="comment"># 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace = <span class="number">0</span> <span class="comment"># 可以种的花的数量</span></span><br><span class="line">        <span class="keyword">for</span> bed <span class="keyword">in</span> flowerbed:</span><br><span class="line">            <span class="keyword">if</span> bed == <span class="number">0</span>: <span class="comment"># 遇到0，连续0的数量+1</span></span><br><span class="line">                countofZero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#遇到1，结算上一段连续的0区间，看能种下几盆花：(countofZero-1)/2</span></span><br><span class="line">                canPlace += <span class="built_in">int</span>((countofZero-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                countofZero = <span class="number">0</span>; <span class="comment"># 0的数量清零，开始统计下一个全0分区        </span></span><br><span class="line">        <span class="comment">#最后一段0区还未结算：</span></span><br><span class="line">        countofZero += <span class="number">1</span><span class="comment"># 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace += (countofZero-<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123. Best Time to Buy and Sell Stock III(hard)</title>
      <link href="/2022/06/11/123/"/>
      <url>/2022/06/11/123/</url>
      
        <content type="html"><![CDATA[<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III-hard"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-hard" class="headerlink" title="123. Best Time to Buy and Sell Stock III(hard)"></a>123. Best Time to Buy and Sell Stock III(hard)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions"><a href="#Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions" class="headerlink" title="Find the maximum profit you can achieve. You may complete at most two transactions."></a>Find the maximum profit you can achieve. You may complete at most two transactions.</h2><h2 id="Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again"><a href="#Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again" class="headerlink" title="Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."></a>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure><p>卖股票第三弹（hard题了）</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>和第二题差不多，但是限制了最多两次交易，之前的小技巧有些用不上了，所以还是得走动态规划的路子。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/">官方题解</a></h2><p>思路与算法</p><p>由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p><ol><li><p>未进行过任何操作；</p></li><li><p>只进行过一次买操作；</p></li><li><p>进行了一次买操作和一次卖操作，即完成了一笔交易；</p></li><li><p>在完成了一笔交易的前提下，进行了第二次买操作；</p></li><li><p>完成了全部两笔交易。</p></li></ol><p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 buy1,sell1,,buy2,sell2 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy1 = buy2 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell1 = sell2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i])</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i])</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i])</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i])</span><br><span class="line">        <span class="keyword">return</span> sell2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II (Easy)</title>
      <link href="/2022/06/11/122/"/>
      <url>/2022/06/11/122/</url>
      
        <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a>122. Best Time to Buy and Sell Stock II (Easy)</h1><h2 id="You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an integer array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day"><a href="#On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day" class="headerlink" title="On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day."></a>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</h2><h2 id="Find-and-return-the-maximum-profit-you-can-achieve"><a href="#Find-and-return-the-maximum-profit-you-can-achieve" class="headerlink" title="Find and return the maximum profit you can achieve."></a>Find and return the maximum profit you can achieve.</h2><p>卖股票第二弹</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大利润 。</p><p>这一题一样是可以用贪心算法或者动态规划写的，但是我在<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/658886">官方题解评论区</a>发现一个极其简单的小技巧。在本题中买卖都是无限次的，所以只要把盈利（也就是上升段）全部加在一起就可以了，相当于每隔一天算一次盈利，盈利为正算在总利润里，盈利为负就丢掉。</p><p>简单来说就是只要把所有的盈利加在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                res += prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock (Easy)</title>
      <link href="/2022/06/11/121/"/>
      <url>/2022/06/11/121/</url>
      
        <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a>121. Best Time to Buy and Sell Stock (Easy)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock"><a href="#You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock" class="headerlink" title="You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock."></a>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</h2><h2 id="Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0"><a href="#Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0" class="headerlink" title="Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0."></a>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</h2><p>其实这题是动态规划的问题.卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-i/">121</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p><img src="https://pic.leetcode-cn.com/4eaadab491f2bf88639d66c9d51bb0115e694ae08d637841ac18172b631cb21f-0121.gif" alt="图片"></p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>406. Queue Reconstruction by Height(Medium)</title>
      <link href="/2022/06/11/406/"/>
      <url>/2022/06/11/406/</url>
      
        <content type="html"><![CDATA[<h1 id="406-Queue-Reconstruction-by-Height-Medium"><a href="#406-Queue-Reconstruction-by-Height-Medium" class="headerlink" title="406. Queue Reconstruction by Height(Medium)"></a>406. Queue Reconstruction by Height(Medium)</h1><h2 id="You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi"><a href="#You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi" class="headerlink" title="You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi."></a>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</h2><h2 id="Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue"><a href="#Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue" class="headerlink" title="Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue)."></a>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</h2><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。</p><p>渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</p><p>在本题目中，首先对数对进行排序，按照数对的元素 1(身高) 降序排序，按照数对的元素 2 (人数)升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。</p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/">leetcode题解</a></p><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = lambda x: (-x[0], x[1]))</span><br></pre></td></tr></table></figure><p>第一个元素降序，第二个元素升序排列，以第一个元素的降序排列优先</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = [[1,4],[2,3],[3,4],[1,3],[1,2]]</span><br><span class="line"></span><br><span class="line">print(sorted(A,key=lambda x:x[1]))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0], x[1])))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [2, 3], [1, 3], [1, 4], [3, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 2], [1, 3], [1, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 4], [1, 3], [1, 2]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="本题例子"><a href="#本题例子" class="headerlink" title="本题例子"></a>本题例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br></pre></td></tr></table></figure><p>所以排序完：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>])) <span class="comment">#排序</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= p[<span class="number">1</span>]:  <span class="comment">#比较的变量是当前数组的长度</span></span><br><span class="line">                res.append(p)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(res) &gt; p[<span class="number">1</span>]:</span><br><span class="line">                res.insert(p[<span class="number">1</span>], p)  <span class="comment"># p is inserted at index p[1]（参与这次排序的P[1])</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> people:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = people[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons (Medium)</title>
      <link href="/2022/06/10/452/"/>
      <url>/2022/06/10/452/</url>
      
        <content type="html"><![CDATA[<h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons (Medium)"></a>452. Minimum Number of Arrows to Burst Balloons (Medium)</h1><h2 id="There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons"><a href="#There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons" class="headerlink" title="There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons."></a>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.</h2><h2 id="Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path"><a href="#Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path" class="headerlink" title="Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path."></a>Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</h2><h2 id="Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons"><a href="#Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons" class="headerlink" title="Given the array points, return the minimum number of arrows that must be shot to burst all balloons."></a>Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</h2><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p><p>也是计算不重叠的区间个数，不过和 Non-overlapping points 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p><p><img src="https://assets.leetcode-cn.com/solution-static/452/1.png" alt="射箭"></p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h2><p>这道题和 435. Non-overlapping Intervals (Medium) 有些类似，都是寻找重合区间</p><p>贪心：<br>既然每个气球都需要被引爆，那么在满足引爆对箭限制最大的那个气球（因为它一定要被引爆，而箭和其它同时被引爆的气球 都可以迁就它，所以满足它是必须的） 的同时，引爆尽可能多其他的气球。</p><p>在付出不变的的前提下，获得尽可能多。</p><p>简单来说就是先按照区间右边边界从小到大排序，为了尽可能的多引爆气球，第一支箭射在第一个区间的最右边，根据后面区间的左端点判断一共引爆了哪些区间，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。</p><p>有个问题是这 nn 个气球对应的区间互不重叠，while 循环需要执行 n 次。所以当遇到x(j) ≤ y(i)时 我们可以直接跳出循环，y(j)就是下一个箭的位置。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. Non-overlapping Intervals (Medium)</title>
      <link href="/2022/06/09/435/"/>
      <url>/2022/06/09/435/</url>
      
        <content type="html"><![CDATA[<h1 id="435-Non-overlapping-Intervals-Medium"><a href="#435-Non-overlapping-Intervals-Medium" class="headerlink" title="435. Non-overlapping Intervals (Medium)"></a>435. Non-overlapping Intervals (Medium)</h1><h2 id="Given-an-array-of-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-intervals-you-need-to-remove-to-make-the-rest-of-the-intervals-non-overlapping"><a href="#Given-an-array-of-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-intervals-you-need-to-remove-to-make-the-rest-of-the-intervals-non-overlapping" class="headerlink" title="Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping."></a>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p><p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        n = <span class="built_in">len</span>(intervals)</span><br><span class="line">        right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= right:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - ans</span><br></pre></td></tr></table></figure><p>注释：<br>key=lambda 元素: 元素[字段索引]</p><p>比如   print(sorted(C, key=lambda x: x[2]))   </p><p>x:x[]字母可以随意修改，排序方式按照中括号[]里面的维度进行排序，[0]按照第一维排序，[2]按照第三维排序</p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C = [(<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> y: y[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#输出[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>]))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455. Assign Cookies (Easy)</title>
      <link href="/2022/06/09/455/"/>
      <url>/2022/06/09/455/</url>
      
        <content type="html"><![CDATA[<h1 id="455-Assign-Cookies-Easy"><a href="#455-Assign-Cookies-Easy" class="headerlink" title="455. Assign Cookies (Easy)"></a>455. Assign Cookies (Easy)</h1><h2 id="Assume-you-are-an-awesome-parent-and-want-to-give-your-children-some-cookies-But-you-should-give-each-child-at-most-one-cookie"><a href="#Assume-you-are-an-awesome-parent-and-want-to-give-your-children-some-cookies-But-you-should-give-each-child-at-most-one-cookie" class="headerlink" title="Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie."></a>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</h2><h2 id="Each-child-i-has-a-greed-factor-g-i-which-is-the-minimum-size-of-a-cookie-that-the-child-will-be-content-with-and-each-cookie-j-has-a-size-s-j-If-s-j-gt-g-i-we-can-assign-the-cookie-j-to-the-child-i-and-the-child-i-will-be-content-Your-goal-is-to-maximize-the-number-of-your-content-children-and-output-the-maximum-number"><a href="#Each-child-i-has-a-greed-factor-g-i-which-is-the-minimum-size-of-a-cookie-that-the-child-will-be-content-with-and-each-cookie-j-has-a-size-s-j-If-s-j-gt-g-i-we-can-assign-the-cookie-j-to-the-child-i-and-the-child-i-will-be-content-Your-goal-is-to-maximize-the-number-of-your-content-children-and-output-the-maximum-number" class="headerlink" title="Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number."></a>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</h2><p>题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。<br>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。<br>在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。 </p><p>个人理解就是尽力把小的孩子喂饱，每轮都按照这样喂饱就是最优解</p><p>自己写的，按照题目逻辑s[j]&gt;=g[i]判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">        i = j = count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># greed factor g[i]</span></span><br><span class="line">        <span class="comment"># cookie size s[j]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[j]&gt;=g[i]:</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">        i = j = count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># greed factor g[i]</span></span><br><span class="line">        <span class="comment"># cookie size s[j]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i] &gt; s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode04-贪心思想</title>
      <link href="/2022/06/09/LeetCode04-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/2022/06/09/LeetCode04-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-贪心思想"><a href="#Leetcode-题解-贪心思想" class="headerlink" title="Leetcode 题解 - 贪心思想"></a>Leetcode 题解 - 贪心思想</h1><h2 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1. 分配饼干"></a>1. 分配饼干</h2><h2 id="2-不重叠的区间个数"><a href="#2-不重叠的区间个数" class="headerlink" title="2. 不重叠的区间个数"></a>2. 不重叠的区间个数</h2><h2 id="3-投飞镖刺破气球"><a href="#3-投飞镖刺破气球" class="headerlink" title="3. 投飞镖刺破气球"></a>3. 投飞镖刺破气球</h2><h2 id="4-根据身高和序号重组队列"><a href="#4-根据身高和序号重组队列" class="headerlink" title="4. 根据身高和序号重组队列"></a>4. 根据身高和序号重组队列</h2><h2 id="5-买卖股票最大的收益"><a href="#5-买卖股票最大的收益" class="headerlink" title="5. 买卖股票最大的收益"></a>5. 买卖股票最大的收益</h2><h2 id="6-买卖股票的最大收益-II"><a href="#6-买卖股票的最大收益-II" class="headerlink" title="6. 买卖股票的最大收益 II"></a>6. 买卖股票的最大收益 II</h2><h2 id="7-种植花朵"><a href="#7-种植花朵" class="headerlink" title="7. 种植花朵"></a>7. 种植花朵</h2><h2 id="8-判断是否为子序列"><a href="#8-判断是否为子序列" class="headerlink" title="8. 判断是否为子序列"></a>8. 判断是否为子序列</h2><h2 id="9-修改一个数成为非递减数组"><a href="#9-修改一个数成为非递减数组" class="headerlink" title="9. 修改一个数成为非递减数组"></a>9. 修改一个数成为非递减数组</h2><h2 id="10-子数组最大的和"><a href="#10-子数组最大的和" class="headerlink" title="10. 子数组最大的和"></a>10. 子数组最大的和</h2><h2 id="11-分隔字符串使同种字符出现在一起"><a href="#11-分隔字符串使同种字符出现在一起" class="headerlink" title="11. 分隔字符串使同种字符出现在一起"></a>11. 分隔字符串使同种字符出现在一起</h2><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors (Medium)</title>
      <link href="/2022/06/09/75/"/>
      <url>/2022/06/09/75/</url>
      
        <content type="html"><![CDATA[<h1 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a>75. Sort Colors (Medium)</h1><h2 id="Given-an-array-nums-with-n-objects-colored-red-white-or-blue-sort-them-in-place-so-that-objects-of-the-same-color-are-adjacent-with-the-colors-in-the-order-red-white-and-blue"><a href="#Given-an-array-nums-with-n-objects-colored-red-white-or-blue-sort-them-in-place-so-that-objects-of-the-same-color-are-adjacent-with-the-colors-in-the-order-red-white-and-blue" class="headerlink" title="Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue."></a>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</h2><h2 id="We-will-use-the-integers-0-1-and-2-to-represent-the-color-red-white-and-blue-respectively"><a href="#We-will-use-the-integers-0-1-and-2-to-represent-the-color-red-white-and-blue-respectively" class="headerlink" title="We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively."></a>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</h2><h2 id="You-must-solve-this-problem-without-using-the-library’s-sort-function"><a href="#You-must-solve-this-problem-without-using-the-library’s-sort-function" class="headerlink" title="You must solve this problem without using the library’s sort function."></a>You must solve this problem without using the library’s sort function.</h2><h2 id="有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。"><a href="#有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。" class="headerlink" title="有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。"></a>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</h2><p>个人理解就是三指针，跟之前的双指针差不多，和之前不同的是因为有三个区间所以要三个指针<br><a href="https://cloud.tencent.com/developer/article/1624933#:~:text=%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%EF%BC%9A%E7%8E%B0%E5%9C%A8%E6%9C%89,%E5%90%8E%E6%AD%A3%E5%A5%BD%E7%BB%84%E6%88%90%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E3%80%82&text=%E8%BF%99%E9%81%93%E9%A2%98%E5%BE%88%E7%BB%8F%E5%85%B8%EF%BC%8C%E5%BE%88%E9%AB%98%E9%A2%91%E3%80%82">荷兰国旗问题参考</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        a = c = <span class="number">0</span></span><br><span class="line">        b = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> c &lt;= b:</span><br><span class="line">            <span class="keyword">if</span> nums[c] == <span class="number">0</span>:</span><br><span class="line">                nums[a], nums[c] = nums[c], nums[a]</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[c] == <span class="number">2</span>:</span><br><span class="line">                nums[c], nums[b] = nums[b], nums[c]</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>451. Sort Characters By Frequency (Medium)</title>
      <link href="/2022/06/09/451/"/>
      <url>/2022/06/09/451/</url>
      
        <content type="html"><![CDATA[<ol start="451"><li>Sort Characters By Frequency (Medium)</li></ol><h2 id="Given-a-string-s-sort-it-in-decreasing-order-based-on-the-frequency-of-the-characters-The-frequency-of-a-character-is-the-number-of-times-it-appears-in-the-string"><a href="#Given-a-string-s-sort-it-in-decreasing-order-based-on-the-frequency-of-the-characters-The-frequency-of-a-character-is-the-number-of-times-it-appears-in-the-string" class="headerlink" title="Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string."></a>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.</h2><h2 id="Return-the-sorted-string-If-there-are-multiple-answers-return-any-of-them"><a href="#Return-the-sorted-string-If-there-are-multiple-answers-return-any-of-them" class="headerlink" title="Return the sorted string. If there are multiple answers, return any of them."></a>Return the sorted string. If there are multiple answers, return any of them.</h2><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/python3-shuang-90-by-key-wu-xbod/">Leetcode 题解</a></p><p>这道题和 347. Top K Frequent Elements (Medium) 几乎一样，一个是数字一个是字符串，方法也类似</p><p>1.建哈希表，将字符串s中的每个字符计数<br>2.根据哈希表中的值进行降序排序即可<br>3.直接字符乘以数目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans] += <span class="number">1</span></span><br><span class="line">        result = <span class="built_in">sorted</span>(hashmap.items(),key=<span class="keyword">lambda</span> hashmap:hashmap[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">            res = result[i][<span class="number">0</span>] * result[i][<span class="number">1</span>]</span><br><span class="line">            s += res</span><br><span class="line">        <span class="keyword">return</span> s </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements (Medium)</title>
      <link href="/2022/06/09/347/"/>
      <url>/2022/06/09/347/</url>
      
        <content type="html"><![CDATA[<h1 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a>347. Top K Frequent Elements (Medium)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-the-k-most-frequent-elements-You-may-return-the-answer-in-any-order"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-the-k-most-frequent-elements-You-may-return-the-answer-in-any-order" class="headerlink" title="Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order."></a>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</h2><p>hashmap<br>1.建哈希表，将数组中的每个数字计数<br>2.根据哈希表中的值进行降序排序即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line"></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[val] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[val] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">        result = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">sorted</span>(dic, key=dic.get, reverse=<span class="literal">True</span>):</span><br><span class="line">            result.append(num)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                <span class="keyword">break</span>    </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">           </span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/bi-guan-fang-ti-jie-geng-kuai-de-fang-fa-lgsc/">题解评论</a></p><p>用字典去代替数组会不会好一些；<br>倒序遍历频次时，最大不超过 n-k+1 ；<br>python3版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashMap = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            hashMap[num] = hashMap.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        bucket = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> x, v <span class="keyword">in</span> hashMap.items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> bucket:</span><br><span class="line">                bucket[v] = [x]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[v].append(x)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - k + <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt;= k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> bucket:</span><br><span class="line">                res.extend(bucket[v])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/python-dui-pai-xu-by-xxinjiee/">leetcode题解</a></p><p>对于 topk 问题：最大堆求topk小，最小堆求 topk 大。</p><p>topk小：构建一个 k 个数的最大堆，当读取的数小于根节点时，替换根节点，重新塑造最大堆<br>topk大：构建一个 k 个数的最小堆，当读取的数大于根节点时，替换根节点，重新塑造最小堆<br>这一题的总体思路 总体时间复杂度 O(nlogk)O(nlogk)</p><p>遍历统计元素出现频率 O(n)O(n)<br>前k个数构造 规模为 k+1 的最小堆 minheap， O(k)O(k)， 注意 +1 是因为占位节点。<br>遍历规模k之外的数据，大于堆顶则入堆，下沉维护规模为k的最小堆 minheap. O(nlogk)O(nlogk)<br>(如需按频率输出，对规模为k的堆进行排序)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span>(<span class="params">arr, root, k</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;下沉log(k),如果新的根节点&gt;子节点就一直下沉&quot;&quot;&quot;</span></span><br><span class="line">            val = arr[root] <span class="comment"># 用类似插入排序的赋值交换</span></span><br><span class="line">            <span class="keyword">while</span> root&lt;&lt;<span class="number">1</span> &lt; k:</span><br><span class="line">                child = root &lt;&lt; <span class="number">1</span></span><br><span class="line">                <span class="comment"># 选取左右孩子中小的与父节点交换</span></span><br><span class="line">                <span class="keyword">if</span> child|<span class="number">1</span> &lt; k <span class="keyword">and</span> arr[child|<span class="number">1</span>][<span class="number">1</span>] &lt; arr[child][<span class="number">1</span>]:</span><br><span class="line">                    child |= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果子节点&lt;新节点,交换,如果已经有序break</span></span><br><span class="line">                <span class="keyword">if</span> arr[child][<span class="number">1</span>] &lt; val[<span class="number">1</span>]:</span><br><span class="line">                    arr[root] = arr[child]</span><br><span class="line">                    root = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            arr[root] = val</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span>(<span class="params">arr, child</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;上浮log(k),如果新加入的节点&lt;父节点就一直上浮&quot;&quot;&quot;</span></span><br><span class="line">            val = arr[child]</span><br><span class="line">            <span class="keyword">while</span> child&gt;&gt;<span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> val[<span class="number">1</span>] &lt; arr[child&gt;&gt;<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                arr[child] = arr[child&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                child &gt;&gt;= <span class="number">1</span></span><br><span class="line">            arr[child] = val</span><br><span class="line"></span><br><span class="line">        stat = collections.Counter(nums)</span><br><span class="line">        stat = <span class="built_in">list</span>(stat.items())</span><br><span class="line">        heap = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建规模为k+1的堆,新元素加入堆尾,上浮</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            heap.append(stat[i])</span><br><span class="line">            sift_up(heap, <span class="built_in">len</span>(heap)-<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 维护规模为k+1的堆,如果新元素大于堆顶,入堆,并下沉</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(stat)):</span><br><span class="line">            <span class="keyword">if</span> stat[i][<span class="number">1</span>] &gt; heap[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                heap[<span class="number">1</span>] = stat[i]</span><br><span class="line">                sift_down(heap, <span class="number">1</span>, k+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> heap[<span class="number">1</span>:]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array (Medium)</title>
      <link href="/2022/06/09/215/"/>
      <url>/2022/06/09/215/</url>
      
        <content type="html"><![CDATA[<h1 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a>215. Kth Largest Element in an Array (Medium)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-the-kth-largest-element-in-the-array"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-the-kth-largest-element-in-the-array" class="headerlink" title="Given an integer array nums and an integer k, return the kth largest element in the array."></a>Given an integer array nums and an integer k, return the kth largest element in the array.</h2><h2 id="Note-that-it-is-the-kth-largest-element-in-the-sorted-order-not-the-kth-distinct-element"><a href="#Note-that-it-is-the-kth-largest-element-in-the-sorted-order-not-the-kth-distinct-element" class="headerlink" title="Note that it is the kth largest element in the sorted order, not the kth distinct element."></a>Note that it is the kth largest element in the sorted order, not the kth distinct element.</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/">leetcode题解</a></p><h2 id="方法一-快速排序（Quick-Sort）"><a href="#方法一-快速排序（Quick-Sort）" class="headerlink" title="方法一. 快速排序（Quick Sort）"></a>方法一. 快速排序（Quick Sort）</h2><p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔（Tony Hoare ）提出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            pivot = arr[low]                                        <span class="comment"># 选取最左边为pivot</span></span><br><span class="line"></span><br><span class="line">            left, right = low, high     <span class="comment"># 双指针</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right] &gt;= pivot:          <span class="comment"># 找到右边第一个&lt;pivot的元素</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                arr[left] = arr[right]                             <span class="comment"># 并将其移动到left处</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[left] &lt;= pivot:           <span class="comment"># 找到左边第一个&gt;pivot的元素</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                arr[right] = arr[left]                             <span class="comment"># 并将其移动到right处</span></span><br><span class="line">            </span><br><span class="line">            arr[left] = pivot           <span class="comment"># pivot放置到中间left=right处</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">randomPartition</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            pivot_idx = random.randint(low, high)                   <span class="comment"># 随机选择pivot</span></span><br><span class="line">            arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low]     <span class="comment"># pivot放置到最左边</span></span><br><span class="line">            <span class="keyword">return</span> partition(arr, low, high)                        <span class="comment"># 调用partition函数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">topKSplit</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="comment"># mid = partition(arr, low, high)                   # 以mid为分割点【非随机选择pivot】</span></span><br><span class="line">            mid = randomPartition(arr, low, high)               <span class="comment"># 以mid为分割点【随机选择pivot】</span></span><br><span class="line">            <span class="keyword">if</span> mid == k-<span class="number">1</span>:                                      <span class="comment"># 第k小元素的下标为k-1</span></span><br><span class="line">                <span class="keyword">return</span> arr[mid]                                 <span class="comment">#【找到即返回】</span></span><br><span class="line">            <span class="keyword">elif</span> mid &lt; k-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> topKSplit(arr, mid+<span class="number">1</span>, high, k)           <span class="comment"># 递归对mid右侧元素进行排序</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> topKSplit(arr, low, mid-<span class="number">1</span>, k)            <span class="comment"># 递归对mid左侧元素进行排序</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> topKSplit(nums, <span class="number">0</span>, n-<span class="number">1</span>, n-k+<span class="number">1</span>)                   <span class="comment"># 第k大元素即为第n-k+1小元素</span></span><br></pre></td></tr></table></figure><h2 id="方法二-堆排序（Heap-Sort）"><a href="#方法二-堆排序（Heap-Sort）" class="headerlink" title="方法二. 堆排序（Heap Sort）"></a>方法二. 堆排序（Heap Sort）</h2><p>堆排序（英语：Heapsort）是指利用堆（heap）这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。[摘自@维基百科]</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/">leetcode题解</a></p><p>堆与排序：</p><p>对于一个待排序的包含 nn 个元素的数组 numsnums，堆排序 通常包含以下几个基本步骤：</p><ol><li>建堆：将待排序的数组初始化为大根堆（小根堆）。此时，堆顶的元素（即根节点）即为整个数组中的最大值（最小值）。</li><li>交换和调整：将堆顶元素与末尾元素进行交换，此时末尾即为最大值（最小值）。除去末尾元素后，将其他 n-1n−1 个元素重新构造成一个大根堆（小根堆），如此便可得到原数组 nn 个元素中的次大值（次小值）。</li><li>重复步骤二，直至堆中仅剩一个元素，如此便可得到一个有序序列了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHeapify</span>(<span class="params">arr, i, end</span>):</span></span><br><span class="line">            j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[j+<span class="number">1</span>] &gt; arr[j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">                    i = j</span><br><span class="line">                    j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHepify</span>(<span class="params">arr, i, end</span>):</span>     <span class="comment"># 大顶堆</span></span><br><span class="line">            j = <span class="number">2</span>*i + <span class="number">1</span>                 <span class="comment"># j为i的左子节点【建堆时下标0表示堆顶】</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:             <span class="comment"># 自上而下进行调整</span></span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[j+<span class="number">1</span>] &gt; arr[j]:    <span class="comment"># i的左右子节点分别为j和j+1</span></span><br><span class="line">                    j += <span class="number">1</span>                              <span class="comment"># 取两者之间的较大者</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:             <span class="comment"># 若i指示的元素小于其子节点中的较大者</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]     <span class="comment"># 交换i和j的元素，并继续往下判断</span></span><br><span class="line">                    i = j                       <span class="comment"># 往下走：i调整为其子节点j</span></span><br><span class="line">                    j = <span class="number">2</span>*i + <span class="number">1</span>                 <span class="comment"># j调整为i的左子节点</span></span><br><span class="line">                <span class="keyword">else</span>:                           <span class="comment"># 否则，结束调整</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建堆【大顶堆】</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):         <span class="comment"># 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整</span></span><br><span class="line">            maxHepify(nums, i, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆</span></span><br><span class="line">        <span class="comment"># k-1次重建堆（堆顶元素），或 k次交换到尾部（倒数第k个元素）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, n-k-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[j] = nums[j], nums[<span class="number">0</span>]     <span class="comment"># 堆顶元素（当前最大值）放置到尾部j</span></span><br><span class="line">            maxHepify(nums, <span class="number">0</span>, j-<span class="number">1</span>)                 <span class="comment"># j-1变成尾部，并从堆顶0开始调整堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于快排的所有TopK问题简单python模板"><a href="#基于快排的所有TopK问题简单python模板" class="headerlink" title="基于快排的所有TopK问题简单python模板"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/ji-yu-kuai-pai-de-suo-you-topkwen-ti-jia-ylsd/">基于快排的所有TopK问题简单python模板</a></h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Heap Sort </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> topk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode03-排序</title>
      <link href="/2022/06/03/LeetCode03-%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/06/03/LeetCode03-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-排序"><a href="#Leetcode-题解-排序" class="headerlink" title="Leetcode 题解 - 排序"></a>Leetcode 题解 - 排序</h1><h2 id="1-快速选择"><a href="#1-快速选择" class="headerlink" title="1. 快速选择"></a>1. 快速选择</h2><h2 id="2-堆-Kth-Element"><a href="#2-堆-Kth-Element" class="headerlink" title="2. 堆-Kth Element"></a>2. 堆-Kth Element</h2><h2 id="3-桶排序"><a href="#3-桶排序" class="headerlink" title="3. 桶排序"></a>3. 桶排序</h2><h2 id="4-荷兰国旗问题"><a href="#4-荷兰国旗问题" class="headerlink" title="4. 荷兰国旗问题"></a>4. 荷兰国旗问题</h2><ol><li>快速选择（快速排序）</li></ol><p>用于求解 Kth Element 问题，也就是第 K 个元素的问题。</p><p>快速选择算法是基于快速排序算法思想的用于解决Top K 问题的算法</p><p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。</p><p>步骤：<br>a. 从数列中挑出一个元素，称为 “基准”（pivot）;</p><p>b. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p><p>c. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><ol start="2"><li>堆排序</li></ol><p>用于求解 TopK Elements 问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。</p><p>堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。</p><p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p><p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p><ol start="3"><li>桶排序<br>桶排序，简单来说就是将待排序序列，按照序列值的大小划分成几个桶，分别对每组进行排序，排完序之后再按照一定的顺序合并所有的桶，即排序完成。</li></ol><p>对这道题而言，设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p><p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p><ol start="4"><li>荷兰国旗问题</li></ol><p>“荷兰国旗问题” 是计算机科学中的一个经典题目，它是由Edsger Dijkstra提出的。荷兰国旗由红、白、蓝三色组成。</p><p>荷兰国旗问题：现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。</p><p>这个问题之所以叫荷兰国旗，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>524. Longest Word in Dictionary through Deleting (Medium)</title>
      <link href="/2022/05/31/524/"/>
      <url>/2022/05/31/524/</url>
      
        <content type="html"><![CDATA[<h1 id="524-Longest-Word-in-Dictionary-through-Deleting-Medium"><a href="#524-Longest-Word-in-Dictionary-through-Deleting-Medium" class="headerlink" title="524. Longest Word in Dictionary through Deleting (Medium)"></a>524. Longest Word in Dictionary through Deleting (Medium)</h1><h2 id="Given-a-string-s-and-a-string-array-dictionary-return-the-longest-string-in-the-dictionary-that-can-be-formed-by-deleting-some-of-the-given-string-characters-If-there-is-more-than-one-possible-result-return-the-longest-word-with-the-smallest-lexicographical-order-If-there-is-no-possible-result-return-the-empty-string"><a href="#Given-a-string-s-and-a-string-array-dictionary-return-the-longest-string-in-the-dictionary-that-can-be-formed-by-deleting-some-of-the-given-string-characters-If-there-is-more-than-one-possible-result-return-the-longest-word-with-the-smallest-lexicographical-order-If-there-is-no-possible-result-return-the-empty-string" class="headerlink" title="Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string."></a>Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</h2><h2 id="题目描述：删除-s-中的一些字符，使得它构成字符串列表-d-中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。"><a href="#题目描述：删除-s-中的一些字符，使得它构成字符串列表-d-中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。" class="headerlink" title="题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。"></a>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</h2><p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="1-只有双指针"><a href="#1-只有双指针" class="headerlink" title="1.只有双指针"></a>1.只有双指针</h4><p>这题还真有些难度，主要是有些问题不能一眼看到逻辑和结果。</p><p>根据题意，我们需要解决三个问题：</p><ol><li><p>给定字符串s删除一些字符后能得到数组的字符串</p></li><li><p>找最长的字符串</p></li><li><p>如果长度相同，选字典顺序最小的字符串<br>官方例子：<br>Input: s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>Output: “apple”</p></li><li><p>第一点很好理解，就是在s这个字符串里找到子串。就像在一个集合里找到子集一样，可以发现[“ale”,”apple”,”plea”]符合</p></li><li><p>最长的字符串就是比较子串长度了，[“apple”] 就比 [“ale”] 和 [“plea”]长度要长</p></li><li><p>字典顺序最小，这个就是比较在字母表上的顺序了，以 a、b、c……z 的顺序排列，a最小，假如还有个新单词 [“appla”],那和[“apple”]比较，虽然长度一样，但是a的字典顺序在e前，所以我们得选择[“appla”]</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> dictionary:</span><br><span class="line">            i = j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(t) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> t[i] == s[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(t):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(t) == <span class="built_in">len</span>(res) <span class="keyword">and</span> t &lt; res):</span><br><span class="line">                    res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>排序+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        f.append([m] * <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(s[i]) == j + <span class="number">97</span>:</span><br><span class="line">                    f[i][j] = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> dictionary:</span><br><span class="line">            match = <span class="literal">True</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">                <span class="keyword">if</span> f[j][<span class="built_in">ord</span>(t[i]) - <span class="number">97</span>] == m:</span><br><span class="line">                    match = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j = f[j][<span class="built_in">ord</span>(t[i]) - <span class="number">97</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(t) == <span class="built_in">len</span>(res) <span class="keyword">and</span> t &lt; res):</span><br><span class="line">                    res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle (Easy)</title>
      <link href="/2022/05/31/141/"/>
      <url>/2022/05/31/141/</url>
      
        <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle-Easy"><a href="#141-Linked-List-Cycle-Easy" class="headerlink" title="141. Linked List Cycle(Easy)"></a>141. Linked List Cycle(Easy)</h1><h2 id="Given-head-the-head-of-a-linked-list-determine-if-the-linked-list-has-a-cycle-in-it"><a href="#Given-head-the-head-of-a-linked-list-determine-if-the-linked-list-has-a-cycle-in-it" class="headerlink" title="Given head, the head of a linked list, determine if the linked list has a cycle in it."></a>Given head, the head of a linked list, determine if the linked list has a cycle in it.</h2><h2 id="There-is-a-cycle-in-a-linked-list-if-there-is-some-node-in-the-list-that-can-be-reached-again-by-continuously-following-the-next-pointer-Internally-pos-is-used-to-denote-the-index-of-the-node-that-tail’s-next-pointer-is-connected-to-Note-that-pos-is-not-passed-as-a-parameter"><a href="#There-is-a-cycle-in-a-linked-list-if-there-is-some-node-in-the-list-that-can-be-reached-again-by-continuously-following-the-next-pointer-Internally-pos-is-used-to-denote-the-index-of-the-node-that-tail’s-next-pointer-is-connected-to-Note-that-pos-is-not-passed-as-a-parameter" class="headerlink" title="There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter."></a>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</h2><h2 id="Return-true-if-there-is-a-cycle-in-the-linked-list-Otherwise-return-false"><a href="#Return-true-if-there-is-a-cycle-in-the-linked-list-Otherwise-return-false" class="headerlink" title="Return true if there is a cycle in the linked list. Otherwise, return false."></a>Return true if there is a cycle in the linked list. Otherwise, return false.</h2><p>快慢指针</p><p>官方题解：<br>「Floyd 判圈算法」（又称龟兔赛跑算法）<br>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p><p>官方解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>leetcode discussion（速度更快，但逻辑是类似的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            slow = head</span><br><span class="line">            fast = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这里有一点小不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> slow != fast:</span><br></pre></td></tr></table></figure><p>这两个的编译速度在我多次尝试后发现没什么不同，应该没有什么影响</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array (Easy)</title>
      <link href="/2022/05/29/88/"/>
      <url>/2022/05/29/88/</url>
      
        <content type="html"><![CDATA[<h1 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a>88. Merge Sorted Array (Easy)</h1><h2 id="You-are-given-two-integer-arrays-nums1-and-nums2-sorted-in-non-decreasing-order-and-two-integers-m-and-n-representing-the-number-of-elements-in-nums1-and-nums2-respectively"><a href="#You-are-given-two-integer-arrays-nums1-and-nums2-sorted-in-non-decreasing-order-and-two-integers-m-and-n-representing-the-number-of-elements-in-nums1-and-nums2-respectively" class="headerlink" title="You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively."></a>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</h2><h2 id="Merge-nums1-and-nums2-into-a-single-array-sorted-in-non-decreasing-order"><a href="#Merge-nums1-and-nums2-into-a-single-array-sorted-in-non-decreasing-order" class="headerlink" title="Merge nums1 and nums2 into a single array sorted in non-decreasing order."></a>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</h2><h2 id="The-final-sorted-array-should-not-be-returned-by-the-function-but-instead-be-stored-inside-the-array-nums1-To-accommodate-this-nums1-has-a-length-of-m-n-where-the-first-m-elements-denote-the-elements-that-should-be-merged-and-the-last-n-elements-are-set-to-0-and-should-be-ignored-nums2-has-a-length-of-n"><a href="#The-final-sorted-array-should-not-be-returned-by-the-function-but-instead-be-stored-inside-the-array-nums1-To-accommodate-this-nums1-has-a-length-of-m-n-where-the-first-m-elements-denote-the-elements-that-should-be-merged-and-the-last-n-elements-are-set-to-0-and-should-be-ignored-nums2-has-a-length-of-n" class="headerlink" title="The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n."></a>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</h2><p>python 数组技巧<br>array[n:]：打印从第n个元素（下标为n-1）到最后一个元素(包括第n个元素)<br>array[:n]：打印从第一个元素到第n个元素（下标为n-1）（包括第n个元素）</p><p>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>Output: [1,2,2,3,5,6]<br>Explanation: The arrays we are merging are [1,2,3] and [2,5,6].<br>The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m-<span class="number">1</span>] &gt;= nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m-<span class="number">1</span>] &gt;= nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>680. Valid Palindrome II (Easy)</title>
      <link href="/2022/05/28/680/"/>
      <url>/2022/05/28/680/</url>
      
        <content type="html"><![CDATA[<h1 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II(Easy)"></a>680. Valid Palindrome II(Easy)</h1><h2 id="Given-a-string-s-return-true-if-the-s-can-be-palindrome-after-deleting-at-most-one-character-from-it"><a href="#Given-a-string-s-return-true-if-the-s-can-be-palindrome-after-deleting-at-most-one-character-from-it" class="headerlink" title="Given a string s, return true if the s can be palindrome after deleting at most one character from it."></a>Given a string s, return true if the s can be palindrome after deleting at most one character from it.</h2><h2 id="官方题解：list-双指针"><a href="#官方题解：list-双指针" class="headerlink" title="官方题解：list+双指针"></a>官方题解：list+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Time: O(n)</span></span><br><span class="line">        <span class="comment"># Space: O(n)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                one, two = s[left:right], s[left + <span class="number">1</span>:right + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">return</span> one == one[::-<span class="number">1</span>] <span class="keyword">or</span> two == two[::-<span class="number">1</span>]</span><br><span class="line">            left, right = left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                delete_i = s[i+<span class="number">1</span>:j+<span class="number">1</span>]</span><br><span class="line">                delete_j = s[i:j]</span><br><span class="line">                <span class="keyword">return</span> self._isPalindrome(delete_i) <span class="keyword">or</span> self._isPalindrome(delete_j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>345. Reverse Vowels of a String (Easy)</title>
      <link href="/2022/05/28/345/"/>
      <url>/2022/05/28/345/</url>
      
        <content type="html"><![CDATA[<h1 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. Reverse Vowels of a String</h1><h2 id="Given-a-string-s-reverse-only-all-the-vowels-in-the-string-and-return-it"><a href="#Given-a-string-s-reverse-only-all-the-vowels-in-the-string-and-return-it" class="headerlink" title="Given a string s, reverse only all the vowels in the string and return it."></a>Given a string s, reverse only all the vowels in the string and return it.</h2><h2 id="The-vowels-are-‘a’-‘e’-‘i’-‘o’-and-‘u’-and-they-can-appear-in-both-cases"><a href="#The-vowels-are-‘a’-‘e’-‘i’-‘o’-and-‘u’-and-they-can-appear-in-both-cases" class="headerlink" title="The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases."></a>The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases.</h2><h2 id="官方题解：list-双指针"><a href="#官方题解：list-双指针" class="headerlink" title="官方题解：list+双指针"></a>官方题解：list+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isVowel</span>(<span class="params">ch: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">return</span> ch <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; n <span class="keyword">and</span> <span class="keyword">not</span> isVowel(s[i]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> isVowel(s[j]):</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                s[left], s[right] = s[right], s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        temp=[]<span class="comment">#存储遇到的元音</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]:</span><br><span class="line">                temp.append(s[i])</span><br><span class="line">        k=<span class="built_in">len</span>(temp)</span><br><span class="line">        s=<span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]:</span><br><span class="line">                s[i]=temp[k-<span class="number">1</span>]<span class="comment">#temp从后往前取值去覆盖</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><p>list+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        vowels = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span>]     <span class="comment"># 元音字母列表</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)                                                     <span class="comment"># 列表化输入字符串</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>                                     <span class="comment"># 初始化左右指针位置</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:                                             <span class="comment"># 如果指针位置合法</span></span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">not</span> <span class="keyword">in</span> vowels:                                   <span class="comment"># 如果左指针处字符不是元音字母</span></span><br><span class="line">                left += <span class="number">1</span>                                               <span class="comment"># 左指针右移</span></span><br><span class="line">            <span class="keyword">elif</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> vowels:                                <span class="comment"># 如果右指针处字符不是元音字母</span></span><br><span class="line">                right -= <span class="number">1</span>                                              <span class="comment"># 右指针左移</span></span><br><span class="line">            <span class="keyword">else</span>:                                                       <span class="comment"># 如果左右指针处字符都是元音字母</span></span><br><span class="line">                s[left], s[right] = s[right], s[left]                   <span class="comment"># 交换位置</span></span><br><span class="line">                left += <span class="number">1</span>                                               <span class="comment"># 左指针右移</span></span><br><span class="line">                right -= <span class="number">1</span>                                              <span class="comment"># 右指针左移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)                                               <span class="comment"># 将列表中的字符连接起来</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>633. Sum of Square Numbers (Medium)</title>
      <link href="/2022/05/28/633-Sum%20of%20Square%20Numbers/"/>
      <url>/2022/05/28/633-Sum%20of%20Square%20Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="633-Sum-of-Square-Numbers"><a href="#633-Sum-of-Square-Numbers" class="headerlink" title="633. Sum of Square Numbers"></a>633. Sum of Square Numbers</h1><h2 id="Given-a-non-negative-integer-c-decide-whether-there’re-two-integers-a-and-b-such-that-a2-b2-c"><a href="#Given-a-non-negative-integer-c-decide-whether-there’re-two-integers-a-and-b-such-that-a2-b2-c" class="headerlink" title="Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c."></a>Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c.</h2><p>同样是双指针</p><p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c</span>):</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">int</span>(c**<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="built_in">sum</span> = l*l+r*r</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; c:</span><br><span class="line">                l +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span>&gt;c:</span><br><span class="line">                r -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input array is sorted (Easy)</title>
      <link href="/2022/05/28/167-twosum-sorted/"/>
      <url>/2022/05/28/167-twosum-sorted/</url>
      
        <content type="html"><![CDATA[<h1 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a>167. Two Sum II - Input Array Is Sorted</h1><h2 id="Given-a-1-indexed-array-of-integers-numbers-that-is-already-sorted-in-non-decreasing-order-find-two-numbers-such-that-they-add-up-to-a-specific-target-number-Let-these-two-numbers-be-numbers-index1-and-numbers-index2-where-1-lt-index1-lt-index2-lt-numbers-length"><a href="#Given-a-1-indexed-array-of-integers-numbers-that-is-already-sorted-in-non-decreasing-order-find-two-numbers-such-that-they-add-up-to-a-specific-target-number-Let-these-two-numbers-be-numbers-index1-and-numbers-index2-where-1-lt-index1-lt-index2-lt-numbers-length" class="headerlink" title="Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length."></a>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.</h2><h2 id="Return-the-indices-of-the-two-numbers-index1-and-index2-added-by-one-as-an-integer-array-index1-index2-of-length-2"><a href="#Return-the-indices-of-the-two-numbers-index1-and-index2-added-by-one-as-an-integer-array-index1-index2-of-length-2" class="headerlink" title="Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2."></a>Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</h2><h2 id="The-tests-are-generated-such-that-there-is-exactly-one-solution-You-may-not-use-the-same-element-twice"><a href="#The-tests-are-generated-such-that-there-is-exactly-one-solution-You-may-not-use-the-same-element-twice" class="headerlink" title="The tests are generated such that there is exactly one solution. You may not use the same element twice."></a>The tests are generated such that there is exactly one solution. You may not use the same element twice.</h2><h2 id="Your-solution-must-use-only-constant-extra-space"><a href="#Your-solution-must-use-only-constant-extra-space" class="headerlink" title="Your solution must use only constant extra space."></a>Your solution must use only constant extra space.</h2><p>和第一题几乎可以用同样的思路，只不过这里的index从1开始，而且有序数组比第一题更简单</p><h3 id="根据第一题改的hashmap"><a href="#根据第一题改的hashmap" class="headerlink" title="根据第一题改的hashmap"></a>根据第一题改的hashmap</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        Hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            key = target - value</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> Hashmap:</span><br><span class="line">                <span class="keyword">return</span> [Hashmap[key]+<span class="number">1</span>, index+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Hashmap[value] = index</span><br></pre></td></tr></table></figure><p>Two pointers: O(n) time and O(1) space<br>Dictionary: O(n) time and O(n) space<br>Binary search: O(nlogn) time and O(1) space</p><h3 id="two-pointer"><a href="#two-pointer" class="headerlink" title="two-pointer"></a>two-pointer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            s = numbers[l] + numbers[r]</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                <span class="keyword">return</span> [l+<span class="number">1</span>, r+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[target-num]+<span class="number">1</span>, i+<span class="number">1</span>]</span><br><span class="line">            dic[num] = i</span><br><span class="line">```           </span><br><span class="line"></span><br><span class="line"><span class="comment">### binary search        </span></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(numbers)):</span><br><span class="line">        l, r = i+<span class="number">1</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        tmp = target - numbers[i]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r-l)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] == tmp:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, mid+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; tmp:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="binary-search-改进版"><a href="#binary-search-改进版" class="headerlink" title="binary search   改进版"></a>binary search   改进版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        investigatedSoFar = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> numbers[i] <span class="keyword">in</span> investigatedSoFar:</span><br><span class="line">                investigatedSoFar.append(numbers[i])</span><br><span class="line">                l, r = i + <span class="number">1</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">                tmp = target - numbers[i]</span><br><span class="line">                <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                    mid = l + (r-l) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> numbers[mid] == tmp:</span><br><span class="line">                        <span class="keyword">return</span>([i + <span class="number">1</span>, mid + <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">elif</span> numbers[mid] &lt; tmp:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = mid - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2022/05/28/1-twosum/"/>
      <url>/2022/05/28/1-twosum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="Given-an-array-of-integers-nums-and-an-integer-target-return-indices-of-the-two-numbers-such-that-they-add-up-to-target"><a href="#Given-an-array-of-integers-nums-and-an-integer-target-return-indices-of-the-two-numbers-such-that-they-add-up-to-target" class="headerlink" title="Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target."></a>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice" class="headerlink" title="You may assume that each input would have exactly one solution, and you may not use the same element twice."></a>You may assume that each input would have exactly one solution, and you may not use the same element twice.</h2><h2 id="You-can-return-the-answer-in-any-order"><a href="#You-can-return-the-answer-in-any-order" class="headerlink" title="You can return the answer in any order."></a>You can return the answer in any order.</h2><p>（无序）</p><p>hashmap<br>enumerate()(单词意思是枚举的意思)是python中的内置函数<br>enumerate(X,[start=0])<br>函数中的参数X可以是一个迭代器(iterator)或者是一个序列，start是起始计数值，默认从0开始。X可以是一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        Hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            key = target - value</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> Hashmap:</span><br><span class="line">                <span class="keyword">return</span> [Hashmap[key], index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Hashmap[value] = index</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode02-指针</title>
      <link href="/2022/05/25/LeetCode02-%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/25/LeetCode02-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>第二篇学习笔记，换一个思路尝试学习</p><h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-双指针"><a href="#Leetcode-题解-双指针" class="headerlink" title="Leetcode 题解 - 双指针"></a>Leetcode 题解 - 双指针</h1><h2 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h2><h2 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h2><h2 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h2><h2 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h2><h2 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h2><h2 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h2><h2 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h2><h2 id="双指针类型"><a href="#双指针类型" class="headerlink" title="双指针类型"></a>双指针类型</h2><p>对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。<br>快慢指针：两个指针方向相同。适合解决数组中的移动、删除元素问题，或者链表中的判断是否有环、长度问题。<br>分离双指针：两个指针分别属于不同的数组 / 链表。适合解决有序数组合并，求交集、并集问题。</p><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><p>对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 新建/启动/部署命令</title>
      <link href="/2022/05/16/hexo-usage/"/>
      <url>/2022/05/16/hexo-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新建一篇文章"><a href="#1-新建一篇文章" class="headerlink" title="1.新建一篇文章"></a>1.新建一篇文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;文章名称&quot;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post hexo_usage</span><br></pre></td></tr></table></figure><h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h2><h3 id="（1）清除缓存文件-db-json-和已生成的静态文件-public-。"><a href="#（1）清除缓存文件-db-json-和已生成的静态文件-public-。" class="headerlink" title="（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。"></a>（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>其实不需要每次都清除缓存文件，直接进行下面两步就可以</p><h3 id="（2）生成静态文件。"><a href="#（2）生成静态文件。" class="headerlink" title="（2）生成静态文件。"></a>（2）生成静态文件。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="（3）部署网站"><a href="#（3）部署网站" class="headerlink" title="（3）部署网站"></a>（3）部署网站</h3><p>部署之前预先生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="3-启动服务器。默认情况下，访问网址为："><a href="#3-启动服务器。默认情况下，访问网址为：" class="headerlink" title="3.启动服务器。默认情况下，访问网址为："></a>3.启动服务器。默认情况下，访问网址为：</h2><p><a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾尔登法环boss战</title>
      <link href="/2022/05/16/elden-ring-boss/"/>
      <url>/2022/05/16/elden-ring-boss/</url>
      
        <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>当我们褪色者重新回到交界地，第一个相遇的法环碎片持有者就是史东威尔城城主“黄金”葛瑞克，一个臭名昭著的神之后裔，黄金家族成员，在史东威尔城附近的破屋里，我们会遇到一位红帽女孩，会知道葛瑞克利用被称为接肢的技术四处劫掠褪色者，将砍下的手脚接在自己身上来增加自身的实力。这座腐朽的城池里到处都是残肢断臂，在一座大厅里我们还能见到在出生点相似的截肢贵族。在城池里我们还会遇到同样对葛瑞克所作所为十分不齿的女战士涅斐丽·露，她会在我们与葛瑞克战斗中助我们一臂之力。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8E%A5%E8%82%A2.5zgwu136oo40.webp" alt="接肢"></p><p>在我们将他击退之后，他还会砍下自己的左手，并接上一个龙头，试图再度增强自己的力量。但当我们最终击败他时，他喃喃地说到：“总有一天，我们会回到黄金树脚下的故乡……“葛瑞克作为曾经最强的一族——”黄金“一族的后人，却非常孱弱，艾尔登法环被女神玛莉卡敲碎后，群雄并起，引发了旷日持久的碎片战争，黄金树脚下的王城多次遭到进攻，葛瑞克混在女人堆里逃出王城，躲在史东薇尔城苟活，曾经想挑战女武神，却被被女武神打的满地找牙。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%85%B5%E8%B4%A5%E5%A6%82%E5%B1%B1%E5%80%92.5rvvday8fkk0.webp" alt="兵败如山倒"></p><p>他妄图通过接肢变得更强，却是想着能够有朝一日可以重现黄金一族的辉煌，当他砍下手臂接上龙头时，他会朝天怒吼：“诸位祖先，敬请见证！”只可惜乱世之中，不符合无上意志的棋子都会被抹去。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>乘着灵马特雷托一路北上，在雷亚卢卡利亚魔法学院，我们会遭遇曾经被称为“满月”女王的蕾娜菈。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%BB%A1%E6%9C%88%E5%A5%B3%E7%8E%8B%E5%A4%A7%E5%8D%A2%E6%81%A9.3jkdl5ccy3c0.webp" alt="满月女王大卢恩"><br>作为卡利亚魔法王国曾经的领导者，卡利亚魔法王国和黄金树势力曾经敌对，黄金树派出了英雄拉达冈前来讨伐，结果蕾娜菈和拉达冈在战场上相爱，双方化干戈为玉帛，喜结连理还诞下了三个子嗣。（分别是碎星将军拉塔恩，月之公主菈妮（神人），黄金树司法官拉卡德）</p><p>但好景不长，拉达冈突然抛下了自己的妻子，回到黄金树和永恒女王玛丽卡结婚。突然失去爱情支撑的蕾娜菈就此丧失了神智，成为现在这幅模样并被卡利亚王室囚禁于大书库。</p><p>她的手里怀抱着拉达冈留给她的琥珀一样的大卢恩，神志不清，不断地利用大卢恩的力量诞生没有自我意识的孩子。</p><p>在打碎女王身边的防护罩后</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E7%8E%8B.6ktlkq7hr88.webp" alt="女王"></p><p>女儿月之公主菈妮会用魔法代替她的母亲与我们战斗，重现了全盛时期的满月女王：灵魂激流一类的法术随意释放，还可以召唤巨龙巨人狼群的灵体协助战斗。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%BB%A1%E6%9C%88%E5%A5%B3%E7%8E%8B.u8tx9yd3ksw.webp" alt="满月女王"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>往东，我们进入了满目猩红腐败的盖利德地区，刚进入红狮子城的配乐极其震撼和忧伤，这么一位一等一的英雄，在盖利德和女武神的战斗中遭受猩红腐败的腐蚀后，自我放逐到恸哭山丘，即使像野狗一样啃噬着战场上的尸体，依然维持着星空的封印。他的手下红狮子军在盖利德修筑了一条熏烧火墙，用火焰同被猩红腐败腐蚀变异的巨大怪物开展永无止境的死斗。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%A1%94%E6%81%A9.6s44iqw0kyw0.webp" alt="拉塔恩"></p><p>一望无际的战场上布满了断戟残垣，只能远远看到他的庞大身躯和贯穿天空的重力大箭，这是一场战斗祭奠，拉塔恩的手下奇异骑士邀请天下豪杰群聚于此，希望能解除他的痛苦，像一位战士一样死去，如果不把战士壶亚历山大和狼哥等英雄们召唤出来，单对单战斗确实是非常困难的事。如果召唤所有英雄跟这位最强半神贴身肉搏，扑面而来的是那种英雄末路的悲壮感，大开大合的招式在战士们中杀进杀出，能坚持战斗到最后一刻的就只剩下壶哥和狼哥，终于击败拉塔恩将军后，天上静滞的星星突然开始流动，随着拉塔恩将军的逝去，群星的封印被解除，新的命运齿轮开始转动</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%A7%A3%E6%94%BE%E7%BE%A4%E6%98%9F.map0i942acw.webp" alt="解放群星"></p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>随着星空封印解除，一枚流星砸穿了地面，地下的永恒之城重现人世，充满恶意的恐怖外神，黑暗弃子艾丝缇从星空坠落，砸穿了天空城之后，又将诺克史黛拉沉入地底，这与永恒之城的种种悖逆之举有关，他们制造了可以伤害无上意志和二指的猎杀指头刀，又试图通过仿身泪滴造出新的神灵，从而引来了无上意志的惩罚。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E6%9A%97%E5%BC%83%E5%AD%90%E8%89%BE%E6%96%AF%E6%8F%90.4mk6fn5wmoe0.webp" alt="黑暗弃子艾斯提"></p><p>巨大的身躯由星星构成，面部是一张令人不寒而栗的骷髅脸，拥有通过黑洞瞬移的能力</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>当褪色者攻进王城，踏入王座大厅之时，我们会遇到一位身上长满犄角，面貌丑陋的王：噩兆王蒙葛特。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%99%A9%E5%85%86%E7%8E%8B-(3).17zez1e8xhk0.webp" alt="噩兆王-(3)"></p><p>他是一位悲剧的半神，因为长相丑陋，自出生时就和兄弟蒙格一同被扔进了王城的下水道，虽然是黄金王朝的王子过得却是老鼠一般的生活。他本应诅咒这个畸形的世界，但讽刺的是，当艾尔登法环破碎后，群雄逐鹿，王城也遭到各路人马的进攻，曾经的半神和神人们纷纷自立门户，只有这位生活在下水道里的噩兆王蒙葛特，在关键时间挑起了守城的重任，并击退了所有来犯之敌，多次保住了黄金王城，在碎片战争中，他甚至击败了有着最强半神名号的拉塔恩将军。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%99%A9%E5%85%86%E7%8E%8B.zz7mh0ns0cw.webp" alt="噩兆王"></p><p>击败蒙葛特后，他的追忆中这样描述：即使生为赐福无缘的恶兆之子，蒙葛特仍愿意为黄金树的守卫，不是因为被爱，想要回馈，而是他单纯希望去爱。似乎与这个黄金王朝的命运一样，他身后的王座只需轻轻一碰就变成了碎片。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>当“黄金”葛德文成为死王子后，古龙就待在他的好友体内，不停与死亡搏斗，在死眠少女菲雅的梦境中，我们见到了传说中的“死龙”弗尔桑克斯。</p><p>当死龙飞翔在天空手持红雷配上木星大红斑似的背景，场景混乱又充满了阴郁的美感。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%AD%BB%E9%BE%99.2o7vqe77gfq0.webp" alt="死龙"></p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>在亚坛高原西边的火山地区，这里有黄金王朝的司法官拉卡德，是一个毫无怜悯心的法官，也是众多拷问官的长官。如蛇一般，令人感到生厌的男人。</p><p>拉卡德是拉达冈和满月女王的孩子之一。对于黄金树信仰而言，“……拉卡德犯下了亵渎罪，是罪无可赦的敌人。”艾尔登法环破碎之前的拉卡德是残酷的司法官，整个牢镇随处可见被折磨虐待的白金之子。在破碎战争中，他曾是反对黄金树的霸王，反叛黄金树信仰，反对无上意志，为了追求更强的力量反抗黄金树主动被大蛇吞噬。我们会先通过小蛇女的邀请加入名为叛律者的组织。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%AB%E5%B1%B1%E5%AE%98%E9%82%B8%E5%B0%8F%E8%9B%87%E5%A5%B3.1uuo8t56o7k0.webp" alt="火山官邸小蛇女"></p><p>那些具有反对黄金树潜质的英雄们，会被邀请到火山府邸，完成一系列亵渎（反抗黄金律法）之举。但是在拉卡德变成大蛇之后，因为最终能出色完成任务的叛律者都要去谒见拉卡德，而这些叛律者最终的遭遇，就和拉卡德曾经的骑士一样被吞噬，变成大蛇的一部分。</p><p>在完成了火山官邸安排的红灵入侵任务（击杀其他褪色者）后，拉卡德的侧室塔尼斯，一个一直戴着面具替拉卡德处理日常事务的女人，终于同意我们觐见亵渎君王拉卡德。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%8D%A1%E5%BE%B7.2qqguzuqhsg0.webp" alt="拉卡德"></p><p>在大蛇前的不远处，有一把大蛇狩猎矛，与大蛇对峙时，能形成风暴似的光刃</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%8D%A1%E5%BE%B7-%E9%A3%8E%E6%9A%B4%E7%9F%9B.1x5z2bhjz51c.webp" alt="拉卡德-风暴矛"></p><p>在拉卡德被风暴之刃击败后，他的侧室会跪坐在大蛇的尸体处，不断地啃食着尸体的头部，希望借此变成蛇人继承他的意志，算是交界地的一对苦命鸳鸯了。</p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E.3kbc2m7gnqw.webp" alt="女武神"></p><p>女武神玛莲妮亚，“米凯拉的锋刃”，手下有战无不胜的尊腐骑士大军，装上义手，带上飞翼头盔，掌握那高展飞翼的技能“水鸟乱舞”。为了帮哥哥米凯拉登上王位参加碎片战争，女武神玛莲妮亚在外四处征战，鲜血君王蒙格趁虚而入将米凯拉从圣树中掳走，玛莲妮亚率领大军一路南下寻找线索，而罪魁祸首蒙格的鲜血王朝就在盖利德地区（碎星将军拉塔恩的统治区域）的地下深处。当女武神赶到盖利德时，认为是拉塔恩抢走了哥哥米凯拉，与驻守于此的碎星将军以及他的红狮子军团展开了一场惊天动地的大战，史称艾奥尼亚之战。在最终的对决中，娇艳的腐败花朵怒放，吞噬了整个艾奥尼亚。拉塔恩与玛莲妮亚战成平手。这场无人胜利的战争伴随着玛莲妮亚的昏迷和拉塔恩的疯狂落下帷幕。</p><p>昏迷的玛莲妮亚被英雄芬雷带回圣树，从那以后好像迷失了自我，安安静静坐在圣树深处，等待着哥哥回归。</p><p>在我们第一次击倒女武神之后，她再次释放了体内的猩红腐败之力</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E4%BA%8C%E9%98%B6%E6%AE%B5.4e8xbca3rrg.webp" alt="女武神二阶段"></p><p>玛莲妮亚如同一只妖艳而致命的蝴蝶飞翔在空中，展现着完全状态下女武神的恐怖力量，她重重的将刀劈向地面，一朵朵猩红腐败之花怒放。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E4%BA%8C%E9%98%B6%E6%AE%B5.5dvcazx35ag0.webp" alt="女武神二阶段"></p><p>击败女武神之后获得的大卢恩也如同她本人一样，也充满了猩红腐败的力量</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E5%A4%A7%E5%8D%A2%E6%81%A9.1zwty3tfz5q8.webp" alt="女武神大卢恩"></p><h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><p>不得不说，玛莉卡的子嗣们，也就是半神们，都有着自己的野心和理想。鲜血君王蒙格，与孪生兄弟噩兆王蒙葛特一起守卫王城之时，也期望能建立属于自己的鲜血王朝。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%B1%B3%E5%87%AF%E6%8B%89%E7%9A%84%E8%8C%A7.3mgjvu8tfwq0.webp" alt="米凯拉的茧"></p><p>在碎片战争中，蒙格绑走了神人米凯拉，神人是神的候补，在玛莉卡女王失踪之后有着成为神的资格，蒙格利用血茧培育着米凯拉，当米凯拉成神之际，自己就可以以艾尔登之王的身份君临天下。殊不知，是蒙格自己的愿望，还是米凯拉的诱惑导致的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%92%99%E6%A0%BC%E5%92%8C%E7%B1%B3%E5%87%AF%E6%8B%89.1bciyje0cckg.webp" alt="蒙格和米凯拉"><br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%92%99%E6%A0%BC.1x6uysx08ug0.webp" alt="蒙格"></p><h2 id="十"><a href="#十" class="headerlink" title="十"></a>十</h2><p>天空城里的黑剑玛利喀斯是玛莉卡女王忠诚的结拜弟弟，将命定之死寄宿在自身的剑里，令所有的半神感到畏惧。而就是因为它们明白何谓畏惧，才会是英雄。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E5%89%91%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BC%80%E5%A4%B4.2zezr2k3z8e0.webp" alt="黑剑二阶段开头"></p><p>在阴谋之夜，死亡的一部分被偷走之后，玛利喀斯把黑剑封印在自己体内，为的是不再让它失窃。</p><p>褪色者和黑剑第一次相遇是在盖利德的最北边的野兽祭祀塔，见到的是野兽祭祀模样的玛利喀斯，穿着肮脏破烂的外衣，迫切的渴望着死根，在吃了四个死根之后他甚至会陷入疯狂攻击我们，在十个死根完全收集之后，他会从祭祀塔里消失，下一次再见是在天空城。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E5%89%91.1wx0hv9col28.webp" alt="黑剑"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BE%99%E7%8E%8B.41eybrgpofo0.webp" alt="龙王"><br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%AB%E5%B1%B1%E5%B7%A8%E4%BA%BA.183gb0scvxog.webp" alt="火山巨人"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%9B%B8%E9%81%87%E5%88%9D%E4%BB%A3%E7%8E%8B.2u204qv0zhs0.webp" alt="相遇初代王"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%88%9D%E4%BB%A3%E7%8E%8B%E6%8B%A6%E8%B7%AF.7acl2a2g6xc0.webp" alt="初代王拦路"></p><p>圣树的女武神是我死亡次数最多的boss，但有猎犬步伐加上耍无赖的用了冤魂绕圈打法，其实难度并没有打只狼的一心艰难，就是得多挂几次学一下怎么躲水鸟，法师的一个问题是血太薄，被水鸟的任何一个连招中的两刀砍到就没了。王城下水道的“恶兆之子”蒙格和鲜血王朝的“碎片君王”蒙格我也没什么战斗记忆，只要记得喝滴露就可以破解他的倒计时大招。火焰巨人倒真是卡住了我一段时间，因为遍地打滚被压碎了好几次，放弃了当甘道夫的想法选择用岩石球就很容易了。龙王普拉顿桑克斯可以说是后期除了女武神之外第二强的boss，瞬移，秒人光炮，大范围龙爪aoe，黑刀姐第一次boss半血都没到就被打没了，主要是每死一次得跑一阵才能到boss房，技能也没有死龙酷炫，基本每招都能秒我，战斗体验很糟糕。然后是黑剑，黑剑二阶段的战斗身姿是最帅的，那套盔甲配上黑剑的火焰燃烧特效从天上劈下刀光非常引人入胜，但整体并不难打，因为他血很薄又没有女武神那样的吸血buff，平台上还有几根石柱，虽然不能秦王绕柱但可以躲柱子后面喝口药回回状态。初代王荷莱露说实话出场表演很一般，并没有感觉到初代艾尔登之王的逼格，猎犬步伐躲投技，跳起来躲大范围捶地aoe，二阶段撕狮子那段很惊讶，但后面鞋子的特写有点出戏（鞋带不好系啊），二阶段在骨灰和女战士（现在是史东威尔城城主）也没什么难度就过了。最终boss红毛拉达冈和艾尔登之兽在圣龙徽护符+2，螃蟹肉和祷告圣防护的buff下打了两次就过了，红毛有个问题，就是读指令的动作太明显了，属于敌不动我不动那种，没有动作游戏的体验，就像只狼里的弦一郎加一心我打了快一天才赢，但是结束以后就觉得很爽，弹刀出刀忍义手有一种见招拆招的快感，跟拉达冈打就像回合制游戏，他出招我就翻滚，等他技能后摇我再砍一剑然后继续泥地打滚或者猎犬步伐找机会。<br>战灰的加入虽然简化了战斗，但个别骨灰的强势导致我完全没有想法使用其他的骨灰，点名黑刀姐和仿身泪滴。仿身泪滴在我玩的时候已经被削，不再是大哥了，但它血厚啊。黑刀姐就更强了，战技经常放还是比例掉血，会瞬移，移动灵活。攻击欲望强，打大型怪跟战神一样，当然希望宫崎老贼的更新方式是加强其他骨灰而不是削已有的强势骨灰。</p><p>你将会在游戏里遇到以下角色：</p><p>一个姑娘告诉你她的城堡里奴隶造反了，她的城主父亲正在努力抵抗叛军，她给你一封信，让你带给他父亲，劝说他离开。于是你杀进城堡找到她父亲，结果他父亲说自己奉葛瑞克大人（这片区域的君王）抵抗叛军，不能离开，关键是镇城之剑不能落入叛军之手，于是你又杀了叛军的老大拿回了剑，你以为城主这下可以和女儿团聚了，于是高兴滴回去找姑娘，结果发现姑娘已经倒在了血泊中，旁边赫然插着奴隶们使用的大刀。你沮丧地回去找城主，却发现不知情的城主说自己的任务已经完成了，未来要为女儿而活……再回到和妹子相遇的地方，会见到这个心碎的父亲在女儿的尸体旁捶地怒吼，高喊要为了女儿复仇。后期在一间充满尸臭的破屋里，这个父亲会失智地攻击我们。复仇已经吞噬了他的心，也许倒在玩家的剑下，和女儿团聚，是对他来说最好的结局。</p><p>在魔法学院外，你会遇到一个落魄魔法师托普斯，求你给他十块钱去弄点吃的，他会教你魔法作为报酬。他教的魔法有点奇怪（比如一个可以照明用魔法，虽然没有战斗力但很实用），他说自己很有自知之明，知道自己是块朽木，很遗憾不能教给玩家好的魔法，他希望能进入魔法学院去研究。之后玩家找到魔法学院钥匙可以交给他，他会非常感谢你然后离去。在玩家探索魔法学院的时候，可以在某一个地方找到托普斯的尸体：被绑在椅子上，死前似乎依然在研究魔法。而调查他的尸体，可以发现他赌上性命研究的魔法：托普斯的立场。这个魔法的效果非常逆天，可以弹开所有魔法。物品介绍中这样描述：后世的人们会明白，那受人嘲讽的理念，其实是足以成立新教室的发现。</p><p>同样是魔法师，你会在某处遗迹地下室遇见一个女魔法师瑟廉，如果你希望她教你魔法，她会警告你自己是被魔法学院驱逐的魔女。如果玩家表示不介意的话，瑟廉会惊讶并表示愿意教我们魔法，并亲切称呼我们为徒弟。在玩家此后的征程中，老师知无不言，还会一直鼓励我们，甚至表示就算玩家一无所成，还是可以去找她，毕竟老师永远会给弟子留一个位置。然而随着剧情推进，我们会发现原来老师就是魔法学院里被称为“尸块魔女”的存在，为了探索禁忌的星星起源而杀害了无数魔法师。当玩家将两位大魔法师尸体的位置告诉老师后，老师最终会和他们融合，变成一颗恐怖的人面球，痛苦地向我们呻吟：“呜呜呜呜，徒弟，呜呜呜……”虽然探索禁忌的疯狂行为终究要付出代价，但即使是内心再怎么疯狂之人，对于那个当初不介意自己出身，愿意接纳自己的小徒弟，她依然愿意袒露内心真心相对。（也有说法人面球就是星星的雏形，老师其实是得道了）</p><p>在一座桥旁， 玩家会遇到一个长着手脚的壶被卡在地上，请求我们的帮忙。帮他脱困后，他会告诉我们自己是战士壶——铁拳亚历山大，正要去红狮子城参加战斗祭奠。他爽朗的笑声让人印象深刻。在战斗祭奠上携手壶哥一同击败半神拉塔恩将军后，壶哥会浑身裂痕趴在地上，告诉我们刚才我们的表现很棒，但自己没几下就被打趴下了，还出现了好多裂痕，壶里的内容物都漏出来了，好在这里有很多战士的尸体，可以弥补遗失的内容物。我们这才知道原来战士壶就是战士尸体的容器，他是战士们战意的承载者。为了变得更强，壶哥决定去火山官邸旁的熔岩接受高温炙烤，又去巨人雪山寻找神火锻造自己，最终他和我们在天空城相逢。每次碰面，他总是用爽朗的笑声回应我们，好像不管何种失意都不会影响他的斗志，尽管他身上的裂痕越来越多。在天空城，壶哥邀请我们作为他的一场试炼，因为我们是他认可的英雄。开打后我们发现，相比其他战士壶，壶哥强太多太多了，他不但可以喷火，甚至挥手就可以掀起火焰风暴，一双铁拳使出的火焰升龙拳甚至可以击飞曾经弑神的玩家。但是壶的承载度终归有限，壶哥还是倒下了。他告诉我们，他知道壶终归只是壶，但作为战士，他战斗到了最后一刻。最终，在爽朗的笑声中，壶哥像其他战士壶一样碎裂成了碎片。</p><p>在游戏中，你会遇到一个自称霍劳斯的骑士，说他和女仆走散了，如果你见到了可以告诉他，还说如果有人敢动他女仆他就不客气了，嘴上还说着霍劳斯以血代言（用让你出血代替用嘴逼逼），给人感觉是个狠人。后来在魔法学院前，你发现他找到了已经被杀害的女仆，他告诉你凶手是火山官邸的人，他非要复仇不可，因为霍劳斯家族以血代言。后来在大本营，他告诉你他找到了火山官邸的人，但对方竟然要拉他入伙，他表示自己气的要大开杀戒了。让人大跌眼镜的是，当玩家进入火山官邸后，竟然见到霍劳斯，他告诉你，他也加入火山官邸了，不想复仇了。他还自己找了一个理由：英雄不会刻意走干净的路，我要选择一条污秽的路来证明我的英雄气概。无数玩家在他的脚下留言：前有大便，前无马（妈），愤怒！等等来表达内心的不满。之后霍劳斯屡屡出任务失败（火山官邸以猎杀同类为任务），他向玩家诉苦自己这双手根本不适合成为英雄。玩家通过支线任务也得知原来霍劳斯有一个哥哥，由于弟弟太过没用，哥哥名正言顺当上了家主，也一直爱着弟弟，并希望弟弟不要走上霍劳斯以血代言的铁血道路。但弟弟也一直想着走出哥哥的阴影……后来在壶村，玩家发现霍劳斯逃出了火山官邸，在这里当上了维壶师，维修这里的战士壶，虽然这份工作看起来低微，但看着在自己的维护下，壶们一个个恢复健康，霍劳斯说：我从火山官邸逃了出来，从所有地方逃了出来，逃避一切。说出来你可能不信，但我在这里，才有了真正活着的感觉。一段时间后玩家回来，会发现所有的壶都碎了，只有一个小壶还完好，而霍劳斯只剩下最后一口气。原来村里遇到了偷猎者，是霍劳斯用性命击退了他们。当你告诉霍劳斯壶都没事时，他会欣慰地说，就算是自己这样没用的人，也会有派上用场的时候，并最后说出了那句他一直挂在嘴边的话：霍劳斯以血代言。在他的尸体旁，全是玩家的留言，几乎都是一样的内容：前有英雄。</p><p>在一座山洞中，你会遇到一个名为帕奇的光头，一开始他会攻击你，但如果你将他打到半血，他会跪地求饶，如果你放过他，他就开始拍你马屁。他的房间里放着一个宝箱，如果玩家去开，就会中陷阱被传送到别处，帕奇还会嘲笑我们是贪婪之徒。之后玩家可以在火山官邸遇到他，他会将自己的猎杀任务让给你（大概率是太强他自己打不过），如果你完成了任务，他会说帮你去汇报，但不会把任务奖励给你，除非你亲自问他才会不情愿地给你，但就是这样一个滑头，却在游戏里得到善终，逍遥快活。</p><p>NPC不得善终，几乎是魂系列的定律，那些坚持原则的角色，大部分落得凄惨的下场，反而是帕奇这样的角色，却能活得游刃有余，这何尝不是对现实世界的一种无情嘲弄。当然，那些明知不可为而为之的角色，虽然最终陨落，但却实实在在给玩家的心里留下了一份感动。</p><p>———3.21更新————</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾尔登法环评价</title>
      <link href="/2022/05/16/elden-ring/"/>
      <url>/2022/05/16/elden-ring/</url>
      
        <content type="html"><![CDATA[<p>说实话，作为我第一款全价购买的steam游戏，艾尔登法环就像一场盛宴，他几乎满足了我对奇幻世界和宏大史诗的全部期待。从四月一日到四月十八日，一周目耗时105小时，完成了所有的结局和几乎所有的支线，在此感谢“老戴解说”，在他的视频帮助下我成功体验到了老头环的魅力，还有全成就(^_^)。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%85%A8%E6%88%90%E5%B0%B1.4l3lk90t6qe0.webp" alt="全成就"></p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><h3 id="1-宏大史诗和庞大的世界观。"><a href="#1-宏大史诗和庞大的世界观。" class="headerlink" title="1.宏大史诗和庞大的世界观。"></a>1.宏大史诗和庞大的世界观。</h3><p>最早接触的魂类游戏是只狼，在我多周目不同的结局后，我开始体验到魂类游戏的魅力，虽然黑魂3前期打boss对我来说并不难，但有个很头疼的问题是迷路，这也是弃坑黑魂3的原因。我个人非常喜欢宏大世界观和史诗故事，看完了龙崎棒棒糖所有关于黑魂背景的介绍视频之后，我很期待乔治马丁和宫崎老贼能描绘出多么精彩的画卷，在剧情和背景的设定上，老头环达到了我对游戏的最高评价。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%87%BA%E7%94%9F%E7%82%B9.77c6cdw5yuw0.webp" alt="出生点"></p><h3 id="2-美学设计-前有绝景"><a href="#2-美学设计-前有绝景" class="headerlink" title="2.美学设计/前有绝景"></a>2.美学设计/前有绝景</h3><p>我从出生点开始，就不断的F12截图，一直到游戏结束，既是记录游戏剧情，也是对游戏画面的感叹。虽然老头环的贴图不算精细，但整体环境充满了特点，并且在老头环，不同的地区会有不同的场景描绘，不像黑魂都是黑暗阴森。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%8F%B2%E4%B8%9C%E5%A8%81%E5%B0%94%E5%9F%8E.2xo9rwygi9c0.webp" alt="史东威尔城"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%8F%B2%E4%B8%9C%E5%A8%81%E5%B0%94%E5%9F%8E-(2).50o20o1khwk0.webp" alt="史东威尔城-(2)"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%9C%B0%E4%B8%8B%E5%9F%8E-(2).7efse996mpw0.webp" alt="地下城-(2)"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%8E%8B%E5%9F%8E-%E4%BA%8C%E5%91%A8%E7%9B%AE.i8o7uazbitk.webp" alt="王城-二周目"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%9B%AA%E5%B1%B1-%E5%89%8D%E6%9C%89%E7%BB%9D%E6%99%AF.5skhjn3gcl00.webp" alt="雪山-前有绝景"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A4%A9%E7%A9%BA%E5%9F%8E.1e9s8xlcq1a8.webp" alt="天空城"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%B0%E5%9F%8E.33b3v6b97dk0.webp" alt="灰城"></p><h2 id="中性（个人看法）"><a href="#中性（个人看法）" class="headerlink" title="中性（个人看法）"></a>中性（个人看法）</h2><h3 id="1-战斗设计"><a href="#1-战斗设计" class="headerlink" title="1.战斗设计"></a>1.战斗设计</h3><p>说实话这种类似黑魂的战斗体验并没有很优秀，快慢刀加读指令还是很头痛的，个人来说还是更喜欢只狼那种偏向ACT的战斗风格，而不是满地打滚当驴学派玩家。不过法师的加入让老头环入门更加简单，作为不用灵魂激流就喜欢月光剑贴脸砍的狂战士甘道夫，虽然少部分时候在受苦，整体来说战斗体验还是不错的。</p><p>但是！后期圣树，雪山和雪原，数值膨胀的太离谱了，不刷级不行，印象深刻的是圣树罗蕾塔门口的两个魔法师，顶级法师了属于是，攻击力极高，血贼厚，没有蓝条，远比后面的罗蕾塔boss强，地方又狭窄，别说战斗了，就是跑酷都不好跑。（打到这的时候就感叹这里的每个小兵都能暴捶葛瑞克之流）</p><h3 id="2-地图设计"><a href="#2-地图设计" class="headerlink" title="2.地图设计"></a>2.地图设计</h3><p>前期洞窟和地面城池的设计算是非常巧妙，很多地方有捷径或者意想不到的到达方式，虽然依然有各种转角遇到背刺的小兵和石像鬼，但这也算是法环作为恐怖游戏的一种标签，但后期雪原非常空旷，如果不是进去的暴风雪挡住了视线，刚进去的那里什么都没有</p><h3 id="3-NPC设计"><a href="#3-NPC设计" class="headerlink" title="3.NPC设计"></a>3.NPC设计</h3><p>NPC的设计可以说是有好有坏，描写非常深刻的有战士壶亚历山大狼哥还有亲爱的老师瑟廉，但其他的就不是那么印象深刻了，其实如果可以把支线连在一起看，大部分NPC都是有血有肉（虽然绝大部分都是悲剧结局）但巧就巧在法环的内容量太大，又有接下来提到的任务指引问题，只有看攻略猛攻一个故事，才能体会深刻，就比如说海德要塞那个城主，要我来回跑图（中途还没有赐福）才能接近完成任务。还有个问题是老头环里的NPC跟投币木马似的，话总是不一次讲完，必须得不停的对话。<br>顺便一提，传说中的魂系经典人物帕奇，说实话如果没有这层buff帕奇就是个杂兵，在一周目我通过攻略经历了所有和帕奇有关的故事，包括被他在火山地区踹下悬崖。我非常不理解为什么玩家们会喜欢这样一个偷奸耍滑作奸犯科的NPC，在二周目我选择直接把他砍翻，除了几个猎杀褪色者任务，即使没有他整个故事流程也没有影响。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><h3 id="1-最垃圾：任务指引"><a href="#1-最垃圾：任务指引" class="headerlink" title="1.最垃圾：任务指引"></a>1.最垃圾：任务指引</h3><p>任务指引其实不能用垃圾来形容，应该是完全没有。碎片化叙事我可以接受，以往的魂类游戏都是在一个走廊里把剧本一张张放好（不一定按顺序），但现在，他把剧本撒在了一个六十层大楼里，需要不断地上蹿下跳去找，而且里面还有各种各样的粪坑。我不相信作为一个普通玩家能够在不看攻略的情况下做完大部分任务，甚至说，不看攻略连很多支线都不知道在哪开始接。<br>作为一个开放世界，没有任务清单意味着我根本记不住多个任务，一边在被小兵暴杀的同时我还要记下一步支线怎么走？好些NPC我一开始不看攻略一头雾水， “你谁啊就跟我搭话”<br>更别说什么商人卖的情报了，有些商人藏在什么鸟不拉屎的地方啊，举个例子，卡利亚学院传送门那里，那个商人在传送门后面的断桥处，但是，你不能通过传送门走，要沿着断桥走，断桥上全是树木和灌木丛遮挡视线，还有一片狼群，然后才能看到商人，不看攻略哪个正常人会在看到传送门的情况下往断桥里钻？<br>就算有商人的情报，米莉森的支线还有三指女巫的支线的地点就完全没有提示，本来任务流程的间隔非常大，这些支线本身体量又有限，开放世界进一步分割并加剧了任务的碎片化，你必须得在这个开放世界闲逛，才能找到他们，这样就光剩碎片没故事了。<br>主线剧情有个大问题是我把老婆当柴火烧了树以后就黑屏到天空城了？到了天空城我为什么要去揍黑剑？什么提示也没有就让我去拿命定之死？命定之死前面只提到可以干掉半神，没说干掉黑剑释放命定之死才能真正烧黄金树。<br>如果只能通过看攻略才能完成任务，那么作为一款游戏我认为法环的任务指引是极其失败的。<br>有人会洗白说这是魂系游戏的特色，“老ass一周目基本不会上网查看攻略的，最多交流下自己发现的问题。魂游戏的一周目无知探索是最有乐趣的而且这个无知不可逆。”但这是开放世界，不是以往的线性叙事，魂系游戏的前提是游戏，这么大的游戏体量难道要我一个普通玩家拿个笔记本自己记？</p><h3 id="2-部分物品获得设计"><a href="#2-部分物品获得设计" class="headerlink" title="2.部分物品获得设计"></a>2.部分物品获得设计</h3><p>故事散布在大楼里就算了，问题是底下还有粪坑，在死根深处有个传说护符，需要穿过一片黑暗的蚂蚁窝，就是在黑暗中，你得辨别蚂蚁窝的布局看着无数只巨大蚂蚁在边上进攻骑马穿梭跳跃，我是真的被恶心到了，纯粹的生理恶心，这个护符的放置地点让我不可能给这个游戏打满分，纯粹故意恶心玩家，不会有打着魂类游戏的旗号的昆虫爱好者喜欢吧，不会吧不会吧<br>更别提什么大手怪还有蚯蚓脸了，但好歹没有那种强制你盯着看的设计出现<br>还有各种各样的奇怪藏东西地点，让我感觉制作组只是故意把他们藏在玩家找不到的地点，而不是打完一场战斗后的战利品，我在收集物品时（特别是后期）完全没有那种“原来在这里”的惊喜</p><h3 id="3-跑酷设计"><a href="#3-跑酷设计" class="headerlink" title="3.跑酷设计"></a>3.跑酷设计</h3><p>在小兵和房顶穿梭的时间远远大于打boss的时间，很多无意义的堆怪耗尽耐心。印象最深的是卡利亚学院楼顶的跑酷，跳到有一处房顶的时候，本来距离就远不太好跳，还在这里布置了一个类似只狼的风筝怪，我在空中被它打下去很多次，我忍了很久才没有卸游戏。当然有人洗白说这是魂系游戏的特点，我只能说适当的恶心人可以，恶心多了就只能徒增厌恶</p><h3 id="4-剧情bug"><a href="#4-剧情bug" class="headerlink" title="4.剧情bug"></a>4.剧情bug</h3><p>黑剑和野兽祭祀，这是很多人都提到的bug了，打完黑剑野兽祭祀还在，有些人洗白说这是不同时空的黑剑，但老头环前面没有出现什么时空分割的设定，我倾向于是有个bug或者是这部分没做完就拿出来发售了。<br>吐槽一下，还有烧树后飞到天空城，这都啥啊就飞上去了？咋飞的啊，要是梅琳娜有这本事她怎么不早用呢。有人说是桂奥尔龙墓的那条大白龙带我们到天空城的，但这都只是解包推测的，本身剧情就是有断层，即使后续有更新但游戏都发售了总得先有个自圆其说的解释吧，拿个什么商人情报或者犄角旮旯里的碎片先当谜语人也行啊，但什么都没有，即使洗白有法环体量大的理由，但事实在这里，在这一段就是有剧情上的漏洞。<br>还有一个是关于火山巨人的，他不是被黄金家族干倒了吗，都被玛莉卡控制了怎么二阶段还可以通过献祭获得邪神力量啊？要是能和邪神沟通有自我意识为什么要阻止我烧树，不应该高高兴兴把黄金树给点了吗，又何必打上这一架。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode01 K Sum</title>
      <link href="/2022/04/13/LeetCode01/"/>
      <url>/2022/04/13/LeetCode01/</url>
      
        <content type="html"><![CDATA[<p>终于开始正式刷题了。这也是第一篇学习笔记，我计划用两个月的时间从头开始学习算法和leetcode，争取在秋招前刷完200题</p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>起步就是最简单的第一题，<br>英文名：1. Two Sum</p><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>没有学过算法的我第一反应就是暴力解法，直接遍历算一圈就可以完事，但通常会超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == nums[i] + nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;nums[i], nums[j]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我也是第一次接触时间复杂度和空间复杂度这两个概念</p><h6 id="具体学习链接-算法的时间与空间复杂度（一看就懂）"><a href="#具体学习链接-算法的时间与空间复杂度（一看就懂）" class="headerlink" title="具体学习链接:算法的时间与空间复杂度（一看就懂）"></a>具体学习链接:<a href="https://zhuanlan.zhihu.com/p/50479555">算法的时间与空间复杂度（一看就懂）</a></h6><h5 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h5><p>时间复杂度：执行算法花了多长时间<br>空间复杂度：执行算法花了多少内存</p><h4 id="常见的时间复杂度量级有："><a href="#常见的时间复杂度量级有：" class="headerlink" title="常见的时间复杂度量级有："></a>常见的时间复杂度量级有：</h4><h5 id="1-常数阶O-1"><a href="#1-常数阶O-1" class="headerlink" title="1. 常数阶O(1)"></a>1. 常数阶O(1)</h5><p>重点：没有循环等复杂结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><h5 id="2-对数阶O-logN"><a href="#2-对数阶O-logN" class="headerlink" title="2. 对数阶O(logN)"></a>2. 对数阶O(logN)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后i就大于n，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log<sub>2</sub>(n)<br>这里把数字设成2，当n无限大的时候，数字是多少都无所谓，所以统称为logN</p><h5 id="3-线性阶O-n"><a href="#3-线性阶O-n" class="headerlink" title="3. 线性阶O(n)"></a>3. 线性阶O(n)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的。<br>简而言之，n跟结果有关系就不是常数阶，一个循环对应一个线性阶</p><h5 id="4-线性对数阶O-nlogN"><a href="#4-线性对数阶O-nlogN" class="headerlink" title="4. 线性对数阶O(nlogN)"></a>4. 线性对数阶O(nlogN)</h5><p>线性对数阶O(nlogN) 就是把时间复杂度为O(logN)的代码外面套一个循环，循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-平方阶O-n-2"><a href="#5-平方阶O-n-2" class="headerlink" title="5. 平方阶O($n^2$)"></a>5. 平方阶O($n^2$)</h5><p>总结：两个循环或者说两个线性阶套娃 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-立方阶O-n-3"><a href="#6-立方阶O-n-3" class="headerlink" title="6. 立方阶O($n^3$)"></a>6. 立方阶O($n^3$)</h5><p>总结：三个循环或者说三个线性阶套娃 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(y=<span class="number">1</span>;y&lt;=n;y++&gt;)&#123;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="7-K次方阶O-n-k"><a href="#7-K次方阶O-n-k" class="headerlink" title="7. K次方阶O($n^k$)"></a>7. K次方阶O($n^k$)</h5><p>总结：K个循环或者说K个线性阶套娃 </p><h5 id="8-指数阶-2-n"><a href="#8-指数阶-2-n" class="headerlink" title="8. 指数阶(2^n)"></a>8. 指数阶(2^n)</h5><p>回忆一下指数的图像，随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aFunc( n ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aFunc(n - <span class="number">1</span>) + aFunc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常见的空间复杂度量级有：O-1-、O-n-、O-n²"><a href="#常见的空间复杂度量级有：O-1-、O-n-、O-n²" class="headerlink" title="常见的空间复杂度量级有：O(1)、O(n)、O(n²)"></a>常见的空间复杂度量级有：O(1)、O(n)、O(n²)</h4><h5 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h5><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h5 id="2-O-n"><a href="#2-O-n" class="headerlink" title="2. O($n$)"></a>2. O($n$)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><h5 id="3-O-n-2"><a href="#3-O-n-2" class="headerlink" title="3. O($n^2$)"></a>3. O($n^2$)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h6 id="具体学习链接-夜深人静写算法（四十四）-n-数之和"><a href="#具体学习链接-夜深人静写算法（四十四）-n-数之和" class="headerlink" title="具体学习链接:夜深人静写算法（四十四）- n 数之和"></a>具体学习链接:<a href="https://mp.weixin.qq.com/s/CE7Bz3SN2JJxLZXMw8p6Yg">夜深人静写算法（四十四）- n 数之和</a></h6><h6 id="fucking-algorithm-算法思维系列-二分查找详解-md"><a href="#fucking-algorithm-算法思维系列-二分查找详解-md" class="headerlink" title="fucking-algorithm/算法思维系列/二分查找详解.md"></a><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">fucking-algorithm/算法思维系列/二分查找详解.md</a></h6><h5 id="二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数"><a href="#二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数" class="headerlink" title="二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数"></a>二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数</h5><h4 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲回这道题</p><h5 id="1-对数组排序；"><a href="#1-对数组排序；" class="headerlink" title="1.对数组排序；"></a>1.对数组排序；</h5><h5 id="2-从前往后枚举第一个数-nums-i-；"><a href="#2-从前往后枚举第一个数-nums-i-；" class="headerlink" title="2.从前往后枚举第一个数 nums[i]；"></a>2.从前往后枚举第一个数 nums[i]；</h5><h5 id="3-由于数组是有序的，所以可以从剩下的数中，二分查找target-nums-i-，一旦找到，则返回二元组-nums-i-target-nums-i-；"><a href="#3-由于数组是有序的，所以可以从剩下的数中，二分查找target-nums-i-，一旦找到，则返回二元组-nums-i-target-nums-i-；" class="headerlink" title="3.由于数组是有序的，所以可以从剩下的数中，二分查找target - nums[i]，一旦找到，则返回二元组 { nums[i], target - nums[i] }；"></a>3.由于数组是有序的，所以可以从剩下的数中，二分查找<code>target - nums[i]</code>，一旦找到，则返回二元组 <code>&#123; nums[i], target - nums[i] &#125;；</code></h5><h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><h6 id="具体学习链接-夜深人静写算法（四十四）-n-数之和-1"><a href="#具体学习链接-夜深人静写算法（四十四）-n-数之和-1" class="headerlink" title="具体学习链接:夜深人静写算法（四十四）- n 数之和"></a>具体学习链接:<a href="https://mp.weixin.qq.com/s/CE7Bz3SN2JJxLZXMw8p6Yg">夜深人静写算法（四十四）- n 数之和</a></h6><h6 id="fucking-algorithm-算法思维系列-二分查找详解-md-1"><a href="#fucking-algorithm-算法思维系列-二分查找详解-md-1" class="headerlink" title="fucking-algorithm/算法思维系列/二分查找详解.md"></a><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">fucking-algorithm/算法思维系列/二分查找详解.md</a></h6><h6 id="具体学习链接-小白-Python-几种解法"><a href="#具体学习链接-小白-Python-几种解法" class="headerlink" title="具体学习链接:小白 Python 几种解法"></a>具体学习链接:<a href="https://leetcode-cn.com/problems/two-sum/solution/xiao-bai-pythonji-chong-jie-fa-by-lao-la-rou-yue-j/">小白 Python 几种解法</a></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i!=j:</span><br><span class="line">                <span class="keyword">return</span> [i,j]</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 46 ms, faster than 90.61% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 14.3 MB, less than 45.68% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure><p>改进版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [i,hashmap.get(target - num)]</span><br><span class="line">            hashmap[num] = i <span class="comment">#这句不能放在if语句之前，解决list中有重复值或target-num=num的情况</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 41 ms, faster than 95.66% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 14.4 MB, less than 45.68% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>解算出来的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       seen = &#123;&#125;</span><br><span class="line">       <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">           remaining = target - nums[i]</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> remaining <span class="keyword">in</span> seen:</span><br><span class="line">               <span class="keyword">return</span> [i, seen[remaining]]</span><br><span class="line">            </span><br><span class="line">           seen[value] = i </span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 68 ms, faster than 84.35% of Python3 online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 15.3 MB, less than 25.99% of Python3 online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plan</title>
      <link href="/2021/10/05/plan/"/>
      <url>/2021/10/05/plan/</url>
      
        <content type="html"><![CDATA[<h1 id="Steins-Gate"><a href="#Steins-Gate" class="headerlink" title="Steins;Gate"></a>Steins;Gate</h1>]]></content>
      
      
      
        <tags>
            
            <tag> schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2021/09/24/first-blog/"/>
      <url>/2021/09/24/first-blog/</url>
      
        <content type="html"><![CDATA[<p>这里是记录研究生生活和学习的第一篇文章，也是一切的开始。<br>生活篇分为日记，回忆，生活技巧。</p><h2 id="日记1"><a href="#日记1" class="headerlink" title="日记1"></a>日记1</h2><h3 id="2021-9-24"><a href="#2021-9-24" class="headerlink" title="2021.9.24"></a>2021.9.24</h3><p>已经是上课的第三周了，逐渐习惯了这样的学习节奏和自己做饭的生活。今天烧了一份红烧蹄膀。在华超买的蹄膀，让人出乎意料的事蹄膀居然是最便宜的肉类，真是暴殄天物啊。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to start the first blog</title>
      <link href="/2021/09/24/%E5%A6%82%E4%BD%95%E5%86%99blog/"/>
      <url>/2021/09/24/%E5%A6%82%E4%BD%95%E5%86%99blog/</url>
      
        <content type="html"><![CDATA[<h1 id="创建新blog"><a href="#创建新blog" class="headerlink" title="创建新blog"></a>创建新blog</h1><h2 id="个人博客学习总结"><a href="#个人博客学习总结" class="headerlink" title="个人博客学习总结"></a><a href="https://www.zhihu.com/column/c_1201860091307458560">个人博客学习总结</a></h2><p>基本可以按照这个流程走</p><p><a href="http://localhost:4000/">http://localhost:4000/</a></p><h2 id="hexo-美化"><a href="#hexo-美化" class="headerlink" title="hexo 美化"></a>hexo 美化</h2><p><a href="https://blog.csdn.net/wizardforcel/article/details/40684953?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-40684953-blog-97758641.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3">Hexo 入门指南（四） - 页面、导航、边栏、底栏</a></p><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p><a href="https://picx.xpoet.cn/#/management">https://picx.xpoet.cn/#/management</a></p><p><a href="https://tholman.com/github-corners/">github corners</a></p><p><a href="http://www.fontawesome.com.cn/faicons/#web-application">图标</a></p><p><a href="https://hexo.io/zh-cn/docs/writing">https://hexo.io/zh-cn/docs/writing</a></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a><a href="https://zhuanlan.zhihu.com/p/26625249">流程</a></h2>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/07/hello-world/"/>
      <url>/2021/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
