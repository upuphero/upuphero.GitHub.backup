<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>21. Merge Two Sorted Lists(easy)</title>
      <link href="/2022/07/04/21/"/>
      <url>/2022/07/04/21/</url>
      
        <content type="html"><![CDATA[<ol start="21"><li>Merge Two Sorted Lists(easy)</li></ol><p>You are given the heads of two sorted linked lists list1 and list2.</p><p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p><p>Return the head of the merged linked list.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">or</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1 <span class="keyword">if</span> <span class="keyword">not</span> list2 <span class="keyword">else</span> list2</span><br><span class="line">        seek, target = (list1, list2) <span class="keyword">if</span> list1.val &lt; list2.val <span class="keyword">else</span> (list2, list1)</span><br><span class="line">        head = seek</span><br><span class="line">        <span class="keyword">while</span> seek <span class="keyword">and</span> target:</span><br><span class="line">            <span class="keyword">while</span> seek.<span class="built_in">next</span> <span class="keyword">and</span> seek.<span class="built_in">next</span>.val &lt; target.val:</span><br><span class="line">                seek = seek.<span class="built_in">next</span></span><br><span class="line">            seek.<span class="built_in">next</span>, target = target, seek.<span class="built_in">next</span></span><br><span class="line">            seek = seek.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer(easy)</title>
      <link href="/2022/07/01/13/"/>
      <url>/2022/07/01/13/</url>
      
        <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-easy"><a href="#13-Roman-to-Integer-easy" class="headerlink" title="13. Roman to Integer(easy)"></a>13. Roman to Integer(easy)</h1><h2 id="Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M"><a href="#Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M" class="headerlink" title="Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M."></a>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</h2><h2 id="For-example-2-is-written-as-II-in-Roman-numeral-just-two-ones-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II"><a href="#For-example-2-is-written-as-II-in-Roman-numeral-just-two-ones-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II" class="headerlink" title="For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II."></a>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</h2><h2 id="Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used"><a href="#Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used" class="headerlink" title="Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:"></a>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</h2><h2 id="I-can-be-placed-before-V-5-and-X-10-to-make-4-and-9"><a href="#I-can-be-placed-before-V-5-and-X-10-to-make-4-and-9" class="headerlink" title="I can be placed before V (5) and X (10) to make 4 and 9."></a>I can be placed before V (5) and X (10) to make 4 and 9.</h2><h2 id="X-can-be-placed-before-L-50-and-C-100-to-make-40-and-90"><a href="#X-can-be-placed-before-L-50-and-C-100-to-make-40-and-90" class="headerlink" title="X can be placed before L (50) and C (100) to make 40 and 90."></a>X can be placed before L (50) and C (100) to make 40 and 90.</h2><h2 id="C-can-be-placed-before-D-500-and-M-1000-to-make-400-and-900"><a href="#C-can-be-placed-before-D-500-and-M-1000-to-make-400-and-900" class="headerlink" title="C can be placed before D (500) and M (1000) to make 400 and 900."></a>C can be placed before D (500) and M (1000) to make 400 and 900.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/">官方题解</a></p><p>这题的特点<br>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p><p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</p><p>例如 XIV 可视作 X−I+V=10−1+5=14。</p><h3 id="但是评论里有超神思路："><a href="#但是评论里有超神思路：" class="headerlink" title="但是评论里有超神思路："></a>但是评论里有超神思路：</h3><p><a href="https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/1060752">从右到左遍历，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减，更好理解吧</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        highestLevel = <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s[::-<span class="number">1</span>]:</span><br><span class="line">            level = mapping[ch]</span><br><span class="line">            <span class="keyword">if</span> level &gt;= highestLevel:</span><br><span class="line">                result += level</span><br><span class="line">                highestLevel = level</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result -= level</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. Palindrome Number(easy)</title>
      <link href="/2022/07/01/9/"/>
      <url>/2022/07/01/9/</url>
      
        <content type="html"><![CDATA[<h1 id="9-Palindrome-Number-easy"><a href="#9-Palindrome-Number-easy" class="headerlink" title="9. Palindrome Number(easy)"></a>9. Palindrome Number(easy)</h1><h2 id="Given-an-integer-x-return-true-if-x-is-palindrome-integer"><a href="#Given-an-integer-x-return-true-if-x-is-palindrome-integer" class="headerlink" title="Given an integer x, return true if x is palindrome integer."></a>Given an integer x, return true if x is palindrome integer.</h2><h2 id="An-integer-is-a-palindrome-when-it-reads-the-same-backward-as-forward"><a href="#An-integer-is-a-palindrome-when-it-reads-the-same-backward-as-forward" class="headerlink" title="An integer is a palindrome when it reads the same backward as forward."></a>An integer is a palindrome when it reads the same backward as forward.</h2><h2 id="For-example-121-is-a-palindrome-while-123-is-not"><a href="#For-example-121-is-a-palindrome-while-123-is-not" class="headerlink" title="For example, 121 is a palindrome while 123 is not."></a>For example, 121 is a palindrome while 123 is not.</h2><p>找到回文数</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/">官方题解</a></h2><p>反转一半数字<br>思路</p><p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。</p><p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p><p>根据官方题解改的python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        revertedNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; revertedNumber:</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber <span class="keyword">or</span> x == revertedNumber // <span class="number">10</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> Palindrome Number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum(medium)</title>
      <link href="/2022/07/01/15/"/>
      <url>/2022/07/01/15/</url>
      
        <content type="html"><![CDATA[<h1 id="15-3Sum-medium"><a href="#15-3Sum-medium" class="headerlink" title="15. 3Sum(medium)"></a>15. 3Sum(medium)</h1><h2 id="Given-an-integer-array-nums-return-all-the-triplets-nums-i-nums-j-nums-k-such-that-i-j-i-k-and-j-k-and-nums-i-nums-j-nums-k-0"><a href="#Given-an-integer-array-nums-return-all-the-triplets-nums-i-nums-j-nums-k-such-that-i-j-i-k-and-j-k-and-nums-i-nums-j-nums-k-0" class="headerlink" title="Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0."></a>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</h2><h2 id="Notice-that-the-solution-set-must-not-contain-duplicate-triplets"><a href="#Notice-that-the-solution-set-must-not-contain-duplicate-triplets" class="headerlink" title="Notice that the solution set must not contain duplicate triplets."></a>Notice that the solution set must not contain duplicate triplets.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>): <span class="comment"># renamed this to left because this will always be the leftmost pointer in the triplet</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]: <span class="comment"># this step makes sure that we do not have any duplicates in our result output</span></span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">        mid = left + <span class="number">1</span> <span class="comment"># renamed this to mid because this is the pointer that is between the left and right pointers</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> mid &lt; right:</span><br><span class="line">            curr_sum = nums[left] + nums[mid] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> curr_sum &lt; <span class="number">0</span>:</span><br><span class="line">                mid += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">elif</span> curr_sum &gt; <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append([nums[left], nums[mid], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> mid &lt; right <span class="keyword">and</span> nums[mid] == nums[mid + <span class="number">1</span>]: <span class="comment"># Another conditional for not calculating duplicates</span></span><br><span class="line">                    mid += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> mid &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]: <span class="comment"># Avoiding duplicates check</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                mid += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water(medium)</title>
      <link href="/2022/07/01/11/"/>
      <url>/2022/07/01/11/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water-medium"><a href="#11-Container-With-Most-Water-medium" class="headerlink" title="11. Container With Most Water(medium)"></a>11. Container With Most Water(medium)</h1><h2 id="You-are-given-an-integer-array-height-of-length-n-There-are-n-vertical-lines-drawn-such-that-the-two-endpoints-of-the-ith-line-are-i-0-and-i-height-i"><a href="#You-are-given-an-integer-array-height-of-length-n-There-are-n-vertical-lines-drawn-such-that-the-two-endpoints-of-the-ith-line-are-i-0-and-i-height-i" class="headerlink" title="You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i])."></a>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</h2><h2 id="Find-two-lines-that-together-with-the-x-axis-form-a-container-such-that-the-container-contains-the-most-water"><a href="#Find-two-lines-that-together-with-the-x-axis-form-a-container-such-that-the-container-contains-the-most-water" class="headerlink" title="Find two lines that together with the x-axis form a container, such that the container contains the most water."></a>Find two lines that together with the x-axis form a container, such that the container contains the most water.</h2><h2 id="Return-the-maximum-amount-of-water-a-container-can-store"><a href="#Return-the-maximum-amount-of-water-a-container-can-store" class="headerlink" title="Return the maximum amount of water a container can store."></a>Return the maximum amount of water a container can store.</h2><h2 id="Notice-that-you-may-not-slant-the-container"><a href="#Notice-that-you-may-not-slant-the-container" class="headerlink" title="Notice that you may not slant the container."></a>Notice that you may not slant the container.</h2><p>看了题解，双指针，从两头开始内卷，先卷矮的那头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            area = <span class="built_in">min</span>(height[l],height[r])*(r-l)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,area)</span><br><span class="line">            l=</span><br><span class="line">            <span class="keyword">if</span> height[l]&lt;height[r]:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height</span>):</span></span><br><span class="line">        L, R, width, res = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(width, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment">#range(start, stop, step)</span></span><br><span class="line">            <span class="keyword">if</span> height[L] &lt; height[R]:</span><br><span class="line">                res, L = <span class="built_in">max</span>(res, height[L] * w), L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res, R = <span class="built_in">max</span>(res, height[R] * w), R - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters(medium)</title>
      <link href="/2022/07/01/3/"/>
      <url>/2022/07/01/3/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters-medium"><a href="#3-Longest-Substring-Without-Repeating-Characters-medium" class="headerlink" title="3. Longest Substring Without Repeating Characters(medium)"></a>3. Longest Substring Without Repeating Characters(medium)</h1><h2 id="Given-a-string-s-find-the-length-of-the-longest-substring-without-repeating-characters"><a href="#Given-a-string-s-find-the-length-of-the-longest-substring-without-repeating-characters" class="headerlink" title="Given a string s, find the length of the longest substring without repeating characters."></a>Given a string s, find the length of the longest substring without repeating characters.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>这道题第一反应是双指针，通过滑动窗口来解决，但有个需要解决的问题是如果判断substring的字母有重复的。</p><p>利用hashmap查找重复字母<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/376956">leetcode评论</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        k, res, c_dict = -<span class="number">1</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> c_dict <span class="keyword">and</span> c_dict[c] &gt; k:  <span class="comment"># 字符c在字典中 且 上次出现的下标大于当前长度的起始下标</span></span><br><span class="line">                k = c_dict[c]</span><br><span class="line">                c_dict[c] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c_dict[c] = i</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用队列查找字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        lst = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> lst:</span><br><span class="line">                <span class="keyword">del</span> lst[<span class="number">0</span>]  <span class="comment"># 队首元素出队</span></span><br><span class="line">            lst.append(s[i]) <span class="comment"># 排除重复元素后 新元素入队</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(lst))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode09-hashmap</title>
      <link href="/2022/06/28/LeetCode09-hashmap/"/>
      <url>/2022/06/28/LeetCode09-hashmap/</url>
      
        <content type="html"><![CDATA[<p>专门列出的一期：hashmap</p><p>官方是有专门的hashmap的<a href="https://leetcode.com/tag/hash-table/">tag</a></p><h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md">Leetcode 题解 - 目录.md</a></h6>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode08-动态规划</title>
      <link href="/2022/06/28/LeetCode08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/06/28/LeetCode08-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-动态规划"><a href="#Leetcode-题解-动态规划" class="headerlink" title="Leetcode 题解 - 动态规划"></a>Leetcode 题解 - 动态规划</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>914. X of a Kind in a Deck of Cards</title>
      <link href="/2022/06/27/914/"/>
      <url>/2022/06/27/914/</url>
      
        <content type="html"><![CDATA[<h1 id="914-X-of-a-Kind-in-a-Deck-of-Cards"><a href="#914-X-of-a-Kind-in-a-Deck-of-Cards" class="headerlink" title="914. X of a Kind in a Deck of Cards"></a>914. X of a Kind in a Deck of Cards</h1><h2 id="In-a-deck-of-cards-each-card-has-an-integer-written-on-it"><a href="#In-a-deck-of-cards-each-card-has-an-integer-written-on-it" class="headerlink" title="In a deck of cards, each card has an integer written on it."></a>In a deck of cards, each card has an integer written on it.</h2><h2 id="Return-true-if-and-only-if-you-can-choose-X-gt-2-such-that-it-is-possible-to-split-the-entire-deck-into-1-or-more-groups-of-cards-where"><a href="#Return-true-if-and-only-if-you-can-choose-X-gt-2-such-that-it-is-possible-to-split-the-entire-deck-into-1-or-more-groups-of-cards-where" class="headerlink" title="Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:"></a>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:</h2><h2 id="Each-group-has-exactly-X-cards"><a href="#Each-group-has-exactly-X-cards" class="headerlink" title="Each group has exactly X cards."></a>Each group has exactly X cards.</h2><h2 id="All-the-cards-in-each-group-have-the-same-integer"><a href="#All-the-cards-in-each-group-have-the-same-integer" class="headerlink" title="All the cards in each group have the same integer."></a>All the cards in each group have the same integer.</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Greatest common divisor  </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. Count Primes (Easy)</title>
      <link href="/2022/06/27/204/"/>
      <url>/2022/06/27/204/</url>
      
        <content type="html"><![CDATA[<h1 id="204-Count-Primes-Easy"><a href="#204-Count-Primes-Easy" class="headerlink" title="204. Count Primes (Easy)"></a>204. Count Primes (Easy)</h1><h2 id="Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n"><a href="#Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n" class="headerlink" title="Given an integer n, return the number of prime numbers that are strictly less than n."></a>Given an integer n, return the number of prime numbers that are strictly less than n.</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/">官方题解</a></h2><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><h3 id="方法二：埃氏筛"><a href="#方法二：埃氏筛" class="headerlink" title="方法二：埃氏筛"></a>方法二：埃氏筛</h3><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 yy 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 xx 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><h4 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.com/problems/count-primes/discuss/153528/Python3-99-112-ms-Explained%3A-The-Sieve-of-Eratosthenes-with-optimizations">leetcode题解</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Sieve of Eratosthenes埃氏筛</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We are only interested in numbers LESS than the input number</span></span><br><span class="line">        <span class="comment"># exit early for numbers LESS than 2; (two is prime)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create strike list for the input range, initializing all indices to</span></span><br><span class="line">        <span class="comment"># prime (1).</span></span><br><span class="line">        strikes = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we know that 0 and 2 are not prime</span></span><br><span class="line">        strikes[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        strikes[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Now set multiples of remaining numbers that are marked as prime to</span></span><br><span class="line">        <span class="comment"># not prime.  It is safe ignore numbers alreay marked as not prime</span></span><br><span class="line">        <span class="comment"># because there are factor(s) that divide evenly into this number and</span></span><br><span class="line">        <span class="comment"># all its multiples.  Use upper limit of (n**0.5)+1, because:</span></span><br><span class="line">        <span class="comment">#  (a) the smallest factor of a non-prime number will not be &gt; sqrt(n).</span></span><br><span class="line">        <span class="comment">#      Ex. non-prime = 100, </span></span><br><span class="line">        <span class="comment">#           5*20</span></span><br><span class="line">        <span class="comment">#           10*10, </span></span><br><span class="line">        <span class="comment">#           20*5   # !! we have seen 5 before.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>  strikes[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># slow:</span></span><br><span class="line">                <span class="comment">#for j in range(i*i, n, i):</span></span><br><span class="line">                <span class="comment">#    strikes[j] = 0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 3x faster:</span></span><br><span class="line">                <span class="comment"># strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)</span></span><br><span class="line">                <span class="comment"># n = 11</span></span><br><span class="line">                <span class="comment"># i = 2</span></span><br><span class="line">                <span class="comment"># (n-1-i*i)//i + 1</span></span><br><span class="line">                <span class="comment"># (n-1)               # get total # of indicies for n (non-inclusive)</span></span><br><span class="line">                <span class="comment">#     -i*i            # shift to get # of slots in range of interest</span></span><br><span class="line">                <span class="comment">#          //i        # get number of groups</span></span><br><span class="line">                <span class="comment">#              + 1    # get number of slots</span></span><br><span class="line">                <span class="comment"># strikes[2*2:11:2]  = [0] * ((11-1-2*2)//2 + 1</span></span><br><span class="line">                <span class="comment"># strikes[4:11:2]    = [0] * 4</span></span><br><span class="line">                <span class="comment"># s[4], s[6], s[8], s10] = 0, 0, 0, 0</span></span><br><span class="line">                strikes[i*i:n:i] = [<span class="number">0</span>] * ((n-<span class="number">1</span>-i*i)//i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(strikes)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]=primes[<span class="number">1</span>]=<span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]= primes[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> prime number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode07-数学</title>
      <link href="/2022/06/26/LeetCode07-%E6%95%B0%E5%AD%A6/"/>
      <url>/2022/06/26/LeetCode07-%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-数学"><a href="#Leetcode-题解-数学" class="headerlink" title="Leetcode 题解 - 数学"></a>Leetcode 题解 - 数学</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p><h3 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h3><h3 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h3><h3 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h3><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h3><h3 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h3><h3 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h3><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h3><h2 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h2><h3 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h3><h3 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h3><h2 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h2><h3 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h3><h2 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h2><h3 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h3><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h3><h3 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h3><h3 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h3><h3 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h3>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode06-搜索</title>
      <link href="/2022/06/23/LeetCode06-%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/06/23/LeetCode06-%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-搜索"><a href="#Leetcode-题解-搜索" class="headerlink" title="Leetcode 题解 - 搜索"></a>Leetcode 题解 - 搜索</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="1-计算在网格中从原点到特定点的最短路径长度"><a href="#1-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="1. 计算在网格中从原点到特定点的最短路径长度"></a>1. 计算在网格中从原点到特定点的最短路径长度</h3><h3 id="2-组成整数的最小平方数数量"><a href="#2-组成整数的最小平方数数量" class="headerlink" title="2. 组成整数的最小平方数数量"></a>2. 组成整数的最小平方数数量</h3><h3 id="3-最短单词路径"><a href="#3-最短单词路径" class="headerlink" title="3. 最短单词路径"></a>3. 最短单词路径</h3><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="1-查找最大的连通面积"><a href="#1-查找最大的连通面积" class="headerlink" title="1. 查找最大的连通面积"></a>1. 查找最大的连通面积</h3><h3 id="2-矩阵中的连通分量数目"><a href="#2-矩阵中的连通分量数目" class="headerlink" title="2. 矩阵中的连通分量数目"></a>2. 矩阵中的连通分量数目</h3><h3 id="3-好友关系的连通分量数目"><a href="#3-好友关系的连通分量数目" class="headerlink" title="3. 好友关系的连通分量数目"></a>3. 好友关系的连通分量数目</h3><h3 id="4-填充封闭区域"><a href="#4-填充封闭区域" class="headerlink" title="4. 填充封闭区域"></a>4. 填充封闭区域</h3><h3 id="5-能到达的太平洋和大西洋的区域"><a href="#5-能到达的太平洋和大西洋的区域" class="headerlink" title="5. 能到达的太平洋和大西洋的区域"></a>5. 能到达的太平洋和大西洋的区域</h3><h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h3 id="1-数字键盘组合"><a href="#1-数字键盘组合" class="headerlink" title="1. 数字键盘组合"></a>1. 数字键盘组合</h3><h3 id="2-IP-地址划分"><a href="#2-IP-地址划分" class="headerlink" title="2. IP 地址划分"></a>2. IP 地址划分</h3><h3 id="3-在矩阵中寻找字符串"><a href="#3-在矩阵中寻找字符串" class="headerlink" title="3. 在矩阵中寻找字符串"></a>3. 在矩阵中寻找字符串</h3><h3 id="4-输出二叉树中所有从根到叶子的路径"><a href="#4-输出二叉树中所有从根到叶子的路径" class="headerlink" title="4. 输出二叉树中所有从根到叶子的路径"></a>4. 输出二叉树中所有从根到叶子的路径</h3><h3 id="5-排列"><a href="#5-排列" class="headerlink" title="5. 排列"></a>5. 排列</h3><h3 id="6-含有相同元素求排列"><a href="#6-含有相同元素求排列" class="headerlink" title="6. 含有相同元素求排列"></a>6. 含有相同元素求排列</h3><h3 id="7-组合"><a href="#7-组合" class="headerlink" title="7. 组合"></a>7. 组合</h3><h3 id="8-组合求和"><a href="#8-组合求和" class="headerlink" title="8. 组合求和"></a>8. 组合求和</h3><h3 id="9-含有相同元素的组合求和"><a href="#9-含有相同元素的组合求和" class="headerlink" title="9. 含有相同元素的组合求和"></a>9. 含有相同元素的组合求和</h3><h3 id="10-1-9-数字的组合求和"><a href="#10-1-9-数字的组合求和" class="headerlink" title="10. 1-9 数字的组合求和"></a>10. 1-9 数字的组合求和</h3><h3 id="11-子集"><a href="#11-子集" class="headerlink" title="11. 子集"></a>11. 子集</h3><h3 id="12-含有相同元素求子集"><a href="#12-含有相同元素求子集" class="headerlink" title="12. 含有相同元素求子集"></a>12. 含有相同元素求子集</h3><h3 id="13-分割字符串使得每个部分都是回文数"><a href="#13-分割字符串使得每个部分都是回文数" class="headerlink" title="13. 分割字符串使得每个部分都是回文数"></a>13. 分割字符串使得每个部分都是回文数</h3><h3 id="14-数独"><a href="#14-数独" class="headerlink" title="14. 数独"></a>14. 数独</h3><h3 id="15-N-皇后"><a href="#15-N-皇后" class="headerlink" title="15. N 皇后"></a>15. N 皇后</h3><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>bfs是按一层一层来访问的，所以适合有目标求最短路的步数，你想想层层搜索每次层就代表了一步。bfs优先访问的是兄弟节点，只有这一层全部访问完才能访问下一层，也就是说bfs第几层就代表当前可以走到的位置(结点).而dfs是按递归来实现的，它优先搜索深度，再回溯，优先访问的是没有访问过的子节点<br>DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。<br>总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易”控制”)，BFS通过控制队列可以很好解决”爆队列”风险。<br>它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>95. Unique Binary Search Trees II (Medium)</title>
      <link href="/2022/06/21/95/"/>
      <url>/2022/06/21/95/</url>
      
        <content type="html"><![CDATA[<h1 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a>95. Unique Binary Search Trees II (Medium)</h1><h2 id="Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order"><a href="#Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order" class="headerlink" title="Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order."></a>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><h2 id="官方leetcode-题解"><a href="#官方leetcode-题解" class="headerlink" title="官方leetcode 题解"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">官方leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>,]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):  <span class="comment"># 枚举可行根节点</span></span><br><span class="line">                <span class="comment"># 获得所有可行的左子树集合</span></span><br><span class="line">                leftTrees = generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获得所有可行的右子树集合</span></span><br><span class="line">                rightTrees = generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        currTree = TreeNode(i)</span><br><span class="line">                        currTree.left = l</span><br><span class="line">                        currTree.right = r</span><br><span class="line">                        allTrees.append(currTree)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>241. Different Ways to Add Parentheses (Medium)</title>
      <link href="/2022/06/21/241/"/>
      <url>/2022/06/21/241/</url>
      
        <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses-Medium"><a href="#241-Different-Ways-to-Add-Parentheses-Medium" class="headerlink" title="241. Different Ways to Add Parentheses (Medium)"></a>241. Different Ways to Add Parentheses (Medium)</h1><h2 id="Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order"><a href="#Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order" class="headerlink" title="Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order."></a>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</h2><h2 id="The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4"><a href="#The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4" class="headerlink" title="The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4."></a>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;2-1-1&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">Explanation:</span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure><h2 id="分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"><a href="#分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。" class="headerlink" title="分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"></a>分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</h2><h2 id="分治法解题的一般步骤（如图1）："><a href="#分治法解题的一般步骤（如图1）：" class="headerlink" title="分治法解题的一般步骤（如图1）："></a>分治法解题的一般步骤（如图1）：</h2><h3 id="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"><a href="#（1）分解，将要解决的问题划分成若干规模较小的同类问题；" class="headerlink" title="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"></a>（1）分解，将要解决的问题划分成若干规模较小的同类问题；</h3><h3 id="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"><a href="#（2）求解，当子问题划分得足够小时，用较简单的方法解决；" class="headerlink" title="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"></a>（2）求解，当子问题划分得足够小时，用较简单的方法解决；</h3><h3 id="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"><a href="#（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。" class="headerlink" title="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"></a>（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</h3><h2 id="leetcode-题解"><a href="#leetcode-题解" class="headerlink" title="leetcode 题解"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/">leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2022/06/20/34/"/>
      <url>/2022/06/20/34/</url>
      
        <content type="html"><![CDATA[<h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a>34. Find First and Last Position of Element in Sorted Array (Medium)</h1><h2 id="Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value"><a href="#Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value" class="headerlink" title="Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value."></a>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</h2><h2 id="If-target-is-not-found-in-the-array-return-1-1"><a href="#If-target-is-not-found-in-the-array-return-1-1" class="headerlink" title="If target is not found in the array, return [-1, -1]."></a>If target is not found in the array, return [-1, -1].</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/837944">Solution</a>:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        start = binarysearchleft(nums, target)</span><br><span class="line">        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start, end]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array (Medium)</title>
      <link href="/2022/06/20/153/"/>
      <url>/2022/06/20/153/</url>
      
        <content type="html"><![CDATA[<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a>153. Find Minimum in Rotated Sorted Array (Medium)</h1><h2 id="Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become"><a href="#Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become" class="headerlink" title="Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:"></a>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</h2><h2 id="4-5-6-7-0-1-2-if-it-was-rotated-4-times"><a href="#4-5-6-7-0-1-2-if-it-was-rotated-4-times" class="headerlink" title="[4,5,6,7,0,1,2] if it was rotated 4 times."></a>[4,5,6,7,0,1,2] if it was rotated 4 times.</h2><h2 id="0-1-2-4-5-6-7-if-it-was-rotated-7-times"><a href="#0-1-2-4-5-6-7-if-it-was-rotated-7-times" class="headerlink" title="[0,1,2,4,5,6,7] if it was rotated 7 times."></a>[0,1,2,4,5,6,7] if it was rotated 7 times.</h2><h2 id="Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2"><a href="#Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2" class="headerlink" title="Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]."></a>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].</h2><h2 id="Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array"><a href="#Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array" class="headerlink" title="Given the sorted rotated array nums of unique elements, return the minimum element of this array."></a>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</h2><h2 id="You-must-write-an-algorithm-that-runs-in-O-log-n-time"><a href="#You-must-write-an-algorithm-that-runs-in-O-log-n-time" class="headerlink" title="You must write an algorithm that runs in O(log n) time."></a>You must write an algorithm that runs in O(log n) time.</h2><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[last] :                </span><br><span class="line">                last = mid         </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[first]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278. First Bad Version (Easy)</title>
      <link href="/2022/06/20/278/"/>
      <url>/2022/06/20/278/</url>
      
        <content type="html"><![CDATA[<h1 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a>278. First Bad Version (Easy)</h1><h2 id="You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad"><a href="#You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad" class="headerlink" title="You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad."></a>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</h2><h2 id="Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad"><a href="#Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad" class="headerlink" title="Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad."></a>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</h2><h2 id="You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API"><a href="#You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API" class="headerlink" title="You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."></a>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/">官方题解</a></h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p><p>具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><p>solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):                </span><br><span class="line">                last= mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">               </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>540. Single Element in a Sorted Array (Medium)</title>
      <link href="/2022/06/20/540/"/>
      <url>/2022/06/20/540/</url>
      
        <content type="html"><![CDATA[<h1 id="540-Single-Element-in-a-Sorted-Array-Medium"><a href="#540-Single-Element-in-a-Sorted-Array-Medium" class="headerlink" title="540. Single Element in a Sorted Array (Medium)"></a>540. Single Element in a Sorted Array (Medium)</h1><h2 id="You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once"><a href="#You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once" class="headerlink" title="You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once."></a>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</h2><h2 id="Return-the-single-element-that-appears-only-once"><a href="#Return-the-single-element-that-appears-only-once" class="headerlink" title="Return the single element that appears only once."></a>Return the single element that appears only once.</h2><h2 id="Your-solution-must-run-in-O-log-n-time-and-O-1-space"><a href="#Your-solution-must-run-in-O-log-n-time-and-O-1-space" class="headerlink" title="Your solution must run in O(log n) time and O(1) space."></a>Your solution must run in O(log n) time and O(1) space.</h2><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。<br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-y8gh/">官方题解</a></h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>这道题的特点在于比较的不是数字本身的大小，而是下标的奇偶性。因为只有一个数只出现一次，所以这个数字的下标就只能是偶数。</p><p>由于数组是有序的，因此数组中相同的元素一定相邻。对于下标 x 左边的下标 y，如果 nums[y]=nums[y+1]，则 y 一定是偶数；对于下标 x 右边的下标 z，如果 nums[z]=nums[z+1]，则 z 一定是奇数。由于下标 x 是相同元素的开始下标的奇偶性的分界，因此可以使用二分查找的方法寻找下标 x。</p><p>初始时，二分查找的左边界是 0，右边界是数组的最大下标。每次取左右边界的平均值 mid 作为待判断的下标，根据 mid 的奇偶性决定和左边或右边的相邻元素比较：</p><p>如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；</p><p>如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。</p><p>如果上述比较相邻元素的结果是相等，则 mid&lt;x, 调整左边界。否则 mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 x 的值。</p><p>得到下标 x 的值之后，nums[x] 即为只出现一次的元素。</p><p>⊕ 是按位异或运算符</p><p>当 mid 是偶数时， mid+1=mid⊕1；</p><p>当 mid 是奇数时， mid−1=mid⊕1。</p><h2 id="注：按位异或-按位或-按位与-amp"><a href="#注：按位异或-按位或-按位与-amp" class="headerlink" title="注：按位异或 ^ ,按位或 | ,按位与 &amp;"></a>注：按位异或 ^ ,按位或 | ,按位与 &amp;</h2><p>也就是说判断奇偶性是靠异或运算</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid ^ <span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16. 3Sum Closest(medium)</title>
      <link href="/2022/06/16/16/"/>
      <url>/2022/06/16/16/</url>
      
        <content type="html"><![CDATA[<h1 id="16-3Sum-Closest-medium"><a href="#16-3Sum-Closest-medium" class="headerlink" title="16. 3Sum Closest(medium)"></a>16. 3Sum Closest(medium)</h1><h2 id="Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target"><a href="#Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target" class="headerlink" title="Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target."></a>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</h2><h2 id="Return-the-sum-of-the-three-integers"><a href="#Return-the-sum-of-the-three-integers" class="headerlink" title="Return the sum of the three integers."></a>Return the sum of the three integers.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution" class="headerlink" title="You may assume that each input would have exactly one solution."></a>You may assume that each input would have exactly one solution.</h2><p><a href="https://leetcode.cn/problems/3sum-closest/solution/pythonshuang-zhi-zhen-you-hua-ji-bai-999-by-hardca/">排序 + 双指针</a><br>这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。</p><p>优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()         <span class="comment"># 排序</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):        <span class="comment"># 枚举第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]: <span class="keyword">continue</span>     <span class="comment"># 保证first不会有重复</span></span><br><span class="line"></span><br><span class="line">            second, third = first + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            max_sum = nums[first] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>]</span><br><span class="line">            min_sum = nums[first] + nums[first + <span class="number">1</span>] + nums[first + <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> max_sum &lt;= target:    <span class="comment"># 最大的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(max_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = max_sum</span><br><span class="line">                <span class="keyword">continue</span>              </span><br><span class="line">            <span class="keyword">elif</span> min_sum &gt;= target:  <span class="comment"># 最小的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(min_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = min_sum      </span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                two_sum_target = target - nums[first]</span><br><span class="line">                s = nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s + nums[first] - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = s + nums[first]</span><br><span class="line">                <span class="keyword">if</span> s &gt; two_sum_target:  <span class="comment"># 当前数值太大 右指针左移</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third + <span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; two_sum_target:  <span class="comment"># 当前数值太小 左指针右移</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 刚好等于 直接返回target即可</span></span><br><span class="line">                    <span class="keyword">return</span> target </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>744. Find Smallest Letter Greater Than Target (Easy)</title>
      <link href="/2022/06/16/744/"/>
      <url>/2022/06/16/744/</url>
      
        <content type="html"><![CDATA[<h1 id="744-Find-Smallest-Letter-Greater-Than-Target-Easy"><a href="#744-Find-Smallest-Letter-Greater-Than-Target-Easy" class="headerlink" title="744. Find Smallest Letter Greater Than Target (Easy)"></a>744. Find Smallest Letter Greater Than Target (Easy)</h1><h2 id="Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target"><a href="#Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target" class="headerlink" title="Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target."></a>Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;d&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;k&quot;</span><br><span class="line">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure><p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution/xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7/">官方题解</a></h2><h2 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h2><p>由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。</p><p>如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>((letter <span class="keyword">for</span> letter <span class="keyword">in</span> letters <span class="keyword">if</span> letter &gt; target), letters[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。</p><p>初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> letters[bisect_right(letters, target)] <span class="keyword">if</span> target &lt; letters[-<span class="number">1</span>] <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h3 id="自己写的完全版"><a href="#自己写的完全版" class="headerlink" title="自己写的完全版"></a>自己写的完全版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        first,last=<span class="number">0</span>,<span class="built_in">len</span>(letters)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意如果目标值大于或等于有序列表的最后一项，返回值为首元素</span></span><br><span class="line">        <span class="comment">#letters[-1]是列表最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> target&gt;=letters[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+ (last-first)//<span class="number">2</span> <span class="comment">#1//2=0,向下取整</span></span><br><span class="line">            <span class="keyword">if</span> letters[mid]&lt;=target:</span><br><span class="line">                first=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = mid</span><br><span class="line">        <span class="keyword">return</span> letters[first]                </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x) (Easy)</title>
      <link href="/2022/06/16/69/"/>
      <url>/2022/06/16/69/</url>
      
        <content type="html"><![CDATA[<h1 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h1><h2 id="Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x"><a href="#Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x" class="headerlink" title="Given a non-negative integer x, compute and return the square root of x."></a>Given a non-negative integer x, compute and return the square root of x.</h2><h2 id="Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned"><a href="#Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned" class="headerlink" title="Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned."></a>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</h2><h2 id="Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5"><a href="#Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5" class="headerlink" title="Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5"></a>Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5</h2><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: </span><br><span class="line">            first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(left-right)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="comment">#mid = (left + right) // 2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="方法二：牛顿迭代"><a href="#方法二：牛顿迭代" class="headerlink" title="方法二：牛顿迭代"></a>方法二：牛顿迭代</h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> binary search algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode05- 二分查找</title>
      <link href="/2022/06/16/Leetcode05-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/06/16/Leetcode05-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-二分查找"><a href="#Leetcode-题解-二分查找" class="headerlink" title="Leetcode 题解 - 二分查找"></a>Leetcode 题解 - 二分查找</h1><h2 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h2><h2 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h2><h2 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h2><h2 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h2><h2 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h2><h2 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h2><p>二分查找 binary search algorithm</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="m-计算"><a href="#m-计算" class="headerlink" title="m 计算"></a>m 计算</h2><p>有两种计算中值 m 的方式：</p><p>m = (l + h) / 2<br>m = l + (h - l) / 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p><h2 id="未成功查找的返回值"><a href="#未成功查找的返回值" class="headerlink" title="未成功查找的返回值"></a>未成功查找的返回值</h2><p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p><p>-1：以一个错误码表示没有查找到 key<br>l：将 key 插入到 nums 中的正确位置</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>763. Partition Labels (Medium)</title>
      <link href="/2022/06/13/763/"/>
      <url>/2022/06/13/763/</url>
      
        <content type="html"><![CDATA[<h1 id="763-Partition-Labels-Medium"><a href="#763-Partition-Labels-Medium" class="headerlink" title="763. Partition Labels (Medium)"></a>763. Partition Labels (Medium)</h1><h2 id="You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part"><a href="#You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part" class="headerlink" title="You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part."></a>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</h2><h2 id="Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s"><a href="#Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s" class="headerlink" title="Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s."></a>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</h2><h2 id="Return-a-list-of-integers-representing-the-size-of-these-parts"><a href="#Return-a-list-of-integers-representing-the-size-of-these-parts" class="headerlink" title="Return a list of integers representing the size of these parts."></a>Return a list of integers representing the size of these parts.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-labels/solution/python-jiu-zhe-quan-guo-zui-cai-you-hua-dai-ma-by-/">思路</a>:<br>其实思路很简单，<br>1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。<br>2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或一段的最后位置大。<br>如果没有刚才的last或一段的最后位置大，无视它继续往后找。<br>如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或一段的最后位置更新为当前的字母的最后位置。<br>3，肯定到有一个时间，这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。<br>注意题目要分隔后的长度，我们就用last - startindex + 1。<br>4，找到一个分割位，更新一下起始位置，同理搜索就行了。</p><p>用字典的好处就是不用每次都搜索位置了。直接用字典存所有字符的最后位置就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;<span class="built_in">list</span>[<span class="built_in">int</span>]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end) <span class="comment">#如果最后位置比刚才的大，就更新最后位置</span></span><br><span class="line">            <span class="keyword">if</span> i == end: <span class="comment">#这里就是找到这一段的结束了，就说明当前位置的index和这个字母在字典里的最后位置应该是相同的。</span></span><br><span class="line">                ans.append(end - start + <span class="number">1</span>) <span class="comment"># 加入result</span></span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray (Easy)</title>
      <link href="/2022/06/13/53/"/>
      <url>/2022/06/13/53/</url>
      
        <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a>53. Maximum Subarray (Easy)</h1><h2 id="Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum"><a href="#Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum" class="headerlink" title="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."></a>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</h2><h1 id="A-subarray-is-a-contiguous-part-of-an-array"><a href="#A-subarray-is-a-contiguous-part-of-an-array" class="headerlink" title="A subarray is a contiguous part of an array."></a>A subarray is a contiguous part of an array.</h1><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>这题第一眼非常像买股票第一弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure><h2 id="本质上是动态规划问题："><a href="#本质上是动态规划问题：" class="headerlink" title="本质上是动态规划问题："></a>本质上是动态规划问题：</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">leetcode题解</a></p><p>方法一：动态规划<br>「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。</p><p>本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。</p><h2 id="关键-1：理解题意"><a href="#关键-1：理解题意" class="headerlink" title="关键 1：理解题意"></a>关键 1：理解题意</h2><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><h2 id="关键-2：如何定义子问题（如何定义状态）"><a href="#关键-2：如何定义子问题（如何定义状态）" class="headerlink" title="关键 2：如何定义子问题（如何定义状态）"></a>关键 2：如何定义子问题（如何定义状态）</h2><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><p>子问题 1：经过 -2 的连续子数组的最大和是多少；<br>子问题 2：经过 1 的连续子数组的最大和是多少；<br>子问题 3：经过 -3 的连续子数组的最大和是多少；<br>子问题 4：经过 4 的连续子数组的最大和是多少；<br>子问题 5：经过 -1 的连续子数组的最大和是多少；<br>子问题 6：经过 2 的连续子数组的最大和是多少；<br>子问题 7：经过 1 的连续子数组的最大和是多少；<br>子问题 8：经过 -5 的连续子数组的最大和是多少；<br>子问题 9：经过 4 的连续子数组的最大和是多少。<br>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 -3 的连续子数组的最大和是多少。</p><p>「经过 -3 的连续子数组」我们任意举出几个：</p><p>[-2,1,-3,4] ，-3 是这个连续子数组的第 3 个元素；<br>[1,-3,4,-1] ，-3 是这个连续子数组的第 2 个元素；<br>……<br>我们不确定的是：-3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>子问题 3：以 -3 结尾的连续子数组的最大和是多少；<br>子问题 4：以 4 结尾的连续子数组的最大和是多少；<br>子问题 5：以 -1 结尾的连续子数组的最大和是多少；<br>子问题 6：以 2 结尾的连续子数组的最大和是多少；<br>子问题 7：以 1 结尾的连续子数组的最大和是多少；<br>子问题 8：以 -5 结尾的连续子数组的最大和是多少；<br>子问题 9：以 4 结尾的连续子数组的最大和是多少。<br>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>以 -2 结尾的连续子数组是 [-2]，因此最大和就是 -2。</p><p>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 1。</p><p>大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：</p><p>一个数 a 加上负数的结果比 a 更小；<br>一个数 a 加上 0 的结果不会比 a 更大；<br>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。<br>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><h2 id="定义状态（定义子问题）"><a href="#定义状态（定义子问题）" class="headerlink" title="定义状态（定义子问题）"></a>定义状态（定义子问题）</h2><p>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</p><p>说明：「结尾」和「连续」是关键字。</p><h2 id="状态转移方程（描述子问题之间的联系）"><a href="#状态转移方程（描述子问题之间的联系）" class="headerlink" title="状态转移方程（描述子问题之间的联系）"></a>状态转移方程（描述子问题之间的联系）</h2><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 dp[i] = dp[i - 1] + nums[i]。</p><p>可是 dp[i - 1] 有可能是负数，于是分类讨论：</p><p>如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；<br>如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</p><h2 id="思考初始值"><a href="#思考初始值" class="headerlink" title="思考初始值"></a>思考初始值</h2><p>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</p><h2 id="思考输出"><a href="#思考输出" class="headerlink" title="思考输出"></a>思考输出</h2><p>注意：</p><h3 id="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"><a href="#这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；" class="headerlink" title="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"></a>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>665. Non-decreasing Array(medium)</title>
      <link href="/2022/06/13/665/"/>
      <url>/2022/06/13/665/</url>
      
        <content type="html"><![CDATA[<h1 id="665-Non-decreasing-Array-medium"><a href="#665-Non-decreasing-Array-medium" class="headerlink" title="665. Non-decreasing Array(medium)"></a>665. Non-decreasing Array(medium)</h1><h2 id="Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element"><a href="#Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element" class="headerlink" title="Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element."></a>Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.</h2><h2 id="We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2"><a href="#We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2" class="headerlink" title="We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2)."></a>We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).</h2><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p>这道题的关键在于修改哪个数，本题在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><p>思路:<br>nums[i] &lt; nums[i - 1]:<br>    nums[i - 1] = nums[i]<br>nums[i] &lt; nums[i - 2]:<br>    nums[i] = nums[i - 1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">2</span>] <span class="keyword">and</span> i-<span class="number">2</span>&gt;=<span class="number">0</span> :</span><br><span class="line">                nums[i]=nums[i-<span class="number">1</span>]</span><br><span class="line">                cnt+=<span class="number">1</span>              </span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[i-<span class="number">1</span>]= nums[i]</span><br><span class="line">                cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>392. Is Subsequence (Medium)</title>
      <link href="/2022/06/13/392/"/>
      <url>/2022/06/13/392/</url>
      
        <content type="html"><![CDATA[<h1 id="392-Is-Subsequence-Medium"><a href="#392-Is-Subsequence-Medium" class="headerlink" title="392. Is Subsequence (Medium)"></a>392. Is Subsequence (Medium)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise" class="headerlink" title="Given two strings s and t, return true if s is a subsequence of t, or false otherwise."></a>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</h2><h2 id="A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not"><a href="#A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not" class="headerlink" title="A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not)."></a>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</h2><p>本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。</p><p>而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。</p><p>这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。</p><p>最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i]==t[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>605. Can Place Flowers (Easy)</title>
      <link href="/2022/06/11/605/"/>
      <url>/2022/06/11/605/</url>
      
        <content type="html"><![CDATA[<h1 id="605-Can-Place-Flowers-Easy"><a href="#605-Can-Place-Flowers-Easy" class="headerlink" title="605. Can Place Flowers (Easy)"></a>605. Can Place Flowers (Easy)</h1><h2 id="You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots"><a href="#You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots" class="headerlink" title="You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots."></a>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.</h2><h2 id="Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule"><a href="#Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule" class="headerlink" title="Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule."></a>Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</h2><p><a href="https://leetcode.cn/problems/can-place-flowers/solution/chong-hua-wen-ti-by-leetcode-solution-sojr/728529">leetcode官解评论</a></p><p>非常巧妙的方法，用数学归纳法很容易推出来公式</p><p>统计连续的0的区间，分别有多少个连续的0即可。对于每一段0区间，都可以根据公式直接算出可以种几朵花。</p><p>公式可以通过数学归纳法推出来，很简单：</p><ol><li>对于中间的0区间：</li></ol><p>1~2个0：可种0朵；</p><p>3~4个：可种1朵；</p><p>5~6个：可种2朵；</p><p>…</p><p>count个：可种 (count-1)/2 朵</p><ol start="2"><li>对于两头的0区间，由于左边、右边分别没有1的限制，可种花朵数稍有不同。</li></ol><p>为了代码流程的统一，可以在数组最左边、数组最右边分别补1个0，意味着花坛左边、右边没有花。</p><p>这样公式就跟1相同了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flowerbed:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        countofZero = <span class="number">1</span> <span class="comment"># 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace = <span class="number">0</span> <span class="comment"># 可以种的花的数量</span></span><br><span class="line">        <span class="keyword">for</span> bed <span class="keyword">in</span> flowerbed:</span><br><span class="line">            <span class="keyword">if</span> bed == <span class="number">0</span>: <span class="comment"># 遇到0，连续0的数量+1</span></span><br><span class="line">                countofZero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#遇到1，结算上一段连续的0区间，看能种下几盆花：(countofZero-1)/2</span></span><br><span class="line">                canPlace += <span class="built_in">int</span>((countofZero-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                countofZero = <span class="number">0</span>; <span class="comment"># 0的数量清零，开始统计下一个全0分区        </span></span><br><span class="line">        <span class="comment">#最后一段0区还未结算：</span></span><br><span class="line">        countofZero += <span class="number">1</span><span class="comment"># 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace += (countofZero-<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123. Best Time to Buy and Sell Stock III(hard)</title>
      <link href="/2022/06/11/123/"/>
      <url>/2022/06/11/123/</url>
      
        <content type="html"><![CDATA[<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III-hard"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-hard" class="headerlink" title="123. Best Time to Buy and Sell Stock III(hard)"></a>123. Best Time to Buy and Sell Stock III(hard)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions"><a href="#Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions" class="headerlink" title="Find the maximum profit you can achieve. You may complete at most two transactions."></a>Find the maximum profit you can achieve. You may complete at most two transactions.</h2><h2 id="Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again"><a href="#Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again" class="headerlink" title="Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."></a>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure><p>卖股票第三弹（hard题了）</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>和第二题差不多，但是限制了最多两次交易，之前的小技巧有些用不上了，所以还是得走动态规划的路子。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/">官方题解</a></h2><p>思路与算法</p><p>由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p><ol><li><p>未进行过任何操作；</p></li><li><p>只进行过一次买操作；</p></li><li><p>进行了一次买操作和一次卖操作，即完成了一笔交易；</p></li><li><p>在完成了一笔交易的前提下，进行了第二次买操作；</p></li><li><p>完成了全部两笔交易。</p></li></ol><p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 buy1,sell1,,buy2,sell2 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy1 = buy2 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell1 = sell2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i])</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i])</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i])</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i])</span><br><span class="line">        <span class="keyword">return</span> sell2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II (Easy)</title>
      <link href="/2022/06/11/122/"/>
      <url>/2022/06/11/122/</url>
      
        <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a>122. Best Time to Buy and Sell Stock II (Easy)</h1><h2 id="You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an integer array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day"><a href="#On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day" class="headerlink" title="On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day."></a>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</h2><h2 id="Find-and-return-the-maximum-profit-you-can-achieve"><a href="#Find-and-return-the-maximum-profit-you-can-achieve" class="headerlink" title="Find and return the maximum profit you can achieve."></a>Find and return the maximum profit you can achieve.</h2><p>卖股票第二弹</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大利润 。</p><p>这一题一样是可以用贪心算法或者动态规划写的，但是我在<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/658886">官方题解评论区</a>发现一个极其简单的小技巧。在本题中买卖都是无限次的，所以只要把盈利（也就是上升段）全部加在一起就可以了，相当于每隔一天算一次盈利，盈利为正算在总利润里，盈利为负就丢掉。</p><p>简单来说就是只要把所有的盈利加在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                res += prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock (Easy)</title>
      <link href="/2022/06/11/121/"/>
      <url>/2022/06/11/121/</url>
      
        <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a>121. Best Time to Buy and Sell Stock (Easy)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock"><a href="#You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock" class="headerlink" title="You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock."></a>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</h2><h2 id="Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0"><a href="#Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0" class="headerlink" title="Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0."></a>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</h2><p>其实这题是动态规划的问题.卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-i/">121</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p><img src="https://pic.leetcode-cn.com/4eaadab491f2bf88639d66c9d51bb0115e694ae08d637841ac18172b631cb21f-0121.gif" alt="图片"></p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>406. Queue Reconstruction by Height(Medium)</title>
      <link href="/2022/06/11/406/"/>
      <url>/2022/06/11/406/</url>
      
        <content type="html"><![CDATA[<h1 id="406-Queue-Reconstruction-by-Height-Medium"><a href="#406-Queue-Reconstruction-by-Height-Medium" class="headerlink" title="406. Queue Reconstruction by Height(Medium)"></a>406. Queue Reconstruction by Height(Medium)</h1><h2 id="You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi"><a href="#You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi" class="headerlink" title="You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi."></a>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</h2><h2 id="Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue"><a href="#Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue" class="headerlink" title="Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue)."></a>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</h2><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。</p><p>渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</p><p>在本题目中，首先对数对进行排序，按照数对的元素 1(身高) 降序排序，按照数对的元素 2 (人数)升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。</p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/">leetcode题解</a></p><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = lambda x: (-x[0], x[1]))</span><br></pre></td></tr></table></figure><p>第一个元素降序，第二个元素升序排列，以第一个元素的降序排列优先</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = [[1,4],[2,3],[3,4],[1,3],[1,2]]</span><br><span class="line"></span><br><span class="line">print(sorted(A,key=lambda x:x[1]))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0], x[1])))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [2, 3], [1, 3], [1, 4], [3, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 2], [1, 3], [1, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 4], [1, 3], [1, 2]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="本题例子"><a href="#本题例子" class="headerlink" title="本题例子"></a>本题例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br></pre></td></tr></table></figure><p>所以排序完：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>])) <span class="comment">#排序</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= p[<span class="number">1</span>]:  <span class="comment">#比较的变量是当前数组的长度</span></span><br><span class="line">                res.append(p)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(res) &gt; p[<span class="number">1</span>]:</span><br><span class="line">                res.insert(p[<span class="number">1</span>], p)  <span class="comment"># p is inserted at index p[1]（参与这次排序的P[1])</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> people:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = people[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons (Medium)</title>
      <link href="/2022/06/10/452/"/>
      <url>/2022/06/10/452/</url>
      
        <content type="html"><![CDATA[<h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons (Medium)"></a>452. Minimum Number of Arrows to Burst Balloons (Medium)</h1><h2 id="There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons"><a href="#There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons" class="headerlink" title="There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons."></a>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.</h2><h2 id="Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path"><a href="#Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path" class="headerlink" title="Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path."></a>Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</h2><h2 id="Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons"><a href="#Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons" class="headerlink" title="Given the array points, return the minimum number of arrows that must be shot to burst all balloons."></a>Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</h2><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p><p>也是计算不重叠的区间个数，不过和 Non-overlapping points 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p><p><img src="https://assets.leetcode-cn.com/solution-static/452/1.png" alt="射箭"></p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h2><p>这道题和 435. Non-overlapping Intervals (Medium) 有些类似，都是寻找重合区间</p><p>贪心：<br>既然每个气球都需要被引爆，那么在满足引爆对箭限制最大的那个气球（因为它一定要被引爆，而箭和其它同时被引爆的气球 都可以迁就它，所以满足它是必须的） 的同时，引爆尽可能多其他的气球。</p><p>在付出不变的的前提下，获得尽可能多。</p><p>简单来说就是先按照区间右边边界从小到大排序，为了尽可能的多引爆气球，第一支箭射在第一个区间的最右边，根据后面区间的左端点判断一共引爆了哪些区间，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。</p><p>有个问题是这 nn 个气球对应的区间互不重叠，while 循环需要执行 n 次。所以当遇到x(j) ≤ y(i)时 我们可以直接跳出循环，y(j)就是下一个箭的位置。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>435. Non-overlapping Intervals (Medium)</title>
      <link href="/2022/06/09/435/"/>
      <url>/2022/06/09/435/</url>
      
        <content type="html"><![CDATA[<h1 id="435-Non-overlapping-Intervals-Medium"><a href="#435-Non-overlapping-Intervals-Medium" class="headerlink" title="435. Non-overlapping Intervals (Medium)"></a>435. Non-overlapping Intervals (Medium)</h1><h2 id="Given-an-array-of-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-intervals-you-need-to-remove-to-make-the-rest-of-the-intervals-non-overlapping"><a href="#Given-an-array-of-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-intervals-you-need-to-remove-to-make-the-rest-of-the-intervals-non-overlapping" class="headerlink" title="Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping."></a>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p><p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        n = <span class="built_in">len</span>(intervals)</span><br><span class="line">        right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= right:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - ans</span><br></pre></td></tr></table></figure><p>注释：<br>key=lambda 元素: 元素[字段索引]</p><p>比如   print(sorted(C, key=lambda x: x[2]))   </p><p>x:x[]字母可以随意修改，排序方式按照中括号[]里面的维度进行排序，[0]按照第一维排序，[2]按照第三维排序</p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C = [(<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> y: y[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#输出[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"><span class="comment">#[(&#x27;a&#x27;, 2, 1), (&#x27;b&#x27;, 3, 3), (&#x27;c&#x27;, 5, 4), (&#x27;d&#x27;, 1, 5), (&#x27;e&#x27;, 4, 2)]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(C, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>]))</span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">4</span>, <span class="number">2</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>455. Assign Cookies (Easy)</title>
      <link href="/2022/06/09/455/"/>
      <url>/2022/06/09/455/</url>
      
        <content type="html"><![CDATA[<h1 id="455-Assign-Cookies-Easy"><a href="#455-Assign-Cookies-Easy" class="headerlink" title="455. Assign Cookies (Easy)"></a>455. Assign Cookies (Easy)</h1><h2 id="Assume-you-are-an-awesome-parent-and-want-to-give-your-children-some-cookies-But-you-should-give-each-child-at-most-one-cookie"><a href="#Assume-you-are-an-awesome-parent-and-want-to-give-your-children-some-cookies-But-you-should-give-each-child-at-most-one-cookie" class="headerlink" title="Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie."></a>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</h2><h2 id="Each-child-i-has-a-greed-factor-g-i-which-is-the-minimum-size-of-a-cookie-that-the-child-will-be-content-with-and-each-cookie-j-has-a-size-s-j-If-s-j-gt-g-i-we-can-assign-the-cookie-j-to-the-child-i-and-the-child-i-will-be-content-Your-goal-is-to-maximize-the-number-of-your-content-children-and-output-the-maximum-number"><a href="#Each-child-i-has-a-greed-factor-g-i-which-is-the-minimum-size-of-a-cookie-that-the-child-will-be-content-with-and-each-cookie-j-has-a-size-s-j-If-s-j-gt-g-i-we-can-assign-the-cookie-j-to-the-child-i-and-the-child-i-will-be-content-Your-goal-is-to-maximize-the-number-of-your-content-children-and-output-the-maximum-number" class="headerlink" title="Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number."></a>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</h2><p>题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><p>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。<br>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。<br>在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。 </p><p>个人理解就是尽力把小的孩子喂饱，每轮都按照这样喂饱就是最优解</p><p>自己写的，按照题目逻辑s[j]&gt;=g[i]判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">        i = j = count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># greed factor g[i]</span></span><br><span class="line">        <span class="comment"># cookie size s[j]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[j]&gt;=g[i]:</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        n, m = <span class="built_in">len</span>(g), <span class="built_in">len</span>(s)</span><br><span class="line">        i = j = count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># greed factor g[i]</span></span><br><span class="line">        <span class="comment"># cookie size s[j]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> g[i] &gt; s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; m:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode04-贪心思想</title>
      <link href="/2022/06/09/LeetCode04-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/2022/06/09/LeetCode04-%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-贪心思想"><a href="#Leetcode-题解-贪心思想" class="headerlink" title="Leetcode 题解 - 贪心思想"></a>Leetcode 题解 - 贪心思想</h1><h2 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1. 分配饼干"></a>1. 分配饼干</h2><h2 id="2-不重叠的区间个数"><a href="#2-不重叠的区间个数" class="headerlink" title="2. 不重叠的区间个数"></a>2. 不重叠的区间个数</h2><h2 id="3-投飞镖刺破气球"><a href="#3-投飞镖刺破气球" class="headerlink" title="3. 投飞镖刺破气球"></a>3. 投飞镖刺破气球</h2><h2 id="4-根据身高和序号重组队列"><a href="#4-根据身高和序号重组队列" class="headerlink" title="4. 根据身高和序号重组队列"></a>4. 根据身高和序号重组队列</h2><h2 id="5-买卖股票最大的收益"><a href="#5-买卖股票最大的收益" class="headerlink" title="5. 买卖股票最大的收益"></a>5. 买卖股票最大的收益</h2><h2 id="6-买卖股票的最大收益-II"><a href="#6-买卖股票的最大收益-II" class="headerlink" title="6. 买卖股票的最大收益 II"></a>6. 买卖股票的最大收益 II</h2><h2 id="7-种植花朵"><a href="#7-种植花朵" class="headerlink" title="7. 种植花朵"></a>7. 种植花朵</h2><h2 id="8-判断是否为子序列"><a href="#8-判断是否为子序列" class="headerlink" title="8. 判断是否为子序列"></a>8. 判断是否为子序列</h2><h2 id="9-修改一个数成为非递减数组"><a href="#9-修改一个数成为非递减数组" class="headerlink" title="9. 修改一个数成为非递减数组"></a>9. 修改一个数成为非递减数组</h2><h2 id="10-子数组最大的和"><a href="#10-子数组最大的和" class="headerlink" title="10. 子数组最大的和"></a>10. 子数组最大的和</h2><h2 id="11-分隔字符串使同种字符出现在一起"><a href="#11-分隔字符串使同种字符出现在一起" class="headerlink" title="11. 分隔字符串使同种字符出现在一起"></a>11. 分隔字符串使同种字符出现在一起</h2><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors (Medium)</title>
      <link href="/2022/06/09/75/"/>
      <url>/2022/06/09/75/</url>
      
        <content type="html"><![CDATA[<h1 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a>75. Sort Colors (Medium)</h1><h2 id="Given-an-array-nums-with-n-objects-colored-red-white-or-blue-sort-them-in-place-so-that-objects-of-the-same-color-are-adjacent-with-the-colors-in-the-order-red-white-and-blue"><a href="#Given-an-array-nums-with-n-objects-colored-red-white-or-blue-sort-them-in-place-so-that-objects-of-the-same-color-are-adjacent-with-the-colors-in-the-order-red-white-and-blue" class="headerlink" title="Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue."></a>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</h2><h2 id="We-will-use-the-integers-0-1-and-2-to-represent-the-color-red-white-and-blue-respectively"><a href="#We-will-use-the-integers-0-1-and-2-to-represent-the-color-red-white-and-blue-respectively" class="headerlink" title="We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively."></a>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</h2><h2 id="You-must-solve-this-problem-without-using-the-library’s-sort-function"><a href="#You-must-solve-this-problem-without-using-the-library’s-sort-function" class="headerlink" title="You must solve this problem without using the library’s sort function."></a>You must solve this problem without using the library’s sort function.</h2><h2 id="有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。"><a href="#有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。" class="headerlink" title="有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。"></a>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</h2><p>个人理解就是三指针，跟之前的双指针差不多，和之前不同的是因为有三个区间所以要三个指针<br><a href="https://cloud.tencent.com/developer/article/1624933#:~:text=%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%EF%BC%9A%E7%8E%B0%E5%9C%A8%E6%9C%89,%E5%90%8E%E6%AD%A3%E5%A5%BD%E7%BB%84%E6%88%90%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E3%80%82&text=%E8%BF%99%E9%81%93%E9%A2%98%E5%BE%88%E7%BB%8F%E5%85%B8%EF%BC%8C%E5%BE%88%E9%AB%98%E9%A2%91%E3%80%82">荷兰国旗问题参考</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        a = c = <span class="number">0</span></span><br><span class="line">        b = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> c &lt;= b:</span><br><span class="line">            <span class="keyword">if</span> nums[c] == <span class="number">0</span>:</span><br><span class="line">                nums[a], nums[c] = nums[c], nums[a]</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[c] == <span class="number">2</span>:</span><br><span class="line">                nums[c], nums[b] = nums[b], nums[c]</span><br><span class="line">                b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>451. Sort Characters By Frequency (Medium)</title>
      <link href="/2022/06/09/451/"/>
      <url>/2022/06/09/451/</url>
      
        <content type="html"><![CDATA[<ol start="451"><li>Sort Characters By Frequency (Medium)</li></ol><h2 id="Given-a-string-s-sort-it-in-decreasing-order-based-on-the-frequency-of-the-characters-The-frequency-of-a-character-is-the-number-of-times-it-appears-in-the-string"><a href="#Given-a-string-s-sort-it-in-decreasing-order-based-on-the-frequency-of-the-characters-The-frequency-of-a-character-is-the-number-of-times-it-appears-in-the-string" class="headerlink" title="Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string."></a>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.</h2><h2 id="Return-the-sorted-string-If-there-are-multiple-answers-return-any-of-them"><a href="#Return-the-sorted-string-If-there-are-multiple-answers-return-any-of-them" class="headerlink" title="Return the sorted string. If there are multiple answers, return any of them."></a>Return the sorted string. If there are multiple answers, return any of them.</h2><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/python3-shuang-90-by-key-wu-xbod/">Leetcode 题解</a></p><p>这道题和 347. Top K Frequent Elements (Medium) 几乎一样，一个是数字一个是字符串，方法也类似</p><p>1.建哈希表，将字符串s中的每个字符计数<br>2.根据哈希表中的值进行降序排序即可<br>3.直接字符乘以数目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans] += <span class="number">1</span></span><br><span class="line">        result = <span class="built_in">sorted</span>(hashmap.items(),key=<span class="keyword">lambda</span> hashmap:hashmap[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">            res = result[i][<span class="number">0</span>] * result[i][<span class="number">1</span>]</span><br><span class="line">            s += res</span><br><span class="line">        <span class="keyword">return</span> s </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements (Medium)</title>
      <link href="/2022/06/09/347/"/>
      <url>/2022/06/09/347/</url>
      
        <content type="html"><![CDATA[<h1 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a>347. Top K Frequent Elements (Medium)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-the-k-most-frequent-elements-You-may-return-the-answer-in-any-order"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-the-k-most-frequent-elements-You-may-return-the-answer-in-any-order" class="headerlink" title="Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order."></a>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</h2><p>hashmap<br>1.建哈希表，将数组中的每个数字计数<br>2.根据哈希表中的值进行降序排序即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums, k</span>):</span> </span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans] += <span class="number">1</span></span><br><span class="line">        result = <span class="built_in">sorted</span>(hashmap.items(),key=<span class="keyword">lambda</span> hashmap:hashmap[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            res.extend(result[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">           </span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/bi-guan-fang-ti-jie-geng-kuai-de-fang-fa-lgsc/">题解评论</a></p><p>用字典去代替数组会不会好一些；<br>倒序遍历频次时，最大不超过 n-k+1 ；<br>python3版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashMap = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            hashMap[num] = hashMap.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        bucket = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> x, v <span class="keyword">in</span> hashMap.items():</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> bucket:</span><br><span class="line">                bucket[v] = [x]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bucket[v].append(x)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - k + <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt;= k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> bucket:</span><br><span class="line">                res.extend(bucket[v])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/python-dui-pai-xu-by-xxinjiee/">leetcode题解</a></p><p>对于 topk 问题：最大堆求topk小，最小堆求 topk 大。</p><p>topk小：构建一个 k 个数的最大堆，当读取的数小于根节点时，替换根节点，重新塑造最大堆<br>topk大：构建一个 k 个数的最小堆，当读取的数大于根节点时，替换根节点，重新塑造最小堆<br>这一题的总体思路 总体时间复杂度 O(nlogk)O(nlogk)</p><p>遍历统计元素出现频率 O(n)O(n)<br>前k个数构造 规模为 k+1 的最小堆 minheap， O(k)O(k)， 注意 +1 是因为占位节点。<br>遍历规模k之外的数据，大于堆顶则入堆，下沉维护规模为k的最小堆 minheap. O(nlogk)O(nlogk)<br>(如需按频率输出，对规模为k的堆进行排序)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span>(<span class="params">arr, root, k</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;下沉log(k),如果新的根节点&gt;子节点就一直下沉&quot;&quot;&quot;</span></span><br><span class="line">            val = arr[root] <span class="comment"># 用类似插入排序的赋值交换</span></span><br><span class="line">            <span class="keyword">while</span> root&lt;&lt;<span class="number">1</span> &lt; k:</span><br><span class="line">                child = root &lt;&lt; <span class="number">1</span></span><br><span class="line">                <span class="comment"># 选取左右孩子中小的与父节点交换</span></span><br><span class="line">                <span class="keyword">if</span> child|<span class="number">1</span> &lt; k <span class="keyword">and</span> arr[child|<span class="number">1</span>][<span class="number">1</span>] &lt; arr[child][<span class="number">1</span>]:</span><br><span class="line">                    child |= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果子节点&lt;新节点,交换,如果已经有序break</span></span><br><span class="line">                <span class="keyword">if</span> arr[child][<span class="number">1</span>] &lt; val[<span class="number">1</span>]:</span><br><span class="line">                    arr[root] = arr[child]</span><br><span class="line">                    root = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            arr[root] = val</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sift_up</span>(<span class="params">arr, child</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;上浮log(k),如果新加入的节点&lt;父节点就一直上浮&quot;&quot;&quot;</span></span><br><span class="line">            val = arr[child]</span><br><span class="line">            <span class="keyword">while</span> child&gt;&gt;<span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> val[<span class="number">1</span>] &lt; arr[child&gt;&gt;<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                arr[child] = arr[child&gt;&gt;<span class="number">1</span>]</span><br><span class="line">                child &gt;&gt;= <span class="number">1</span></span><br><span class="line">            arr[child] = val</span><br><span class="line"></span><br><span class="line">        stat = collections.Counter(nums)</span><br><span class="line">        stat = <span class="built_in">list</span>(stat.items())</span><br><span class="line">        heap = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建规模为k+1的堆,新元素加入堆尾,上浮</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            heap.append(stat[i])</span><br><span class="line">            sift_up(heap, <span class="built_in">len</span>(heap)-<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 维护规模为k+1的堆,如果新元素大于堆顶,入堆,并下沉</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(stat)):</span><br><span class="line">            <span class="keyword">if</span> stat[i][<span class="number">1</span>] &gt; heap[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                heap[<span class="number">1</span>] = stat[i]</span><br><span class="line">                sift_down(heap, <span class="number">1</span>, k+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> [item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> heap[<span class="number">1</span>:]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Python </tag>
            
            <tag> topk </tag>
            
            <tag> hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array (Medium)</title>
      <link href="/2022/06/09/215/"/>
      <url>/2022/06/09/215/</url>
      
        <content type="html"><![CDATA[<h1 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a>215. Kth Largest Element in an Array (Medium)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-the-kth-largest-element-in-the-array"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-the-kth-largest-element-in-the-array" class="headerlink" title="Given an integer array nums and an integer k, return the kth largest element in the array."></a>Given an integer array nums and an integer k, return the kth largest element in the array.</h2><h2 id="Note-that-it-is-the-kth-largest-element-in-the-sorted-order-not-the-kth-distinct-element"><a href="#Note-that-it-is-the-kth-largest-element-in-the-sorted-order-not-the-kth-distinct-element" class="headerlink" title="Note that it is the kth largest element in the sorted order, not the kth distinct element."></a>Note that it is the kth largest element in the sorted order, not the kth distinct element.</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/">leetcode题解</a></p><h2 id="方法一-快速排序（Quick-Sort）"><a href="#方法一-快速排序（Quick-Sort）" class="headerlink" title="方法一. 快速排序（Quick Sort）"></a>方法一. 快速排序（Quick Sort）</h2><p>快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔（Tony Hoare ）提出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            pivot = arr[low]                                        <span class="comment"># 选取最左边为pivot</span></span><br><span class="line"></span><br><span class="line">            left, right = low, high     <span class="comment"># 双指针</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right] &gt;= pivot:          <span class="comment"># 找到右边第一个&lt;pivot的元素</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                arr[left] = arr[right]                             <span class="comment"># 并将其移动到left处</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[left] &lt;= pivot:           <span class="comment"># 找到左边第一个&gt;pivot的元素</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                arr[right] = arr[left]                             <span class="comment"># 并将其移动到right处</span></span><br><span class="line">            </span><br><span class="line">            arr[left] = pivot           <span class="comment"># pivot放置到中间left=right处</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">randomPartition</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            pivot_idx = random.randint(low, high)                   <span class="comment"># 随机选择pivot</span></span><br><span class="line">            arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low]     <span class="comment"># pivot放置到最左边</span></span><br><span class="line">            <span class="keyword">return</span> partition(arr, low, high)                        <span class="comment"># 调用partition函数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">topKSplit</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="comment"># mid = partition(arr, low, high)                   # 以mid为分割点【非随机选择pivot】</span></span><br><span class="line">            mid = randomPartition(arr, low, high)               <span class="comment"># 以mid为分割点【随机选择pivot】</span></span><br><span class="line">            <span class="keyword">if</span> mid == k-<span class="number">1</span>:                                      <span class="comment"># 第k小元素的下标为k-1</span></span><br><span class="line">                <span class="keyword">return</span> arr[mid]                                 <span class="comment">#【找到即返回】</span></span><br><span class="line">            <span class="keyword">elif</span> mid &lt; k-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> topKSplit(arr, mid+<span class="number">1</span>, high, k)           <span class="comment"># 递归对mid右侧元素进行排序</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> topKSplit(arr, low, mid-<span class="number">1</span>, k)            <span class="comment"># 递归对mid左侧元素进行排序</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> topKSplit(nums, <span class="number">0</span>, n-<span class="number">1</span>, n-k+<span class="number">1</span>)                   <span class="comment"># 第k大元素即为第n-k+1小元素</span></span><br></pre></td></tr></table></figure><h2 id="方法二-堆排序（Heap-Sort）"><a href="#方法二-堆排序（Heap-Sort）" class="headerlink" title="方法二. 堆排序（Heap Sort）"></a>方法二. 堆排序（Heap Sort）</h2><p>堆排序（英语：Heapsort）是指利用堆（heap）这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。[摘自@维基百科]</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/by-flix-amc8/">leetcode题解</a></p><p>堆与排序：</p><p>对于一个待排序的包含 nn 个元素的数组 numsnums，堆排序 通常包含以下几个基本步骤：</p><ol><li>建堆：将待排序的数组初始化为大根堆（小根堆）。此时，堆顶的元素（即根节点）即为整个数组中的最大值（最小值）。</li><li>交换和调整：将堆顶元素与末尾元素进行交换，此时末尾即为最大值（最小值）。除去末尾元素后，将其他 n-1n−1 个元素重新构造成一个大根堆（小根堆），如此便可得到原数组 nn 个元素中的次大值（次小值）。</li><li>重复步骤二，直至堆中仅剩一个元素，如此便可得到一个有序序列了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHeapify</span>(<span class="params">arr, i, end</span>):</span></span><br><span class="line">            j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[j+<span class="number">1</span>] &gt; arr[j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:</span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">                    i = j</span><br><span class="line">                    j = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxHepify</span>(<span class="params">arr, i, end</span>):</span>     <span class="comment"># 大顶堆</span></span><br><span class="line">            j = <span class="number">2</span>*i + <span class="number">1</span>                 <span class="comment"># j为i的左子节点【建堆时下标0表示堆顶】</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:             <span class="comment"># 自上而下进行调整</span></span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[j+<span class="number">1</span>] &gt; arr[j]:    <span class="comment"># i的左右子节点分别为j和j+1</span></span><br><span class="line">                    j += <span class="number">1</span>                              <span class="comment"># 取两者之间的较大者</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt; arr[j]:             <span class="comment"># 若i指示的元素小于其子节点中的较大者</span></span><br><span class="line">                    arr[i], arr[j] = arr[j], arr[i]     <span class="comment"># 交换i和j的元素，并继续往下判断</span></span><br><span class="line">                    i = j                       <span class="comment"># 往下走：i调整为其子节点j</span></span><br><span class="line">                    j = <span class="number">2</span>*i + <span class="number">1</span>                 <span class="comment"># j调整为i的左子节点</span></span><br><span class="line">                <span class="keyword">else</span>:                           <span class="comment"># 否则，结束调整</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 建堆【大顶堆】</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):         <span class="comment"># 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整</span></span><br><span class="line">            maxHepify(nums, i, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆</span></span><br><span class="line">        <span class="comment"># k-1次重建堆（堆顶元素），或 k次交换到尾部（倒数第k个元素）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, n-k-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            nums[<span class="number">0</span>], nums[j] = nums[j], nums[<span class="number">0</span>]     <span class="comment"># 堆顶元素（当前最大值）放置到尾部j</span></span><br><span class="line">            maxHepify(nums, <span class="number">0</span>, j-<span class="number">1</span>)                 <span class="comment"># j-1变成尾部，并从堆顶0开始调整堆</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于快排的所有TopK问题简单python模板"><a href="#基于快排的所有TopK问题简单python模板" class="headerlink" title="基于快排的所有TopK问题简单python模板"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/ji-yu-kuai-pai-de-suo-you-topkwen-ti-jia-ylsd/">基于快排的所有TopK问题简单python模板</a></h2>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Heap Sort </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> topk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode03-排序</title>
      <link href="/2022/06/03/LeetCode03-%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/06/03/LeetCode03-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-排序"><a href="#Leetcode-题解-排序" class="headerlink" title="Leetcode 题解 - 排序"></a>Leetcode 题解 - 排序</h1><h2 id="1-快速选择"><a href="#1-快速选择" class="headerlink" title="1. 快速选择"></a>1. 快速选择</h2><h2 id="2-堆-Kth-Element"><a href="#2-堆-Kth-Element" class="headerlink" title="2. 堆-Kth Element"></a>2. 堆-Kth Element</h2><h2 id="3-桶排序"><a href="#3-桶排序" class="headerlink" title="3. 桶排序"></a>3. 桶排序</h2><h2 id="4-荷兰国旗问题"><a href="#4-荷兰国旗问题" class="headerlink" title="4. 荷兰国旗问题"></a>4. 荷兰国旗问题</h2><ol><li>快速选择（快速排序）</li></ol><p>用于求解 Kth Element 问题，也就是第 K 个元素的问题。</p><p>快速选择算法是基于快速排序算法思想的用于解决Top K 问题的算法</p><p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N2)。</p><p>步骤：<br>a. 从数列中挑出一个元素，称为 “基准”（pivot）;</p><p>b. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p><p>c. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><ol start="2"><li>堆排序</li></ol><p>用于求解 TopK Elements 问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。</p><p>堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。</p><p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p><p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p><ol start="3"><li>桶排序<br>桶排序，简单来说就是将待排序序列，按照序列值的大小划分成几个桶，分别对每组进行排序，排完序之后再按照一定的顺序合并所有的桶，即排序完成。</li></ol><p>对这道题而言，设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p><p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p><ol start="4"><li>荷兰国旗问题</li></ol><p>“荷兰国旗问题” 是计算机科学中的一个经典题目，它是由Edsger Dijkstra提出的。荷兰国旗由红、白、蓝三色组成。</p><p>荷兰国旗问题：现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。</p><p>这个问题之所以叫荷兰国旗，是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>524. Longest Word in Dictionary through Deleting (Medium)</title>
      <link href="/2022/05/31/524/"/>
      <url>/2022/05/31/524/</url>
      
        <content type="html"><![CDATA[<h1 id="524-Longest-Word-in-Dictionary-through-Deleting-Medium"><a href="#524-Longest-Word-in-Dictionary-through-Deleting-Medium" class="headerlink" title="524. Longest Word in Dictionary through Deleting (Medium)"></a>524. Longest Word in Dictionary through Deleting (Medium)</h1><h2 id="Given-a-string-s-and-a-string-array-dictionary-return-the-longest-string-in-the-dictionary-that-can-be-formed-by-deleting-some-of-the-given-string-characters-If-there-is-more-than-one-possible-result-return-the-longest-word-with-the-smallest-lexicographical-order-If-there-is-no-possible-result-return-the-empty-string"><a href="#Given-a-string-s-and-a-string-array-dictionary-return-the-longest-string-in-the-dictionary-that-can-be-formed-by-deleting-some-of-the-given-string-characters-If-there-is-more-than-one-possible-result-return-the-longest-word-with-the-smallest-lexicographical-order-If-there-is-no-possible-result-return-the-empty-string" class="headerlink" title="Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string."></a>Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</h2><h2 id="题目描述：删除-s-中的一些字符，使得它构成字符串列表-d-中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。"><a href="#题目描述：删除-s-中的一些字符，使得它构成字符串列表-d-中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。" class="headerlink" title="题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。"></a>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</h2><p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><h4 id="1-只有双指针"><a href="#1-只有双指针" class="headerlink" title="1.只有双指针"></a>1.只有双指针</h4><p>这题还真有些难度，主要是有些问题不能一眼看到逻辑和结果。</p><p>根据题意，我们需要解决三个问题：</p><ol><li><p>给定字符串s删除一些字符后能得到数组的字符串</p></li><li><p>找最长的字符串</p></li><li><p>如果长度相同，选字典顺序最小的字符串<br>官方例子：<br>Input: s = “abpcplea”, dictionary = [“ale”,”apple”,”monkey”,”plea”]<br>Output: “apple”</p></li><li><p>第一点很好理解，就是在s这个字符串里找到子串。就像在一个集合里找到子集一样，可以发现[“ale”,”apple”,”plea”]符合</p></li><li><p>最长的字符串就是比较子串长度了，[“apple”] 就比 [“ale”] 和 [“plea”]长度要长</p></li><li><p>字典顺序最小，这个就是比较在字母表上的顺序了，以 a、b、c……z 的顺序排列，a最小，假如还有个新单词 [“appla”],那和[“apple”]比较，虽然长度一样，但是a的字典顺序在e前，所以我们得选择[“appla”]</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> dictionary:</span><br><span class="line">            i = j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(t) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> t[i] == s[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(t):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(t) == <span class="built_in">len</span>(res) <span class="keyword">and</span> t &lt; res):</span><br><span class="line">                    res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>排序+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        m = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        f.append([m] * <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(s[i]) == j + <span class="number">97</span>:</span><br><span class="line">                    f[i][j] = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> dictionary:</span><br><span class="line">            match = <span class="literal">True</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">                <span class="keyword">if</span> f[j][<span class="built_in">ord</span>(t[i]) - <span class="number">97</span>] == m:</span><br><span class="line">                    match = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j = f[j][<span class="built_in">ord</span>(t[i]) - <span class="number">97</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> match:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(t) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(t) == <span class="built_in">len</span>(res) <span class="keyword">and</span> t &lt; res):</span><br><span class="line">                    res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle (Easy)</title>
      <link href="/2022/05/31/141/"/>
      <url>/2022/05/31/141/</url>
      
        <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><h2 id="Given-head-the-head-of-a-linked-list-determine-if-the-linked-list-has-a-cycle-in-it"><a href="#Given-head-the-head-of-a-linked-list-determine-if-the-linked-list-has-a-cycle-in-it" class="headerlink" title="Given head, the head of a linked list, determine if the linked list has a cycle in it."></a>Given head, the head of a linked list, determine if the linked list has a cycle in it.</h2><h2 id="There-is-a-cycle-in-a-linked-list-if-there-is-some-node-in-the-list-that-can-be-reached-again-by-continuously-following-the-next-pointer-Internally-pos-is-used-to-denote-the-index-of-the-node-that-tail’s-next-pointer-is-connected-to-Note-that-pos-is-not-passed-as-a-parameter"><a href="#There-is-a-cycle-in-a-linked-list-if-there-is-some-node-in-the-list-that-can-be-reached-again-by-continuously-following-the-next-pointer-Internally-pos-is-used-to-denote-the-index-of-the-node-that-tail’s-next-pointer-is-connected-to-Note-that-pos-is-not-passed-as-a-parameter" class="headerlink" title="There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter."></a>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</h2><h2 id="Return-true-if-there-is-a-cycle-in-the-linked-list-Otherwise-return-false"><a href="#Return-true-if-there-is-a-cycle-in-the-linked-list-Otherwise-return-false" class="headerlink" title="Return true if there is a cycle in the linked list. Otherwise, return false."></a>Return true if there is a cycle in the linked list. Otherwise, return false.</h2><p>快慢指针</p><p>官方题解：<br>「Floyd 判圈算法」（又称龟兔赛跑算法）<br>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p><p>官方解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>leetcode discussion（速度更快，但逻辑是类似的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            slow = head</span><br><span class="line">            fast = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>这里有一点小不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> fast:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> slow != fast:</span><br></pre></td></tr></table></figure><p>这两个的编译速度在我多次尝试后发现没什么不同，应该没有什么影响</p>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array (Easy)</title>
      <link href="/2022/05/29/88/"/>
      <url>/2022/05/29/88/</url>
      
        <content type="html"><![CDATA[<h1 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a>88. Merge Sorted Array (Easy)</h1><h2 id="You-are-given-two-integer-arrays-nums1-and-nums2-sorted-in-non-decreasing-order-and-two-integers-m-and-n-representing-the-number-of-elements-in-nums1-and-nums2-respectively"><a href="#You-are-given-two-integer-arrays-nums1-and-nums2-sorted-in-non-decreasing-order-and-two-integers-m-and-n-representing-the-number-of-elements-in-nums1-and-nums2-respectively" class="headerlink" title="You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively."></a>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</h2><h2 id="Merge-nums1-and-nums2-into-a-single-array-sorted-in-non-decreasing-order"><a href="#Merge-nums1-and-nums2-into-a-single-array-sorted-in-non-decreasing-order" class="headerlink" title="Merge nums1 and nums2 into a single array sorted in non-decreasing order."></a>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</h2><h2 id="The-final-sorted-array-should-not-be-returned-by-the-function-but-instead-be-stored-inside-the-array-nums1-To-accommodate-this-nums1-has-a-length-of-m-n-where-the-first-m-elements-denote-the-elements-that-should-be-merged-and-the-last-n-elements-are-set-to-0-and-should-be-ignored-nums2-has-a-length-of-n"><a href="#The-final-sorted-array-should-not-be-returned-by-the-function-but-instead-be-stored-inside-the-array-nums1-To-accommodate-this-nums1-has-a-length-of-m-n-where-the-first-m-elements-denote-the-elements-that-should-be-merged-and-the-last-n-elements-are-set-to-0-and-should-be-ignored-nums2-has-a-length-of-n" class="headerlink" title="The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n."></a>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</h2><p>python 数组技巧<br>array[n:]：打印从第n个元素（下标为n-1）到最后一个元素(包括第n个元素)<br>array[:n]：打印从第一个元素到第n个元素（下标为n-1）（包括第n个元素）</p><p>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>Output: [1,2,2,3,5,6]<br>Explanation: The arrays we are merging are [1,2,3] and [2,5,6].<br>The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m-<span class="number">1</span>] &gt;= nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m-<span class="number">1</span>] &gt;= nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>680. Valid Palindrome II (Easy)</title>
      <link href="/2022/05/28/680/"/>
      <url>/2022/05/28/680/</url>
      
        <content type="html"><![CDATA[<h1 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II(Easy)"></a>680. Valid Palindrome II(Easy)</h1><h2 id="Given-a-string-s-return-true-if-the-s-can-be-palindrome-after-deleting-at-most-one-character-from-it"><a href="#Given-a-string-s-return-true-if-the-s-can-be-palindrome-after-deleting-at-most-one-character-from-it" class="headerlink" title="Given a string s, return true if the s can be palindrome after deleting at most one character from it."></a>Given a string s, return true if the s can be palindrome after deleting at most one character from it.</h2><h2 id="官方题解：list-双指针"><a href="#官方题解：list-双指针" class="headerlink" title="官方题解：list+双指针"></a>官方题解：list+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> s: s == s[::-<span class="number">1</span>]</span><br><span class="line">        strPart = <span class="keyword">lambda</span> s, x: s[:x] + s[x + <span class="number">1</span>:]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strPart(s, left)) <span class="keyword">or</span> isPalindrome(strPart(s, right))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Time: O(n)</span></span><br><span class="line">        <span class="comment"># Space: O(n)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] != s[right]:</span><br><span class="line">                one, two = s[left:right], s[left + <span class="number">1</span>:right + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">return</span> one == one[::-<span class="number">1</span>] <span class="keyword">or</span> two == two[::-<span class="number">1</span>]</span><br><span class="line">            left, right = left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                delete_i = s[i+<span class="number">1</span>:j+<span class="number">1</span>]</span><br><span class="line">                delete_j = s[i:j]</span><br><span class="line">                <span class="keyword">return</span> self._isPalindrome(delete_i) <span class="keyword">or</span> self._isPalindrome(delete_j)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>345. Reverse Vowels of a String (Easy)</title>
      <link href="/2022/05/28/345/"/>
      <url>/2022/05/28/345/</url>
      
        <content type="html"><![CDATA[<h1 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. Reverse Vowels of a String</h1><h2 id="Given-a-string-s-reverse-only-all-the-vowels-in-the-string-and-return-it"><a href="#Given-a-string-s-reverse-only-all-the-vowels-in-the-string-and-return-it" class="headerlink" title="Given a string s, reverse only all the vowels in the string and return it."></a>Given a string s, reverse only all the vowels in the string and return it.</h2><h2 id="The-vowels-are-‘a’-‘e’-‘i’-‘o’-and-‘u’-and-they-can-appear-in-both-cases"><a href="#The-vowels-are-‘a’-‘e’-‘i’-‘o’-and-‘u’-and-they-can-appear-in-both-cases" class="headerlink" title="The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases."></a>The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases.</h2><h2 id="官方题解：list-双指针"><a href="#官方题解：list-双指针" class="headerlink" title="官方题解：list+双指针"></a>官方题解：list+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isVowel</span>(<span class="params">ch: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">return</span> ch <span class="keyword">in</span> <span class="string">&quot;aeiouAEIOU&quot;</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; n <span class="keyword">and</span> <span class="keyword">not</span> isVowel(s[i]):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> isVowel(s[j]):</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                s[left], s[right] = s[right], s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        temp=[]<span class="comment">#存储遇到的元音</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]:</span><br><span class="line">                temp.append(s[i])</span><br><span class="line">        k=<span class="built_in">len</span>(temp)</span><br><span class="line">        s=<span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;U&#x27;</span>]:</span><br><span class="line">                s[i]=temp[k-<span class="number">1</span>]<span class="comment">#temp从后往前取值去覆盖</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br></pre></td></tr></table></figure><p>list+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        vowels = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span>]     <span class="comment"># 元音字母列表</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)                                                     <span class="comment"># 列表化输入字符串</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>                                     <span class="comment"># 初始化左右指针位置</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:                                             <span class="comment"># 如果指针位置合法</span></span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">not</span> <span class="keyword">in</span> vowels:                                   <span class="comment"># 如果左指针处字符不是元音字母</span></span><br><span class="line">                left += <span class="number">1</span>                                               <span class="comment"># 左指针右移</span></span><br><span class="line">            <span class="keyword">elif</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> vowels:                                <span class="comment"># 如果右指针处字符不是元音字母</span></span><br><span class="line">                right -= <span class="number">1</span>                                              <span class="comment"># 右指针左移</span></span><br><span class="line">            <span class="keyword">else</span>:                                                       <span class="comment"># 如果左右指针处字符都是元音字母</span></span><br><span class="line">                s[left], s[right] = s[right], s[left]                   <span class="comment"># 交换位置</span></span><br><span class="line">                left += <span class="number">1</span>                                               <span class="comment"># 左指针右移</span></span><br><span class="line">                right -= <span class="number">1</span>                                              <span class="comment"># 右指针左移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s)                                               <span class="comment"># 将列表中的字符连接起来</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>633. Sum of Square Numbers (Medium)</title>
      <link href="/2022/05/28/633-Sum%20of%20Square%20Numbers/"/>
      <url>/2022/05/28/633-Sum%20of%20Square%20Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="633-Sum-of-Square-Numbers"><a href="#633-Sum-of-Square-Numbers" class="headerlink" title="633. Sum of Square Numbers"></a>633. Sum of Square Numbers</h1><h2 id="Given-a-non-negative-integer-c-decide-whether-there’re-two-integers-a-and-b-such-that-a2-b2-c"><a href="#Given-a-non-negative-integer-c-decide-whether-there’re-two-integers-a-and-b-such-that-a2-b2-c" class="headerlink" title="Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c."></a>Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 = c.</h2><p>同样是双指针</p><p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c</span>):</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">int</span>(c**<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="built_in">sum</span> = l*l+r*r</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; c:</span><br><span class="line">                l +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span>&gt;c:</span><br><span class="line">                r -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167. Two Sum II - Input array is sorted (Easy)</title>
      <link href="/2022/05/28/167-twosum-sorted/"/>
      <url>/2022/05/28/167-twosum-sorted/</url>
      
        <content type="html"><![CDATA[<h1 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a>167. Two Sum II - Input Array Is Sorted</h1><h2 id="Given-a-1-indexed-array-of-integers-numbers-that-is-already-sorted-in-non-decreasing-order-find-two-numbers-such-that-they-add-up-to-a-specific-target-number-Let-these-two-numbers-be-numbers-index1-and-numbers-index2-where-1-lt-index1-lt-index2-lt-numbers-length"><a href="#Given-a-1-indexed-array-of-integers-numbers-that-is-already-sorted-in-non-decreasing-order-find-two-numbers-such-that-they-add-up-to-a-specific-target-number-Let-these-two-numbers-be-numbers-index1-and-numbers-index2-where-1-lt-index1-lt-index2-lt-numbers-length" class="headerlink" title="Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length."></a>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.</h2><h2 id="Return-the-indices-of-the-two-numbers-index1-and-index2-added-by-one-as-an-integer-array-index1-index2-of-length-2"><a href="#Return-the-indices-of-the-two-numbers-index1-and-index2-added-by-one-as-an-integer-array-index1-index2-of-length-2" class="headerlink" title="Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2."></a>Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.</h2><h2 id="The-tests-are-generated-such-that-there-is-exactly-one-solution-You-may-not-use-the-same-element-twice"><a href="#The-tests-are-generated-such-that-there-is-exactly-one-solution-You-may-not-use-the-same-element-twice" class="headerlink" title="The tests are generated such that there is exactly one solution. You may not use the same element twice."></a>The tests are generated such that there is exactly one solution. You may not use the same element twice.</h2><h2 id="Your-solution-must-use-only-constant-extra-space"><a href="#Your-solution-must-use-only-constant-extra-space" class="headerlink" title="Your solution must use only constant extra space."></a>Your solution must use only constant extra space.</h2><p>和第一题几乎可以用同样的思路，只不过这里的index从1开始，而且有序数组比第一题更简单</p><h3 id="根据第一题改的hashmap"><a href="#根据第一题改的hashmap" class="headerlink" title="根据第一题改的hashmap"></a>根据第一题改的hashmap</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        Hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            key = target - value</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> Hashmap:</span><br><span class="line">                <span class="keyword">return</span> [Hashmap[key]+<span class="number">1</span>, index+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Hashmap[value] = index</span><br></pre></td></tr></table></figure><p>Two pointers: O(n) time and O(1) space<br>Dictionary: O(n) time and O(n) space<br>Binary search: O(nlogn) time and O(1) space</p><h3 id="two-pointer"><a href="#two-pointer" class="headerlink" title="two-pointer"></a>two-pointer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            s = numbers[l] + numbers[r]</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                <span class="keyword">return</span> [l+<span class="number">1</span>, r+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> target-num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[target-num]+<span class="number">1</span>, i+<span class="number">1</span>]</span><br><span class="line">            dic[num] = i</span><br><span class="line">```           </span><br><span class="line"></span><br><span class="line"><span class="comment">### binary search        </span></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(numbers)):</span><br><span class="line">        l, r = i+<span class="number">1</span>, <span class="built_in">len</span>(numbers)-<span class="number">1</span></span><br><span class="line">        tmp = target - numbers[i]</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = l + (r-l)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] == tmp:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, mid+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &lt; tmp:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="binary-search-改进版"><a href="#binary-search-改进版" class="headerlink" title="binary search   改进版"></a>binary search   改进版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        investigatedSoFar = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> numbers[i] <span class="keyword">in</span> investigatedSoFar:</span><br><span class="line">                investigatedSoFar.append(numbers[i])</span><br><span class="line">                l, r = i + <span class="number">1</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">                tmp = target - numbers[i]</span><br><span class="line">                <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                    mid = l + (r-l) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> numbers[mid] == tmp:</span><br><span class="line">                        <span class="keyword">return</span>([i + <span class="number">1</span>, mid + <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">elif</span> numbers[mid] &lt; tmp:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = mid - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> two-pointers </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2022/05/28/1-twosum/"/>
      <url>/2022/05/28/1-twosum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h2 id="Given-an-array-of-integers-nums-and-an-integer-target-return-indices-of-the-two-numbers-such-that-they-add-up-to-target"><a href="#Given-an-array-of-integers-nums-and-an-integer-target-return-indices-of-the-two-numbers-such-that-they-add-up-to-target" class="headerlink" title="Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target."></a>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice" class="headerlink" title="You may assume that each input would have exactly one solution, and you may not use the same element twice."></a>You may assume that each input would have exactly one solution, and you may not use the same element twice.</h2><h2 id="You-can-return-the-answer-in-any-order"><a href="#You-can-return-the-answer-in-any-order" class="headerlink" title="You can return the answer in any order."></a>You can return the answer in any order.</h2><p>（无序）</p><p>hashmap<br>enumerate()(单词意思是枚举的意思)是python中的内置函数<br>enumerate(X,[start=0])<br>函数中的参数X可以是一个迭代器(iterator)或者是一个序列，start是起始计数值，默认从0开始。X可以是一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        Hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            key = target - value</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> Hashmap:</span><br><span class="line">                <span class="keyword">return</span> [Hashmap[key], index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Hashmap[value] = index</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode02-指针</title>
      <link href="/2022/05/25/LeetCode02-%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/25/LeetCode02-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>第二篇学习笔记，换一个思路尝试学习</p><h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-双指针"><a href="#Leetcode-题解-双指针" class="headerlink" title="Leetcode 题解 - 双指针"></a>Leetcode 题解 - 双指针</h1><h2 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h2><h2 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h2><h2 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h2><h2 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h2><h2 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h2><h2 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h2><h2 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h2><h2 id="双指针类型"><a href="#双指针类型" class="headerlink" title="双指针类型"></a>双指针类型</h2><p>对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。<br>快慢指针：两个指针方向相同。适合解决数组中的移动、删除元素问题，或者链表中的判断是否有环、长度问题。<br>分离双指针：两个指针分别属于不同的数组 / 链表。适合解决有序数组合并，求交集、并集问题。</p><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><p>对撞指针：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ol><li><p>Two Sum</p></li><li><p>Two Sum II - Input Array Is Sorted两数之和 II - 输入有序数组 </p></li></ol><ol start="125"><li>验证回文串</li></ol><ol start="344"><li><p>Reverse String</p></li><li><p>Remove Duplicates from Sorted Array</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 新建/启动/部署命令</title>
      <link href="/2022/05/16/hexo-usage/"/>
      <url>/2022/05/16/hexo-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新建一篇文章"><a href="#1-新建一篇文章" class="headerlink" title="1.新建一篇文章"></a>1.新建一篇文章</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;文章名称&quot;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post hexo_usage</span><br></pre></td></tr></table></figure><h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h2><h3 id="（1）清除缓存文件-db-json-和已生成的静态文件-public-。"><a href="#（1）清除缓存文件-db-json-和已生成的静态文件-public-。" class="headerlink" title="（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。"></a>（1）清除缓存文件 (db.json) 和已生成的静态文件 (public)。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>其实不需要每次都清除缓存文件，直接进行下面两步就可以</p><h3 id="（2）生成静态文件。"><a href="#（2）生成静态文件。" class="headerlink" title="（2）生成静态文件。"></a>（2）生成静态文件。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="（3）部署网站"><a href="#（3）部署网站" class="headerlink" title="（3）部署网站"></a>（3）部署网站</h3><p>部署之前预先生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="3-启动服务器。默认情况下，访问网址为："><a href="#3-启动服务器。默认情况下，访问网址为：" class="headerlink" title="3.启动服务器。默认情况下，访问网址为："></a>3.启动服务器。默认情况下，访问网址为：</h2><p><a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾尔登法环boss战</title>
      <link href="/2022/05/16/elden-ring-boss/"/>
      <url>/2022/05/16/elden-ring-boss/</url>
      
        <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>当我们褪色者重新回到交界地，第一个相遇的法环碎片持有者就是史东威尔城城主“黄金”葛瑞克，一个臭名昭著的神之后裔，黄金家族成员，在史东威尔城附近的破屋里，我们会遇到一位红帽女孩，会知道葛瑞克利用被称为接肢的技术四处劫掠褪色者，将砍下的手脚接在自己身上来增加自身的实力。这座腐朽的城池里到处都是残肢断臂，在一座大厅里我们还能见到在出生点相似的截肢贵族。在城池里我们还会遇到同样对葛瑞克所作所为十分不齿的女战士涅斐丽·露，她会在我们与葛瑞克战斗中助我们一臂之力。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8E%A5%E8%82%A2.5zgwu136oo40.webp" alt="接肢"></p><p>在我们将他击退之后，他还会砍下自己的左手，并接上一个龙头，试图再度增强自己的力量。但当我们最终击败他时，他喃喃地说到：“总有一天，我们会回到黄金树脚下的故乡……“葛瑞克作为曾经最强的一族——”黄金“一族的后人，却非常孱弱，艾尔登法环被女神玛莉卡敲碎后，群雄并起，引发了旷日持久的碎片战争，黄金树脚下的王城多次遭到进攻，葛瑞克混在女人堆里逃出王城，躲在史东薇尔城苟活，曾经想挑战女武神，却被被女武神打的满地找牙。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%85%B5%E8%B4%A5%E5%A6%82%E5%B1%B1%E5%80%92.5rvvday8fkk0.webp" alt="兵败如山倒"></p><p>他妄图通过接肢变得更强，却是想着能够有朝一日可以重现黄金一族的辉煌，当他砍下手臂接上龙头时，他会朝天怒吼：“诸位祖先，敬请见证！”只可惜乱世之中，不符合无上意志的棋子都会被抹去。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>乘着灵马特雷托一路北上，在雷亚卢卡利亚魔法学院，我们会遭遇曾经被称为“满月”女王的蕾娜菈。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%BB%A1%E6%9C%88%E5%A5%B3%E7%8E%8B%E5%A4%A7%E5%8D%A2%E6%81%A9.3jkdl5ccy3c0.webp" alt="满月女王大卢恩"><br>作为卡利亚魔法王国曾经的领导者，卡利亚魔法王国和黄金树势力曾经敌对，黄金树派出了英雄拉达冈前来讨伐，结果蕾娜菈和拉达冈在战场上相爱，双方化干戈为玉帛，喜结连理还诞下了三个子嗣。（分别是碎星将军拉塔恩，月之公主菈妮（神人），黄金树司法官拉卡德）</p><p>但好景不长，拉达冈突然抛下了自己的妻子，回到黄金树和永恒女王玛丽卡结婚。突然失去爱情支撑的蕾娜菈就此丧失了神智，成为现在这幅模样并被卡利亚王室囚禁于大书库。</p><p>她的手里怀抱着拉达冈留给她的琥珀一样的大卢恩，神志不清，不断地利用大卢恩的力量诞生没有自我意识的孩子。</p><p>在打碎女王身边的防护罩后</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E7%8E%8B.6ktlkq7hr88.webp" alt="女王"></p><p>女儿月之公主菈妮会用魔法代替她的母亲与我们战斗，重现了全盛时期的满月女王：灵魂激流一类的法术随意释放，还可以召唤巨龙巨人狼群的灵体协助战斗。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%BB%A1%E6%9C%88%E5%A5%B3%E7%8E%8B.u8tx9yd3ksw.webp" alt="满月女王"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>往东，我们进入了满目猩红腐败的盖利德地区，刚进入红狮子城的配乐极其震撼和忧伤，这么一位一等一的英雄，在盖利德和女武神的战斗中遭受猩红腐败的腐蚀后，自我放逐到恸哭山丘，即使像野狗一样啃噬着战场上的尸体，依然维持着星空的封印。他的手下红狮子军在盖利德修筑了一条熏烧火墙，用火焰同被猩红腐败腐蚀变异的巨大怪物开展永无止境的死斗。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%A1%94%E6%81%A9.6s44iqw0kyw0.webp" alt="拉塔恩"></p><p>一望无际的战场上布满了断戟残垣，只能远远看到他的庞大身躯和贯穿天空的重力大箭，这是一场战斗祭奠，拉塔恩的手下奇异骑士邀请天下豪杰群聚于此，希望能解除他的痛苦，像一位战士一样死去，如果不把战士壶亚历山大和狼哥等英雄们召唤出来，单对单战斗确实是非常困难的事。如果召唤所有英雄跟这位最强半神贴身肉搏，扑面而来的是那种英雄末路的悲壮感，大开大合的招式在战士们中杀进杀出，能坚持战斗到最后一刻的就只剩下壶哥和狼哥，终于击败拉塔恩将军后，天上静滞的星星突然开始流动，随着拉塔恩将军的逝去，群星的封印被解除，新的命运齿轮开始转动</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%A7%A3%E6%94%BE%E7%BE%A4%E6%98%9F.map0i942acw.webp" alt="解放群星"></p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>随着星空封印解除，一枚流星砸穿了地面，地下的永恒之城重现人世，充满恶意的恐怖外神，黑暗弃子艾丝缇从星空坠落，砸穿了天空城之后，又将诺克史黛拉沉入地底，这与永恒之城的种种悖逆之举有关，他们制造了可以伤害无上意志和二指的猎杀指头刀，又试图通过仿身泪滴造出新的神灵，从而引来了无上意志的惩罚。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E6%9A%97%E5%BC%83%E5%AD%90%E8%89%BE%E6%96%AF%E6%8F%90.4mk6fn5wmoe0.webp" alt="黑暗弃子艾斯提"></p><p>巨大的身躯由星星构成，面部是一张令人不寒而栗的骷髅脸，拥有通过黑洞瞬移的能力</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>当褪色者攻进王城，踏入王座大厅之时，我们会遇到一位身上长满犄角，面貌丑陋的王：噩兆王蒙葛特。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%99%A9%E5%85%86%E7%8E%8B-(3).17zez1e8xhk0.webp" alt="噩兆王-(3)"></p><p>他是一位悲剧的半神，因为长相丑陋，自出生时就和兄弟蒙格一同被扔进了王城的下水道，虽然是黄金王朝的王子过得却是老鼠一般的生活。他本应诅咒这个畸形的世界，但讽刺的是，当艾尔登法环破碎后，群雄逐鹿，王城也遭到各路人马的进攻，曾经的半神和神人们纷纷自立门户，只有这位生活在下水道里的噩兆王蒙葛特，在关键时间挑起了守城的重任，并击退了所有来犯之敌，多次保住了黄金王城，在碎片战争中，他甚至击败了有着最强半神名号的拉塔恩将军。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%99%A9%E5%85%86%E7%8E%8B.zz7mh0ns0cw.webp" alt="噩兆王"></p><p>击败蒙葛特后，他的追忆中这样描述：即使生为赐福无缘的恶兆之子，蒙葛特仍愿意为黄金树的守卫，不是因为被爱，想要回馈，而是他单纯希望去爱。似乎与这个黄金王朝的命运一样，他身后的王座只需轻轻一碰就变成了碎片。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>当“黄金”葛德文成为死王子后，古龙就待在他的好友体内，不停与死亡搏斗，在死眠少女菲雅的梦境中，我们见到了传说中的“死龙”弗尔桑克斯。</p><p>当死龙飞翔在天空手持红雷配上木星大红斑似的背景，场景混乱又充满了阴郁的美感。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%AD%BB%E9%BE%99.2o7vqe77gfq0.webp" alt="死龙"></p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>在亚坛高原西边的火山地区，这里有黄金王朝的司法官拉卡德，是一个毫无怜悯心的法官，也是众多拷问官的长官。如蛇一般，令人感到生厌的男人。</p><p>拉卡德是拉达冈和满月女王的孩子之一。对于黄金树信仰而言，“……拉卡德犯下了亵渎罪，是罪无可赦的敌人。”艾尔登法环破碎之前的拉卡德是残酷的司法官，整个牢镇随处可见被折磨虐待的白金之子。在破碎战争中，他曾是反对黄金树的霸王，反叛黄金树信仰，反对无上意志，为了追求更强的力量反抗黄金树主动被大蛇吞噬。我们会先通过小蛇女的邀请加入名为叛律者的组织。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%AB%E5%B1%B1%E5%AE%98%E9%82%B8%E5%B0%8F%E8%9B%87%E5%A5%B3.1uuo8t56o7k0.webp" alt="火山官邸小蛇女"></p><p>那些具有反对黄金树潜质的英雄们，会被邀请到火山府邸，完成一系列亵渎（反抗黄金律法）之举。但是在拉卡德变成大蛇之后，因为最终能出色完成任务的叛律者都要去谒见拉卡德，而这些叛律者最终的遭遇，就和拉卡德曾经的骑士一样被吞噬，变成大蛇的一部分。</p><p>在完成了火山官邸安排的红灵入侵任务（击杀其他褪色者）后，拉卡德的侧室塔尼斯，一个一直戴着面具替拉卡德处理日常事务的女人，终于同意我们觐见亵渎君王拉卡德。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%8D%A1%E5%BE%B7.2qqguzuqhsg0.webp" alt="拉卡德"></p><p>在大蛇前的不远处，有一把大蛇狩猎矛，与大蛇对峙时，能形成风暴似的光刃</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E6%8B%89%E5%8D%A1%E5%BE%B7-%E9%A3%8E%E6%9A%B4%E7%9F%9B.1x5z2bhjz51c.webp" alt="拉卡德-风暴矛"></p><p>在拉卡德被风暴之刃击败后，他的侧室会跪坐在大蛇的尸体处，不断地啃食着尸体的头部，希望借此变成蛇人继承他的意志，算是交界地的一对苦命鸳鸯了。</p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E.3kbc2m7gnqw.webp" alt="女武神"></p><p>女武神玛莲妮亚，“米凯拉的锋刃”，手下有战无不胜的尊腐骑士大军，装上义手，带上飞翼头盔，掌握那高展飞翼的技能“水鸟乱舞”。为了帮哥哥米凯拉登上王位参加碎片战争，女武神玛莲妮亚在外四处征战，鲜血君王蒙格趁虚而入将米凯拉从圣树中掳走，玛莲妮亚率领大军一路南下寻找线索，而罪魁祸首蒙格的鲜血王朝就在盖利德地区（碎星将军拉塔恩的统治区域）的地下深处。当女武神赶到盖利德时，认为是拉塔恩抢走了哥哥米凯拉，与驻守于此的碎星将军以及他的红狮子军团展开了一场惊天动地的大战，史称艾奥尼亚之战。在最终的对决中，娇艳的腐败花朵怒放，吞噬了整个艾奥尼亚。拉塔恩与玛莲妮亚战成平手。这场无人胜利的战争伴随着玛莲妮亚的昏迷和拉塔恩的疯狂落下帷幕。</p><p>昏迷的玛莲妮亚被英雄芬雷带回圣树，从那以后好像迷失了自我，安安静静坐在圣树深处，等待着哥哥回归。</p><p>在我们第一次击倒女武神之后，她再次释放了体内的猩红腐败之力</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E4%BA%8C%E9%98%B6%E6%AE%B5.4e8xbca3rrg.webp" alt="女武神二阶段"></p><p>玛莲妮亚如同一只妖艳而致命的蝴蝶飞翔在空中，展现着完全状态下女武神的恐怖力量，她重重的将刀劈向地面，一朵朵猩红腐败之花怒放。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E4%BA%8C%E9%98%B6%E6%AE%B5.5dvcazx35ag0.webp" alt="女武神二阶段"></p><p>击败女武神之后获得的大卢恩也如同她本人一样，也充满了猩红腐败的力量</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A5%B3%E6%AD%A6%E7%A5%9E%E5%A4%A7%E5%8D%A2%E6%81%A9.1zwty3tfz5q8.webp" alt="女武神大卢恩"></p><h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><p>不得不说，玛莉卡的子嗣们，也就是半神们，都有着自己的野心和理想。鲜血君王蒙格，与孪生兄弟噩兆王蒙葛特一起守卫王城之时，也期望能建立属于自己的鲜血王朝。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%B1%B3%E5%87%AF%E6%8B%89%E7%9A%84%E8%8C%A7.3mgjvu8tfwq0.webp" alt="米凯拉的茧"></p><p>在碎片战争中，蒙格绑走了神人米凯拉，神人是神的候补，在玛莉卡女王失踪之后有着成为神的资格，蒙格利用血茧培育着米凯拉，当米凯拉成神之际，自己就可以以艾尔登之王的身份君临天下。殊不知，是蒙格自己的愿望，还是米凯拉的诱惑导致的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%92%99%E6%A0%BC%E5%92%8C%E7%B1%B3%E5%87%AF%E6%8B%89.1bciyje0cckg.webp" alt="蒙格和米凯拉"><br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E8%92%99%E6%A0%BC.1x6uysx08ug0.webp" alt="蒙格"></p><h2 id="十"><a href="#十" class="headerlink" title="十"></a>十</h2><p>天空城里的黑剑玛利喀斯是玛莉卡女王忠诚的结拜弟弟，将命定之死寄宿在自身的剑里，令所有的半神感到畏惧。而就是因为它们明白何谓畏惧，才会是英雄。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E5%89%91%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%BC%80%E5%A4%B4.2zezr2k3z8e0.webp" alt="黑剑二阶段开头"></p><p>在阴谋之夜，死亡的一部分被偷走之后，玛利喀斯把黑剑封印在自己体内，为的是不再让它失窃。</p><p>褪色者和黑剑第一次相遇是在盖利德的最北边的野兽祭祀塔，见到的是野兽祭祀模样的玛利喀斯，穿着肮脏破烂的外衣，迫切的渴望着死根，在吃了四个死根之后他甚至会陷入疯狂攻击我们，在十个死根完全收集之后，他会从祭祀塔里消失，下一次再见是在天空城。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BB%91%E5%89%91.1wx0hv9col28.webp" alt="黑剑"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%BE%99%E7%8E%8B.41eybrgpofo0.webp" alt="龙王"><br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%AB%E5%B1%B1%E5%B7%A8%E4%BA%BA.183gb0scvxog.webp" alt="火山巨人"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%9B%B8%E9%81%87%E5%88%9D%E4%BB%A3%E7%8E%8B.2u204qv0zhs0.webp" alt="相遇初代王"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%88%9D%E4%BB%A3%E7%8E%8B%E6%8B%A6%E8%B7%AF.7acl2a2g6xc0.webp" alt="初代王拦路"></p><p>圣树的女武神是我死亡次数最多的boss，但有猎犬步伐加上耍无赖的用了冤魂绕圈打法，其实难度并没有打只狼的一心艰难，就是得多挂几次学一下怎么躲水鸟，法师的一个问题是血太薄，被水鸟的任何一个连招中的两刀砍到就没了。王城下水道的“恶兆之子”蒙格和鲜血王朝的“碎片君王”蒙格我也没什么战斗记忆，只要记得喝滴露就可以破解他的倒计时大招。火焰巨人倒真是卡住了我一段时间，因为遍地打滚被压碎了好几次，放弃了当甘道夫的想法选择用岩石球就很容易了。龙王普拉顿桑克斯可以说是后期除了女武神之外第二强的boss，瞬移，秒人光炮，大范围龙爪aoe，黑刀姐第一次boss半血都没到就被打没了，主要是每死一次得跑一阵才能到boss房，技能也没有死龙酷炫，基本每招都能秒我，战斗体验很糟糕。然后是黑剑，黑剑二阶段的战斗身姿是最帅的，那套盔甲配上黑剑的火焰燃烧特效从天上劈下刀光非常引人入胜，但整体并不难打，因为他血很薄又没有女武神那样的吸血buff，平台上还有几根石柱，虽然不能秦王绕柱但可以躲柱子后面喝口药回回状态。初代王荷莱露说实话出场表演很一般，并没有感觉到初代艾尔登之王的逼格，猎犬步伐躲投技，跳起来躲大范围捶地aoe，二阶段撕狮子那段很惊讶，但后面鞋子的特写有点出戏（鞋带不好系啊），二阶段在骨灰和女战士（现在是史东威尔城城主）也没什么难度就过了。最终boss红毛拉达冈和艾尔登之兽在圣龙徽护符+2，螃蟹肉和祷告圣防护的buff下打了两次就过了，红毛有个问题，就是读指令的动作太明显了，属于敌不动我不动那种，没有动作游戏的体验，就像只狼里的弦一郎加一心我打了快一天才赢，但是结束以后就觉得很爽，弹刀出刀忍义手有一种见招拆招的快感，跟拉达冈打就像回合制游戏，他出招我就翻滚，等他技能后摇我再砍一剑然后继续泥地打滚或者猎犬步伐找机会。<br>战灰的加入虽然简化了战斗，但个别骨灰的强势导致我完全没有想法使用其他的骨灰，点名黑刀姐和仿身泪滴。仿身泪滴在我玩的时候已经被削，不再是大哥了，但它血厚啊。黑刀姐就更强了，战技经常放还是比例掉血，会瞬移，移动灵活。攻击欲望强，打大型怪跟战神一样，当然希望宫崎老贼的更新方式是加强其他骨灰而不是削已有的强势骨灰。</p><p>你将会在游戏里遇到以下角色：</p><p>一个姑娘告诉你她的城堡里奴隶造反了，她的城主父亲正在努力抵抗叛军，她给你一封信，让你带给他父亲，劝说他离开。于是你杀进城堡找到她父亲，结果他父亲说自己奉葛瑞克大人（这片区域的君王）抵抗叛军，不能离开，关键是镇城之剑不能落入叛军之手，于是你又杀了叛军的老大拿回了剑，你以为城主这下可以和女儿团聚了，于是高兴滴回去找姑娘，结果发现姑娘已经倒在了血泊中，旁边赫然插着奴隶们使用的大刀。你沮丧地回去找城主，却发现不知情的城主说自己的任务已经完成了，未来要为女儿而活……再回到和妹子相遇的地方，会见到这个心碎的父亲在女儿的尸体旁捶地怒吼，高喊要为了女儿复仇。后期在一间充满尸臭的破屋里，这个父亲会失智地攻击我们。复仇已经吞噬了他的心，也许倒在玩家的剑下，和女儿团聚，是对他来说最好的结局。</p><p>在魔法学院外，你会遇到一个落魄魔法师托普斯，求你给他十块钱去弄点吃的，他会教你魔法作为报酬。他教的魔法有点奇怪（比如一个可以照明用魔法，虽然没有战斗力但很实用），他说自己很有自知之明，知道自己是块朽木，很遗憾不能教给玩家好的魔法，他希望能进入魔法学院去研究。之后玩家找到魔法学院钥匙可以交给他，他会非常感谢你然后离去。在玩家探索魔法学院的时候，可以在某一个地方找到托普斯的尸体：被绑在椅子上，死前似乎依然在研究魔法。而调查他的尸体，可以发现他赌上性命研究的魔法：托普斯的立场。这个魔法的效果非常逆天，可以弹开所有魔法。物品介绍中这样描述：后世的人们会明白，那受人嘲讽的理念，其实是足以成立新教室的发现。</p><p>同样是魔法师，你会在某处遗迹地下室遇见一个女魔法师瑟廉，如果你希望她教你魔法，她会警告你自己是被魔法学院驱逐的魔女。如果玩家表示不介意的话，瑟廉会惊讶并表示愿意教我们魔法，并亲切称呼我们为徒弟。在玩家此后的征程中，老师知无不言，还会一直鼓励我们，甚至表示就算玩家一无所成，还是可以去找她，毕竟老师永远会给弟子留一个位置。然而随着剧情推进，我们会发现原来老师就是魔法学院里被称为“尸块魔女”的存在，为了探索禁忌的星星起源而杀害了无数魔法师。当玩家将两位大魔法师尸体的位置告诉老师后，老师最终会和他们融合，变成一颗恐怖的人面球，痛苦地向我们呻吟：“呜呜呜呜，徒弟，呜呜呜……”虽然探索禁忌的疯狂行为终究要付出代价，但即使是内心再怎么疯狂之人，对于那个当初不介意自己出身，愿意接纳自己的小徒弟，她依然愿意袒露内心真心相对。（也有说法人面球就是星星的雏形，老师其实是得道了）</p><p>在一座桥旁， 玩家会遇到一个长着手脚的壶被卡在地上，请求我们的帮忙。帮他脱困后，他会告诉我们自己是战士壶——铁拳亚历山大，正要去红狮子城参加战斗祭奠。他爽朗的笑声让人印象深刻。在战斗祭奠上携手壶哥一同击败半神拉塔恩将军后，壶哥会浑身裂痕趴在地上，告诉我们刚才我们的表现很棒，但自己没几下就被打趴下了，还出现了好多裂痕，壶里的内容物都漏出来了，好在这里有很多战士的尸体，可以弥补遗失的内容物。我们这才知道原来战士壶就是战士尸体的容器，他是战士们战意的承载者。为了变得更强，壶哥决定去火山官邸旁的熔岩接受高温炙烤，又去巨人雪山寻找神火锻造自己，最终他和我们在天空城相逢。每次碰面，他总是用爽朗的笑声回应我们，好像不管何种失意都不会影响他的斗志，尽管他身上的裂痕越来越多。在天空城，壶哥邀请我们作为他的一场试炼，因为我们是他认可的英雄。开打后我们发现，相比其他战士壶，壶哥强太多太多了，他不但可以喷火，甚至挥手就可以掀起火焰风暴，一双铁拳使出的火焰升龙拳甚至可以击飞曾经弑神的玩家。但是壶的承载度终归有限，壶哥还是倒下了。他告诉我们，他知道壶终归只是壶，但作为战士，他战斗到了最后一刻。最终，在爽朗的笑声中，壶哥像其他战士壶一样碎裂成了碎片。</p><p>在游戏中，你会遇到一个自称霍劳斯的骑士，说他和女仆走散了，如果你见到了可以告诉他，还说如果有人敢动他女仆他就不客气了，嘴上还说着霍劳斯以血代言（用让你出血代替用嘴逼逼），给人感觉是个狠人。后来在魔法学院前，你发现他找到了已经被杀害的女仆，他告诉你凶手是火山官邸的人，他非要复仇不可，因为霍劳斯家族以血代言。后来在大本营，他告诉你他找到了火山官邸的人，但对方竟然要拉他入伙，他表示自己气的要大开杀戒了。让人大跌眼镜的是，当玩家进入火山官邸后，竟然见到霍劳斯，他告诉你，他也加入火山官邸了，不想复仇了。他还自己找了一个理由：英雄不会刻意走干净的路，我要选择一条污秽的路来证明我的英雄气概。无数玩家在他的脚下留言：前有大便，前无马（妈），愤怒！等等来表达内心的不满。之后霍劳斯屡屡出任务失败（火山官邸以猎杀同类为任务），他向玩家诉苦自己这双手根本不适合成为英雄。玩家通过支线任务也得知原来霍劳斯有一个哥哥，由于弟弟太过没用，哥哥名正言顺当上了家主，也一直爱着弟弟，并希望弟弟不要走上霍劳斯以血代言的铁血道路。但弟弟也一直想着走出哥哥的阴影……后来在壶村，玩家发现霍劳斯逃出了火山官邸，在这里当上了维壶师，维修这里的战士壶，虽然这份工作看起来低微，但看着在自己的维护下，壶们一个个恢复健康，霍劳斯说：我从火山官邸逃了出来，从所有地方逃了出来，逃避一切。说出来你可能不信，但我在这里，才有了真正活着的感觉。一段时间后玩家回来，会发现所有的壶都碎了，只有一个小壶还完好，而霍劳斯只剩下最后一口气。原来村里遇到了偷猎者，是霍劳斯用性命击退了他们。当你告诉霍劳斯壶都没事时，他会欣慰地说，就算是自己这样没用的人，也会有派上用场的时候，并最后说出了那句他一直挂在嘴边的话：霍劳斯以血代言。在他的尸体旁，全是玩家的留言，几乎都是一样的内容：前有英雄。</p><p>在一座山洞中，你会遇到一个名为帕奇的光头，一开始他会攻击你，但如果你将他打到半血，他会跪地求饶，如果你放过他，他就开始拍你马屁。他的房间里放着一个宝箱，如果玩家去开，就会中陷阱被传送到别处，帕奇还会嘲笑我们是贪婪之徒。之后玩家可以在火山官邸遇到他，他会将自己的猎杀任务让给你（大概率是太强他自己打不过），如果你完成了任务，他会说帮你去汇报，但不会把任务奖励给你，除非你亲自问他才会不情愿地给你，但就是这样一个滑头，却在游戏里得到善终，逍遥快活。</p><p>NPC不得善终，几乎是魂系列的定律，那些坚持原则的角色，大部分落得凄惨的下场，反而是帕奇这样的角色，却能活得游刃有余，这何尝不是对现实世界的一种无情嘲弄。当然，那些明知不可为而为之的角色，虽然最终陨落，但却实实在在给玩家的心里留下了一份感动。</p><p>———3.21更新————</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>艾尔登法环评价</title>
      <link href="/2022/05/16/elden-ring/"/>
      <url>/2022/05/16/elden-ring/</url>
      
        <content type="html"><![CDATA[<p>说实话，作为我第一款全价购买的steam游戏，艾尔登法环就像一场盛宴，他几乎满足了我对奇幻世界和宏大史诗的全部期待。从四月一日到四月十八日，一周目耗时105小时，完成了所有的结局和几乎所有的支线，在此感谢“老戴解说”，在他的视频帮助下我成功体验到了老头环的魅力，还有全成就(^_^)。</p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%85%A8%E6%88%90%E5%B0%B1.4l3lk90t6qe0.webp" alt="全成就"></p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><h3 id="1-宏大史诗和庞大的世界观。"><a href="#1-宏大史诗和庞大的世界观。" class="headerlink" title="1.宏大史诗和庞大的世界观。"></a>1.宏大史诗和庞大的世界观。</h3><p>最早接触的魂类游戏是只狼，在我多周目不同的结局后，我开始体验到魂类游戏的魅力，虽然黑魂3前期打boss对我来说并不难，但有个很头疼的问题是迷路，这也是弃坑黑魂3的原因。我个人非常喜欢宏大世界观和史诗故事，看完了龙崎棒棒糖所有关于黑魂背景的介绍视频之后，我很期待乔治马丁和宫崎老贼能描绘出多么精彩的画卷，在剧情和背景的设定上，老头环达到了我对游戏的最高评价。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%87%BA%E7%94%9F%E7%82%B9.77c6cdw5yuw0.webp" alt="出生点"></p><h3 id="2-美学设计-前有绝景"><a href="#2-美学设计-前有绝景" class="headerlink" title="2.美学设计/前有绝景"></a>2.美学设计/前有绝景</h3><p>我从出生点开始，就不断的F12截图，一直到游戏结束，既是记录游戏剧情，也是对游戏画面的感叹。虽然老头环的贴图不算精细，但整体环境充满了特点，并且在老头环，不同的地区会有不同的场景描绘，不像黑魂都是黑暗阴森。<br><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%8F%B2%E4%B8%9C%E5%A8%81%E5%B0%94%E5%9F%8E.2xo9rwygi9c0.webp" alt="史东威尔城"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%8F%B2%E4%B8%9C%E5%A8%81%E5%B0%94%E5%9F%8E-(2).50o20o1khwk0.webp" alt="史东威尔城-(2)"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%9C%B0%E4%B8%8B%E5%9F%8E-(2).7efse996mpw0.webp" alt="地下城-(2)"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%8E%8B%E5%9F%8E-%E4%BA%8C%E5%91%A8%E7%9B%AE.i8o7uazbitk.webp" alt="王城-二周目"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E9%9B%AA%E5%B1%B1-%E5%89%8D%E6%9C%89%E7%BB%9D%E6%99%AF.5skhjn3gcl00.webp" alt="雪山-前有绝景"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E5%A4%A9%E7%A9%BA%E5%9F%8E.1e9s8xlcq1a8.webp" alt="天空城"></p><p><img src="https://cdn.jsdelivr.net/gh/upuphero/image-hosting@master/elden/%E7%81%B0%E5%9F%8E.33b3v6b97dk0.webp" alt="灰城"></p><h2 id="中性（个人看法）"><a href="#中性（个人看法）" class="headerlink" title="中性（个人看法）"></a>中性（个人看法）</h2><h3 id="1-战斗设计"><a href="#1-战斗设计" class="headerlink" title="1.战斗设计"></a>1.战斗设计</h3><p>说实话这种类似黑魂的战斗体验并没有很优秀，快慢刀加读指令还是很头痛的，个人来说还是更喜欢只狼那种偏向ACT的战斗风格，而不是满地打滚当驴学派玩家。不过法师的加入让老头环入门更加简单，作为不用灵魂激流就喜欢月光剑贴脸砍的狂战士甘道夫，虽然少部分时候在受苦，整体来说战斗体验还是不错的。</p><p>但是！后期圣树，雪山和雪原，数值膨胀的太离谱了，不刷级不行，印象深刻的是圣树罗蕾塔门口的两个魔法师，顶级法师了属于是，攻击力极高，血贼厚，没有蓝条，远比后面的罗蕾塔boss强，地方又狭窄，别说战斗了，就是跑酷都不好跑。（打到这的时候就感叹这里的每个小兵都能暴捶葛瑞克之流）</p><h3 id="2-地图设计"><a href="#2-地图设计" class="headerlink" title="2.地图设计"></a>2.地图设计</h3><p>前期洞窟和地面城池的设计算是非常巧妙，很多地方有捷径或者意想不到的到达方式，虽然依然有各种转角遇到背刺的小兵和石像鬼，但这也算是法环作为恐怖游戏的一种标签，但后期雪原非常空旷，如果不是进去的暴风雪挡住了视线，刚进去的那里什么都没有</p><h3 id="3-NPC设计"><a href="#3-NPC设计" class="headerlink" title="3.NPC设计"></a>3.NPC设计</h3><p>NPC的设计可以说是有好有坏，描写非常深刻的有战士壶亚历山大狼哥还有亲爱的老师瑟廉，但其他的就不是那么印象深刻了，其实如果可以把支线连在一起看，大部分NPC都是有血有肉（虽然绝大部分都是悲剧结局）但巧就巧在法环的内容量太大，又有接下来提到的任务指引问题，只有看攻略猛攻一个故事，才能体会深刻，就比如说海德要塞那个城主，要我来回跑图（中途还没有赐福）才能接近完成任务。还有个问题是老头环里的NPC跟投币木马似的，话总是不一次讲完，必须得不停的对话。<br>顺便一提，传说中的魂系经典人物帕奇，说实话如果没有这层buff帕奇就是个杂兵，在一周目我通过攻略经历了所有和帕奇有关的故事，包括被他在火山地区踹下悬崖。我非常不理解为什么玩家们会喜欢这样一个偷奸耍滑作奸犯科的NPC，在二周目我选择直接把他砍翻，除了几个猎杀褪色者任务，即使没有他整个故事流程也没有影响。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><h3 id="1-最垃圾：任务指引"><a href="#1-最垃圾：任务指引" class="headerlink" title="1.最垃圾：任务指引"></a>1.最垃圾：任务指引</h3><p>任务指引其实不能用垃圾来形容，应该是完全没有。碎片化叙事我可以接受，以往的魂类游戏都是在一个走廊里把剧本一张张放好（不一定按顺序），但现在，他把剧本撒在了一个六十层大楼里，需要不断地上蹿下跳去找，而且里面还有各种各样的粪坑。我不相信作为一个普通玩家能够在不看攻略的情况下做完大部分任务，甚至说，不看攻略连很多支线都不知道在哪开始接。<br>作为一个开放世界，没有任务清单意味着我根本记不住多个任务，一边在被小兵暴杀的同时我还要记下一步支线怎么走？好些NPC我一开始不看攻略一头雾水， “你谁啊就跟我搭话”<br>更别说什么商人卖的情报了，有些商人藏在什么鸟不拉屎的地方啊，举个例子，卡利亚学院传送门那里，那个商人在传送门后面的断桥处，但是，你不能通过传送门走，要沿着断桥走，断桥上全是树木和灌木丛遮挡视线，还有一片狼群，然后才能看到商人，不看攻略哪个正常人会在看到传送门的情况下往断桥里钻？<br>就算有商人的情报，米莉森的支线还有三指女巫的支线的地点就完全没有提示，本来任务流程的间隔非常大，这些支线本身体量又有限，开放世界进一步分割并加剧了任务的碎片化，你必须得在这个开放世界闲逛，才能找到他们，这样就光剩碎片没故事了。<br>主线剧情有个大问题是我把老婆当柴火烧了树以后就黑屏到天空城了？到了天空城我为什么要去揍黑剑？什么提示也没有就让我去拿命定之死？命定之死前面只提到可以干掉半神，没说干掉黑剑释放命定之死才能真正烧黄金树。<br>如果只能通过看攻略才能完成任务，那么作为一款游戏我认为法环的任务指引是极其失败的。<br>有人会洗白说这是魂系游戏的特色，“老ass一周目基本不会上网查看攻略的，最多交流下自己发现的问题。魂游戏的一周目无知探索是最有乐趣的而且这个无知不可逆。”但这是开放世界，不是以往的线性叙事，魂系游戏的前提是游戏，这么大的游戏体量难道要我一个普通玩家拿个笔记本自己记？</p><h3 id="2-部分物品获得设计"><a href="#2-部分物品获得设计" class="headerlink" title="2.部分物品获得设计"></a>2.部分物品获得设计</h3><p>故事散布在大楼里就算了，问题是底下还有粪坑，在死根深处有个传说护符，需要穿过一片黑暗的蚂蚁窝，就是在黑暗中，你得辨别蚂蚁窝的布局看着无数只巨大蚂蚁在边上进攻骑马穿梭跳跃，我是真的被恶心到了，纯粹的生理恶心，这个护符的放置地点让我不可能给这个游戏打满分，纯粹故意恶心玩家，不会有打着魂类游戏的旗号的昆虫爱好者喜欢吧，不会吧不会吧<br>更别提什么大手怪还有蚯蚓脸了，但好歹没有那种强制你盯着看的设计出现<br>还有各种各样的奇怪藏东西地点，让我感觉制作组只是故意把他们藏在玩家找不到的地点，而不是打完一场战斗后的战利品，我在收集物品时（特别是后期）完全没有那种“原来在这里”的惊喜</p><h3 id="3-跑酷设计"><a href="#3-跑酷设计" class="headerlink" title="3.跑酷设计"></a>3.跑酷设计</h3><p>在小兵和房顶穿梭的时间远远大于打boss的时间，很多无意义的堆怪耗尽耐心。印象最深的是卡利亚学院楼顶的跑酷，跳到有一处房顶的时候，本来距离就远不太好跳，还在这里布置了一个类似只狼的风筝怪，我在空中被它打下去很多次，我忍了很久才没有卸游戏。当然有人洗白说这是魂系游戏的特点，我只能说适当的恶心人可以，恶心多了就只能徒增厌恶</p><h3 id="4-剧情bug"><a href="#4-剧情bug" class="headerlink" title="4.剧情bug"></a>4.剧情bug</h3><p>黑剑和野兽祭祀，这是很多人都提到的bug了，打完黑剑野兽祭祀还在，有些人洗白说这是不同时空的黑剑，但老头环前面没有出现什么时空分割的设定，我倾向于是有个bug或者是这部分没做完就拿出来发售了。<br>吐槽一下，还有烧树后飞到天空城，这都啥啊就飞上去了？咋飞的啊，要是梅琳娜有这本事她怎么不早用呢。有人说是桂奥尔龙墓的那条大白龙带我们到天空城的，但这都只是解包推测的，本身剧情就是有断层，即使后续有更新但游戏都发售了总得先有个自圆其说的解释吧，拿个什么商人情报或者犄角旮旯里的碎片先当谜语人也行啊，但什么都没有，即使洗白有法环体量大的理由，但事实在这里，在这一段就是有剧情上的漏洞。<br>还有一个是关于火山巨人的，他不是被黄金家族干倒了吗，都被玛莉卡控制了怎么二阶段还可以通过献祭获得邪神力量啊？要是能和邪神沟通有自我意识为什么要阻止我烧树，不应该高高兴兴把黄金树给点了吗，又何必打上这一架。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode01 K Sum</title>
      <link href="/2022/04/13/LeetCode01/"/>
      <url>/2022/04/13/LeetCode01/</url>
      
        <content type="html"><![CDATA[<p>终于开始正式刷题了。这也是第一篇学习笔记，我计划用两个月的时间从头开始学习算法和leetcode，争取在秋招前刷完200题</p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>起步就是最简单的第一题，<br>英文名：1. Two Sum</p><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>没有学过算法的我第一反应就是暴力解法，直接遍历算一圈就可以完事，但通常会超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target == nums[i] + nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;nums[i], nums[j]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>我也是第一次接触时间复杂度和空间复杂度这两个概念</p><h6 id="具体学习链接-算法的时间与空间复杂度（一看就懂）"><a href="#具体学习链接-算法的时间与空间复杂度（一看就懂）" class="headerlink" title="具体学习链接:算法的时间与空间复杂度（一看就懂）"></a>具体学习链接:<a href="https://zhuanlan.zhihu.com/p/50479555">算法的时间与空间复杂度（一看就懂）</a></h6><h5 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h5><p>时间复杂度：执行算法花了多长时间<br>空间复杂度：执行算法花了多少内存</p><h4 id="常见的时间复杂度量级有："><a href="#常见的时间复杂度量级有：" class="headerlink" title="常见的时间复杂度量级有："></a>常见的时间复杂度量级有：</h4><h5 id="1-常数阶O-1"><a href="#1-常数阶O-1" class="headerlink" title="1. 常数阶O(1)"></a>1. 常数阶O(1)</h5><p>重点：没有循环等复杂结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><h5 id="2-对数阶O-logN"><a href="#2-对数阶O-logN" class="headerlink" title="2. 对数阶O(logN)"></a>2. 对数阶O(logN)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后i就大于n，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log<sub>2</sub>(n)<br>这里把数字设成2，当n无限大的时候，数字是多少都无所谓，所以统称为logN</p><h5 id="3-线性阶O-n"><a href="#3-线性阶O-n" class="headerlink" title="3. 线性阶O(n)"></a>3. 线性阶O(n)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的。<br>简而言之，n跟结果有关系就不是常数阶，一个循环对应一个线性阶</p><h5 id="4-线性对数阶O-nlogN"><a href="#4-线性对数阶O-nlogN" class="headerlink" title="4. 线性对数阶O(nlogN)"></a>4. 线性对数阶O(nlogN)</h5><p>线性对数阶O(nlogN) 就是把时间复杂度为O(logN)的代码外面套一个循环，循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-平方阶O-n-2"><a href="#5-平方阶O-n-2" class="headerlink" title="5. 平方阶O($n^2$)"></a>5. 平方阶O($n^2$)</h5><p>总结：两个循环或者说两个线性阶套娃 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-立方阶O-n-3"><a href="#6-立方阶O-n-3" class="headerlink" title="6. 立方阶O($n^3$)"></a>6. 立方阶O($n^3$)</h5><p>总结：三个循环或者说三个线性阶套娃 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(y=<span class="number">1</span>;y&lt;=n;y++&gt;)&#123;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="7-K次方阶O-n-k"><a href="#7-K次方阶O-n-k" class="headerlink" title="7. K次方阶O($n^k$)"></a>7. K次方阶O($n^k$)</h5><p>总结：K个循环或者说K个线性阶套娃 </p><h5 id="8-指数阶-2-n"><a href="#8-指数阶-2-n" class="headerlink" title="8. 指数阶(2^n)"></a>8. 指数阶(2^n)</h5><p>回忆一下指数的图像，随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aFunc( n ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aFunc(n - <span class="number">1</span>) + aFunc(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常见的空间复杂度量级有：O-1-、O-n-、O-n²"><a href="#常见的空间复杂度量级有：O-1-、O-n-、O-n²" class="headerlink" title="常见的空间复杂度量级有：O(1)、O(n)、O(n²)"></a>常见的空间复杂度量级有：O(1)、O(n)、O(n²)</h4><h5 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h5><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h5 id="2-O-n"><a href="#2-O-n" class="headerlink" title="2. O($n$)"></a>2. O($n$)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><h5 id="3-O-n-2"><a href="#3-O-n-2" class="headerlink" title="3. O($n^2$)"></a>3. O($n^2$)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h6 id="具体学习链接-夜深人静写算法（四十四）-n-数之和"><a href="#具体学习链接-夜深人静写算法（四十四）-n-数之和" class="headerlink" title="具体学习链接:夜深人静写算法（四十四）- n 数之和"></a>具体学习链接:<a href="https://mp.weixin.qq.com/s/CE7Bz3SN2JJxLZXMw8p6Yg">夜深人静写算法（四十四）- n 数之和</a></h6><h6 id="fucking-algorithm-算法思维系列-二分查找详解-md"><a href="#fucking-algorithm-算法思维系列-二分查找详解-md" class="headerlink" title="fucking-algorithm/算法思维系列/二分查找详解.md"></a><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">fucking-algorithm/算法思维系列/二分查找详解.md</a></h6><h5 id="二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数"><a href="#二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数" class="headerlink" title="二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数"></a>二分查找简单来说就是从中间一个数开始分成两边，左边找一下，找不到就找右边的，右边里发现了这个数，就再通过中间一个数分成两边，循环至找到这个数</h5><h4 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲回这道题</p><h5 id="1-对数组排序；"><a href="#1-对数组排序；" class="headerlink" title="1.对数组排序；"></a>1.对数组排序；</h5><h5 id="2-从前往后枚举第一个数-nums-i-；"><a href="#2-从前往后枚举第一个数-nums-i-；" class="headerlink" title="2.从前往后枚举第一个数 nums[i]；"></a>2.从前往后枚举第一个数 nums[i]；</h5><h5 id="3-由于数组是有序的，所以可以从剩下的数中，二分查找target-nums-i-，一旦找到，则返回二元组-nums-i-target-nums-i-；"><a href="#3-由于数组是有序的，所以可以从剩下的数中，二分查找target-nums-i-，一旦找到，则返回二元组-nums-i-target-nums-i-；" class="headerlink" title="3.由于数组是有序的，所以可以从剩下的数中，二分查找target - nums[i]，一旦找到，则返回二元组 { nums[i], target - nums[i] }；"></a>3.由于数组是有序的，所以可以从剩下的数中，二分查找<code>target - nums[i]</code>，一旦找到，则返回二元组 <code>&#123; nums[i], target - nums[i] &#125;；</code></h5><h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><h6 id="具体学习链接-夜深人静写算法（四十四）-n-数之和-1"><a href="#具体学习链接-夜深人静写算法（四十四）-n-数之和-1" class="headerlink" title="具体学习链接:夜深人静写算法（四十四）- n 数之和"></a>具体学习链接:<a href="https://mp.weixin.qq.com/s/CE7Bz3SN2JJxLZXMw8p6Yg">夜深人静写算法（四十四）- n 数之和</a></h6><h6 id="fucking-algorithm-算法思维系列-二分查找详解-md-1"><a href="#fucking-algorithm-算法思维系列-二分查找详解-md-1" class="headerlink" title="fucking-algorithm/算法思维系列/二分查找详解.md"></a><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.md">fucking-algorithm/算法思维系列/二分查找详解.md</a></h6><h6 id="具体学习链接-小白-Python-几种解法"><a href="#具体学习链接-小白-Python-几种解法" class="headerlink" title="具体学习链接:小白 Python 几种解法"></a>具体学习链接:<a href="https://leetcode-cn.com/problems/two-sum/solution/xiao-bai-pythonji-chong-jie-fa-by-lao-la-rou-yue-j/">小白 Python 几种解法</a></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i!=j:</span><br><span class="line">                <span class="keyword">return</span> [i,j]</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 46 ms, faster than 90.61% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 14.3 MB, less than 45.68% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure><p>改进版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [i,hashmap.get(target - num)]</span><br><span class="line">            hashmap[num] = i <span class="comment">#这句不能放在if语句之前，解决list中有重复值或target-num=num的情况</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 41 ms, faster than 95.66% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 14.4 MB, less than 45.68% of Python online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>解算出来的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       seen = &#123;&#125;</span><br><span class="line">       <span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">           remaining = target - nums[i]</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> remaining <span class="keyword">in</span> seen:</span><br><span class="line">               <span class="keyword">return</span> [i, seen[remaining]]</span><br><span class="line">            </span><br><span class="line">           seen[value] = i </span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 68 ms, faster than 84.35% of Python3 online submissions <span class="keyword">for</span> Two Sum.</span><br><span class="line">Memory Usage: 15.3 MB, less than 25.99% of Python3 online submissions <span class="keyword">for</span> Two Sum.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plan</title>
      <link href="/2021/10/05/plan/"/>
      <url>/2021/10/05/plan/</url>
      
        <content type="html"><![CDATA[<h1 id="Steins-Gate"><a href="#Steins-Gate" class="headerlink" title="Steins;Gate"></a>Steins;Gate</h1>]]></content>
      
      
      
        <tags>
            
            <tag> schedule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2021/09/24/first-blog/"/>
      <url>/2021/09/24/first-blog/</url>
      
        <content type="html"><![CDATA[<p>这里是记录研究生生活和学习的第一篇文章，也是一切的开始。<br>生活篇分为日记，回忆，生活技巧。</p><h2 id="日记1"><a href="#日记1" class="headerlink" title="日记1"></a>日记1</h2><h3 id="2021-9-24"><a href="#2021-9-24" class="headerlink" title="2021.9.24"></a>2021.9.24</h3><p>已经是上课的第三周了，逐渐习惯了这样的学习节奏和自己做饭的生活。今天烧了一份红烧蹄膀。在华超买的蹄膀，让人出乎意料的事蹄膀居然是最便宜的肉类，真是暴殄天物啊。</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to start the first blog</title>
      <link href="/2021/09/24/%E5%A6%82%E4%BD%95%E5%86%99blog/"/>
      <url>/2021/09/24/%E5%A6%82%E4%BD%95%E5%86%99blog/</url>
      
        <content type="html"><![CDATA[<h1 id="创建新blog"><a href="#创建新blog" class="headerlink" title="创建新blog"></a>创建新blog</h1><h2 id="个人博客学习总结"><a href="#个人博客学习总结" class="headerlink" title="个人博客学习总结"></a><a href="https://www.zhihu.com/column/c_1201860091307458560">个人博客学习总结</a></h2><p>基本可以按照这个流程走</p><p><a href="http://localhost:4000/">http://localhost:4000/</a></p><h2 id="hexo-美化"><a href="#hexo-美化" class="headerlink" title="hexo 美化"></a>hexo 美化</h2><p><a href="https://blog.csdn.net/wizardforcel/article/details/40684953?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-40684953-blog-97758641.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3">Hexo 入门指南（四） - 页面、导航、边栏、底栏</a></p><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p><a href="https://picx.xpoet.cn/#/management">https://picx.xpoet.cn/#/management</a></p><p><a href="https://tholman.com/github-corners/">github corners</a></p><p><a href="http://www.fontawesome.com.cn/faicons/#web-application">图标</a></p><p><a href="https://hexo.io/zh-cn/docs/writing">https://hexo.io/zh-cn/docs/writing</a></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a><a href="https://zhuanlan.zhihu.com/p/26625249">流程</a></h2>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/07/hello-world/"/>
      <url>/2021/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
