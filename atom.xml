<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  <subtitle>Engineering House</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-20T04:09:01.013Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/08/20/205/"/>
    <id>http://example.com/2022/08/20/205/</id>
    <published>2022-08-20T04:07:47.299Z</published>
    <updated>2022-08-20T04:09:01.013Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 205. Isomorphic Strings(easy)<br>date: 2022-08-20 00:07:47<br>tags: [ ‘leetcode’, ‘Python’,’hashmap’ ,’hashset’]<br>categories: study<br>cover: <a href="https://cdn.staticaly.com/gh/upuphero/image-hosting@master/allied.zxxjnfadtog.webp">https://cdn.staticaly.com/gh/upuphero/image-hosting@master/allied.zxxjnfadtog.webp</a></p><h1 id="205-Isomorphic-Strings-easy"><a href="#205-Isomorphic-Strings-easy" class="headerlink" title="205. Isomorphic Strings(easy)"></a>205. Isomorphic Strings(easy)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 205. Isomorphic Strings(easy)&lt;br&gt;date: 2022-08-20 00:07:47&lt;br&gt;tags: [ ‘leetcode’, ‘Python’,’hashmap’ ,’hashset’]&lt;br&gt;categorie</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>202. Happy Number(easy)</title>
    <link href="http://example.com/2022/08/19/202/"/>
    <id>http://example.com/2022/08/19/202/</id>
    <published>2022-08-19T21:05:01.000Z</published>
    <updated>2022-08-20T04:08:55.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202-Happy-Number-easy"><a href="#202-Happy-Number-easy" class="headerlink" title="202. Happy Number(easy)"></a>202. Happy Number(easy)</h1><h2 id="Write-an-algorithm-to-determine-if-a-number-n-is-happy"><a href="#Write-an-algorithm-to-determine-if-a-number-n-is-happy" class="headerlink" title="Write an algorithm to determine if a number n is happy."></a>Write an algorithm to determine if a number n is happy.</h2><h2 id="A-happy-number-is-a-number-defined-by-the-following-process"><a href="#A-happy-number-is-a-number-defined-by-the-following-process" class="headerlink" title="A happy number is a number defined by the following process:"></a>A happy number is a number defined by the following process:</h2><h2 id="Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits"><a href="#Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits" class="headerlink" title="Starting with any positive integer, replace the number by the sum of the squares of its digits."></a>Starting with any positive integer, replace the number by the sum of the squares of its digits.</h2><h2 id="Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1"><a href="#Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1" class="headerlink" title="Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1."></a>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</h2><h2 id="Those-numbers-for-which-this-process-ends-in-1-are-happy"><a href="#Those-numbers-for-which-this-process-ends-in-1-are-happy" class="headerlink" title="Those numbers for which this process ends in 1 are happy."></a>Those numbers for which this process ends in 1 are happy.</h2><h2 id="Return-true-if-n-is-a-happy-number-and-false-if-not"><a href="#Return-true-if-n-is-a-happy-number-and-false-if-not" class="headerlink" title="Return true if n is a happy number, and false if not."></a>Return true if n is a happy number, and false if not.</h2><p>又是一个奇怪的数，叫做happy number</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">官方题解</a></h3><p>总结一下，数字每一位的平方和后的结果有两种可能性</p><ol><li>变成1</li><li>变成循环</li></ol><p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限增大的选择。</p><p>算法</p><p>算法分为两部分，我们需要设计和编写代码。</p><p>给一个数字 nn，它的下一个数字是什么？<br>按照一系列的数字来判断我们是否进入了一个循环。</p><ol><li><p>我们按照题目的要求做数位分离，求平方和。</p></li><li><p>可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p></li></ol><p>如果它不在哈希集合中，我们应该添加它。<br>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</p><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p>Hashmap解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n_history=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                n_history[n]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                n_history[n]=<span class="number">0</span></span><br><span class="line">                digit_li=[<span class="built_in">str</span>(n)[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(n)))]</span><br><span class="line">                n=<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="built_in">int</span>(x))**<span class="number">2</span>,digit_li)))</span><br><span class="line">                <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">```                </span><br><span class="line">相当于把数字n转换成字符串，再进行平方和运算                </span><br><span class="line">```python                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            seen.add(n)</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">str</span>(n)</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> num:</span><br><span class="line">                temp += <span class="built_in">int</span>(ch)**<span class="number">2</span></span><br><span class="line">            n = temp            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hashset解法</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)   <span class="comment">#divmod求余数</span></span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>() <span class="comment"># python里hashset的本质就是set</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = get_next(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;202-Happy-Number-easy&quot;&gt;&lt;a href=&quot;#202-Happy-Number-easy&quot; class=&quot;headerlink&quot; title=&quot;202. Happy Number(easy)&quot;&gt;&lt;/a&gt;202. Happy Number(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
  <entry>
    <title>169. Majority Element(easy)</title>
    <link href="http://example.com/2022/08/19/169/"/>
    <id>http://example.com/2022/08/19/169/</id>
    <published>2022-08-19T20:38:31.000Z</published>
    <updated>2022-08-20T04:08:46.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="169-Majority-Element-easy"><a href="#169-Majority-Element-easy" class="headerlink" title="169. Majority Element(easy)"></a>169. Majority Element(easy)</h1><h2 id="Given-an-array-nums-of-size-n-return-the-majority-element"><a href="#Given-an-array-nums-of-size-n-return-the-majority-element" class="headerlink" title="Given an array nums of size n, return the majority element."></a>Given an array nums of size n, return the majority element.</h2><h2 id="The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array"><a href="#The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array" class="headerlink" title="The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array."></a>The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h4 id="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"><a href="#堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。" class="headerlink" title="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"></a>堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。</h4><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        hashmap = &#123;&#125;        n=len(nums)        for ans in nums:            if ans not in hashmap:                hashmap[ans]=1            else:                hashmap[ans]+=1        for ans in hashmap:            if hashmap[ans]&gt;n//2:                return ans</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;169-Majority-Element-easy&quot;&gt;&lt;a href=&quot;#169-Majority-Element-easy&quot; class=&quot;headerlink&quot; title=&quot;169. Majority Element(easy)&quot;&gt;&lt;/a&gt;169. Majo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree (Easy)</title>
    <link href="http://example.com/2022/08/17/101/"/>
    <id>http://example.com/2022/08/17/101/</id>
    <published>2022-08-18T03:42:45.000Z</published>
    <updated>2022-08-18T21:36:30.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a>101. Symmetric Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center"><a href="#Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center" class="headerlink" title="Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center)."></a>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type root: TreeNode</span></span><br><span class="line"><span class="string">:rtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left,right</span>):</span></span><br><span class="line"><span class="comment"># 递归的终止条件是两个节点都为空</span></span><br><span class="line"><span class="comment"># 或者两个节点中有一个为空</span></span><br><span class="line"><span class="comment"># 或者两个节点的值不相等</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> left.val!=right.val:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> dfs(left.left,right.right) <span class="keyword">and</span> dfs(left.right,right.left)</span><br><span class="line"><span class="comment"># 用递归函数，比较左节点，右节点</span></span><br><span class="line"><span class="keyword">return</span> dfs(root.left,root.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-Symmetric-Tree-Easy&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree (Easy)&quot;&gt;&lt;/a&gt;101. Symmetric</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>572. Subtree of Another Tree (Easy)</title>
    <link href="http://example.com/2022/08/17/572/"/>
    <id>http://example.com/2022/08/17/572/</id>
    <published>2022-08-18T03:39:46.000Z</published>
    <updated>2022-08-18T21:35:14.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="572-Subtree-of-Another-Tree-Easy"><a href="#572-Subtree-of-Another-Tree-Easy" class="headerlink" title="572. Subtree of Another Tree (Easy)"></a>572. Subtree of Another Tree (Easy)</h1><h2 id="Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise"><a href="#Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise" class="headerlink" title="Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise."></a>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</h2><h2 id="A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself"><a href="#A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself" class="headerlink" title="A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself."></a>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root, subRoot</span>) :</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> curr.val == subRoot.val :</span><br><span class="line">                <span class="keyword">if</span> self.compare(curr,subRoot):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> curr.right:</span><br><span class="line">                queue.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                queue.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self,curr,subRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr.val == subRoot.val :</span><br><span class="line">            r_flag = self.compare(curr.right,subRoot.right)</span><br><span class="line">            l_flag = self.compare(curr.left,subRoot.left)</span><br><span class="line">            <span class="keyword">if</span> r_flag <span class="keyword">and</span> l_flag:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;572-Subtree-of-Another-Tree-Easy&quot;&gt;&lt;a href=&quot;#572-Subtree-of-Another-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;572. Subtree of Another Tree</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>437. Path Sum III (Easy)</title>
    <link href="http://example.com/2022/08/17/437/"/>
    <id>http://example.com/2022/08/17/437/</id>
    <published>2022-08-18T03:34:41.000Z</published>
    <updated>2022-08-18T21:35:06.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="437-Path-Sum-III-Easy"><a href="#437-Path-Sum-III-Easy" class="headerlink" title="437. Path Sum III (Easy)"></a>437. Path Sum III (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</h2><h2 id="The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes"><a href="#The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes" class="headerlink" title="The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes)."></a>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><h3 id="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。"><a href="#我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。" class="headerlink" title="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。"></a>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。</h3><h3 id="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。"><a href="#对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。" class="headerlink" title="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。"></a>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。</h3><h3 id="假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p"><a href="#假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p" class="headerlink" title="假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p"></a>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p</h3><p>1<br>​<br> →p<br>2<br>​<br> →…→p<br>k<br>​<br> →node，此时我们可以已经保存了节点 p_1, p_2, p_3, \ldots, p_kp<br>1<br>​<br> ,p<br>2<br>​<br> ,p<br>3<br>​<br> ,…,p<br>k<br>​<br>  的前缀和，并且计算出了节点 node 的前缀和。</p><p>假设当前从根节点 root 到节点 node 的前缀和为 \textit{curr}curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 \textit{curr} - curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 p_ip<br>i<br>​<br>  到根节点 root 的前缀和为 \textit{curr} - curr−targetSum，则节点 p_{i+1}p<br>i+1<br>​<br>  到 node 的路径上所有节点的和一定为 targetSum。</p><p>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;437-Path-Sum-III-Easy&quot;&gt;&lt;a href=&quot;#437-Path-Sum-III-Easy&quot; class=&quot;headerlink&quot; title=&quot;437. Path Sum III (Easy)&quot;&gt;&lt;/a&gt;437. Path Sum III (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>112. Path Sum (Easy)</title>
    <link href="http://example.com/2022/08/16/112/"/>
    <id>http://example.com/2022/08/16/112/</id>
    <published>2022-08-17T03:37:14.000Z</published>
    <updated>2022-08-17T03:55:30.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a>112. Path Sum (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</h2><h2 id="A-leaf-is-a-node-with-no-children"><a href="#A-leaf-is-a-node-with-no-children" class="headerlink" title="A leaf is a node with no children."></a>A leaf is a node with no children.</h2><p><a href="https://leetcode.cn/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">官方题解</a></p><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p><p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p><p>复杂度分析</p><p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;112-Path-Sum-Easy&quot;&gt;&lt;a href=&quot;#112-Path-Sum-Easy&quot; class=&quot;headerlink&quot; title=&quot;112. Path Sum (Easy)&quot;&gt;&lt;/a&gt;112. Path Sum (Easy)&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>617. Merge Two Binary Trees (Easy)</title>
    <link href="http://example.com/2022/08/15/617/"/>
    <id>http://example.com/2022/08/15/617/</id>
    <published>2022-08-16T03:26:38.000Z</published>
    <updated>2022-08-17T03:55:09.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-Merge-Two-Binary-Trees-Easy"><a href="#617-Merge-Two-Binary-Trees-Easy" class="headerlink" title="617. Merge Two Binary Trees (Easy)"></a>617. Merge Two Binary Trees (Easy)</h1><h2 id="You-are-given-two-binary-trees-root1-and-root2"><a href="#You-are-given-two-binary-trees-root1-and-root2" class="headerlink" title="You are given two binary trees root1 and root2."></a>You are given two binary trees root1 and root2.</h2><h2 id="Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree"><a href="#Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree" class="headerlink" title="Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree."></a>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</h2><h2 id="Return-the-merged-tree"><a href="#Return-the-merged-tree" class="headerlink" title="Return the merged tree."></a>Return the merged tree.</h2><h2 id="Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees"><a href="#Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees" class="headerlink" title="Note: The merging process must start from the root nodes of both trees."></a>Note: The merging process must start from the root nodes of both trees.</h2><h3 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/">参考解析</a></h3><p>对于二叉树来说，如果我们像遍历数组那样，挨个遍历两颗二叉树中的每个节点，再把他们相加，那问题就比较容易解决了。</p><p>遍历二叉树很简单，用 前序 遍历就可以了，再依次把访问到的节点值相加，因为题目没有说不能改变树的值和结构，我们不用再创建新的节点了，直接将树2合并到树1上再返回就可以了。<br>需要注意：这两颗树并不是长得完全一样，有的树可能有左节点，但有的树没有。</p><p>总结下递归的条件：</p><p>终止条件：树 1 的节点为 null，或者树 2 的节点为 null<br>递归函数内：将两个树的节点相加后，再赋给树 1 的节点。再递归的执行两个树的左节点，递归执行两个树的右节点</p><p>总结一下就是把root2的值复制到root1上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root1,root2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root1 <span class="keyword">and</span> root2):</span><br><span class="line">                <span class="keyword">return</span> root1 <span class="keyword">if</span> root1 <span class="keyword">else</span> root2</span><br><span class="line">            root1.val += root2.val</span><br><span class="line">            root1.left = dfs(root1.left,root2.left)</span><br><span class="line">            root1.right = dfs(root1.right,root2.right)</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">return</span> dfs(root1,root2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;617-Merge-Two-Binary-Trees-Easy&quot;&gt;&lt;a href=&quot;#617-Merge-Two-Binary-Trees-Easy&quot; class=&quot;headerlink&quot; title=&quot;617. Merge Two Binary Trees (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>226. Invert Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/15/226/"/>
    <id>http://example.com/2022/08/15/226/</id>
    <published>2022-08-16T03:08:56.000Z</published>
    <updated>2022-08-17T03:54:54.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a>226. Invert Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root"><a href="#Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root" class="headerlink" title="Given the root of a binary tree, invert the tree, and return its root."></a>Given the root of a binary tree, invert the tree, and return its root.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode-solution/">官方题解</a></h3><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if not root:            return root        left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left = right        root.right = left        return root</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;226-Invert-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree (Easy)&quot;&gt;&lt;/a&gt;22</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>543. Diameter of Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/543/"/>
    <id>http://example.com/2022/08/14/543/</id>
    <published>2022-08-15T02:24:25.000Z</published>
    <updated>2022-08-16T03:26:12.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a>543. Diameter of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree"><a href="#Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree" class="headerlink" title="Given the root of a binary tree, return the length of the diameter of the tree."></a>Given the root of a binary tree, return the length of the diameter of the tree.</h2><h2 id="The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root"><a href="#The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root" class="headerlink" title="The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root."></a>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</h2><h2 id="The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them"><a href="#The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them" class="headerlink" title="The length of a path between two nodes is represented by the number of edges between them."></a>The length of a path between two nodes is represented by the number of edges between them.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/">官方题解</a></h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>其实我看到这道题感觉和<a href="https://upuphero.github.io/2022/08/14/110/">110. Balanced Binary Tree (Easy)</a>很像，可以在求高度的基础上稍微改一下<br>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p><p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p><p>我们记节点node 为起点的路径经过节点数的最大值为 d<sub>node</sub>，那么二叉树的直径就是所有节点 d<sub>node</sub>的最大值减一。</p><p>最后的算法流程为：我们定义一个递归函数 depth(node) 计算 d<sub>node</sub>，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为max(L,R)+1</p><p>该节点的 d<sub>node</sub> 值为L+R+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="comment"># 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 左儿子为根的子树的深度</span></span><br><span class="line">            L = depth(root.left)</span><br><span class="line">            <span class="comment"># 右儿子为根的子树的深度</span></span><br><span class="line">            R = depth(root.right)</span><br><span class="line">            <span class="comment"># 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, L + R + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 返回该节点为根的子树的深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        depth(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;543-Diameter-of-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#543-Diameter-of-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;543. Diameter of Binary Tree</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>110. Balanced Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/110/"/>
    <id>http://example.com/2022/08/14/110/</id>
    <published>2022-08-14T21:49:16.000Z</published>
    <updated>2022-08-16T02:54:48.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a>110. Balanced Binary Tree (Easy)</h1><h2 id="Given-a-binary-tree-determine-if-it-is-height-balanced"><a href="#Given-a-binary-tree-determine-if-it-is-height-balanced" class="headerlink" title="Given a binary tree, determine if it is height-balanced."></a>Given a binary tree, determine if it is height-balanced.</h2><h2 id="For-this-problem-a-height-balanced-binary-tree-is-defined-as"><a href="#For-this-problem-a-height-balanced-binary-tree-is-defined-as" class="headerlink" title="For this problem, a height-balanced binary tree is defined as:"></a>For this problem, a height-balanced binary tree is defined as:</h2><h2 id="a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1"><a href="#a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1" class="headerlink" title="a binary tree in which the left and right subtrees of every node differ in height by no more than 1."></a>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">两种办法</a></p><h3 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h3><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：<br>height(p)=max(height(p.left),height(p.right))+1 P是非空节点</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(height(root.left), height(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><h3 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h3><p>方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftHeight = height(root.left)</span><br><span class="line">            rightHeight = height(root.right)</span><br><span class="line">            <span class="keyword">if</span> leftHeight == -<span class="number">1</span> <span class="keyword">or</span> rightHeight == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;110-Balanced-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#110-Balanced-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;110. Balanced Binary Tree (Easy)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
    <category term="Tree" scheme="http://example.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>104. Maximum Depth of Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/104/"/>
    <id>http://example.com/2022/08/14/104/</id>
    <published>2022-08-14T19:58:34.000Z</published>
    <updated>2022-08-16T02:54:57.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a>104. Maximum Depth of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-its-maximum-depth"><a href="#Given-the-root-of-a-binary-tree-return-its-maximum-depth" class="headerlink" title="Given the root of a binary tree, return its maximum depth."></a>Given the root of a binary tree, return its maximum depth.</h2><h2 id="A-binary-tree’s-maximum-depth-is-the-number-of-nodes-along-the-longest-path-from-the-root-node-down-to-the-farthest-leaf-node"><a href="#A-binary-tree’s-maximum-depth-is-the-number-of-nodes-along-the-longest-path-from-the-root-node-down-to-the-farthest-leaf-node" class="headerlink" title="A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node."></a>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><p>这道题是求二叉树的深度，可以用深度优先搜索。<br>算法思想： 一个节点的高度=max(左孩子的高度,右孩子的高度)+1。 进行先序遍历搜索，每次递归返回的时候统计其左右孩子中最大的深度。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root is None:            return 0        else:            left_height = self.maxDepth(root.left)            right_height = self.maxDepth(root.right)            return max(left_height,right_height)+1</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;104-Maximum-Depth-of-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#104-Maximum-Depth-of-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;104. Maximum Depth</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
    <category term="Tree" scheme="http://example.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>328. Odd Even Linked List (Medium)</title>
    <link href="http://example.com/2022/08/06/328/"/>
    <id>http://example.com/2022/08/06/328/</id>
    <published>2022-08-07T03:14:11.000Z</published>
    <updated>2022-08-07T03:22:50.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="328-Odd-Even-Linked-List-Medium"><a href="#328-Odd-Even-Linked-List-Medium" class="headerlink" title="328. Odd Even Linked List (Medium)"></a>328. Odd Even Linked List (Medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-group-all-the-nodes-with-odd-indices-together-followed-by-the-nodes-with-even-indices-and-return-the-reordered-list"><a href="#Given-the-head-of-a-singly-linked-list-group-all-the-nodes-with-odd-indices-together-followed-by-the-nodes-with-even-indices-and-return-the-reordered-list" class="headerlink" title="Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list."></a>Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.</h2><h2 id="The-first-node-is-considered-odd-and-the-second-node-is-even-and-so-on"><a href="#The-first-node-is-considered-odd-and-the-second-node-is-even-and-so-on" class="headerlink" title="The first node is considered odd, and the second node is even, and so on."></a>The first node is considered odd, and the second node is even, and so on.</h2><h2 id="Note-that-the-relative-order-inside-both-the-even-and-odd-groups-should-remain-as-it-was-in-the-input"><a href="#Note-that-the-relative-order-inside-both-the-even-and-odd-groups-should-remain-as-it-was-in-the-input" class="headerlink" title="Note that the relative order inside both the even and odd groups should remain as it was in the input."></a>Note that the relative order inside both the even and odd groups should remain as it was in the input.</h2><h2 id="You-must-solve-the-problem-in-O-1-extra-space-complexity-and-O-n-time-complexity"><a href="#You-must-solve-the-problem-in-O-1-extra-space-complexity-and-O-n-time-complexity" class="headerlink" title="You must solve the problem in O(1) extra space complexity and O(n) time complexity."></a>You must solve the problem in O(1) extra space complexity and O(n) time complexity.</h2><p>总结是把奇数节点串一块儿，再把偶数节点串一起，然后把两个连成一条链表</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/odd-even-linked-list/solution/qi-ou-lian-biao-by-leetcode-solution/">官方题解</a></h3><p><img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        evenHead = head.<span class="built_in">next</span> <span class="comment">#新建一个链表头</span></span><br><span class="line">        odd, even = head, evenHead</span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">            odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">            odd = odd.<span class="built_in">next</span></span><br><span class="line">            even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">            even = even.<span class="built_in">next</span></span><br><span class="line">        odd.<span class="built_in">next</span> = evenHead</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;328-Odd-Even-Linked-List-Medium&quot;&gt;&lt;a href=&quot;#328-Odd-Even-Linked-List-Medium&quot; class=&quot;headerlink&quot; title=&quot;328. Odd Even Linked List (Med</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>725. Split Linked List in Parts(Medium)</title>
    <link href="http://example.com/2022/08/06/725/"/>
    <id>http://example.com/2022/08/06/725/</id>
    <published>2022-08-06T21:29:09.000Z</published>
    <updated>2022-08-07T03:16:30.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="725-Split-Linked-List-in-Parts-Medium"><a href="#725-Split-Linked-List-in-Parts-Medium" class="headerlink" title="725. Split Linked List in Parts(Medium)"></a>725. Split Linked List in Parts(Medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-and-an-integer-k-split-the-linked-list-into-k-consecutive-linked-list-parts"><a href="#Given-the-head-of-a-singly-linked-list-and-an-integer-k-split-the-linked-list-into-k-consecutive-linked-list-parts" class="headerlink" title="Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts."></a>Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.</h2><h2 id="The-length-of-each-part-should-be-as-equal-as-possible-no-two-parts-should-have-a-size-differing-by-more-than-one-This-may-lead-to-some-parts-being-null"><a href="#The-length-of-each-part-should-be-as-equal-as-possible-no-two-parts-should-have-a-size-differing-by-more-than-one-This-may-lead-to-some-parts-being-null" class="headerlink" title="The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null."></a>The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.</h2><h2 id="The-parts-should-be-in-the-order-of-occurrence-in-the-input-list-and-parts-occurring-earlier-should-always-have-a-size-greater-than-or-equal-to-parts-occurring-later"><a href="#The-parts-should-be-in-the-order-of-occurrence-in-the-input-list-and-parts-occurring-earlier-should-always-have-a-size-greater-than-or-equal-to-parts-occurring-later" class="headerlink" title="The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later."></a>The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.</h2><h2 id="Return-an-array-of-the-k-parts"><a href="#Return-an-array-of-the-k-parts" class="headerlink" title="Return an array of the k parts."></a>Return an array of the k parts.</h2><h3 id="题目描述：把链表分隔成-k-部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。"><a href="#题目描述：把链表分隔成-k-部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。" class="headerlink" title="题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。"></a>题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</h3><p>其实就是n个数分成m组，前面一些组多一个，n/m+1，后面的组数量是n/m</p><p><a href="https://leetcode.cn/problems/split-linked-list-in-parts/solution/fen-ge-lian-biao-by-leetcode-solution-wevt/">代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[ListNode]:</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node: <span class="comment">#一次遍历得到长度</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        quotient, remainder = L // k, L % k</span><br><span class="line"></span><br><span class="line">        parts = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]  <span class="comment">#create lists of size n and initialize with None</span></span><br><span class="line">        i, curr = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> i &lt; k <span class="keyword">and</span> curr:</span><br><span class="line">            parts[i] = curr</span><br><span class="line">            <span class="keyword">if</span> i&lt;remainder:</span><br><span class="line">                part_size = quotient + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                part_size = quotient</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(part_size - <span class="number">1</span>):</span><br><span class="line">                <span class="comment">#for _ in range:When you are not interested in some values returned by a function we use underscore in place of variable name . Basically it means you are not interested in how many times the loop is run till now just that it should run some specific number of times overall.</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> parts</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;725-Split-Linked-List-in-Parts-Medium&quot;&gt;&lt;a href=&quot;#725-Split-Linked-List-in-Parts-Medium&quot; class=&quot;headerlink&quot; title=&quot;725. Split Linked </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List (Easy)</title>
    <link href="http://example.com/2022/08/04/234/"/>
    <id>http://example.com/2022/08/04/234/</id>
    <published>2022-08-05T03:41:28.000Z</published>
    <updated>2022-08-07T03:14:40.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a>234. Palindrome Linked List (Easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-return-true-if-it-is-a-palindrome"><a href="#Given-the-head-of-a-singly-linked-list-return-true-if-it-is-a-palindrome" class="headerlink" title="Given the head of a singly linked list, return true if it is a palindrome."></a>Given the head of a singly linked list, return true if it is a palindrome.</h2><p>这道题的关键在于如何控制空间复杂度。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/">官方题解</a></h3><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n):"></a>O(n):</h3><p>简单来说就是把链表的数值全都存到数组里，然后再进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        vals = []</span><br><span class="line">        current_node = head</span><br><span class="line">        <span class="keyword">while</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            vals.append(current_node.val)</span><br><span class="line">            current_node = current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1):"></a>O(1):</h3><p>避免使用 O(n)额外空间的方法就是改变输入。</p><p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p><p>该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p><p>算法</p><p>整个流程可以分为以下五个步骤：</p><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        first_half_end = self.end_of_first_half(head)</span><br><span class="line">        second_half_start = self.reverse_list(first_half_end.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否回文</span></span><br><span class="line">        result = <span class="literal">True</span></span><br><span class="line">        first_position = head</span><br><span class="line">        second_position = second_half_start</span><br><span class="line">        <span class="keyword">while</span> result <span class="keyword">and</span> second_position <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> first_position.val != second_position.val:</span><br><span class="line">                result = <span class="literal">False</span></span><br><span class="line">            first_position = first_position.<span class="built_in">next</span></span><br><span class="line">            second_position = second_position.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 还原链表并返回结果</span></span><br><span class="line">        first_half_end.<span class="built_in">next</span> = self.reverse_list(second_half_start)</span><br><span class="line">        <span class="keyword">return</span> result    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_of_first_half</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = next_node</span><br><span class="line">        <span class="keyword">return</span> previous</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;234-Palindrome-Linked-List-Easy&quot;&gt;&lt;a href=&quot;#234-Palindrome-Linked-List-Easy&quot; class=&quot;headerlink&quot; title=&quot;234. Palindrome Linked List (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>445. Add Two Numbers II (Medium)</title>
    <link href="http://example.com/2022/08/04/445/"/>
    <id>http://example.com/2022/08/04/445/</id>
    <published>2022-08-05T03:38:49.000Z</published>
    <updated>2022-08-06T21:28:48.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="445-Add-Two-Numbers-II-Medium"><a href="#445-Add-Two-Numbers-II-Medium" class="headerlink" title="445. Add Two Numbers II (Medium)"></a>445. Add Two Numbers II (Medium)</h1><h2 id="You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-most-significant-digit-comes-first-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list"><a href="#You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-most-significant-digit-comes-first-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list" class="headerlink" title="You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list."></a>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</h2><h2 id="You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself"><a href="#You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself" class="headerlink" title="You may assume the two numbers do not contain any leading zero, except the number 0 itself."></a>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">Output: [7,8,0,7]</span><br></pre></td></tr></table></figure><p>这个例子想讲的其实就是7243+564=7807</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/">官方题解</a></h2><p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p><h3 id="对于逆序处理应该首先想到栈"><a href="#对于逆序处理应该首先想到栈" class="headerlink" title="对于逆序处理应该首先想到栈"></a>对于逆序处理应该首先想到栈</h3><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/zhang-by-kind-i3lackburnmaf-aamu/">代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s1 <span class="keyword">else</span> s1.pop()</span><br><span class="line">            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">else</span> s2.pop()</span><br><span class="line">            cur = a + b + carry</span><br><span class="line">            carry = cur // <span class="number">10</span></span><br><span class="line">            cur %= <span class="number">10</span></span><br><span class="line">            curnode = ListNode(cur)</span><br><span class="line">            curnode.<span class="built_in">next</span> = ans</span><br><span class="line">            ans = curnode</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;445-Add-Two-Numbers-II-Medium&quot;&gt;&lt;a href=&quot;#445-Add-Two-Numbers-II-Medium&quot; class=&quot;headerlink&quot; title=&quot;445. Add Two Numbers II (Medium)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>24. Swap Nodes in Pairs (Medium)</title>
    <link href="http://example.com/2022/08/04/24/"/>
    <id>http://example.com/2022/08/04/24/</id>
    <published>2022-08-05T03:28:03.000Z</published>
    <updated>2022-08-05T03:50:21.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a>24. Swap Nodes in Pairs (Medium)</h1><h2 id="Given-a-linked-list-swap-every-two-adjacent-nodes-and-return-its-head-You-must-solve-the-problem-without-modifying-the-values-in-the-list’s-nodes-i-e-only-nodes-themselves-may-be-changed"><a href="#Given-a-linked-list-swap-every-two-adjacent-nodes-and-return-its-head-You-must-solve-the-problem-without-modifying-the-values-in-the-list’s-nodes-i-e-only-nodes-themselves-may-be-changed" class="headerlink" title="Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)"></a>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(newHead.<span class="built_in">next</span>)</span><br><span class="line">        newHead.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;24-Swap-Nodes-in-Pairs-Medium&quot;&gt;&lt;a href=&quot;#24-Swap-Nodes-in-Pairs-Medium&quot; class=&quot;headerlink&quot; title=&quot;24. Swap Nodes in Pairs (Medium)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>19. Remove Nth Node From End of List (medium)</title>
    <link href="http://example.com/2022/08/01/19/"/>
    <id>http://example.com/2022/08/01/19/</id>
    <published>2022-08-02T02:17:04.000Z</published>
    <updated>2022-08-05T03:27:38.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-Remove-Nth-Node-From-End-of-List-medium"><a href="#19-Remove-Nth-Node-From-End-of-List-medium" class="headerlink" title="19. Remove Nth Node From End of List (medium)"></a>19. Remove Nth Node From End of List (medium)</h1><h2 id="Given-the-head-of-a-linked-list-remove-the-nth-node-from-the-end-of-the-list-and-return-its-head"><a href="#Given-the-head-of-a-linked-list-remove-the-nth-node-from-the-end-of-the-list-and-return-its-head" class="headerlink" title="Given the head of a linked list, remove the nth node from the end of the list and return its head."></a>Given the head of a linked list, remove the nth node from the end of the list and return its head.</h2><p>移除倒序的第n个节点</p><p>第一反应是两次遍历，第一次遍历先判断链表长度L，然后再遍历第二次算出应该删除的L−n+1节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">head: ListNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 添加哑结点dummy</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        length = getLength(head)</span><br><span class="line">        current = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - n + <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>方法二</p><h3 id="双指针解决问题思路："><a href="#双指针解决问题思路：" class="headerlink" title="双指针解决问题思路："></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/dong-hua-tu-jie-leetcode-di-19-hao-wen-ti-shan-chu/">双指针解决问题思路</a>：</h3><p>我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。</p><ol><li>设置虚拟节点 dummyHead 指向 head</li><li>设定双指针 p 和 q，初始都指向虚拟节点 dummyHead</li><li>移动 q，直到 p 与 q 之间相隔的元素个数为 n</li><li>同时移动 p 与 q，直到 q 指向的为 NULL</li><li>将 p 的下一个节点指向下下个节点</li></ol><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/">代码</a>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        first = head</span><br><span class="line">        second = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first:</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">            second = second.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加哑节点："><a href="#添加哑节点：" class="headerlink" title="添加哑节点："></a>添加哑节点：</h3><p>添加一个哑节点（dummy node），让它的next 指针指向链表的头节点。这样一来，头节点的前驱节点就是哑节点本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(0,head)  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;19-Remove-Nth-Node-From-End-of-List-medium&quot;&gt;&lt;a href=&quot;#19-Remove-Nth-Node-From-End-of-List-medium&quot; class=&quot;headerlink&quot; title=&quot;19. Remo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>83. Remove Duplicates from Sorted List (Easy)</title>
    <link href="http://example.com/2022/08/01/83/"/>
    <id>http://example.com/2022/08/01/83/</id>
    <published>2022-08-01T22:44:28.000Z</published>
    <updated>2022-08-01T22:46:08.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List (Easy)"></a>83. Remove Duplicates from Sorted List (Easy)</h1><h2 id="Given-the-head-of-a-sorted-linked-list-delete-all-duplicates-such-that-each-element-appears-only-once-Return-the-linked-list-sorted-as-well"><a href="#Given-the-head-of-a-sorted-linked-list-delete-all-duplicates-such-that-each-element-appears-only-once-Return-the-linked-list-sorted-as-well" class="headerlink" title="Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well."></a>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</h2><p>删除重复节点<br>因为是有序节点，经过一遍遍历，把重复的删除就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:            </span><br><span class="line">            <span class="keyword">if</span> current.val== current.<span class="built_in">next</span>.val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head     </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;83-Remove-Duplicates-from-Sorted-List-Easy&quot;&gt;&lt;a href=&quot;#83-Remove-Duplicates-from-Sorted-List-Easy&quot; class=&quot;headerlink&quot; title=&quot;83. Remo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List(easy)</title>
    <link href="http://example.com/2022/07/20/206/"/>
    <id>http://example.com/2022/07/20/206/</id>
    <published>2022-07-20T22:21:02.000Z</published>
    <updated>2022-07-21T03:24:20.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-Reverse-Linked-List-easy"><a href="#206-Reverse-Linked-List-easy" class="headerlink" title="206. Reverse Linked List(easy)"></a>206. Reverse Linked List(easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-reverse-the-list-and-return-the-reversed-list"><a href="#Given-the-head-of-a-singly-linked-list-reverse-the-list-and-return-the-reversed-list" class="headerlink" title="Given the head of a singly linked list, reverse the list, and return the reversed list."></a>Given the head of a singly linked list, reverse the list, and return the reversed list.</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p><p>反转数组，还是用双指针，另外设置了一个临时变量tmp记录current的下一个值<br>图例可以看这个<a href="https://leetcode.cn/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">回答</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current !=<span class="literal">None</span>:</span><br><span class="line">            tmp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-Reverse-Linked-List-easy&quot;&gt;&lt;a href=&quot;#206-Reverse-Linked-List-easy&quot; class=&quot;headerlink&quot; title=&quot;206. Reverse Linked List(easy)&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
</feed>
