<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  <subtitle>Engineering House</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-24T21:40:46.912Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-skill2-python_funciton</title>
    <link href="http://example.com/2022/08/24/LeetCode-skill2-python-funciton/"/>
    <id>http://example.com/2022/08/24/LeetCode-skill2-python-funciton/</id>
    <published>2022-08-24T21:16:04.000Z</published>
    <updated>2022-08-24T21:40:46.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-常用函数"><a href="#python-常用函数" class="headerlink" title="python 常用函数"></a>python 常用函数</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Python 的列表 List 基本就是其它语言的 Array.</p><h3 id="Initialization-初始化"><a href="#Initialization-初始化" class="headerlink" title="Initialization 初始化"></a>Initialization 初始化</h3><p>List 的初始化一般用 List comprehension，往往能一行解决问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1d array</span><br><span class="line">l = [0 for _ in range(len(array)]</span><br><span class="line"></span><br><span class="line"># 2d</span><br><span class="line">l = [[0 for i in range(cols)] for j in range(rows)]</span><br></pre></td></tr></table></figure><h3 id="Start-from-the-behind"><a href="#Start-from-the-behind" class="headerlink" title="Start from the behind"></a>Start from the behind</h3><p>你可以轻松从后往前访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lastElement = l[-1]</span><br><span class="line"></span><br><span class="line">lastTwo = l[-2:]</span><br><span class="line"></span><br><span class="line">for i in range(0, -10, -1)</span><br><span class="line"># 0, -1, -2, -3, -4, -5, -6, -7, -8, -9</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="copy-复制"><a href="#copy-复制" class="headerlink" title="copy 复制"></a>copy 复制</h3><h3 id="shallow-copy-浅拷贝"><a href="#shallow-copy-浅拷贝" class="headerlink" title="shallow copy 浅拷贝"></a>shallow copy 浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l2 = l1[:]</span><br><span class="line"># or</span><br><span class="line">l2 = l1.copy()</span><br></pre></td></tr></table></figure><p>浅复制的问题在于，如果 l1 内部还有 list，那么这种嵌套的索引不能被复制，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, [3, 4]]</span><br><span class="line">b = a[:]</span><br><span class="line">a[2].append(5)</span><br><span class="line">print(b)</span><br><span class="line"># [1, 2, [3, 4, 5]]</span><br></pre></td></tr></table></figure><h3 id="deep-copy-深拷贝"><a href="#deep-copy-深拷贝" class="headerlink" title="deep copy 深拷贝"></a>deep copy 深拷贝</h3><p>所以如果要做深拷贝，要节制自带库 copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">copy.deepcopy()</span><br></pre></td></tr></table></figure><h3 id="enumerate-枚举"><a href="#enumerate-枚举" class="headerlink" title="enumerate 枚举"></a>enumerate 枚举</h3><p>当我们需要枚举一个数组并同时获得值与 index 的时候可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">for i, v in enumerate(l):</span><br><span class="line">    print(i, v)</span><br><span class="line"># 0 a</span><br><span class="line"># 1 b</span><br><span class="line"># 2 c</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip 本意就是拉链，可以想象成将两个数组像拉链一样挨个聚合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce 可以分别对相邻元素使用同一种计算规则，同时每一步结果作为下一步的参数，很典型的函数式编程用法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># importing functools for reduce()</span><br><span class="line">import functools</span><br><span class="line"># initializing list</span><br><span class="line">lis = [ 1, 3, 5, 6, 2, ]</span><br><span class="line"></span><br><span class="line"># using reduce to compute sum of list</span><br><span class="line">print (&quot;The sum of the list elements is : &quot;,end=&quot;&quot;)</span><br><span class="line">print (functools.reduce(lambda a,b : a+b,lis))</span><br><span class="line"></span><br><span class="line"># The sum of the list elements is : 17</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>可以将参数一一映射来计算， 比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date = &quot;2019-8-15&quot;</span><br><span class="line">Y, M, D = map(int, date.split(&#x27;-&#x27;))</span><br><span class="line"># Y = 2019, M = 8, D = 15</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>list 删除末尾的操作是O(1)的，但是删除头操作就是O(n)，这时候我们就需要一个双端队列 deque。<br>首尾的常规操作为：</p><p>append，添加到末尾<br>appendleft, 添加到开头<br>pop, 剔除末尾<br>popleft，移除开头</p><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>list 自身有自带的 sort(), 但是它不返回新的 list. sorted 能返回一个新的 list, 并且支持传入参数reverse。</p><p>比如我们有一个 tuple 的数组，我们想按照 tuple 的第一个元素进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1 = [(1,2), (0,1), (3,10) ]</span><br><span class="line"></span><br><span class="line">l2 = sorted(l1, key=lambda x: x[0])</span><br><span class="line"></span><br><span class="line"># l2 = [(0, 1), (1, 2), (3, 10)]</span><br></pre></td></tr></table></figure><p>这里的 key 允许传入一个自定义参数，也可以用自带函数进行比较，比如在一个 string 数组里只想比较小写，可以传入key=str.lower</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1 = [&quot;banana&quot;,&quot;APPLE&quot;, &quot;Watermelon&quot;]</span><br><span class="line">l2 = sorted(l1, key=str.lower)</span><br><span class="line">print(l2)</span><br><span class="line"></span><br><span class="line"># [&#x27;APPLE&#x27;, &#x27;banana&#x27;, &#x27;Watermelon&#x27;]</span><br></pre></td></tr></table></figure><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>你注意到我们在上面使用了 lambda 来定义一个匿名函数，十分方便。如果你熟悉其它语言类似 JS 的话，可以把它理解成一个 callback 函数，参数名一一对应就行。</p><h3 id="cmp-to-key"><a href="#cmp-to-key" class="headerlink" title="cmp_to_key"></a>cmp_to_key</h3><p>在 python3 中，sorted 函数取消了自带的cmp函数，需要借助functools 库中的 cmp_to_key来做比较。<br>比如如果要按照数组元素的绝对值来排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from functools import cmp_to_key</span><br><span class="line">def absSort(arr):</span><br><span class="line">    newarr = sorted(arr, key = cmp_to_key(sortfunc))</span><br><span class="line">    return newarr</span><br><span class="line">def sortfunc(a, b):</span><br><span class="line">    if abs(a) &lt; abs(b):</span><br><span class="line">      return -1</span><br><span class="line">    elif abs(a) &gt; abs(b):</span><br><span class="line">      return 1</span><br><span class="line">    else:</span><br><span class="line">      return a - b</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 的查找操作复杂度为O(1)，有时候可以替代dict 来存储中间过程。</p><p>add : set 的添加是 add 不是append</p><p>remove vs discard: 都是删除操作，区别在于remove不存在的元素会报错，discard不会。</p><p>union, intersection: 快速获得并集和交集，方便一些去重操作。</p><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>字典，相当于其它语言中的map, hashtable, hashmap之类的，读取操作也是O(1) 复杂度</p><h3 id="keys-values-items"><a href="#keys-values-items" class="headerlink" title="keys(), values(), items()"></a>keys(), values(), items()</h3><p>这三个方法可以分别获得key, value, {key: value}的数组。</p><h3 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault"></a>setdefault</h3><p>这个函数经常在初始化字典时候使用，如果某个key在字典中存在，返回它的value, 否则返回你给的 default 值。比如在建一个 trie 树的时候</p><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>OrderedDict 能记录你 key 和 value 插入的顺序，底层其实是一个双向链表加哈希表的实现。我们甚至可以使用move_to_end这样的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = OrderedDict.fromkeys(&#x27;abcde&#x27;)</span><br><span class="line">&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;)</span><br><span class="line">&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())</span><br><span class="line">&#x27;acdeb&#x27;</span><br><span class="line"># 放开头</span><br><span class="line">&gt;&gt;&gt; d.move_to_end(&#x27;b&#x27;, last=False)</span><br><span class="line">&gt;&gt;&gt; &#x27;&#x27;.join(d.keys())</span><br><span class="line">&#x27;bacde&#x27;</span><br></pre></td></tr></table></figure><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>defaultdict可以很好地来解决一些初始化的问题，比如 value 是一个 list，每次需要判断 key 是否存在的情况。这时我们可以直接定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = defaultdict(list)</span><br><span class="line"></span><br><span class="line">s = [(&#x27;yellow&#x27;, 1), (&#x27;blue&#x27;, 2), (&#x27;yellow&#x27;, 3), (&#x27;blue&#x27;, 4), (&#x27;red&#x27;, 1)]</span><br><span class="line">for k, v in s:</span><br><span class="line">     d[k].append(v)</span><br><span class="line">sorted(d.items())</span><br><span class="line"># [(&#x27;blue&#x27;, [2, 4]), (&#x27;red&#x27;, [1]), (&#x27;yellow&#x27;, [1, 3])]</span><br></pre></td></tr></table></figure><h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><p>heapq 就是 python 的 priority queue，heapq[0]即为堆顶元素。</p><p>heapq 的实现是小顶堆，如果需要一个大顶堆，常规的一个做法是把值取负存入，取出时再反转。<br>以下是借助 heapq 来实现 heapsort 的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def heapsort(iterable):</span><br><span class="line">...     h = []</span><br><span class="line">...     for value in iterable:</span><br><span class="line">...         heappush(h, value)</span><br><span class="line">...     return [heappop(h) for i in range(len(h))]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>python 自带二分查找的库，在一些不要求实现 binary search，但是借助它能加速的场景下可以直接使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect(a, x, lo=0, hi=len(a))</span><br><span class="line">这里的参数分别为 数组，要查找的数，范围起始点，范围结束点</span><br></pre></td></tr></table></figure><p>相似函数还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bisect.bisect_left</span><br><span class="line">bisect.bisect_right</span><br></pre></td></tr></table></figure><p>分别返回可以插入 x 的最左和最右 index</p><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>Counter 接受的参数可以是一个 string, 或者一个 list, mapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = Counter()                           # a new, empty counter</span><br><span class="line">&gt;&gt;&gt; c = Counter(&#x27;gallahad&#x27;)                 # a new counter from an iterable</span><br><span class="line">&gt;&gt;&gt; c = Counter(&#123;&#x27;red&#x27;: 4, &#x27;blue&#x27;: 2&#125;)      # a new counter from a mapping</span><br><span class="line">&gt;&gt;&gt; c = Counter(cats=4, dogs=8)             # a new counter from keyword args</span><br></pre></td></tr></table></figure><p>most_common(n)<br>可以得到出现次数最多的 n 个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Counter(&#x27;abracadabra&#x27;).most_common(3)  # doctest: +SKIP</span><br><span class="line">[(&#x27;a&#x27;, 5), (&#x27;r&#x27;, 2), (&#x27;b&#x27;, 2)]</span><br></pre></td></tr></table></figure><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><h3 id="ord-char"><a href="#ord-char" class="headerlink" title="ord, char"></a>ord, char</h3><p>ord 返回单个字符的 unicode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&#x27;a&#x27;)</span><br><span class="line">97</span><br></pre></td></tr></table></figure><p>char 则是反向操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(100)</span><br><span class="line">&#x27;d&#x27;</span><br></pre></td></tr></table></figure><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p>移除 string 前后的字符串，默认来移除空格，但是也可以给一个字符串，然后会移除含有这个字符串的部分：</p><p>``</p><blockquote><blockquote><blockquote><p>‘   spacious   ‘.strip()<br>‘spacious’<br>‘<a href="http://www.example.com&/#39;.strip(&#39;cmowz.&#39;)">www.example.com&#39;.strip(&#39;cmowz.&#39;)</a><br>‘example’<br>``</p></blockquote></blockquote></blockquote><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>按照某个字符串来切分，返回一个 list, 可以传入一个参数maxsplit来限定分离数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;)</span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;1,2,3&#x27;.split(&#x27;,&#x27;, maxsplit=1)</span><br><span class="line">[&#x27;1&#x27;, &#x27;2,3&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;1,2,,3,&#x27;.split(&#x27;,&#x27;)</span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;&#x27;]</span><br></pre></td></tr></table></figure><h2 id="int-float"><a href="#int-float" class="headerlink" title="int/ float"></a>int/ float</h2><h3 id="最大-最小-number"><a href="#最大-最小-number" class="headerlink" title="最大, 最小 number"></a>最大, 最小 number</h3><p>有时候初始化我们需要设定 Math.max() 和 Math.min(), 在 python 中分别以 float(‘inf’) 和 float(‘-inf’)表示</p><p>或者也可以用math库里的 math.inf 和 math.inf</p><p>在 python2 中我们也可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#maxint</span><br><span class="line">Max = sys.maxint</span><br></pre></td></tr></table></figure><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>在 python3 中， / 会保留浮点，相当于 float 相除，如果需要做到像 pyhton2 中的 int 相除，需要 //：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 / 2</span><br><span class="line">1.5</span><br><span class="line">&gt;&gt;&gt; 3 // 2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p>在 python 中为 **:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 ** 10</span><br><span class="line">1024</span><br></pre></td></tr></table></figure><h2 id="conditions"><a href="#conditions" class="headerlink" title="conditions"></a>conditions</h2><p>在 python 的三项表达式(ternary operation) 与其它语言不太一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = a if condition else b</span><br></pre></td></tr></table></figure><p>它表示如果 condition 满足，那么 res = a, 不然 res = b，在类 c 的语言里即为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = condition ? a : b;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python-常用函数&quot;&gt;&lt;a href=&quot;#python-常用函数&quot; class=&quot;headerlink&quot; title=&quot;python 常用函数&quot;&gt;&lt;/a&gt;python 常用函数&lt;/h1&gt;&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="python function" scheme="http://example.com/tags/python-function/"/>
    
  </entry>
  
  <entry>
    <title>304. Range Sum Query 2D - Immutable(medium)</title>
    <link href="http://example.com/2022/08/24/304/"/>
    <id>http://example.com/2022/08/24/304/</id>
    <published>2022-08-24T20:43:59.000Z</published>
    <updated>2022-08-24T21:15:31.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="304-Range-Sum-Query-2D-Immutable-medium"><a href="#304-Range-Sum-Query-2D-Immutable-medium" class="headerlink" title="304. Range Sum Query 2D - Immutable(medium)"></a>304. Range Sum Query 2D - Immutable(medium)</h1><h2 id="Given-a-2D-matrix-matrix-handle-multiple-queries-of-the-following-type"><a href="#Given-a-2D-matrix-matrix-handle-multiple-queries-of-the-following-type" class="headerlink" title="Given a 2D matrix matrix, handle multiple queries of the following type:"></a>Given a 2D matrix matrix, handle multiple queries of the following type:</h2><h2 id="Calculate-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2"><a href="#Calculate-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2" class="headerlink" title="Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2)."></a>Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</h2><h2 id="Implement-the-NumMatrix-class"><a href="#Implement-the-NumMatrix-class" class="headerlink" title="Implement the NumMatrix class:"></a>Implement the NumMatrix class:</h2><h3 id="NumMatrix-int-matrix-Initializes-the-object-with-the-integer-matrix-matrix"><a href="#NumMatrix-int-matrix-Initializes-the-object-with-the-integer-matrix-matrix" class="headerlink" title="NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix."></a>NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.</h3><h3 id="int-sumRegion-int-row1-int-col1-int-row2-int-col2-Returns-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2"><a href="#int-sumRegion-int-row1-int-col1-int-row2-int-col2-Returns-the-sum-of-the-elements-of-matrix-inside-the-rectangle-defined-by-its-upper-left-corner-row1-col1-and-lower-right-corner-row2-col2" class="headerlink" title="int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2)."></a>int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</h3><h2 id="You-must-design-an-algorithm-where-sumRegion-works-on-O-1-time-complexity"><a href="#You-must-design-an-algorithm-where-sumRegion-works-on-O-1-time-complexity" class="headerlink" title="You must design an algorithm where sumRegion works on O(1) time complexity."></a>You must design an algorithm where sumRegion works on O(1) time complexity.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/">官方题解</a></h3><p>这道题是303题的升级版，从一维数组升级成二维矩阵，同样是前缀和数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), (<span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="keyword">if</span> matrix <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        self.sums = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        _sums = self.sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                _sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = _sums[i][j + <span class="number">1</span>] + _sums[i + <span class="number">1</span>][j] - _sums[i][j] + matrix[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRegion</span>(<span class="params">self, row1: <span class="built_in">int</span>, col1: <span class="built_in">int</span>, row2: <span class="built_in">int</span>, col2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        _sums = self.sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - _sums[row1][col2 + <span class="number">1</span>] - _sums[row2 + <span class="number">1</span>][col1] + _sums[row1][col1]</span><br></pre></td></tr></table></figure><p>作者：LeetCode-Solution<br>链接：<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;304-Range-Sum-Query-2D-Immutable-medium&quot;&gt;&lt;a href=&quot;#304-Range-Sum-Query-2D-Immutable-medium&quot; class=&quot;headerlink&quot; title=&quot;304. Range Sum</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
    <category term="prefix sum" scheme="http://example.com/tags/prefix-sum/"/>
    
  </entry>
  
  <entry>
    <title>303. Range Sum Query - Immutable(easy)</title>
    <link href="http://example.com/2022/08/24/303/"/>
    <id>http://example.com/2022/08/24/303/</id>
    <published>2022-08-24T20:33:33.000Z</published>
    <updated>2022-08-24T20:42:33.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="303-Range-Sum-Query-Immutable-easy"><a href="#303-Range-Sum-Query-Immutable-easy" class="headerlink" title="303. Range Sum Query - Immutable(easy)"></a>303. Range Sum Query - Immutable(easy)</h1><h2 id="Given-an-integer-array-nums-handle-multiple-queries-of-the-following-type"><a href="#Given-an-integer-array-nums-handle-multiple-queries-of-the-following-type" class="headerlink" title="Given an integer array nums, handle multiple queries of the following type:"></a>Given an integer array nums, handle multiple queries of the following type:</h2><h2 id="Calculate-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive-where-left-lt-right"><a href="#Calculate-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive-where-left-lt-right" class="headerlink" title="Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right."></a>Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.</h2><h2 id="Implement-the-NumArray-class"><a href="#Implement-the-NumArray-class" class="headerlink" title="Implement the NumArray class:"></a>Implement the NumArray class:</h2><h2 id="NumArray-int-nums-Initializes-the-object-with-the-integer-array-nums"><a href="#NumArray-int-nums-Initializes-the-object-with-the-integer-array-nums" class="headerlink" title="NumArray(int[] nums) Initializes the object with the integer array nums."></a>NumArray(int[] nums) Initializes the object with the integer array nums.</h2><h2 id="int-sumRange-int-left-int-right-Returns-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive"><a href="#int-sumRange-int-left-int-right-Returns-the-sum-of-the-elements-of-nums-between-indices-left-and-right-inclusive" class="headerlink" title="int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive"></a>int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive</h2><h2 id="i-e-nums-left-nums-left-1-…-nums-right"><a href="#i-e-nums-left-nums-left-1-…-nums-right" class="headerlink" title="(i.e. nums[left] + nums[left + 1] + … + nums[right])."></a>(i.e. nums[left] + nums[left + 1] + … + nums[right]).</h2><p>最基础的前缀和问题<br><a href="https://leetcode.cn/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.sums = [<span class="number">0</span>]</span><br><span class="line">        _sums = self.sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            _sums.append(_sums[-<span class="number">1</span>] + num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        _sums = self.sums</span><br><span class="line">        <span class="keyword">return</span> _sums[j + <span class="number">1</span>] - _sums[i]</span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(left,right)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span>  <span class="comment"># 68 ms, faster than 97.72%</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.preSum = nums  <span class="comment"># pass by pointer!</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            self.preSum[i+<span class="number">1</span>] += self.preSum[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> self.preSum[right]</span><br><span class="line">        <span class="keyword">return</span> self.preSum[right] - self.preSum[left-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;303-Range-Sum-Query-Immutable-easy&quot;&gt;&lt;a href=&quot;#303-Range-Sum-Query-Immutable-easy&quot; class=&quot;headerlink&quot; title=&quot;303. Range Sum Query - I</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
    <category term="prefix sum" scheme="http://example.com/tags/prefix-sum/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-skill1-prefix_sum</title>
    <link href="http://example.com/2022/08/24/LeetCode-skill1-prefix-sum/"/>
    <id>http://example.com/2022/08/24/LeetCode-skill1-prefix-sum/</id>
    <published>2022-08-24T20:16:20.000Z</published>
    <updated>2022-08-24T21:16:43.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀和（prefix-sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现-“子数组和”-或者-“连续的子数组”-既可以考虑使用前缀和来求解会得到不错的效果。"><a href="#前缀和（prefix-sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现-“子数组和”-或者-“连续的子数组”-既可以考虑使用前缀和来求解会得到不错的效果。" class="headerlink" title="前缀和（prefix sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现 “子数组和” 或者 “连续的子数组” 既可以考虑使用前缀和来求解会得到不错的效果。"></a>前缀和（prefix sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现 “子数组和” 或者 “连续的子数组” 既可以考虑使用前缀和来求解会得到不错的效果。</h2><p>303题</p><p>304题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前缀和（prefix-sum）是算法题中比较实用的一种技巧，当算法题的背景是整数型数组且出现-“子数组和”-或者-“连续的子数组”-既可以考虑使用前缀和来求解会得到不错的效果。&quot;&gt;&lt;a href=&quot;#前缀和（prefix-sum）是算法题中比较实用的一种技巧，当算</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
    <category term="prefix sum" scheme="http://example.com/tags/prefix-sum/"/>
    
  </entry>
  
  <entry>
    <title>518. Coin Change 2(medium)</title>
    <link href="http://example.com/2022/08/23/518/"/>
    <id>http://example.com/2022/08/23/518/</id>
    <published>2022-08-24T02:40:56.000Z</published>
    <updated>2022-08-24T07:35:23.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="518-Coin-Change-2-medium"><a href="#518-Coin-Change-2-medium" class="headerlink" title="518. Coin Change 2(medium)"></a>518. Coin Change 2(medium)</h1><h2 id="You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money"><a href="#You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money" class="headerlink" title="You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money."></a>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</h2><h2 id="Return-the-number-of-combinations-that-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-0"><a href="#Return-the-number-of-combinations-that-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-0" class="headerlink" title="Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0."></a>Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.</h2><h2 id="You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin"><a href="#You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin" class="headerlink" title="You may assume that you have an infinite number of each kind of coin."></a>You may assume that you have an infinite number of each kind of coin.</h2><h2 id="The-answer-is-guaranteed-to-fit-into-a-signed-32-bit-integer"><a href="#The-answer-is-guaranteed-to-fit-into-a-signed-32-bit-integer" class="headerlink" title="The answer is guaranteed to fit into a signed 32-bit integer."></a>The answer is guaranteed to fit into a signed 32-bit integer.</h2><h3 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/">leetcode题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]   <span class="comment"># 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>    <span class="comment"># 合法的初始化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完全背包：优化后的状态转移</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):         <span class="comment"># 第一层循环：遍历硬币</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):   <span class="comment"># 第二层循环：遍历背包</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; coins[i-<span class="number">1</span>]:      <span class="comment"># 容量有限，无法选择第i个硬币</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 可选择第i个硬币</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-coins[i-<span class="number">1</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></table></figure><p>作者：flix<br>链接：<a href="https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/">https://leetcode.cn/problems/coin-change-2/solution/by-flix-e1vv/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;518-Coin-Change-2-medium&quot;&gt;&lt;a href=&quot;#518-Coin-Change-2-medium&quot; class=&quot;headerlink&quot; title=&quot;518. Coin Change 2(medium)&quot;&gt;&lt;/a&gt;518. Coin Ch</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>322. Coin Change(medium)</title>
    <link href="http://example.com/2022/08/23/322/"/>
    <id>http://example.com/2022/08/23/322/</id>
    <published>2022-08-24T02:40:31.000Z</published>
    <updated>2022-08-24T02:47:36.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="322-Coin-Change-medium"><a href="#322-Coin-Change-medium" class="headerlink" title="322. Coin Change(medium)"></a>322. Coin Change(medium)</h1><h2 id="You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money"><a href="#You-are-given-an-integer-array-coins-representing-coins-of-different-denominations-and-an-integer-amount-representing-a-total-amount-of-money" class="headerlink" title="You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money."></a>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</h2><h2 id="Return-the-fewest-number-of-coins-that-you-need-to-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-1"><a href="#Return-the-fewest-number-of-coins-that-you-need-to-make-up-that-amount-If-that-amount-of-money-cannot-be-made-up-by-any-combination-of-the-coins-return-1" class="headerlink" title="Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1."></a>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</h2><h2 id="You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin"><a href="#You-may-assume-that-you-have-an-infinite-number-of-each-kind-of-coin" class="headerlink" title="You may assume that you have an infinite number of each kind of coin."></a>You may assume that you have an infinite number of each kind of coin.</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;322-Coin-Change-medium&quot;&gt;&lt;a href=&quot;#322-Coin-Change-medium&quot; class=&quot;headerlink&quot; title=&quot;322. Coin Change(medium)&quot;&gt;&lt;/a&gt;322. Coin Change(m</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>253. Meeting Rooms II</title>
    <link href="http://example.com/2022/08/23/253/"/>
    <id>http://example.com/2022/08/23/253/</id>
    <published>2022-08-23T04:20:16.000Z</published>
    <updated>2022-08-23T04:40:14.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a>253. Meeting Rooms II</h1><h2 id="Given-an-array-of-meeting-time-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-conference-rooms-required"><a href="#Given-an-array-of-meeting-time-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-conference-rooms-required" class="headerlink" title="Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required."></a>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</h2><h2 id="思想："><a href="#思想：" class="headerlink" title="思想："></a><a href="https://labuladong.github.io/algo/3/29/100/">思想：</a></h2><p>红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。<br>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 count 加一，每遇到绿色的点，计数器 count 减一：<br>这样一来，每个时刻有多少个会议在同时进行，就是计数器 count 的值，count 的最大值，就是需要申请的会议室数量。</p><p>对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。</p><p>代码实现<br>那么，如何写代码实现这个扫描的过程呢？</p><p>首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序<br>然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器 count 的最大值就是答案：<br>这里使用的是 双指针技巧，根据 i, j 的相对位置模拟扫描线前进的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n= <span class="built_in">len</span>(intervals)</span><br><span class="line">        begin =[]</span><br><span class="line">        end = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res,c,j=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            begin.append(intervals[i][<span class="number">0</span>])</span><br><span class="line">            end.append(intervals[i][<span class="number">1</span>])    </span><br><span class="line">        begin.sort()</span><br><span class="line">        end.sort()</span><br><span class="line">        <span class="keyword">while</span> (c&lt;n <span class="keyword">and</span> j&lt;n):</span><br><span class="line">            <span class="keyword">if</span> begin[c]&lt;end[j]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                c+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count-=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,count)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">int</span> minMeetingRooms(<span class="built_in">int</span>[][] meetings) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = meetings.length;</span><br><span class="line">    <span class="built_in">int</span>[] begin = new <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="built_in">int</span>[] end = new <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        begin[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(begin);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line"></span><br><span class="line">    // 扫描过程中的计数器</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    // 双指针技巧</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin[i] &lt; end[j]) &#123;</span><br><span class="line">            // 扫描到一个红点</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // 扫描到一个绿点</span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录扫描过程中的最大值</span><br><span class="line">        res = Math.<span class="built_in">max</span>(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;253-Meeting-Rooms-II&quot;&gt;&lt;a href=&quot;#253-Meeting-Rooms-II&quot; class=&quot;headerlink&quot; title=&quot;253. Meeting Rooms II&quot;&gt;&lt;/a&gt;253. Meeting Rooms II&lt;/h1</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>1207. Unique Number of Occurrences(easy)</title>
    <link href="http://example.com/2022/08/22/1207/"/>
    <id>http://example.com/2022/08/22/1207/</id>
    <published>2022-08-23T03:44:19.000Z</published>
    <updated>2022-08-23T03:53:11.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1207-Unique-Number-of-Occurrences-easy"><a href="#1207-Unique-Number-of-Occurrences-easy" class="headerlink" title="1207. Unique Number of Occurrences(easy)"></a>1207. Unique Number of Occurrences(easy)</h1><h2 id="Given-an-array-of-integers-arr-return-true-if-the-number-of-occurrences-of-each-value-in-the-array-is-unique-or-false-otherwise"><a href="#Given-an-array-of-integers-arr-return-true-if-the-number-of-occurrences-of-each-value-in-the-array-is-unique-or-false-otherwise" class="headerlink" title="Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise."></a>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,2,1,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</span><br></pre></td></tr></table></figure><p>这道题相对比较简单，判断hashmap的value是否都是unique的，通过set的无重复性很容易就能判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniqueOccurrences(self, arr: List[int]) -&gt; bool:</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res=[]</span><br><span class="line">        for i in arr:</span><br><span class="line">            if i not in hashmap:</span><br><span class="line">                hashmap[i]=1</span><br><span class="line">            else:</span><br><span class="line">                hashmap[i]+=1</span><br><span class="line">        for i in hashmap.keys():</span><br><span class="line">            res.append(hashmap[i])</span><br><span class="line">        return len(set(res))==len(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1207-Unique-Number-of-Occurrences-easy&quot;&gt;&lt;a href=&quot;#1207-Unique-Number-of-Occurrences-easy&quot; class=&quot;headerlink&quot; title=&quot;1207. Unique Num</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>146. LRU Cache(medium)</title>
    <link href="http://example.com/2022/08/22/146/"/>
    <id>http://example.com/2022/08/22/146/</id>
    <published>2022-08-22T22:14:56.000Z</published>
    <updated>2022-08-23T03:52:19.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="146-LRU-Cache-medium"><a href="#146-LRU-Cache-medium" class="headerlink" title="146. LRU Cache(medium)"></a>146. LRU Cache(medium)</h1><h2 id="Design-a-data-structure-that-follows-the-constraints-of-a-Least-Recently-Used-LRU-cache"><a href="#Design-a-data-structure-that-follows-the-constraints-of-a-Least-Recently-Used-LRU-cache" class="headerlink" title="Design a data structure that follows the constraints of a Least Recently Used (LRU) cache."></a>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</h2><h2 id="Implement-the-LRUCache-class"><a href="#Implement-the-LRUCache-class" class="headerlink" title="Implement the LRUCache class:"></a>Implement the LRUCache class:</h2><h3 id="LRUCache-int-capacity-Initialize-the-LRU-cache-with-positive-size-capacity"><a href="#LRUCache-int-capacity-Initialize-the-LRU-cache-with-positive-size-capacity" class="headerlink" title="LRUCache(int capacity) Initialize the LRU cache with positive size capacity."></a>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</h3><h3 id="int-get-int-key-Return-the-value-of-the-key-if-the-key-exists-otherwise-return-1"><a href="#int-get-int-key-Return-the-value-of-the-key-if-the-key-exists-otherwise-return-1" class="headerlink" title="int get(int key) Return the value of the key if the key exists, otherwise return -1."></a>int get(int key) Return the value of the key if the key exists, otherwise return -1.</h3><h3 id="void-put-int-key-int-value-Update-the-value-of-the-key-if-the-key-exists-Otherwise-add-the-key-value-pair-to-the-cache-If-the-number-of-keys-exceeds-the-capacity-from-this-operation-evict-the-least-recently-used-key"><a href="#void-put-int-key-int-value-Update-the-value-of-the-key-if-the-key-exists-Otherwise-add-the-key-value-pair-to-the-cache-If-the-number-of-keys-exceeds-the-capacity-from-this-operation-evict-the-least-recently-used-key" class="headerlink" title="void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key."></a>void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</h3><h2 id="The-functions-get-and-put-must-each-run-in-O-1-average-time-complexity"><a href="#The-functions-get-and-put-must-each-run-in-O-1-average-time-complexity" class="headerlink" title="The functions get and put must each run in O(1) average time complexity."></a>The functions get and put must each run in O(1) average time complexity.</h2><h2 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a><a href="https://leetcode.cn/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/">官方答案</a></h2><p>这道题是hashmap频率第一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;146-LRU-Cache-medium&quot;&gt;&lt;a href=&quot;#146-LRU-Cache-medium&quot; class=&quot;headerlink&quot; title=&quot;146. LRU Cache(medium)&quot;&gt;&lt;/a&gt;146. LRU Cache(medium)&lt;/</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>290. Word Pattern(easy)</title>
    <link href="http://example.com/2022/08/21/290/"/>
    <id>http://example.com/2022/08/21/290/</id>
    <published>2022-08-22T02:07:56.000Z</published>
    <updated>2022-08-23T03:52:14.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="290-Word-Pattern-easy"><a href="#290-Word-Pattern-easy" class="headerlink" title="290. Word Pattern(easy)"></a>290. Word Pattern(easy)</h1><h2 id="Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern"><a href="#Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern" class="headerlink" title="Given a pattern and a string s, find if s follows the same pattern."></a>Given a pattern and a string s, find if s follows the same pattern.</h2><h2 id="Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s"><a href="#Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s" class="headerlink" title="Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s."></a>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>这道题与<a href="https://leetcode-cn.com/problems/isomorphic-strings/">205.同构字符串</a>几乎一样，区别在于：<br>1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况</p><p>2.本题需要将s分隔成单个单词</p><p>常规做法是，根据pattern和s的对应关系建立一个hashmap，然后再遍历s与hashmap的映射做比较，有不一样就返回false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s=s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern))!=<span class="built_in">len</span>(<span class="built_in">set</span>(s)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> pattern[i] <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[pattern[i]]=s[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pattern)):</span><br><span class="line">            <span class="keyword">if</span> hashmap[pattern[i]]!=s[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优雅的python解法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s = s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pattern) != <span class="built_in">len</span>(s): </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern)) == <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(pattern,s)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;290-Word-Pattern-easy&quot;&gt;&lt;a href=&quot;#290-Word-Pattern-easy&quot; class=&quot;headerlink&quot; title=&quot;290. Word Pattern(easy)&quot;&gt;&lt;/a&gt;290. Word Pattern(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>350. Intersection of Two Arrays II</title>
    <link href="http://example.com/2022/08/21/350/"/>
    <id>http://example.com/2022/08/21/350/</id>
    <published>2022-08-21T21:13:28.000Z</published>
    <updated>2022-08-23T03:52:07.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</h2><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii">https://leetcode.cn/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">官方题解</a><br>用的是heap 加hashmap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.intersect(nums2, nums1)</span><br><span class="line">        </span><br><span class="line">        m = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            m[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        intersection = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> (count := m.get(num, <span class="number">0</span>)) &gt; <span class="number">0</span>:</span><br><span class="line">                intersection.append(num)</span><br><span class="line">                m[num] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m[num] == <span class="number">0</span>:</span><br><span class="line">                    m.pop(num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intersection</span><br></pre></td></tr></table></figure><p>这个方法用的是python一些独特的函数 Counter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        num1 = collections.Counter(nums1)</span><br><span class="line">        num2 = collections.Counter(nums2)</span><br><span class="line">        num = num1 &amp; num2</span><br><span class="line">        <span class="keyword">return</span> num.elements()</span><br></pre></td></tr></table></figure><p>链接：<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;350-Intersection-of-Two-Arrays-II&quot;&gt;&lt;a href=&quot;#350-Intersection-of-Two-Arrays-II&quot; class=&quot;headerlink&quot; title=&quot;350. Intersection of Two A</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>349. Intersection of Two Arrays</title>
    <link href="http://example.com/2022/08/21/349/"/>
    <id>http://example.com/2022/08/21/349/</id>
    <published>2022-08-21T20:57:39.000Z</published>
    <updated>2022-08-23T03:51:56.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p>这题相对比较简单，就是找到nums1 和nums2相同的数字，并且输出hashset（不能输出重复数字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hashmap:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;349-Intersection-of-Two-Arrays&quot;&gt;&lt;a href=&quot;#349-Intersection-of-Two-Arrays&quot; class=&quot;headerlink&quot; title=&quot;349. Intersection of Two Arrays&quot;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>299. Bulls and Cows</title>
    <link href="http://example.com/2022/08/21/299/"/>
    <id>http://example.com/2022/08/21/299/</id>
    <published>2022-08-21T20:19:24.000Z</published>
    <updated>2022-08-23T03:51:46.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a>299. Bulls and Cows</h1><h2 id="You-are-playing-the-Bulls-and-Cows-game-with-your-friend"><a href="#You-are-playing-the-Bulls-and-Cows-game-with-your-friend" class="headerlink" title="You are playing the Bulls and Cows game with your friend."></a>You are playing the Bulls and Cows game with your friend.</h2><h2 id="You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info"><a href="#You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info" class="headerlink" title="You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:"></a>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</h2><h2 id="The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position"><a href="#The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position" class="headerlink" title="The number of “bulls”, which are digits in the guess that are in the correct position."></a>The number of “bulls”, which are digits in the guess that are in the correct position.</h2><h2 id="The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls"><a href="#The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls" class="headerlink" title="The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls."></a>The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</h2><h2 id="Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess"><a href="#Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess" class="headerlink" title="Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess."></a>Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess.</h2><h2 id="The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits"><a href="#The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits" class="headerlink" title="The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits."></a>The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.</h2><p>原理：<br>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），<br>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;299-Bulls-and-Cows&quot;&gt;&lt;a href=&quot;#299-Bulls-and-Cows&quot; class=&quot;headerlink&quot; title=&quot;299. Bulls and Cows&quot;&gt;&lt;/a&gt;299. Bulls and Cows&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>264. Ugly Number II(medium)</title>
    <link href="http://example.com/2022/08/20/264/"/>
    <id>http://example.com/2022/08/20/264/</id>
    <published>2022-08-21T02:47:26.000Z</published>
    <updated>2022-08-21T20:05:34.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="264-Ugly-Number-II-medium"><a href="#264-Ugly-Number-II-medium" class="headerlink" title="264. Ugly Number II(medium)"></a>264. Ugly Number II(medium)</h1><h2 id="An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5"><a href="#An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5" class="headerlink" title="An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5."></a>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</h2><h1 id="Given-an-integer-n-return-the-nth-ugly-number"><a href="#Given-an-integer-n-return-the-nth-ugly-number" class="headerlink" title="Given an integer n, return the nth ugly number."></a>Given an integer n, return the nth ugly number.</h1><p>“prime factor”是质因子，质因子是所有因子中是质数的</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125;</span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            curr = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := curr * factor) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nxt)</span><br><span class="line">                    heapq.heappush(heap, nxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution">https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ugly = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment"># pointers that point to the last element 2, 3 or 5 was multiplied to</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ugly) &lt; n:</span><br><span class="line">            u2 = <span class="number">2</span> * ugly[p2]</span><br><span class="line">            u3 = <span class="number">3</span> * ugly[p3]</span><br><span class="line">            u5 = <span class="number">5</span> * ugly[p5]</span><br><span class="line">            </span><br><span class="line">            u = <span class="built_in">min</span>(u2, u3, u5) </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u2: <span class="comment"># if the minimum result was result of multiplying the element(ugly[p2]) by 2</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u3: <span class="comment"># if minimum was result of multiplying the element(ugly[p3]) by 3</span></span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> u == u5: <span class="comment"># if minimus was result of multiplying the element(ugly[p5]) by 5</span></span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">ugly.append(u)</span><br><span class="line"><span class="keyword">return</span> ugly[-<span class="number">1</span>] <span class="comment"># return the last element of ugly list</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;264-Ugly-Number-II-medium&quot;&gt;&lt;a href=&quot;#264-Ugly-Number-II-medium&quot; class=&quot;headerlink&quot; title=&quot;264. Ugly Number II(medium)&quot;&gt;&lt;/a&gt;264. Ugly</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>268. Missing Number</title>
    <link href="http://example.com/2022/08/20/268/"/>
    <id>http://example.com/2022/08/20/268/</id>
    <published>2022-08-21T02:29:40.000Z</published>
    <updated>2022-08-21T04:54:20.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><h2 id="Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array"><a href="#Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array" class="headerlink" title="Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array."></a>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</h2><p>题目是说给了n个数，找到0-n之间缺的那个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p>思路：<br>本质上与242. Valid AnagramZ(easy) 没有什么区别，相当于是两个hashmap的比较，这里有个隐性的比较，分别是nums建成的hashmap，还有一个是完整的0-n这样的list建成的hashmap，所以第一步是建造一个包含0-n数字的list，然后以nums建成的hasmap为基础，拿完整版进行比较，这样可以得到缺失的数字</p><pre><code class="python">class Solution:    def missingNumber(self, nums: List[int]) -&gt; int:        hashmap=&#123;&#125;        n=len(nums)        list = []        for i in nums:            if i not in hashmap:                hashmap[i]=1            else:                hashmap[i]+=1                for i in range(n+1):            list.append(i)        for i in list:            if i not in hashmap:                a = i        return a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;268-Missing-Number&quot;&gt;&lt;a href=&quot;#268-Missing-Number&quot; class=&quot;headerlink&quot; title=&quot;268. Missing Number&quot;&gt;&lt;/a&gt;268. Missing Number&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>242. Valid Anagram(easy)</title>
    <link href="http://example.com/2022/08/20/242/"/>
    <id>http://example.com/2022/08/20/242/</id>
    <published>2022-08-21T01:37:24.000Z</published>
    <updated>2022-08-21T04:53:47.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="242-Valid-AnagramZ-easy"><a href="#242-Valid-AnagramZ-easy" class="headerlink" title="242. Valid AnagramZ(easy)"></a>242. Valid AnagramZ(easy)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise" class="headerlink" title="Given two strings s and t, return true if t is an anagram of s, and false otherwise."></a>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</h2><h2 id="An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once"><a href="#An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once" class="headerlink" title="An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once."></a>An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once.</h2><p>这道题和 205. Isomorphic Strings 有点像，但这道题更简单。这道题最容易想到的方法就是直接对字符串排序比较得到结果，首先字符串长度不同肯定输出false，接下来再对字符串排序，如果排序后相同就输出true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(s)==<span class="built_in">sorted</span>(t)</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line"><span class="comment">### [但是！](htps://leetcode.cn/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/)</span></span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlogn+n)=O(nlogn)。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(logn)。排序需要 O(logn) 的空间复杂度。注意，在某些语言（比如 Java &amp; JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：</span><br><span class="line"></span><br><span class="line">这依赖于语言的细节；</span><br><span class="line">这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以，有第二种方法，也就是hashmap：</span><br><span class="line">从另一个角度考虑，t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <span class="number">26</span> 个小写字母，因此我们可以维护一个长度为 <span class="number">26</span> 的频次数组 table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现 table[i]&lt;<span class="number">0</span>，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。</span><br><span class="line"></span><br><span class="line">其实简单点想，就是建两个hashmap，最后比较是否相同就完事了。</span><br><span class="line">比较的函数</span><br><span class="line">```python</span><br><span class="line">operator.eq(hashmap1,hashmap2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>        </span><br><span class="line">        hashmap1=&#123;&#125;</span><br><span class="line">        hashmap2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c1 <span class="keyword">not</span> <span class="keyword">in</span> hashmap1:</span><br><span class="line">                hashmap1[c1]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap1[c1]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c2 <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> c2 <span class="keyword">not</span> <span class="keyword">in</span> hashmap2:</span><br><span class="line">                hashmap2[c2]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap2[c2]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> operator.eq(hashmap1,hashmap2)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br>对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 Unicode 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和 UTF−16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。</p><p>回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#Using Hashmaps: (O(s+t) time and space)</span></span><br><span class="line">        s_map = &#123;&#125;</span><br><span class="line">        t_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> s:</span><br><span class="line">            s_map[leter] = s_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> t:</span><br><span class="line">            t_map[leter] = t_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s_map == t_map</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;242-Valid-AnagramZ-easy&quot;&gt;&lt;a href=&quot;#242-Valid-AnagramZ-easy&quot; class=&quot;headerlink&quot; title=&quot;242. Valid AnagramZ(easy)&quot;&gt;&lt;/a&gt;242. Valid Anag</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>229. Majority Element II(easy)</title>
    <link href="http://example.com/2022/08/20/229/"/>
    <id>http://example.com/2022/08/20/229/</id>
    <published>2022-08-20T21:50:59.000Z</published>
    <updated>2022-08-21T02:01:14.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="229-Majority-Element-II-easy"><a href="#229-Majority-Element-II-easy" class="headerlink" title="229. Majority Element II(easy)"></a>229. Majority Element II(easy)</h1><h2 id="Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times"><a href="#Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times" class="headerlink" title="Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times."></a>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</h2><p>这道题有点像TOP K问题，看到all elements里的遍历想到hashmap</p><p>把top K 的代码和Majority Element I的放在一起就可以解决这个问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hashmap.keys():</span><br><span class="line">            <span class="keyword">if</span> hashmap[i]&gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line">这里需要注意的是，在输出所有有可能的数组时，TOP K 问题用的是extend，而这里用的是append</span><br><span class="line">append可以追加一个<span class="built_in">list</span>，一个对象；</span><br><span class="line">extend则是把两个<span class="built_in">list</span>连接起来，类似matlab的cat函数        </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">NumList1.append(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2append到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, [‘a’, ‘b’, ‘c’]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第四个元素为&#x27;</span>,NumList1[<span class="number">3</span>]) <span class="comment">#[‘a’, ‘b’, ‘c’]</span></span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList1.extend(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2extend到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, ‘a’, ‘b’, ‘c’]</span></span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">列表2append到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [‘a’, ‘b’, ‘c’]]</span><br><span class="line">第四个元素为 [‘a’, ‘b’, ‘c’]</span><br><span class="line">列表2extend到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ‘a’, ‘b’, ‘c’]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;229-Majority-Element-II-easy&quot;&gt;&lt;a href=&quot;#229-Majority-Element-II-easy&quot; class=&quot;headerlink&quot; title=&quot;229. Majority Element II(easy)&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>219. Contains Duplicate II(easy)</title>
    <link href="http://example.com/2022/08/20/219/"/>
    <id>http://example.com/2022/08/20/219/</id>
    <published>2022-08-20T21:06:38.000Z</published>
    <updated>2022-08-20T21:49:45.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="219-Contains-Duplicate-II-easy"><a href="#219-Contains-Duplicate-II-easy" class="headerlink" title="219. Contains Duplicate II(easy)"></a>219. Contains Duplicate II(easy)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k" class="headerlink" title="Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k."></a>Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode-kluvk/">官方题解</a></h3><p>可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 nums，当遍历到下标 i 时，进行如下操作：</p><p>如果哈希表中已经存在和 nums[i] 相等的元素且该元素在哈希表中记录的下标 j 满足 i−j≤k，返回 true；</p><p>将 nums[i] 和下标 i 存入哈希表，此时 i 是 nums[i] 的最大下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> pos <span class="keyword">and</span> i - pos[num] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pos[num] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;219-Contains-Duplicate-II-easy&quot;&gt;&lt;a href=&quot;#219-Contains-Duplicate-II-easy&quot; class=&quot;headerlink&quot; title=&quot;219. Contains Duplicate II(easy)</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>205. Isomorphic Strings(easy)</title>
    <link href="http://example.com/2022/08/20/205/"/>
    <id>http://example.com/2022/08/20/205/</id>
    <published>2022-08-20T04:07:47.000Z</published>
    <updated>2022-08-21T01:45:06.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="205-Isomorphic-Strings-easy"><a href="#205-Isomorphic-Strings-easy" class="headerlink" title="205. Isomorphic Strings(easy)"></a>205. Isomorphic Strings(easy)</h1><h2 id="Given-two-strings-s-and-t-determine-if-they-are-isomorphic"><a href="#Given-two-strings-s-and-t-determine-if-they-are-isomorphic" class="headerlink" title="Given two strings s and t, determine if they are isomorphic."></a>Given two strings s and t, determine if they are isomorphic.</h2><h2 id="Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t"><a href="#Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t" class="headerlink" title="Two strings s and t are isomorphic if the characters in s can be replaced to get t."></a>Two strings s and t are isomorphic if the characters in s can be replaced to get t.</h2><h2 id="All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself"><a href="#All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself" class="headerlink" title="All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself."></a>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/">官方题解</a></h3><p>此题是「290. 单词规律」的简化版，需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</p><p>总结一下就是得一一对应，并且是互相对应。<br>所以第一种方法可以用两个hashmap互相存储对应关系，再往后进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hashmap1 = &#123;&#125;</span><br><span class="line">        hashmap2 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">            <span class="comment">#The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it.</span></span><br><span class="line">            <span class="keyword">if</span> hashmap1.get(c1, c2) != c2 <span class="keyword">or</span> hashmap2.get(c2, c1) != c1:   </span><br><span class="line">                <span class="comment">#The get() method returns the value for the specified key if the key is in the dictionary.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            hashmap1[c1] = c2</span><br><span class="line">            hashmap2[c2] = c1</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法也是评论里的很有意思的方法，利用set的无重复特性来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(t)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(s, t)))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;205-Isomorphic-Strings-easy&quot;&gt;&lt;a href=&quot;#205-Isomorphic-Strings-easy&quot; class=&quot;headerlink&quot; title=&quot;205. Isomorphic Strings(easy)&quot;&gt;&lt;/a&gt;205</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
  <entry>
    <title>202. Happy Number(easy)</title>
    <link href="http://example.com/2022/08/19/202/"/>
    <id>http://example.com/2022/08/19/202/</id>
    <published>2022-08-19T21:05:01.000Z</published>
    <updated>2022-08-20T04:08:55.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202-Happy-Number-easy"><a href="#202-Happy-Number-easy" class="headerlink" title="202. Happy Number(easy)"></a>202. Happy Number(easy)</h1><h2 id="Write-an-algorithm-to-determine-if-a-number-n-is-happy"><a href="#Write-an-algorithm-to-determine-if-a-number-n-is-happy" class="headerlink" title="Write an algorithm to determine if a number n is happy."></a>Write an algorithm to determine if a number n is happy.</h2><h2 id="A-happy-number-is-a-number-defined-by-the-following-process"><a href="#A-happy-number-is-a-number-defined-by-the-following-process" class="headerlink" title="A happy number is a number defined by the following process:"></a>A happy number is a number defined by the following process:</h2><h2 id="Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits"><a href="#Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits" class="headerlink" title="Starting with any positive integer, replace the number by the sum of the squares of its digits."></a>Starting with any positive integer, replace the number by the sum of the squares of its digits.</h2><h2 id="Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1"><a href="#Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1" class="headerlink" title="Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1."></a>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</h2><h2 id="Those-numbers-for-which-this-process-ends-in-1-are-happy"><a href="#Those-numbers-for-which-this-process-ends-in-1-are-happy" class="headerlink" title="Those numbers for which this process ends in 1 are happy."></a>Those numbers for which this process ends in 1 are happy.</h2><h2 id="Return-true-if-n-is-a-happy-number-and-false-if-not"><a href="#Return-true-if-n-is-a-happy-number-and-false-if-not" class="headerlink" title="Return true if n is a happy number, and false if not."></a>Return true if n is a happy number, and false if not.</h2><p>又是一个奇怪的数，叫做happy number</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">官方题解</a></h3><p>总结一下，数字每一位的平方和后的结果有两种可能性</p><ol><li>变成1</li><li>变成循环</li></ol><p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限增大的选择。</p><p>算法</p><p>算法分为两部分，我们需要设计和编写代码。</p><p>给一个数字 nn，它的下一个数字是什么？<br>按照一系列的数字来判断我们是否进入了一个循环。</p><ol><li><p>我们按照题目的要求做数位分离，求平方和。</p></li><li><p>可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p></li></ol><p>如果它不在哈希集合中，我们应该添加它。<br>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</p><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p>Hashmap解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n_history=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                n_history[n]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                n_history[n]=<span class="number">0</span></span><br><span class="line">                digit_li=[<span class="built_in">str</span>(n)[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(n)))]</span><br><span class="line">                n=<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="built_in">int</span>(x))**<span class="number">2</span>,digit_li)))</span><br><span class="line">                <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">```                </span><br><span class="line">相当于把数字n转换成字符串，再进行平方和运算                </span><br><span class="line">```python                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            seen.add(n)</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">str</span>(n)</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> num:</span><br><span class="line">                temp += <span class="built_in">int</span>(ch)**<span class="number">2</span></span><br><span class="line">            n = temp            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hashset解法</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)   <span class="comment">#divmod求余数</span></span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>() <span class="comment"># python里hashset的本质就是set</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = get_next(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;202-Happy-Number-easy&quot;&gt;&lt;a href=&quot;#202-Happy-Number-easy&quot; class=&quot;headerlink&quot; title=&quot;202. Happy Number(easy)&quot;&gt;&lt;/a&gt;202. Happy Number(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
</feed>
