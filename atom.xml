<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-22T03:13:39.465Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>95. Unique Binary Search Trees II (Medium)</title>
    <link href="http://example.com/2022/06/21/95/"/>
    <id>http://example.com/2022/06/21/95/</id>
    <published>2022-06-22T02:47:55.000Z</published>
    <updated>2022-06-22T03:13:39.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a>95. Unique Binary Search Trees II (Medium)</h1><h2 id="Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order"><a href="#Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order" class="headerlink" title="Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order."></a>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><h2 id="官方leetcode-题解"><a href="#官方leetcode-题解" class="headerlink" title="官方leetcode 题解"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">官方leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>,]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):  <span class="comment"># 枚举可行根节点</span></span><br><span class="line">                <span class="comment"># 获得所有可行的左子树集合</span></span><br><span class="line">                leftTrees = generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获得所有可行的右子树集合</span></span><br><span class="line">                rightTrees = generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        currTree = TreeNode(i)</span><br><span class="line">                        currTree.left = l</span><br><span class="line">                        currTree.right = r</span><br><span class="line">                        allTrees.append(currTree)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;95-Unique-Binary-Search-Trees-II-Medium&quot;&gt;&lt;a href=&quot;#95-Unique-Binary-Search-Trees-II-Medium&quot; class=&quot;headerlink&quot; title=&quot;95. Unique Bin</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="divide and conquer" scheme="http://example.com/tags/divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>241. Different Ways to Add Parentheses (Medium)</title>
    <link href="http://example.com/2022/06/21/241/"/>
    <id>http://example.com/2022/06/21/241/</id>
    <published>2022-06-22T02:47:33.000Z</published>
    <updated>2022-06-22T03:04:18.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses-Medium"><a href="#241-Different-Ways-to-Add-Parentheses-Medium" class="headerlink" title="241. Different Ways to Add Parentheses (Medium)"></a>241. Different Ways to Add Parentheses (Medium)</h1><h2 id="Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order"><a href="#Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order" class="headerlink" title="Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order."></a>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</h2><h2 id="The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4"><a href="#The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4" class="headerlink" title="The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4."></a>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;2-1-1&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">Explanation:</span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure><h2 id="分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"><a href="#分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。" class="headerlink" title="分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"></a>分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</h2><h2 id="分治法解题的一般步骤（如图1）："><a href="#分治法解题的一般步骤（如图1）：" class="headerlink" title="分治法解题的一般步骤（如图1）："></a>分治法解题的一般步骤（如图1）：</h2><h3 id="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"><a href="#（1）分解，将要解决的问题划分成若干规模较小的同类问题；" class="headerlink" title="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"></a>（1）分解，将要解决的问题划分成若干规模较小的同类问题；</h3><h3 id="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"><a href="#（2）求解，当子问题划分得足够小时，用较简单的方法解决；" class="headerlink" title="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"></a>（2）求解，当子问题划分得足够小时，用较简单的方法解决；</h3><h3 id="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"><a href="#（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。" class="headerlink" title="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"></a>（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</h3><h2 id="leetcode-题解"><a href="#leetcode-题解" class="headerlink" title="leetcode 题解"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/">leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;241-Different-Ways-to-Add-Parentheses-Medium&quot;&gt;&lt;a href=&quot;#241-Different-Ways-to-Add-Parentheses-Medium&quot; class=&quot;headerlink&quot; title=&quot;241.</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="divide and conquer" scheme="http://example.com/tags/divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <link href="http://example.com/2022/06/20/34/"/>
    <id>http://example.com/2022/06/20/34/</id>
    <published>2022-06-21T02:40:29.000Z</published>
    <updated>2022-06-21T03:51:34.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a>34. Find First and Last Position of Element in Sorted Array (Medium)</h1><h2 id="Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value"><a href="#Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value" class="headerlink" title="Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value."></a>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</h2><h2 id="If-target-is-not-found-in-the-array-return-1-1"><a href="#If-target-is-not-found-in-the-array-return-1-1" class="headerlink" title="If target is not found in the array, return [-1, -1]."></a>If target is not found in the array, return [-1, -1].</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/837944">Solution</a>:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        start = binarysearchleft(nums, target)</span><br><span class="line">        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start, end]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#34-Find-First-and-Last-Position-of-Element-in-Sorted-Ar</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array (Medium)</title>
    <link href="http://example.com/2022/06/20/153/"/>
    <id>http://example.com/2022/06/20/153/</id>
    <published>2022-06-21T02:40:20.000Z</published>
    <updated>2022-06-21T03:51:21.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a>153. Find Minimum in Rotated Sorted Array (Medium)</h1><h2 id="Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become"><a href="#Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become" class="headerlink" title="Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:"></a>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</h2><h2 id="4-5-6-7-0-1-2-if-it-was-rotated-4-times"><a href="#4-5-6-7-0-1-2-if-it-was-rotated-4-times" class="headerlink" title="[4,5,6,7,0,1,2] if it was rotated 4 times."></a>[4,5,6,7,0,1,2] if it was rotated 4 times.</h2><h2 id="0-1-2-4-5-6-7-if-it-was-rotated-7-times"><a href="#0-1-2-4-5-6-7-if-it-was-rotated-7-times" class="headerlink" title="[0,1,2,4,5,6,7] if it was rotated 7 times."></a>[0,1,2,4,5,6,7] if it was rotated 7 times.</h2><h2 id="Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2"><a href="#Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2" class="headerlink" title="Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]."></a>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].</h2><h2 id="Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array"><a href="#Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array" class="headerlink" title="Given the sorted rotated array nums of unique elements, return the minimum element of this array."></a>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</h2><h2 id="You-must-write-an-algorithm-that-runs-in-O-log-n-time"><a href="#You-must-write-an-algorithm-that-runs-in-O-log-n-time" class="headerlink" title="You must write an algorithm that runs in O(log n) time."></a>You must write an algorithm that runs in O(log n) time.</h2><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[last] :                </span><br><span class="line">                last = mid         </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[first]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;153-Find-Minimum-in-Rotated-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#153-Find-Minimum-in-Rotated-Sorted-Array-Medium&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>278. First Bad Version (Easy)</title>
    <link href="http://example.com/2022/06/20/278/"/>
    <id>http://example.com/2022/06/20/278/</id>
    <published>2022-06-21T02:27:02.000Z</published>
    <updated>2022-06-21T03:51:02.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a>278. First Bad Version (Easy)</h1><h2 id="You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad"><a href="#You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad" class="headerlink" title="You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad."></a>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</h2><h2 id="Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad"><a href="#Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad" class="headerlink" title="Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad."></a>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</h2><h2 id="You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API"><a href="#You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API" class="headerlink" title="You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."></a>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/">官方题解</a></h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p><p>具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><p>solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):                </span><br><span class="line">                last= mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">               </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;278-First-Bad-Version-Easy&quot;&gt;&lt;a href=&quot;#278-First-Bad-Version-Easy&quot; class=&quot;headerlink&quot; title=&quot;278. First Bad Version (Easy)&quot;&gt;&lt;/a&gt;278. </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>540. Single Element in a Sorted Array (Medium)</title>
    <link href="http://example.com/2022/06/20/540/"/>
    <id>http://example.com/2022/06/20/540/</id>
    <published>2022-06-21T01:39:30.000Z</published>
    <updated>2022-06-21T03:50:48.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="540-Single-Element-in-a-Sorted-Array-Medium"><a href="#540-Single-Element-in-a-Sorted-Array-Medium" class="headerlink" title="540. Single Element in a Sorted Array (Medium)"></a>540. Single Element in a Sorted Array (Medium)</h1><h2 id="You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once"><a href="#You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once" class="headerlink" title="You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once."></a>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</h2><h2 id="Return-the-single-element-that-appears-only-once"><a href="#Return-the-single-element-that-appears-only-once" class="headerlink" title="Return the single element that appears only once."></a>Return the single element that appears only once.</h2><h2 id="Your-solution-must-run-in-O-log-n-time-and-O-1-space"><a href="#Your-solution-must-run-in-O-log-n-time-and-O-1-space" class="headerlink" title="Your solution must run in O(log n) time and O(1) space."></a>Your solution must run in O(log n) time and O(1) space.</h2><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。<br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-y8gh/">官方题解</a></h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>这道题的特点在于比较的不是数字本身的大小，而是下标的奇偶性。因为只有一个数只出现一次，所以这个数字的下标就只能是偶数。</p><p>由于数组是有序的，因此数组中相同的元素一定相邻。对于下标 x 左边的下标 y，如果 nums[y]=nums[y+1]，则 y 一定是偶数；对于下标 x 右边的下标 z，如果 nums[z]=nums[z+1]，则 z 一定是奇数。由于下标 x 是相同元素的开始下标的奇偶性的分界，因此可以使用二分查找的方法寻找下标 x。</p><p>初始时，二分查找的左边界是 0，右边界是数组的最大下标。每次取左右边界的平均值 mid 作为待判断的下标，根据 mid 的奇偶性决定和左边或右边的相邻元素比较：</p><p>如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；</p><p>如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。</p><p>如果上述比较相邻元素的结果是相等，则 mid&lt;x, 调整左边界。否则 mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 x 的值。</p><p>得到下标 x 的值之后，nums[x] 即为只出现一次的元素。</p><p>⊕ 是按位异或运算符</p><p>当 mid 是偶数时， mid+1=mid⊕1；</p><p>当 mid 是奇数时， mid−1=mid⊕1。</p><h2 id="注：按位异或-按位或-按位与-amp"><a href="#注：按位异或-按位或-按位与-amp" class="headerlink" title="注：按位异或 ^ ,按位或 | ,按位与 &amp;"></a>注：按位异或 ^ ,按位或 | ,按位与 &amp;</h2><p>也就是说判断奇偶性是靠异或运算</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid ^ <span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;540-Single-Element-in-a-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#540-Single-Element-in-a-Sorted-Array-Medium&quot; class=&quot;headerlink&quot; title=&quot;540. S</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>16. 3Sum Closest(medium)</title>
    <link href="http://example.com/2022/06/16/16/"/>
    <id>http://example.com/2022/06/16/16/</id>
    <published>2022-06-16T19:24:32.000Z</published>
    <updated>2022-06-16T19:32:58.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="16-3Sum-Closest-medium"><a href="#16-3Sum-Closest-medium" class="headerlink" title="16. 3Sum Closest(medium)"></a>16. 3Sum Closest(medium)</h1><h2 id="Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target"><a href="#Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target" class="headerlink" title="Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target."></a>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</h2><h2 id="Return-the-sum-of-the-three-integers"><a href="#Return-the-sum-of-the-three-integers" class="headerlink" title="Return the sum of the three integers."></a>Return the sum of the three integers.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution" class="headerlink" title="You may assume that each input would have exactly one solution."></a>You may assume that each input would have exactly one solution.</h2><p><a href="https://leetcode.cn/problems/3sum-closest/solution/pythonshuang-zhi-zhen-you-hua-ji-bai-999-by-hardca/">排序 + 双指针</a><br>这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。</p><p>优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()         <span class="comment"># 排序</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):        <span class="comment"># 枚举第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]: <span class="keyword">continue</span>     <span class="comment"># 保证first不会有重复</span></span><br><span class="line"></span><br><span class="line">            second, third = first + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            max_sum = nums[first] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>]</span><br><span class="line">            min_sum = nums[first] + nums[first + <span class="number">1</span>] + nums[first + <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> max_sum &lt;= target:    <span class="comment"># 最大的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(max_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = max_sum</span><br><span class="line">                <span class="keyword">continue</span>              </span><br><span class="line">            <span class="keyword">elif</span> min_sum &gt;= target:  <span class="comment"># 最小的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(min_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = min_sum      </span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                two_sum_target = target - nums[first]</span><br><span class="line">                s = nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s + nums[first] - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = s + nums[first]</span><br><span class="line">                <span class="keyword">if</span> s &gt; two_sum_target:  <span class="comment"># 当前数值太大 右指针左移</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third + <span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; two_sum_target:  <span class="comment"># 当前数值太小 左指针右移</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 刚好等于 直接返回target即可</span></span><br><span class="line">                    <span class="keyword">return</span> target </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;16-3Sum-Closest-medium&quot;&gt;&lt;a href=&quot;#16-3Sum-Closest-medium&quot; class=&quot;headerlink&quot; title=&quot;16. 3Sum Closest(medium)&quot;&gt;&lt;/a&gt;16. 3Sum Closest(m</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="sort" scheme="http://example.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>744. Find Smallest Letter Greater Than Target (Easy)</title>
    <link href="http://example.com/2022/06/16/744/"/>
    <id>http://example.com/2022/06/16/744/</id>
    <published>2022-06-16T16:42:31.000Z</published>
    <updated>2022-06-21T01:40:29.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="744-Find-Smallest-Letter-Greater-Than-Target-Easy"><a href="#744-Find-Smallest-Letter-Greater-Than-Target-Easy" class="headerlink" title="744. Find Smallest Letter Greater Than Target (Easy)"></a>744. Find Smallest Letter Greater Than Target (Easy)</h1><h2 id="Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target"><a href="#Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target" class="headerlink" title="Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target."></a>Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;d&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;k&quot;</span><br><span class="line">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure><p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution/xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7/">官方题解</a></h2><h2 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h2><p>由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。</p><p>如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>((letter <span class="keyword">for</span> letter <span class="keyword">in</span> letters <span class="keyword">if</span> letter &gt; target), letters[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。</p><p>初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> letters[bisect_right(letters, target)] <span class="keyword">if</span> target &lt; letters[-<span class="number">1</span>] <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h3 id="自己写的完全版"><a href="#自己写的完全版" class="headerlink" title="自己写的完全版"></a>自己写的完全版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        first,last=<span class="number">0</span>,<span class="built_in">len</span>(letters)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意如果目标值大于或等于有序列表的最后一项，返回值为首元素</span></span><br><span class="line">        <span class="comment">#letters[-1]是列表最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> target&gt;=letters[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+ (last-first)//<span class="number">2</span> <span class="comment">#1//2=0,向下取整</span></span><br><span class="line">            <span class="keyword">if</span> letters[mid]&lt;=target:</span><br><span class="line">                first=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = mid</span><br><span class="line">        <span class="keyword">return</span> letters[first]                </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;744-Find-Smallest-Letter-Greater-Than-Target-Easy&quot;&gt;&lt;a href=&quot;#744-Find-Smallest-Letter-Greater-Than-Target-Easy&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>69. Sqrt(x) (Easy)</title>
    <link href="http://example.com/2022/06/16/69/"/>
    <id>http://example.com/2022/06/16/69/</id>
    <published>2022-06-16T14:18:13.000Z</published>
    <updated>2022-06-16T16:42:00.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h1><h2 id="Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x"><a href="#Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x" class="headerlink" title="Given a non-negative integer x, compute and return the square root of x."></a>Given a non-negative integer x, compute and return the square root of x.</h2><h2 id="Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned"><a href="#Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned" class="headerlink" title="Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned."></a>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</h2><h2 id="Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5"><a href="#Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5" class="headerlink" title="Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5"></a>Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5</h2><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: </span><br><span class="line">            first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(left-right)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="comment">#mid = (left + right) // 2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="方法二：牛顿迭代"><a href="#方法二：牛顿迭代" class="headerlink" title="方法二：牛顿迭代"></a>方法二：牛顿迭代</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;69-Sqrt-x-Easy&quot;&gt;&lt;a href=&quot;#69-Sqrt-x-Easy&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x) (Easy)&quot;&gt;&lt;/a&gt;69. Sqrt(x) (Easy)&lt;/h1&gt;&lt;h2 id=&quot;Given-a-n</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode05</title>
    <link href="http://example.com/2022/06/16/LeetCode05/"/>
    <id>http://example.com/2022/06/16/LeetCode05/</id>
    <published>2022-06-16T14:12:48.000Z</published>
    <updated>2022-06-16T15:58:17.017Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-二分查找"><a href="#Leetcode-题解-二分查找" class="headerlink" title="Leetcode 题解 - 二分查找"></a>Leetcode 题解 - 二分查找</h1><h2 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h2><h2 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h2><h2 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h2><h2 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h2><h2 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h2><h2 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h2><p>二分查找 binary search algorithm</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="m-计算"><a href="#m-计算" class="headerlink" title="m 计算"></a>m 计算</h2><p>有两种计算中值 m 的方式：</p><p>m = (l + h) / 2<br>m = l + (h - l) / 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p><h2 id="未成功查找的返回值"><a href="#未成功查找的返回值" class="headerlink" title="未成功查找的返回值"></a>未成功查找的返回值</h2><p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p><p>-1：以一个错误码表示没有查找到 key<br>l：将 key 插入到 nums 中的正确位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>763. Partition Labels (Medium)</title>
    <link href="http://example.com/2022/06/13/763/"/>
    <id>http://example.com/2022/06/13/763/</id>
    <published>2022-06-14T03:40:49.000Z</published>
    <updated>2022-06-14T03:51:29.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="763-Partition-Labels-Medium"><a href="#763-Partition-Labels-Medium" class="headerlink" title="763. Partition Labels (Medium)"></a>763. Partition Labels (Medium)</h1><h2 id="You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part"><a href="#You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part" class="headerlink" title="You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part."></a>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</h2><h2 id="Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s"><a href="#Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s" class="headerlink" title="Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s."></a>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</h2><h2 id="Return-a-list-of-integers-representing-the-size-of-these-parts"><a href="#Return-a-list-of-integers-representing-the-size-of-these-parts" class="headerlink" title="Return a list of integers representing the size of these parts."></a>Return a list of integers representing the size of these parts.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-labels/solution/python-jiu-zhe-quan-guo-zui-cai-you-hua-dai-ma-by-/">思路</a>:<br>其实思路很简单，<br>1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。<br>2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或一段的最后位置大。<br>如果没有刚才的last或一段的最后位置大，无视它继续往后找。<br>如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或一段的最后位置更新为当前的字母的最后位置。<br>3，肯定到有一个时间，这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。<br>注意题目要分隔后的长度，我们就用last - startindex + 1。<br>4，找到一个分割位，更新一下起始位置，同理搜索就行了。</p><p>用字典的好处就是不用每次都搜索位置了。直接用字典存所有字符的最后位置就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;<span class="built_in">list</span>[<span class="built_in">int</span>]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end) <span class="comment">#如果最后位置比刚才的大，就更新最后位置</span></span><br><span class="line">            <span class="keyword">if</span> i == end: <span class="comment">#这里就是找到这一段的结束了，就说明当前位置的index和这个字母在字典里的最后位置应该是相同的。</span></span><br><span class="line">                ans.append(end - start + <span class="number">1</span>) <span class="comment"># 加入result</span></span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;763-Partition-Labels-Medium&quot;&gt;&lt;a href=&quot;#763-Partition-Labels-Medium&quot; class=&quot;headerlink&quot; title=&quot;763. Partition Labels (Medium)&quot;&gt;&lt;/a&gt;76</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>53. Maximum Subarray (Easy)</title>
    <link href="http://example.com/2022/06/13/53/"/>
    <id>http://example.com/2022/06/13/53/</id>
    <published>2022-06-14T03:09:56.000Z</published>
    <updated>2022-06-14T03:52:46.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a>53. Maximum Subarray (Easy)</h1><h2 id="Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum"><a href="#Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum" class="headerlink" title="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."></a>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</h2><h1 id="A-subarray-is-a-contiguous-part-of-an-array"><a href="#A-subarray-is-a-contiguous-part-of-an-array" class="headerlink" title="A subarray is a contiguous part of an array."></a>A subarray is a contiguous part of an array.</h1><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>这题第一眼非常像买股票第一弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure><h2 id="本质上是动态规划问题："><a href="#本质上是动态规划问题：" class="headerlink" title="本质上是动态规划问题："></a>本质上是动态规划问题：</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">leetcode题解</a></p><p>方法一：动态规划<br>「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。</p><p>本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。</p><h2 id="关键-1：理解题意"><a href="#关键-1：理解题意" class="headerlink" title="关键 1：理解题意"></a>关键 1：理解题意</h2><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><h2 id="关键-2：如何定义子问题（如何定义状态）"><a href="#关键-2：如何定义子问题（如何定义状态）" class="headerlink" title="关键 2：如何定义子问题（如何定义状态）"></a>关键 2：如何定义子问题（如何定义状态）</h2><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><p>子问题 1：经过 -2 的连续子数组的最大和是多少；<br>子问题 2：经过 1 的连续子数组的最大和是多少；<br>子问题 3：经过 -3 的连续子数组的最大和是多少；<br>子问题 4：经过 4 的连续子数组的最大和是多少；<br>子问题 5：经过 -1 的连续子数组的最大和是多少；<br>子问题 6：经过 2 的连续子数组的最大和是多少；<br>子问题 7：经过 1 的连续子数组的最大和是多少；<br>子问题 8：经过 -5 的连续子数组的最大和是多少；<br>子问题 9：经过 4 的连续子数组的最大和是多少。<br>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 -3 的连续子数组的最大和是多少。</p><p>「经过 -3 的连续子数组」我们任意举出几个：</p><p>[-2,1,-3,4] ，-3 是这个连续子数组的第 3 个元素；<br>[1,-3,4,-1] ，-3 是这个连续子数组的第 2 个元素；<br>……<br>我们不确定的是：-3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>子问题 3：以 -3 结尾的连续子数组的最大和是多少；<br>子问题 4：以 4 结尾的连续子数组的最大和是多少；<br>子问题 5：以 -1 结尾的连续子数组的最大和是多少；<br>子问题 6：以 2 结尾的连续子数组的最大和是多少；<br>子问题 7：以 1 结尾的连续子数组的最大和是多少；<br>子问题 8：以 -5 结尾的连续子数组的最大和是多少；<br>子问题 9：以 4 结尾的连续子数组的最大和是多少。<br>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>以 -2 结尾的连续子数组是 [-2]，因此最大和就是 -2。</p><p>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 1。</p><p>大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：</p><p>一个数 a 加上负数的结果比 a 更小；<br>一个数 a 加上 0 的结果不会比 a 更大；<br>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。<br>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><h2 id="定义状态（定义子问题）"><a href="#定义状态（定义子问题）" class="headerlink" title="定义状态（定义子问题）"></a>定义状态（定义子问题）</h2><p>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</p><p>说明：「结尾」和「连续」是关键字。</p><h2 id="状态转移方程（描述子问题之间的联系）"><a href="#状态转移方程（描述子问题之间的联系）" class="headerlink" title="状态转移方程（描述子问题之间的联系）"></a>状态转移方程（描述子问题之间的联系）</h2><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 dp[i] = dp[i - 1] + nums[i]。</p><p>可是 dp[i - 1] 有可能是负数，于是分类讨论：</p><p>如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；<br>如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</p><h2 id="思考初始值"><a href="#思考初始值" class="headerlink" title="思考初始值"></a>思考初始值</h2><p>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</p><h2 id="思考输出"><a href="#思考输出" class="headerlink" title="思考输出"></a>思考输出</h2><p>注意：</p><h3 id="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"><a href="#这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；" class="headerlink" title="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"></a>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-Maximum-Subarray-Easy&quot;&gt;&lt;a href=&quot;#53-Maximum-Subarray-Easy&quot; class=&quot;headerlink&quot; title=&quot;53. Maximum Subarray (Easy)&quot;&gt;&lt;/a&gt;53. Maximum</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>665. Non-decreasing Array(medium)</title>
    <link href="http://example.com/2022/06/13/665/"/>
    <id>http://example.com/2022/06/13/665/</id>
    <published>2022-06-14T02:13:19.000Z</published>
    <updated>2022-06-14T03:51:01.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="665-Non-decreasing-Array-medium"><a href="#665-Non-decreasing-Array-medium" class="headerlink" title="665. Non-decreasing Array(medium)"></a>665. Non-decreasing Array(medium)</h1><h2 id="Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element"><a href="#Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element" class="headerlink" title="Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element."></a>Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.</h2><h2 id="We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2"><a href="#We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2" class="headerlink" title="We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2)."></a>We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).</h2><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p>这道题的关键在于修改哪个数，本题在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><p>思路:<br>nums[i] &lt; nums[i - 1]:<br>    nums[i - 1] = nums[i]<br>nums[i] &lt; nums[i - 2]:<br>    nums[i] = nums[i - 1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">2</span>] <span class="keyword">and</span> i-<span class="number">2</span>&gt;=<span class="number">0</span> :</span><br><span class="line">                nums[i]=nums[i-<span class="number">1</span>]</span><br><span class="line">                cnt+=<span class="number">1</span>              </span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[i-<span class="number">1</span>]= nums[i]</span><br><span class="line">                cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;665-Non-decreasing-Array-medium&quot;&gt;&lt;a href=&quot;#665-Non-decreasing-Array-medium&quot; class=&quot;headerlink&quot; title=&quot;665. Non-decreasing Array(medi</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>392. Is Subsequence (Medium)</title>
    <link href="http://example.com/2022/06/13/392/"/>
    <id>http://example.com/2022/06/13/392/</id>
    <published>2022-06-14T01:58:20.000Z</published>
    <updated>2022-06-14T03:50:49.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="392-Is-Subsequence-Medium"><a href="#392-Is-Subsequence-Medium" class="headerlink" title="392. Is Subsequence (Medium)"></a>392. Is Subsequence (Medium)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise" class="headerlink" title="Given two strings s and t, return true if s is a subsequence of t, or false otherwise."></a>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</h2><h2 id="A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not"><a href="#A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not" class="headerlink" title="A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not)."></a>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</h2><p>本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。</p><p>而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。</p><p>这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。</p><p>最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i]==t[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;392-Is-Subsequence-Medium&quot;&gt;&lt;a href=&quot;#392-Is-Subsequence-Medium&quot; class=&quot;headerlink&quot; title=&quot;392. Is Subsequence (Medium)&quot;&gt;&lt;/a&gt;392. Is </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>605. Can Place Flowers (Easy)</title>
    <link href="http://example.com/2022/06/11/605/"/>
    <id>http://example.com/2022/06/11/605/</id>
    <published>2022-06-12T02:33:46.000Z</published>
    <updated>2022-06-12T03:10:50.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="605-Can-Place-Flowers-Easy"><a href="#605-Can-Place-Flowers-Easy" class="headerlink" title="605. Can Place Flowers (Easy)"></a>605. Can Place Flowers (Easy)</h1><h2 id="You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots"><a href="#You-have-a-long-flowerbed-in-which-some-of-the-plots-are-planted-and-some-are-not-However-flowers-cannot-be-planted-in-adjacent-plots" class="headerlink" title="You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots."></a>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.</h2><h2 id="Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule"><a href="#Given-an-integer-array-flowerbed-containing-0’s-and-1’s-where-0-means-empty-and-1-means-not-empty-and-an-integer-n-return-if-n-new-flowers-can-be-planted-in-the-flowerbed-without-violating-the-no-adjacent-flowers-rule" class="headerlink" title="Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule."></a>Given an integer array flowerbed containing 0’s and 1’s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</h2><p><a href="https://leetcode.cn/problems/can-place-flowers/solution/chong-hua-wen-ti-by-leetcode-solution-sojr/728529">leetcode官解评论</a></p><p>非常巧妙的方法，用数学归纳法很容易推出来公式</p><p>统计连续的0的区间，分别有多少个连续的0即可。对于每一段0区间，都可以根据公式直接算出可以种几朵花。</p><p>公式可以通过数学归纳法推出来，很简单：</p><ol><li>对于中间的0区间：</li></ol><p>1~2个0：可种0朵；</p><p>3~4个：可种1朵；</p><p>5~6个：可种2朵；</p><p>…</p><p>count个：可种 (count-1)/2 朵</p><ol start="2"><li>对于两头的0区间，由于左边、右边分别没有1的限制，可种花朵数稍有不同。</li></ol><p>为了代码流程的统一，可以在数组最左边、数组最右边分别补1个0，意味着花坛左边、右边没有花。</p><p>这样公式就跟1相同了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flowerbed:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        countofZero = <span class="number">1</span> <span class="comment"># 当前全0区段中连续0的数量，刚开始预设1个0，因为开头花坛的最左边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace = <span class="number">0</span> <span class="comment"># 可以种的花的数量</span></span><br><span class="line">        <span class="keyword">for</span> bed <span class="keyword">in</span> flowerbed:</span><br><span class="line">            <span class="keyword">if</span> bed == <span class="number">0</span>: <span class="comment"># 遇到0，连续0的数量+1</span></span><br><span class="line">                countofZero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#遇到1，结算上一段连续的0区间，看能种下几盆花：(countofZero-1)/2</span></span><br><span class="line">                canPlace += <span class="built_in">int</span>((countofZero-<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                countofZero = <span class="number">0</span>; <span class="comment"># 0的数量清零，开始统计下一个全0分区        </span></span><br><span class="line">        <span class="comment">#最后一段0区还未结算：</span></span><br><span class="line">        countofZero += <span class="number">1</span><span class="comment"># 最后再预设1个0，因为最后花坛的最右边没有花，可以认为存在一个虚无的0</span></span><br><span class="line">        canPlace += (countofZero-<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> canPlace &gt;= n: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;605-Can-Place-Flowers-Easy&quot;&gt;&lt;a href=&quot;#605-Can-Place-Flowers-Easy&quot; class=&quot;headerlink&quot; title=&quot;605. Can Place Flowers (Easy)&quot;&gt;&lt;/a&gt;605. </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>123. Best Time to Buy and Sell Stock III(hard)</title>
    <link href="http://example.com/2022/06/11/123/"/>
    <id>http://example.com/2022/06/11/123/</id>
    <published>2022-06-12T01:55:04.000Z</published>
    <updated>2022-06-12T02:29:24.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III-hard"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-hard" class="headerlink" title="123. Best Time to Buy and Sell Stock III(hard)"></a>123. Best Time to Buy and Sell Stock III(hard)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions"><a href="#Find-the-maximum-profit-you-can-achieve-You-may-complete-at-most-two-transactions" class="headerlink" title="Find the maximum profit you can achieve. You may complete at most two transactions."></a>Find the maximum profit you can achieve. You may complete at most two transactions.</h2><h2 id="Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again"><a href="#Note-You-may-not-engage-in-multiple-transactions-simultaneously-i-e-you-must-sell-the-stock-before-you-buy-again" class="headerlink" title="Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."></a>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br><span class="line">Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</span><br></pre></td></tr></table></figure><p>卖股票第三弹（hard题了）</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>和第二题差不多，但是限制了最多两次交易，之前的小技巧有些用不上了，所以还是得走动态规划的路子。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/">官方题解</a></h2><p>思路与算法</p><p>由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p><ol><li><p>未进行过任何操作；</p></li><li><p>只进行过一次买操作；</p></li><li><p>进行了一次买操作和一次卖操作，即完成了一笔交易；</p></li><li><p>在完成了一笔交易的前提下，进行了第二次买操作；</p></li><li><p>完成了全部两笔交易。</p></li></ol><p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 buy1,sell1,,buy2,sell2 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy1 = buy2 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell1 = sell2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i])</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i])</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i])</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i])</span><br><span class="line">        <span class="keyword">return</span> sell2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;123-Best-Time-to-Buy-and-Sell-Stock-III-hard&quot;&gt;&lt;a href=&quot;#123-Best-Time-to-Buy-and-Sell-Stock-III-hard&quot; class=&quot;headerlink&quot; title=&quot;123.</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>122. Best Time to Buy and Sell Stock II (Easy)</title>
    <link href="http://example.com/2022/06/11/122/"/>
    <id>http://example.com/2022/06/11/122/</id>
    <published>2022-06-12T01:33:44.000Z</published>
    <updated>2022-06-16T17:28:57.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a>122. Best Time to Buy and Sell Stock II (Easy)</h1><h2 id="You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-integer-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an integer array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day"><a href="#On-each-day-you-may-decide-to-buy-and-or-sell-the-stock-You-can-only-hold-at-most-one-share-of-the-stock-at-any-time-However-you-can-buy-it-then-immediately-sell-it-on-the-same-day" class="headerlink" title="On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day."></a>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</h2><h2 id="Find-and-return-the-maximum-profit-you-can-achieve"><a href="#Find-and-return-the-maximum-profit-you-can-achieve" class="headerlink" title="Find and return the maximum profit you can achieve."></a>Find and return the maximum profit you can achieve.</h2><p>卖股票第二弹</p><p>卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大利润 。</p><p>这一题一样是可以用贪心算法或者动态规划写的，但是我在<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/658886">官方题解评论区</a>发现一个极其简单的小技巧。在本题中买卖都是无限次的，所以只要把盈利（也就是上升段）全部加在一起就可以了，相当于每隔一天算一次盈利，盈利为正算在总利润里，盈利为负就丢掉。</p><p>简单来说就是只要把所有的盈利加在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                res += prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II-Easy&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy&quot; class=&quot;headerlink&quot; title=&quot;122. B</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>121. Best Time to Buy and Sell Stock (Easy)</title>
    <link href="http://example.com/2022/06/11/121/"/>
    <id>http://example.com/2022/06/11/121/</id>
    <published>2022-06-12T01:21:17.000Z</published>
    <updated>2022-06-16T16:59:53.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a>121. Best Time to Buy and Sell Stock (Easy)</h1><h2 id="You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day"><a href="#You-are-given-an-array-prices-where-prices-i-is-the-price-of-a-given-stock-on-the-ith-day" class="headerlink" title="You are given an array prices where prices[i] is the price of a given stock on the ith day."></a>You are given an array prices where prices[i] is the price of a given stock on the ith day.</h2><h2 id="You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock"><a href="#You-want-to-maximize-your-profit-by-choosing-a-single-day-to-buy-one-stock-and-choosing-a-different-day-in-the-future-to-sell-that-stock" class="headerlink" title="You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock."></a>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</h2><h2 id="Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0"><a href="#Return-the-maximum-profit-you-can-achieve-from-this-transaction-If-you-cannot-achieve-any-profit-return-0" class="headerlink" title="Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0."></a>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</h2><p>其实这题是动态规划的问题.卖股票一共六题，分别是<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-i/">121</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a>,<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714</a></p><p><img src="https://pic.leetcode-cn.com/4eaadab491f2bf88639d66c9d51bb0115e694ae08d637841ac18172b631cb21f-0121.gif" alt="图片"></p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;121-Best-Time-to-Buy-and-Sell-Stock-Easy&quot;&gt;&lt;a href=&quot;#121-Best-Time-to-Buy-and-Sell-Stock-Easy&quot; class=&quot;headerlink&quot; title=&quot;121. Best Ti</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>406. Queue Reconstruction by Height(Medium)</title>
    <link href="http://example.com/2022/06/11/406/"/>
    <id>http://example.com/2022/06/11/406/</id>
    <published>2022-06-11T20:52:34.000Z</published>
    <updated>2022-06-12T02:01:24.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="406-Queue-Reconstruction-by-Height-Medium"><a href="#406-Queue-Reconstruction-by-Height-Medium" class="headerlink" title="406. Queue Reconstruction by Height(Medium)"></a>406. Queue Reconstruction by Height(Medium)</h1><h2 id="You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi"><a href="#You-are-given-an-array-of-people-people-which-are-the-attributes-of-some-people-in-a-queue-not-necessarily-in-order-Each-people-i-hi-ki-represents-the-ith-person-of-height-hi-with-exactly-ki-other-people-in-front-who-have-a-height-greater-than-or-equal-to-hi" class="headerlink" title="You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi."></a>You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.</h2><h2 id="Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue"><a href="#Reconstruct-and-return-the-queue-that-is-represented-by-the-input-array-people-The-returned-queue-should-be-formatted-as-an-array-queue-where-queue-j-hj-kj-is-the-attributes-of-the-jth-person-in-the-queue-queue-0-is-the-person-at-the-front-of-the-queue" class="headerlink" title="Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue)."></a>Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</h2><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。</p><p>渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</p><p>在本题目中，首先对数对进行排序，按照数对的元素 1(身高) 降序排序，按照数对的元素 2 (人数)升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。</p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/">leetcode题解</a></p><p>注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = lambda x: (-x[0], x[1]))</span><br></pre></td></tr></table></figure><p>第一个元素降序，第二个元素升序排列，以第一个元素的降序排列优先</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = [[1,4],[2,3],[3,4],[1,3],[1,2]]</span><br><span class="line"></span><br><span class="line">print(sorted(A,key=lambda x:x[1]))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0], x[1])))</span><br><span class="line"></span><br><span class="line">print(sorted(A,key = lambda x: (-x[0])))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [2, 3], [1, 3], [1, 4], [3, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 2], [1, 3], [1, 4]]</span><br><span class="line">[[3, 4], [2, 3], [1, 4], [1, 3], [1, 2]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="本题例子"><a href="#本题例子" class="headerlink" title="本题例子"></a>本题例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br></pre></td></tr></table></figure><p>所以排序完：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>])) <span class="comment">#排序</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= p[<span class="number">1</span>]:  <span class="comment">#比较的变量是当前数组的长度</span></span><br><span class="line">                res.append(p)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(res) &gt; p[<span class="number">1</span>]:</span><br><span class="line">                res.insert(p[<span class="number">1</span>], p)  <span class="comment"># p is inserted at index p[1]（参与这次排序的P[1])</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> people:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = people[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;406-Queue-Reconstruction-by-Height-Medium&quot;&gt;&lt;a href=&quot;#406-Queue-Reconstruction-by-Height-Medium&quot; class=&quot;headerlink&quot; title=&quot;406. Queue</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>452. Minimum Number of Arrows to Burst Balloons (Medium)</title>
    <link href="http://example.com/2022/06/10/452/"/>
    <id>http://example.com/2022/06/10/452/</id>
    <published>2022-06-11T02:58:19.000Z</published>
    <updated>2022-06-11T20:52:51.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons (Medium)"></a>452. Minimum Number of Arrows to Burst Balloons (Medium)</h1><h2 id="There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons"><a href="#There-are-some-spherical-balloons-taped-onto-a-flat-wall-that-represents-the-XY-plane-The-balloons-are-represented-as-a-2D-integer-array-points-where-points-i-xstart-xend-denotes-a-balloon-whose-horizontal-diameter-stretches-between-xstart-and-xend-You-do-not-know-the-exact-y-coordinates-of-the-balloons" class="headerlink" title="There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons."></a>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.</h2><h2 id="Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path"><a href="#Arrows-can-be-shot-up-directly-vertically-in-the-positive-y-direction-from-different-points-along-the-x-axis-A-balloon-with-xstart-and-xend-is-burst-by-an-arrow-shot-at-x-if-xstart-lt-x-lt-xend-There-is-no-limit-to-the-number-of-arrows-that-can-be-shot-A-shot-arrow-keeps-traveling-up-infinitely-bursting-any-balloons-in-its-path" class="headerlink" title="Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path."></a>Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</h2><h2 id="Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons"><a href="#Given-the-array-points-return-the-minimum-number-of-arrows-that-must-be-shot-to-burst-all-balloons" class="headerlink" title="Given the array points, return the minimum number of arrows that must be shot to burst all balloons."></a>Given the array points, return the minimum number of arrows that must be shot to burst all balloons.</h2><p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p><p>也是计算不重叠的区间个数，不过和 Non-overlapping points 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p><p><img src="https://assets.leetcode-cn.com/solution-static/452/1.png" alt="射箭"></p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h2><p>这道题和 435. Non-overlapping Intervals (Medium) 有些类似，都是寻找重合区间</p><p>贪心：<br>既然每个气球都需要被引爆，那么在满足引爆对箭限制最大的那个气球（因为它一定要被引爆，而箭和其它同时被引爆的气球 都可以迁就它，所以满足它是必须的） 的同时，引爆尽可能多其他的气球。</p><p>在付出不变的的前提下，获得尽可能多。</p><p>简单来说就是先按照区间右边边界从小到大排序，为了尽可能的多引爆气球，第一支箭射在第一个区间的最右边，根据后面区间的左端点判断一共引爆了哪些区间，并从剩下未被引爆的气球中，再选择右边界位置最靠左的那一个，确定下一支箭，直到所有的气球都被引爆。</p><p>有个问题是这 nn 个气球对应的区间互不重叠，while 循环需要执行 n 次。所以当遇到x(j) ≤ y(i)时 我们可以直接跳出循环，y(j)就是下一个箭的位置。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>        </span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> balloon: balloon[<span class="number">1</span>])</span><br><span class="line">        pos = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> balloon <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> balloon[<span class="number">0</span>] &gt; pos:</span><br><span class="line">                pos = balloon[<span class="number">1</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium&quot;&gt;&lt;a href=&quot;#452-Minimum-Number-of-Arrows-to-Burst-Balloons-Medium&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
  </entry>
  
</feed>
