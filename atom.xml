<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  <subtitle>Engineering House</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-24T02:40:56.717Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>518</title>
    <link href="http://example.com/2022/08/23/518/"/>
    <id>http://example.com/2022/08/23/518/</id>
    <published>2022-08-24T02:40:56.000Z</published>
    <updated>2022-08-24T02:40:56.717Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>322</title>
    <link href="http://example.com/2022/08/23/322/"/>
    <id>http://example.com/2022/08/23/322/</id>
    <published>2022-08-24T02:40:31.000Z</published>
    <updated>2022-08-24T02:40:31.547Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>253. Meeting Rooms II</title>
    <link href="http://example.com/2022/08/23/253/"/>
    <id>http://example.com/2022/08/23/253/</id>
    <published>2022-08-23T04:20:16.000Z</published>
    <updated>2022-08-23T04:40:14.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a>253. Meeting Rooms II</h1><h2 id="Given-an-array-of-meeting-time-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-conference-rooms-required"><a href="#Given-an-array-of-meeting-time-intervals-intervals-where-intervals-i-starti-endi-return-the-minimum-number-of-conference-rooms-required" class="headerlink" title="Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required."></a>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.</h2><h2 id="思想："><a href="#思想：" class="headerlink" title="思想："></a><a href="https://labuladong.github.io/algo/3/29/100/">思想：</a></h2><p>红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。<br>现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 count 加一，每遇到绿色的点，计数器 count 减一：<br>这样一来，每个时刻有多少个会议在同时进行，就是计数器 count 的值，count 的最大值，就是需要申请的会议室数量。</p><p>对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。</p><p>代码实现<br>那么，如何写代码实现这个扫描的过程呢？</p><p>首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序<br>然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器 count 的最大值就是答案：<br>这里使用的是 双指针技巧，根据 i, j 的相对位置模拟扫描线前进的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n= <span class="built_in">len</span>(intervals)</span><br><span class="line">        begin =[]</span><br><span class="line">        end = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res,c,j=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            begin.append(intervals[i][<span class="number">0</span>])</span><br><span class="line">            end.append(intervals[i][<span class="number">1</span>])    </span><br><span class="line">        begin.sort()</span><br><span class="line">        end.sort()</span><br><span class="line">        <span class="keyword">while</span> (c&lt;n <span class="keyword">and</span> j&lt;n):</span><br><span class="line">            <span class="keyword">if</span> begin[c]&lt;end[j]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                c+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count-=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,count)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">int</span> minMeetingRooms(<span class="built_in">int</span>[][] meetings) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = meetings.length;</span><br><span class="line">    <span class="built_in">int</span>[] begin = new <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="built_in">int</span>[] end = new <span class="built_in">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        begin[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(begin);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line"></span><br><span class="line">    // 扫描过程中的计数器</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    // 双指针技巧</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin[i] &lt; end[j]) &#123;</span><br><span class="line">            // 扫描到一个红点</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // 扫描到一个绿点</span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录扫描过程中的最大值</span><br><span class="line">        res = Math.<span class="built_in">max</span>(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;253-Meeting-Rooms-II&quot;&gt;&lt;a href=&quot;#253-Meeting-Rooms-II&quot; class=&quot;headerlink&quot; title=&quot;253. Meeting Rooms II&quot;&gt;&lt;/a&gt;253. Meeting Rooms II&lt;/h1</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>1207. Unique Number of Occurrences(easy)</title>
    <link href="http://example.com/2022/08/22/1207/"/>
    <id>http://example.com/2022/08/22/1207/</id>
    <published>2022-08-23T03:44:19.000Z</published>
    <updated>2022-08-23T03:53:11.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1207-Unique-Number-of-Occurrences-easy"><a href="#1207-Unique-Number-of-Occurrences-easy" class="headerlink" title="1207. Unique Number of Occurrences(easy)"></a>1207. Unique Number of Occurrences(easy)</h1><h2 id="Given-an-array-of-integers-arr-return-true-if-the-number-of-occurrences-of-each-value-in-the-array-is-unique-or-false-otherwise"><a href="#Given-an-array-of-integers-arr-return-true-if-the-number-of-occurrences-of-each-value-in-the-array-is-unique-or-false-otherwise" class="headerlink" title="Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise."></a>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,2,1,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</span><br></pre></td></tr></table></figure><p>这道题相对比较简单，判断hashmap的value是否都是unique的，通过set的无重复性很容易就能判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniqueOccurrences(self, arr: List[int]) -&gt; bool:</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res=[]</span><br><span class="line">        for i in arr:</span><br><span class="line">            if i not in hashmap:</span><br><span class="line">                hashmap[i]=1</span><br><span class="line">            else:</span><br><span class="line">                hashmap[i]+=1</span><br><span class="line">        for i in hashmap.keys():</span><br><span class="line">            res.append(hashmap[i])</span><br><span class="line">        return len(set(res))==len(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1207-Unique-Number-of-Occurrences-easy&quot;&gt;&lt;a href=&quot;#1207-Unique-Number-of-Occurrences-easy&quot; class=&quot;headerlink&quot; title=&quot;1207. Unique Num</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>146. LRU Cache(medium)</title>
    <link href="http://example.com/2022/08/22/146/"/>
    <id>http://example.com/2022/08/22/146/</id>
    <published>2022-08-22T22:14:56.000Z</published>
    <updated>2022-08-23T03:52:19.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="146-LRU-Cache-medium"><a href="#146-LRU-Cache-medium" class="headerlink" title="146. LRU Cache(medium)"></a>146. LRU Cache(medium)</h1><h2 id="Design-a-data-structure-that-follows-the-constraints-of-a-Least-Recently-Used-LRU-cache"><a href="#Design-a-data-structure-that-follows-the-constraints-of-a-Least-Recently-Used-LRU-cache" class="headerlink" title="Design a data structure that follows the constraints of a Least Recently Used (LRU) cache."></a>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</h2><h2 id="Implement-the-LRUCache-class"><a href="#Implement-the-LRUCache-class" class="headerlink" title="Implement the LRUCache class:"></a>Implement the LRUCache class:</h2><h3 id="LRUCache-int-capacity-Initialize-the-LRU-cache-with-positive-size-capacity"><a href="#LRUCache-int-capacity-Initialize-the-LRU-cache-with-positive-size-capacity" class="headerlink" title="LRUCache(int capacity) Initialize the LRU cache with positive size capacity."></a>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</h3><h3 id="int-get-int-key-Return-the-value-of-the-key-if-the-key-exists-otherwise-return-1"><a href="#int-get-int-key-Return-the-value-of-the-key-if-the-key-exists-otherwise-return-1" class="headerlink" title="int get(int key) Return the value of the key if the key exists, otherwise return -1."></a>int get(int key) Return the value of the key if the key exists, otherwise return -1.</h3><h3 id="void-put-int-key-int-value-Update-the-value-of-the-key-if-the-key-exists-Otherwise-add-the-key-value-pair-to-the-cache-If-the-number-of-keys-exceeds-the-capacity-from-this-operation-evict-the-least-recently-used-key"><a href="#void-put-int-key-int-value-Update-the-value-of-the-key-if-the-key-exists-Otherwise-add-the-key-value-pair-to-the-cache-If-the-number-of-keys-exceeds-the-capacity-from-this-operation-evict-the-least-recently-used-key" class="headerlink" title="void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key."></a>void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</h3><h2 id="The-functions-get-and-put-must-each-run-in-O-1-average-time-complexity"><a href="#The-functions-get-and-put-must-each-run-in-O-1-average-time-complexity" class="headerlink" title="The functions get and put must each run in O(1) average time complexity."></a>The functions get and put must each run in O(1) average time complexity.</h2><h2 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a><a href="https://leetcode.cn/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/">官方答案</a></h2><p>这道题是hashmap频率第一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt; self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;146-LRU-Cache-medium&quot;&gt;&lt;a href=&quot;#146-LRU-Cache-medium&quot; class=&quot;headerlink&quot; title=&quot;146. LRU Cache(medium)&quot;&gt;&lt;/a&gt;146. LRU Cache(medium)&lt;/</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>290. Word Pattern(easy)</title>
    <link href="http://example.com/2022/08/21/290/"/>
    <id>http://example.com/2022/08/21/290/</id>
    <published>2022-08-22T02:07:56.000Z</published>
    <updated>2022-08-23T03:52:14.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="290-Word-Pattern-easy"><a href="#290-Word-Pattern-easy" class="headerlink" title="290. Word Pattern(easy)"></a>290. Word Pattern(easy)</h1><h2 id="Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern"><a href="#Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern" class="headerlink" title="Given a pattern and a string s, find if s follows the same pattern."></a>Given a pattern and a string s, find if s follows the same pattern.</h2><h2 id="Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s"><a href="#Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s" class="headerlink" title="Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s."></a>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>这道题与<a href="https://leetcode-cn.com/problems/isomorphic-strings/">205.同构字符串</a>几乎一样，区别在于：<br>1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况</p><p>2.本题需要将s分隔成单个单词</p><p>常规做法是，根据pattern和s的对应关系建立一个hashmap，然后再遍历s与hashmap的映射做比较，有不一样就返回false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s=s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern))!=<span class="built_in">len</span>(<span class="built_in">set</span>(s)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> pattern[i] <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[pattern[i]]=s[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pattern)):</span><br><span class="line">            <span class="keyword">if</span> hashmap[pattern[i]]!=s[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优雅的python解法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s = s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pattern) != <span class="built_in">len</span>(s): </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern)) == <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(pattern,s)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;290-Word-Pattern-easy&quot;&gt;&lt;a href=&quot;#290-Word-Pattern-easy&quot; class=&quot;headerlink&quot; title=&quot;290. Word Pattern(easy)&quot;&gt;&lt;/a&gt;290. Word Pattern(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>350. Intersection of Two Arrays II</title>
    <link href="http://example.com/2022/08/21/350/"/>
    <id>http://example.com/2022/08/21/350/</id>
    <published>2022-08-21T21:13:28.000Z</published>
    <updated>2022-08-23T03:52:07.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</h2><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii">https://leetcode.cn/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">官方题解</a><br>用的是heap 加hashmap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.intersect(nums2, nums1)</span><br><span class="line">        </span><br><span class="line">        m = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            m[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        intersection = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> (count := m.get(num, <span class="number">0</span>)) &gt; <span class="number">0</span>:</span><br><span class="line">                intersection.append(num)</span><br><span class="line">                m[num] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m[num] == <span class="number">0</span>:</span><br><span class="line">                    m.pop(num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intersection</span><br></pre></td></tr></table></figure><p>这个方法用的是python一些独特的函数 Counter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        num1 = collections.Counter(nums1)</span><br><span class="line">        num2 = collections.Counter(nums2)</span><br><span class="line">        num = num1 &amp; num2</span><br><span class="line">        <span class="keyword">return</span> num.elements()</span><br></pre></td></tr></table></figure><p>链接：<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;350-Intersection-of-Two-Arrays-II&quot;&gt;&lt;a href=&quot;#350-Intersection-of-Two-Arrays-II&quot; class=&quot;headerlink&quot; title=&quot;350. Intersection of Two A</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>349. Intersection of Two Arrays</title>
    <link href="http://example.com/2022/08/21/349/"/>
    <id>http://example.com/2022/08/21/349/</id>
    <published>2022-08-21T20:57:39.000Z</published>
    <updated>2022-08-23T03:51:56.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p>这题相对比较简单，就是找到nums1 和nums2相同的数字，并且输出hashset（不能输出重复数字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hashmap:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;349-Intersection-of-Two-Arrays&quot;&gt;&lt;a href=&quot;#349-Intersection-of-Two-Arrays&quot; class=&quot;headerlink&quot; title=&quot;349. Intersection of Two Arrays&quot;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>299. Bulls and Cows</title>
    <link href="http://example.com/2022/08/21/299/"/>
    <id>http://example.com/2022/08/21/299/</id>
    <published>2022-08-21T20:19:24.000Z</published>
    <updated>2022-08-23T03:51:46.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a>299. Bulls and Cows</h1><h2 id="You-are-playing-the-Bulls-and-Cows-game-with-your-friend"><a href="#You-are-playing-the-Bulls-and-Cows-game-with-your-friend" class="headerlink" title="You are playing the Bulls and Cows game with your friend."></a>You are playing the Bulls and Cows game with your friend.</h2><h2 id="You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info"><a href="#You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info" class="headerlink" title="You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:"></a>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</h2><h2 id="The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position"><a href="#The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position" class="headerlink" title="The number of “bulls”, which are digits in the guess that are in the correct position."></a>The number of “bulls”, which are digits in the guess that are in the correct position.</h2><h2 id="The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls"><a href="#The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls" class="headerlink" title="The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls."></a>The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</h2><h2 id="Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess"><a href="#Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess" class="headerlink" title="Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess."></a>Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess.</h2><h2 id="The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits"><a href="#The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits" class="headerlink" title="The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits."></a>The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.</h2><p>原理：<br>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），<br>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;299-Bulls-and-Cows&quot;&gt;&lt;a href=&quot;#299-Bulls-and-Cows&quot; class=&quot;headerlink&quot; title=&quot;299. Bulls and Cows&quot;&gt;&lt;/a&gt;299. Bulls and Cows&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>264. Ugly Number II(medium)</title>
    <link href="http://example.com/2022/08/20/264/"/>
    <id>http://example.com/2022/08/20/264/</id>
    <published>2022-08-21T02:47:26.000Z</published>
    <updated>2022-08-21T20:05:34.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="264-Ugly-Number-II-medium"><a href="#264-Ugly-Number-II-medium" class="headerlink" title="264. Ugly Number II(medium)"></a>264. Ugly Number II(medium)</h1><h2 id="An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5"><a href="#An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5" class="headerlink" title="An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5."></a>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</h2><h1 id="Given-an-integer-n-return-the-nth-ugly-number"><a href="#Given-an-integer-n-return-the-nth-ugly-number" class="headerlink" title="Given an integer n, return the nth ugly number."></a>Given an integer n, return the nth ugly number.</h1><p>“prime factor”是质因子，质因子是所有因子中是质数的</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125;</span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            curr = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := curr * factor) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nxt)</span><br><span class="line">                    heapq.heappush(heap, nxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution">https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ugly = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment"># pointers that point to the last element 2, 3 or 5 was multiplied to</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ugly) &lt; n:</span><br><span class="line">            u2 = <span class="number">2</span> * ugly[p2]</span><br><span class="line">            u3 = <span class="number">3</span> * ugly[p3]</span><br><span class="line">            u5 = <span class="number">5</span> * ugly[p5]</span><br><span class="line">            </span><br><span class="line">            u = <span class="built_in">min</span>(u2, u3, u5) </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u2: <span class="comment"># if the minimum result was result of multiplying the element(ugly[p2]) by 2</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u3: <span class="comment"># if minimum was result of multiplying the element(ugly[p3]) by 3</span></span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> u == u5: <span class="comment"># if minimus was result of multiplying the element(ugly[p5]) by 5</span></span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">ugly.append(u)</span><br><span class="line"><span class="keyword">return</span> ugly[-<span class="number">1</span>] <span class="comment"># return the last element of ugly list</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;264-Ugly-Number-II-medium&quot;&gt;&lt;a href=&quot;#264-Ugly-Number-II-medium&quot; class=&quot;headerlink&quot; title=&quot;264. Ugly Number II(medium)&quot;&gt;&lt;/a&gt;264. Ugly</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>268. Missing Number</title>
    <link href="http://example.com/2022/08/20/268/"/>
    <id>http://example.com/2022/08/20/268/</id>
    <published>2022-08-21T02:29:40.000Z</published>
    <updated>2022-08-21T04:54:20.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><h2 id="Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array"><a href="#Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array" class="headerlink" title="Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array."></a>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</h2><p>题目是说给了n个数，找到0-n之间缺的那个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p>思路：<br>本质上与242. Valid AnagramZ(easy) 没有什么区别，相当于是两个hashmap的比较，这里有个隐性的比较，分别是nums建成的hashmap，还有一个是完整的0-n这样的list建成的hashmap，所以第一步是建造一个包含0-n数字的list，然后以nums建成的hasmap为基础，拿完整版进行比较，这样可以得到缺失的数字</p><pre><code class="python">class Solution:    def missingNumber(self, nums: List[int]) -&gt; int:        hashmap=&#123;&#125;        n=len(nums)        list = []        for i in nums:            if i not in hashmap:                hashmap[i]=1            else:                hashmap[i]+=1                for i in range(n+1):            list.append(i)        for i in list:            if i not in hashmap:                a = i        return a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;268-Missing-Number&quot;&gt;&lt;a href=&quot;#268-Missing-Number&quot; class=&quot;headerlink&quot; title=&quot;268. Missing Number&quot;&gt;&lt;/a&gt;268. Missing Number&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>242. Valid Anagram(easy)</title>
    <link href="http://example.com/2022/08/20/242/"/>
    <id>http://example.com/2022/08/20/242/</id>
    <published>2022-08-21T01:37:24.000Z</published>
    <updated>2022-08-21T04:53:47.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="242-Valid-AnagramZ-easy"><a href="#242-Valid-AnagramZ-easy" class="headerlink" title="242. Valid AnagramZ(easy)"></a>242. Valid AnagramZ(easy)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise" class="headerlink" title="Given two strings s and t, return true if t is an anagram of s, and false otherwise."></a>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</h2><h2 id="An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once"><a href="#An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once" class="headerlink" title="An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once."></a>An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once.</h2><p>这道题和 205. Isomorphic Strings 有点像，但这道题更简单。这道题最容易想到的方法就是直接对字符串排序比较得到结果，首先字符串长度不同肯定输出false，接下来再对字符串排序，如果排序后相同就输出true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(s)==<span class="built_in">sorted</span>(t)</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line"><span class="comment">### [但是！](htps://leetcode.cn/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/)</span></span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlogn+n)=O(nlogn)。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(logn)。排序需要 O(logn) 的空间复杂度。注意，在某些语言（比如 Java &amp; JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：</span><br><span class="line"></span><br><span class="line">这依赖于语言的细节；</span><br><span class="line">这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以，有第二种方法，也就是hashmap：</span><br><span class="line">从另一个角度考虑，t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <span class="number">26</span> 个小写字母，因此我们可以维护一个长度为 <span class="number">26</span> 的频次数组 table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现 table[i]&lt;<span class="number">0</span>，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。</span><br><span class="line"></span><br><span class="line">其实简单点想，就是建两个hashmap，最后比较是否相同就完事了。</span><br><span class="line">比较的函数</span><br><span class="line">```python</span><br><span class="line">operator.eq(hashmap1,hashmap2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>        </span><br><span class="line">        hashmap1=&#123;&#125;</span><br><span class="line">        hashmap2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c1 <span class="keyword">not</span> <span class="keyword">in</span> hashmap1:</span><br><span class="line">                hashmap1[c1]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap1[c1]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c2 <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> c2 <span class="keyword">not</span> <span class="keyword">in</span> hashmap2:</span><br><span class="line">                hashmap2[c2]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap2[c2]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> operator.eq(hashmap1,hashmap2)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br>对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 Unicode 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和 UTF−16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。</p><p>回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#Using Hashmaps: (O(s+t) time and space)</span></span><br><span class="line">        s_map = &#123;&#125;</span><br><span class="line">        t_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> s:</span><br><span class="line">            s_map[leter] = s_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> t:</span><br><span class="line">            t_map[leter] = t_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s_map == t_map</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;242-Valid-AnagramZ-easy&quot;&gt;&lt;a href=&quot;#242-Valid-AnagramZ-easy&quot; class=&quot;headerlink&quot; title=&quot;242. Valid AnagramZ(easy)&quot;&gt;&lt;/a&gt;242. Valid Anag</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>229. Majority Element II(easy)</title>
    <link href="http://example.com/2022/08/20/229/"/>
    <id>http://example.com/2022/08/20/229/</id>
    <published>2022-08-20T21:50:59.000Z</published>
    <updated>2022-08-21T02:01:14.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="229-Majority-Element-II-easy"><a href="#229-Majority-Element-II-easy" class="headerlink" title="229. Majority Element II(easy)"></a>229. Majority Element II(easy)</h1><h2 id="Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times"><a href="#Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times" class="headerlink" title="Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times."></a>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</h2><p>这道题有点像TOP K问题，看到all elements里的遍历想到hashmap</p><p>把top K 的代码和Majority Element I的放在一起就可以解决这个问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hashmap.keys():</span><br><span class="line">            <span class="keyword">if</span> hashmap[i]&gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line">这里需要注意的是，在输出所有有可能的数组时，TOP K 问题用的是extend，而这里用的是append</span><br><span class="line">append可以追加一个<span class="built_in">list</span>，一个对象；</span><br><span class="line">extend则是把两个<span class="built_in">list</span>连接起来，类似matlab的cat函数        </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">NumList1.append(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2append到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, [‘a’, ‘b’, ‘c’]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第四个元素为&#x27;</span>,NumList1[<span class="number">3</span>]) <span class="comment">#[‘a’, ‘b’, ‘c’]</span></span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList1.extend(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2extend到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, ‘a’, ‘b’, ‘c’]</span></span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">列表2append到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [‘a’, ‘b’, ‘c’]]</span><br><span class="line">第四个元素为 [‘a’, ‘b’, ‘c’]</span><br><span class="line">列表2extend到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ‘a’, ‘b’, ‘c’]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;229-Majority-Element-II-easy&quot;&gt;&lt;a href=&quot;#229-Majority-Element-II-easy&quot; class=&quot;headerlink&quot; title=&quot;229. Majority Element II(easy)&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>219. Contains Duplicate II(easy)</title>
    <link href="http://example.com/2022/08/20/219/"/>
    <id>http://example.com/2022/08/20/219/</id>
    <published>2022-08-20T21:06:38.000Z</published>
    <updated>2022-08-20T21:49:45.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="219-Contains-Duplicate-II-easy"><a href="#219-Contains-Duplicate-II-easy" class="headerlink" title="219. Contains Duplicate II(easy)"></a>219. Contains Duplicate II(easy)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k" class="headerlink" title="Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k."></a>Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode-kluvk/">官方题解</a></h3><p>可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 nums，当遍历到下标 i 时，进行如下操作：</p><p>如果哈希表中已经存在和 nums[i] 相等的元素且该元素在哈希表中记录的下标 j 满足 i−j≤k，返回 true；</p><p>将 nums[i] 和下标 i 存入哈希表，此时 i 是 nums[i] 的最大下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> pos <span class="keyword">and</span> i - pos[num] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pos[num] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;219-Contains-Duplicate-II-easy&quot;&gt;&lt;a href=&quot;#219-Contains-Duplicate-II-easy&quot; class=&quot;headerlink&quot; title=&quot;219. Contains Duplicate II(easy)</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>205. Isomorphic Strings(easy)</title>
    <link href="http://example.com/2022/08/20/205/"/>
    <id>http://example.com/2022/08/20/205/</id>
    <published>2022-08-20T04:07:47.000Z</published>
    <updated>2022-08-21T01:45:06.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="205-Isomorphic-Strings-easy"><a href="#205-Isomorphic-Strings-easy" class="headerlink" title="205. Isomorphic Strings(easy)"></a>205. Isomorphic Strings(easy)</h1><h2 id="Given-two-strings-s-and-t-determine-if-they-are-isomorphic"><a href="#Given-two-strings-s-and-t-determine-if-they-are-isomorphic" class="headerlink" title="Given two strings s and t, determine if they are isomorphic."></a>Given two strings s and t, determine if they are isomorphic.</h2><h2 id="Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t"><a href="#Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t" class="headerlink" title="Two strings s and t are isomorphic if the characters in s can be replaced to get t."></a>Two strings s and t are isomorphic if the characters in s can be replaced to get t.</h2><h2 id="All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself"><a href="#All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself" class="headerlink" title="All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself."></a>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/">官方题解</a></h3><p>此题是「290. 单词规律」的简化版，需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</p><p>总结一下就是得一一对应，并且是互相对应。<br>所以第一种方法可以用两个hashmap互相存储对应关系，再往后进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hashmap1 = &#123;&#125;</span><br><span class="line">        hashmap2 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">            <span class="comment">#The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it.</span></span><br><span class="line">            <span class="keyword">if</span> hashmap1.get(c1, c2) != c2 <span class="keyword">or</span> hashmap2.get(c2, c1) != c1:   </span><br><span class="line">                <span class="comment">#The get() method returns the value for the specified key if the key is in the dictionary.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            hashmap1[c1] = c2</span><br><span class="line">            hashmap2[c2] = c1</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法也是评论里的很有意思的方法，利用set的无重复特性来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(t)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(s, t)))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;205-Isomorphic-Strings-easy&quot;&gt;&lt;a href=&quot;#205-Isomorphic-Strings-easy&quot; class=&quot;headerlink&quot; title=&quot;205. Isomorphic Strings(easy)&quot;&gt;&lt;/a&gt;205</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
  <entry>
    <title>202. Happy Number(easy)</title>
    <link href="http://example.com/2022/08/19/202/"/>
    <id>http://example.com/2022/08/19/202/</id>
    <published>2022-08-19T21:05:01.000Z</published>
    <updated>2022-08-20T04:08:55.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202-Happy-Number-easy"><a href="#202-Happy-Number-easy" class="headerlink" title="202. Happy Number(easy)"></a>202. Happy Number(easy)</h1><h2 id="Write-an-algorithm-to-determine-if-a-number-n-is-happy"><a href="#Write-an-algorithm-to-determine-if-a-number-n-is-happy" class="headerlink" title="Write an algorithm to determine if a number n is happy."></a>Write an algorithm to determine if a number n is happy.</h2><h2 id="A-happy-number-is-a-number-defined-by-the-following-process"><a href="#A-happy-number-is-a-number-defined-by-the-following-process" class="headerlink" title="A happy number is a number defined by the following process:"></a>A happy number is a number defined by the following process:</h2><h2 id="Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits"><a href="#Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits" class="headerlink" title="Starting with any positive integer, replace the number by the sum of the squares of its digits."></a>Starting with any positive integer, replace the number by the sum of the squares of its digits.</h2><h2 id="Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1"><a href="#Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1" class="headerlink" title="Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1."></a>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</h2><h2 id="Those-numbers-for-which-this-process-ends-in-1-are-happy"><a href="#Those-numbers-for-which-this-process-ends-in-1-are-happy" class="headerlink" title="Those numbers for which this process ends in 1 are happy."></a>Those numbers for which this process ends in 1 are happy.</h2><h2 id="Return-true-if-n-is-a-happy-number-and-false-if-not"><a href="#Return-true-if-n-is-a-happy-number-and-false-if-not" class="headerlink" title="Return true if n is a happy number, and false if not."></a>Return true if n is a happy number, and false if not.</h2><p>又是一个奇怪的数，叫做happy number</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">官方题解</a></h3><p>总结一下，数字每一位的平方和后的结果有两种可能性</p><ol><li>变成1</li><li>变成循环</li></ol><p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限增大的选择。</p><p>算法</p><p>算法分为两部分，我们需要设计和编写代码。</p><p>给一个数字 nn，它的下一个数字是什么？<br>按照一系列的数字来判断我们是否进入了一个循环。</p><ol><li><p>我们按照题目的要求做数位分离，求平方和。</p></li><li><p>可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p></li></ol><p>如果它不在哈希集合中，我们应该添加它。<br>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</p><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p>Hashmap解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n_history=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                n_history[n]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                n_history[n]=<span class="number">0</span></span><br><span class="line">                digit_li=[<span class="built_in">str</span>(n)[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(n)))]</span><br><span class="line">                n=<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="built_in">int</span>(x))**<span class="number">2</span>,digit_li)))</span><br><span class="line">                <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">```                </span><br><span class="line">相当于把数字n转换成字符串，再进行平方和运算                </span><br><span class="line">```python                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            seen.add(n)</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">str</span>(n)</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> num:</span><br><span class="line">                temp += <span class="built_in">int</span>(ch)**<span class="number">2</span></span><br><span class="line">            n = temp            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hashset解法</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)   <span class="comment">#divmod求余数</span></span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>() <span class="comment"># python里hashset的本质就是set</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = get_next(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;202-Happy-Number-easy&quot;&gt;&lt;a href=&quot;#202-Happy-Number-easy&quot; class=&quot;headerlink&quot; title=&quot;202. Happy Number(easy)&quot;&gt;&lt;/a&gt;202. Happy Number(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
  <entry>
    <title>169. Majority Element(easy)</title>
    <link href="http://example.com/2022/08/19/169/"/>
    <id>http://example.com/2022/08/19/169/</id>
    <published>2022-08-19T20:38:31.000Z</published>
    <updated>2022-08-20T04:10:11.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="169-Majority-Element-easy"><a href="#169-Majority-Element-easy" class="headerlink" title="169. Majority Element(easy)"></a>169. Majority Element(easy)</h1><h2 id="Given-an-array-nums-of-size-n-return-the-majority-element"><a href="#Given-an-array-nums-of-size-n-return-the-majority-element" class="headerlink" title="Given an array nums of size n, return the majority element."></a>Given an array nums of size n, return the majority element.</h2><h2 id="The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array"><a href="#The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array" class="headerlink" title="The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array."></a>The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h4 id="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"><a href="#堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。" class="headerlink" title="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"></a>堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。</h4><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        hashmap = &#123;&#125;        n=len(nums)        for ans in nums:            if ans not in hashmap:                hashmap[ans]=1            else:                hashmap[ans]+=1        for ans in hashmap:            if hashmap[ans]&gt;n//2:                return ans</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;169-Majority-Element-easy&quot;&gt;&lt;a href=&quot;#169-Majority-Element-easy&quot; class=&quot;headerlink&quot; title=&quot;169. Majority Element(easy)&quot;&gt;&lt;/a&gt;169. Majo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree (Easy)</title>
    <link href="http://example.com/2022/08/17/101/"/>
    <id>http://example.com/2022/08/17/101/</id>
    <published>2022-08-18T03:42:45.000Z</published>
    <updated>2022-08-18T21:36:30.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a>101. Symmetric Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center"><a href="#Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center" class="headerlink" title="Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center)."></a>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type root: TreeNode</span></span><br><span class="line"><span class="string">:rtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left,right</span>):</span></span><br><span class="line"><span class="comment"># 递归的终止条件是两个节点都为空</span></span><br><span class="line"><span class="comment"># 或者两个节点中有一个为空</span></span><br><span class="line"><span class="comment"># 或者两个节点的值不相等</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> left.val!=right.val:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> dfs(left.left,right.right) <span class="keyword">and</span> dfs(left.right,right.left)</span><br><span class="line"><span class="comment"># 用递归函数，比较左节点，右节点</span></span><br><span class="line"><span class="keyword">return</span> dfs(root.left,root.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-Symmetric-Tree-Easy&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree (Easy)&quot;&gt;&lt;/a&gt;101. Symmetric</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>572. Subtree of Another Tree (Easy)</title>
    <link href="http://example.com/2022/08/17/572/"/>
    <id>http://example.com/2022/08/17/572/</id>
    <published>2022-08-18T03:39:46.000Z</published>
    <updated>2022-08-21T01:38:20.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="572-Subtree-of-Another-Tree-Easy"><a href="#572-Subtree-of-Another-Tree-Easy" class="headerlink" title="572. Subtree of Another Tree (Easy)"></a>572. Subtree of Another Tree (Easy)</h1><h2 id="Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise"><a href="#Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise" class="headerlink" title="Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise."></a>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</h2><h2 id="A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself"><a href="#A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself" class="headerlink" title="A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself."></a>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root, subRoot</span>) :</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> curr.val == subRoot.val :</span><br><span class="line">                <span class="keyword">if</span> self.compare(curr,subRoot):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> curr.right:</span><br><span class="line">                queue.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                queue.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self,curr,subRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr.val == subRoot.val :</span><br><span class="line">            r_flag = self.compare(curr.right,subRoot.right)</span><br><span class="line">            l_flag = self.compare(curr.left,subRoot.left)</span><br><span class="line">            <span class="keyword">if</span> r_flag <span class="keyword">and</span> l_flag:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;572-Subtree-of-Another-Tree-Easy&quot;&gt;&lt;a href=&quot;#572-Subtree-of-Another-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;572. Subtree of Another Tree</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>437. Path Sum III (Easy)</title>
    <link href="http://example.com/2022/08/17/437/"/>
    <id>http://example.com/2022/08/17/437/</id>
    <published>2022-08-18T03:34:41.000Z</published>
    <updated>2022-08-18T21:35:06.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="437-Path-Sum-III-Easy"><a href="#437-Path-Sum-III-Easy" class="headerlink" title="437. Path Sum III (Easy)"></a>437. Path Sum III (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</h2><h2 id="The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes"><a href="#The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes" class="headerlink" title="The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes)."></a>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><h3 id="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。"><a href="#我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。" class="headerlink" title="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。"></a>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。</h3><h3 id="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。"><a href="#对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。" class="headerlink" title="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。"></a>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。</h3><h3 id="假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p"><a href="#假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p" class="headerlink" title="假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p"></a>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p</h3><p>1<br>​<br> →p<br>2<br>​<br> →…→p<br>k<br>​<br> →node，此时我们可以已经保存了节点 p_1, p_2, p_3, \ldots, p_kp<br>1<br>​<br> ,p<br>2<br>​<br> ,p<br>3<br>​<br> ,…,p<br>k<br>​<br>  的前缀和，并且计算出了节点 node 的前缀和。</p><p>假设当前从根节点 root 到节点 node 的前缀和为 \textit{curr}curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 \textit{curr} - curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 p_ip<br>i<br>​<br>  到根节点 root 的前缀和为 \textit{curr} - curr−targetSum，则节点 p_{i+1}p<br>i+1<br>​<br>  到 node 的路径上所有节点的和一定为 targetSum。</p><p>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;437-Path-Sum-III-Easy&quot;&gt;&lt;a href=&quot;#437-Path-Sum-III-Easy&quot; class=&quot;headerlink&quot; title=&quot;437. Path Sum III (Easy)&quot;&gt;&lt;/a&gt;437. Path Sum III (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
</feed>
