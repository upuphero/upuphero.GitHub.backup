<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-29T03:38:09.578Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode09</title>
    <link href="http://example.com/2022/06/28/LeetCode09/"/>
    <id>http://example.com/2022/06/28/LeetCode09/</id>
    <published>2022-06-29T03:37:33.000Z</published>
    <updated>2022-06-29T03:38:09.578Z</updated>
    
    <content type="html"><![CDATA[<p>专门列出的一期：hashmap</p><p>官方是有专门的hashmap的<a href="https://leetcode.com/tag/hash-table/">tag</a></p><h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md">Leetcode 题解 - 目录.md</a></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;专门列出的一期：hashmap&lt;/p&gt;
&lt;p&gt;官方是有专门的hashmap的&lt;a href=&quot;https://leetcode.com/tag/hash-table/&quot;&gt;tag&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode08</title>
    <link href="http://example.com/2022/06/28/LeetCode08/"/>
    <id>http://example.com/2022/06/28/LeetCode08/</id>
    <published>2022-06-29T03:14:48.000Z</published>
    <updated>2022-06-29T03:37:47.017Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-动态规划"><a href="#Leetcode-题解-动态规划" class="headerlink" title="Leetcode 题解 - 动态规划"></a>Leetcode 题解 - 动态规划</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>914</title>
    <link href="http://example.com/2022/06/27/914/"/>
    <id>http://example.com/2022/06/27/914/</id>
    <published>2022-06-27T23:53:57.000Z</published>
    <updated>2022-06-27T23:56:33.236Z</updated>
    
    <content type="html"><![CDATA[<ol start="914"><li>卡牌分组</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;914&quot;&gt;
&lt;li&gt;卡牌分组&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Greatest common divisor " scheme="http://example.com/tags/Greatest-common-divisor/"/>
    
  </entry>
  
  <entry>
    <title>204. Count Primes (Easy)</title>
    <link href="http://example.com/2022/06/27/204/"/>
    <id>http://example.com/2022/06/27/204/</id>
    <published>2022-06-27T21:28:56.000Z</published>
    <updated>2022-06-27T23:55:43.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="204-Count-Primes-Easy"><a href="#204-Count-Primes-Easy" class="headerlink" title="204. Count Primes (Easy)"></a>204. Count Primes (Easy)</h1><h2 id="Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n"><a href="#Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n" class="headerlink" title="Given an integer n, return the number of prime numbers that are strictly less than n."></a>Given an integer n, return the number of prime numbers that are strictly less than n.</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/">官方题解</a></h2><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><h3 id="方法二：埃氏筛"><a href="#方法二：埃氏筛" class="headerlink" title="方法二：埃氏筛"></a>方法二：埃氏筛</h3><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 yy 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 xx 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><h4 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.com/problems/count-primes/discuss/153528/Python3-99-112-ms-Explained%3A-The-Sieve-of-Eratosthenes-with-optimizations">leetcode题解</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Sieve of Eratosthenes埃氏筛</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We are only interested in numbers LESS than the input number</span></span><br><span class="line">        <span class="comment"># exit early for numbers LESS than 2; (two is prime)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create strike list for the input range, initializing all indices to</span></span><br><span class="line">        <span class="comment"># prime (1).</span></span><br><span class="line">        strikes = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we know that 0 and 2 are not prime</span></span><br><span class="line">        strikes[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        strikes[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Now set multiples of remaining numbers that are marked as prime to</span></span><br><span class="line">        <span class="comment"># not prime.  It is safe ignore numbers alreay marked as not prime</span></span><br><span class="line">        <span class="comment"># because there are factor(s) that divide evenly into this number and</span></span><br><span class="line">        <span class="comment"># all its multiples.  Use upper limit of (n**0.5)+1, because:</span></span><br><span class="line">        <span class="comment">#  (a) the smallest factor of a non-prime number will not be &gt; sqrt(n).</span></span><br><span class="line">        <span class="comment">#      Ex. non-prime = 100, </span></span><br><span class="line">        <span class="comment">#           5*20</span></span><br><span class="line">        <span class="comment">#           10*10, </span></span><br><span class="line">        <span class="comment">#           20*5   # !! we have seen 5 before.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>  strikes[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># slow:</span></span><br><span class="line">                <span class="comment">#for j in range(i*i, n, i):</span></span><br><span class="line">                <span class="comment">#    strikes[j] = 0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 3x faster:</span></span><br><span class="line">                <span class="comment"># strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)</span></span><br><span class="line">                <span class="comment"># n = 11</span></span><br><span class="line">                <span class="comment"># i = 2</span></span><br><span class="line">                <span class="comment"># (n-1-i*i)//i + 1</span></span><br><span class="line">                <span class="comment"># (n-1)               # get total # of indicies for n (non-inclusive)</span></span><br><span class="line">                <span class="comment">#     -i*i            # shift to get # of slots in range of interest</span></span><br><span class="line">                <span class="comment">#          //i        # get number of groups</span></span><br><span class="line">                <span class="comment">#              + 1    # get number of slots</span></span><br><span class="line">                <span class="comment"># strikes[2*2:11:2]  = [0] * ((11-1-2*2)//2 + 1</span></span><br><span class="line">                <span class="comment"># strikes[4:11:2]    = [0] * 4</span></span><br><span class="line">                <span class="comment"># s[4], s[6], s[8], s10] = 0, 0, 0, 0</span></span><br><span class="line">                strikes[i*i:n:i] = [<span class="number">0</span>] * ((n-<span class="number">1</span>-i*i)//i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(strikes)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]=primes[<span class="number">1</span>]=<span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]= primes[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;204-Count-Primes-Easy&quot;&gt;&lt;a href=&quot;#204-Count-Primes-Easy&quot; class=&quot;headerlink&quot; title=&quot;204. Count Primes (Easy)&quot;&gt;&lt;/a&gt;204. Count Primes (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="prime number" scheme="http://example.com/tags/prime-number/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode07</title>
    <link href="http://example.com/2022/06/26/LeetCode07/"/>
    <id>http://example.com/2022/06/26/LeetCode07/</id>
    <published>2022-06-27T02:22:25.000Z</published>
    <updated>2022-06-27T21:28:33.725Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-数学"><a href="#Leetcode-题解-数学" class="headerlink" title="Leetcode 题解 - 数学"></a>Leetcode 题解 - 数学</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p><h3 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h3><h3 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h3><h3 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h3><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h3><h3 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h3><h3 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h3><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h3><h2 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h2><h3 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h3><h3 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h3><h2 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h2><h3 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h3><h2 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h2><h3 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h3><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h3><h3 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h3><h3 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h3><h3 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode06</title>
    <link href="http://example.com/2022/06/23/LeetCode06/"/>
    <id>http://example.com/2022/06/23/LeetCode06/</id>
    <published>2022-06-24T02:59:51.000Z</published>
    <updated>2022-06-24T03:08:57.344Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-搜索"><a href="#Leetcode-题解-搜索" class="headerlink" title="Leetcode 题解 - 搜索"></a>Leetcode 题解 - 搜索</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="1-计算在网格中从原点到特定点的最短路径长度"><a href="#1-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="1. 计算在网格中从原点到特定点的最短路径长度"></a>1. 计算在网格中从原点到特定点的最短路径长度</h3><h3 id="2-组成整数的最小平方数数量"><a href="#2-组成整数的最小平方数数量" class="headerlink" title="2. 组成整数的最小平方数数量"></a>2. 组成整数的最小平方数数量</h3><h3 id="3-最短单词路径"><a href="#3-最短单词路径" class="headerlink" title="3. 最短单词路径"></a>3. 最短单词路径</h3><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="1-查找最大的连通面积"><a href="#1-查找最大的连通面积" class="headerlink" title="1. 查找最大的连通面积"></a>1. 查找最大的连通面积</h3><h3 id="2-矩阵中的连通分量数目"><a href="#2-矩阵中的连通分量数目" class="headerlink" title="2. 矩阵中的连通分量数目"></a>2. 矩阵中的连通分量数目</h3><h3 id="3-好友关系的连通分量数目"><a href="#3-好友关系的连通分量数目" class="headerlink" title="3. 好友关系的连通分量数目"></a>3. 好友关系的连通分量数目</h3><h3 id="4-填充封闭区域"><a href="#4-填充封闭区域" class="headerlink" title="4. 填充封闭区域"></a>4. 填充封闭区域</h3><h3 id="5-能到达的太平洋和大西洋的区域"><a href="#5-能到达的太平洋和大西洋的区域" class="headerlink" title="5. 能到达的太平洋和大西洋的区域"></a>5. 能到达的太平洋和大西洋的区域</h3><h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h3 id="1-数字键盘组合"><a href="#1-数字键盘组合" class="headerlink" title="1. 数字键盘组合"></a>1. 数字键盘组合</h3><h3 id="2-IP-地址划分"><a href="#2-IP-地址划分" class="headerlink" title="2. IP 地址划分"></a>2. IP 地址划分</h3><h3 id="3-在矩阵中寻找字符串"><a href="#3-在矩阵中寻找字符串" class="headerlink" title="3. 在矩阵中寻找字符串"></a>3. 在矩阵中寻找字符串</h3><h3 id="4-输出二叉树中所有从根到叶子的路径"><a href="#4-输出二叉树中所有从根到叶子的路径" class="headerlink" title="4. 输出二叉树中所有从根到叶子的路径"></a>4. 输出二叉树中所有从根到叶子的路径</h3><h3 id="5-排列"><a href="#5-排列" class="headerlink" title="5. 排列"></a>5. 排列</h3><h3 id="6-含有相同元素求排列"><a href="#6-含有相同元素求排列" class="headerlink" title="6. 含有相同元素求排列"></a>6. 含有相同元素求排列</h3><h3 id="7-组合"><a href="#7-组合" class="headerlink" title="7. 组合"></a>7. 组合</h3><h3 id="8-组合求和"><a href="#8-组合求和" class="headerlink" title="8. 组合求和"></a>8. 组合求和</h3><h3 id="9-含有相同元素的组合求和"><a href="#9-含有相同元素的组合求和" class="headerlink" title="9. 含有相同元素的组合求和"></a>9. 含有相同元素的组合求和</h3><h3 id="10-1-9-数字的组合求和"><a href="#10-1-9-数字的组合求和" class="headerlink" title="10. 1-9 数字的组合求和"></a>10. 1-9 数字的组合求和</h3><h3 id="11-子集"><a href="#11-子集" class="headerlink" title="11. 子集"></a>11. 子集</h3><h3 id="12-含有相同元素求子集"><a href="#12-含有相同元素求子集" class="headerlink" title="12. 含有相同元素求子集"></a>12. 含有相同元素求子集</h3><h3 id="13-分割字符串使得每个部分都是回文数"><a href="#13-分割字符串使得每个部分都是回文数" class="headerlink" title="13. 分割字符串使得每个部分都是回文数"></a>13. 分割字符串使得每个部分都是回文数</h3><h3 id="14-数独"><a href="#14-数独" class="headerlink" title="14. 数独"></a>14. 数独</h3><h3 id="15-N-皇后"><a href="#15-N-皇后" class="headerlink" title="15. N 皇后"></a>15. N 皇后</h3><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>bfs是按一层一层来访问的，所以适合有目标求最短路的步数，你想想层层搜索每次层就代表了一步。bfs优先访问的是兄弟节点，只有这一层全部访问完才能访问下一层，也就是说bfs第几层就代表当前可以走到的位置(结点).而dfs是按递归来实现的，它优先搜索深度，再回溯，优先访问的是没有访问过的子节点<br>DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。<br>总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易”控制”)，BFS通过控制队列可以很好解决”爆队列”风险。<br>它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>95. Unique Binary Search Trees II (Medium)</title>
    <link href="http://example.com/2022/06/21/95/"/>
    <id>http://example.com/2022/06/21/95/</id>
    <published>2022-06-22T02:47:55.000Z</published>
    <updated>2022-06-23T15:35:37.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a>95. Unique Binary Search Trees II (Medium)</h1><h2 id="Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order"><a href="#Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order" class="headerlink" title="Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order."></a>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><h2 id="官方leetcode-题解"><a href="#官方leetcode-题解" class="headerlink" title="官方leetcode 题解"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">官方leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>,]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):  <span class="comment"># 枚举可行根节点</span></span><br><span class="line">                <span class="comment"># 获得所有可行的左子树集合</span></span><br><span class="line">                leftTrees = generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获得所有可行的右子树集合</span></span><br><span class="line">                rightTrees = generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        currTree = TreeNode(i)</span><br><span class="line">                        currTree.left = l</span><br><span class="line">                        currTree.right = r</span><br><span class="line">                        allTrees.append(currTree)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;95-Unique-Binary-Search-Trees-II-Medium&quot;&gt;&lt;a href=&quot;#95-Unique-Binary-Search-Trees-II-Medium&quot; class=&quot;headerlink&quot; title=&quot;95. Unique Bin</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="divide and conquer" scheme="http://example.com/tags/divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>241. Different Ways to Add Parentheses (Medium)</title>
    <link href="http://example.com/2022/06/21/241/"/>
    <id>http://example.com/2022/06/21/241/</id>
    <published>2022-06-22T02:47:33.000Z</published>
    <updated>2022-06-23T15:36:10.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses-Medium"><a href="#241-Different-Ways-to-Add-Parentheses-Medium" class="headerlink" title="241. Different Ways to Add Parentheses (Medium)"></a>241. Different Ways to Add Parentheses (Medium)</h1><h2 id="Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order"><a href="#Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order" class="headerlink" title="Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order."></a>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</h2><h2 id="The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4"><a href="#The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4" class="headerlink" title="The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4."></a>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;2-1-1&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">Explanation:</span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure><h2 id="分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"><a href="#分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。" class="headerlink" title="分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"></a>分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</h2><h2 id="分治法解题的一般步骤（如图1）："><a href="#分治法解题的一般步骤（如图1）：" class="headerlink" title="分治法解题的一般步骤（如图1）："></a>分治法解题的一般步骤（如图1）：</h2><h3 id="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"><a href="#（1）分解，将要解决的问题划分成若干规模较小的同类问题；" class="headerlink" title="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"></a>（1）分解，将要解决的问题划分成若干规模较小的同类问题；</h3><h3 id="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"><a href="#（2）求解，当子问题划分得足够小时，用较简单的方法解决；" class="headerlink" title="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"></a>（2）求解，当子问题划分得足够小时，用较简单的方法解决；</h3><h3 id="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"><a href="#（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。" class="headerlink" title="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"></a>（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</h3><h2 id="leetcode-题解"><a href="#leetcode-题解" class="headerlink" title="leetcode 题解"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/">leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;241-Different-Ways-to-Add-Parentheses-Medium&quot;&gt;&lt;a href=&quot;#241-Different-Ways-to-Add-Parentheses-Medium&quot; class=&quot;headerlink&quot; title=&quot;241.</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="divide and conquer" scheme="http://example.com/tags/divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <link href="http://example.com/2022/06/20/34/"/>
    <id>http://example.com/2022/06/20/34/</id>
    <published>2022-06-21T02:40:29.000Z</published>
    <updated>2022-06-21T03:51:34.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a>34. Find First and Last Position of Element in Sorted Array (Medium)</h1><h2 id="Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value"><a href="#Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value" class="headerlink" title="Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value."></a>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</h2><h2 id="If-target-is-not-found-in-the-array-return-1-1"><a href="#If-target-is-not-found-in-the-array-return-1-1" class="headerlink" title="If target is not found in the array, return [-1, -1]."></a>If target is not found in the array, return [-1, -1].</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/837944">Solution</a>:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        start = binarysearchleft(nums, target)</span><br><span class="line">        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start, end]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#34-Find-First-and-Last-Position-of-Element-in-Sorted-Ar</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array (Medium)</title>
    <link href="http://example.com/2022/06/20/153/"/>
    <id>http://example.com/2022/06/20/153/</id>
    <published>2022-06-21T02:40:20.000Z</published>
    <updated>2022-06-23T15:36:16.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a>153. Find Minimum in Rotated Sorted Array (Medium)</h1><h2 id="Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become"><a href="#Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become" class="headerlink" title="Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:"></a>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</h2><h2 id="4-5-6-7-0-1-2-if-it-was-rotated-4-times"><a href="#4-5-6-7-0-1-2-if-it-was-rotated-4-times" class="headerlink" title="[4,5,6,7,0,1,2] if it was rotated 4 times."></a>[4,5,6,7,0,1,2] if it was rotated 4 times.</h2><h2 id="0-1-2-4-5-6-7-if-it-was-rotated-7-times"><a href="#0-1-2-4-5-6-7-if-it-was-rotated-7-times" class="headerlink" title="[0,1,2,4,5,6,7] if it was rotated 7 times."></a>[0,1,2,4,5,6,7] if it was rotated 7 times.</h2><h2 id="Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2"><a href="#Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2" class="headerlink" title="Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]."></a>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].</h2><h2 id="Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array"><a href="#Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array" class="headerlink" title="Given the sorted rotated array nums of unique elements, return the minimum element of this array."></a>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</h2><h2 id="You-must-write-an-algorithm-that-runs-in-O-log-n-time"><a href="#You-must-write-an-algorithm-that-runs-in-O-log-n-time" class="headerlink" title="You must write an algorithm that runs in O(log n) time."></a>You must write an algorithm that runs in O(log n) time.</h2><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[last] :                </span><br><span class="line">                last = mid         </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[first]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;153-Find-Minimum-in-Rotated-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#153-Find-Minimum-in-Rotated-Sorted-Array-Medium&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>278. First Bad Version (Easy)</title>
    <link href="http://example.com/2022/06/20/278/"/>
    <id>http://example.com/2022/06/20/278/</id>
    <published>2022-06-21T02:27:02.000Z</published>
    <updated>2022-06-21T03:51:02.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a>278. First Bad Version (Easy)</h1><h2 id="You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad"><a href="#You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad" class="headerlink" title="You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad."></a>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</h2><h2 id="Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad"><a href="#Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad" class="headerlink" title="Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad."></a>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</h2><h2 id="You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API"><a href="#You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API" class="headerlink" title="You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."></a>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/">官方题解</a></h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p><p>具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><p>solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):                </span><br><span class="line">                last= mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">               </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;278-First-Bad-Version-Easy&quot;&gt;&lt;a href=&quot;#278-First-Bad-Version-Easy&quot; class=&quot;headerlink&quot; title=&quot;278. First Bad Version (Easy)&quot;&gt;&lt;/a&gt;278. </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>540. Single Element in a Sorted Array (Medium)</title>
    <link href="http://example.com/2022/06/20/540/"/>
    <id>http://example.com/2022/06/20/540/</id>
    <published>2022-06-21T01:39:30.000Z</published>
    <updated>2022-06-21T03:50:48.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="540-Single-Element-in-a-Sorted-Array-Medium"><a href="#540-Single-Element-in-a-Sorted-Array-Medium" class="headerlink" title="540. Single Element in a Sorted Array (Medium)"></a>540. Single Element in a Sorted Array (Medium)</h1><h2 id="You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once"><a href="#You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once" class="headerlink" title="You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once."></a>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</h2><h2 id="Return-the-single-element-that-appears-only-once"><a href="#Return-the-single-element-that-appears-only-once" class="headerlink" title="Return the single element that appears only once."></a>Return the single element that appears only once.</h2><h2 id="Your-solution-must-run-in-O-log-n-time-and-O-1-space"><a href="#Your-solution-must-run-in-O-log-n-time-and-O-1-space" class="headerlink" title="Your solution must run in O(log n) time and O(1) space."></a>Your solution must run in O(log n) time and O(1) space.</h2><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。<br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-y8gh/">官方题解</a></h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>这道题的特点在于比较的不是数字本身的大小，而是下标的奇偶性。因为只有一个数只出现一次，所以这个数字的下标就只能是偶数。</p><p>由于数组是有序的，因此数组中相同的元素一定相邻。对于下标 x 左边的下标 y，如果 nums[y]=nums[y+1]，则 y 一定是偶数；对于下标 x 右边的下标 z，如果 nums[z]=nums[z+1]，则 z 一定是奇数。由于下标 x 是相同元素的开始下标的奇偶性的分界，因此可以使用二分查找的方法寻找下标 x。</p><p>初始时，二分查找的左边界是 0，右边界是数组的最大下标。每次取左右边界的平均值 mid 作为待判断的下标，根据 mid 的奇偶性决定和左边或右边的相邻元素比较：</p><p>如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；</p><p>如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。</p><p>如果上述比较相邻元素的结果是相等，则 mid&lt;x, 调整左边界。否则 mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 x 的值。</p><p>得到下标 x 的值之后，nums[x] 即为只出现一次的元素。</p><p>⊕ 是按位异或运算符</p><p>当 mid 是偶数时， mid+1=mid⊕1；</p><p>当 mid 是奇数时， mid−1=mid⊕1。</p><h2 id="注：按位异或-按位或-按位与-amp"><a href="#注：按位异或-按位或-按位与-amp" class="headerlink" title="注：按位异或 ^ ,按位或 | ,按位与 &amp;"></a>注：按位异或 ^ ,按位或 | ,按位与 &amp;</h2><p>也就是说判断奇偶性是靠异或运算</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid ^ <span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;540-Single-Element-in-a-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#540-Single-Element-in-a-Sorted-Array-Medium&quot; class=&quot;headerlink&quot; title=&quot;540. S</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>16. 3Sum Closest(medium)</title>
    <link href="http://example.com/2022/06/16/16/"/>
    <id>http://example.com/2022/06/16/16/</id>
    <published>2022-06-16T19:24:32.000Z</published>
    <updated>2022-06-16T19:32:58.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="16-3Sum-Closest-medium"><a href="#16-3Sum-Closest-medium" class="headerlink" title="16. 3Sum Closest(medium)"></a>16. 3Sum Closest(medium)</h1><h2 id="Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target"><a href="#Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target" class="headerlink" title="Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target."></a>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</h2><h2 id="Return-the-sum-of-the-three-integers"><a href="#Return-the-sum-of-the-three-integers" class="headerlink" title="Return the sum of the three integers."></a>Return the sum of the three integers.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution" class="headerlink" title="You may assume that each input would have exactly one solution."></a>You may assume that each input would have exactly one solution.</h2><p><a href="https://leetcode.cn/problems/3sum-closest/solution/pythonshuang-zhi-zhen-you-hua-ji-bai-999-by-hardca/">排序 + 双指针</a><br>这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。</p><p>优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()         <span class="comment"># 排序</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):        <span class="comment"># 枚举第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]: <span class="keyword">continue</span>     <span class="comment"># 保证first不会有重复</span></span><br><span class="line"></span><br><span class="line">            second, third = first + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            max_sum = nums[first] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>]</span><br><span class="line">            min_sum = nums[first] + nums[first + <span class="number">1</span>] + nums[first + <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> max_sum &lt;= target:    <span class="comment"># 最大的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(max_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = max_sum</span><br><span class="line">                <span class="keyword">continue</span>              </span><br><span class="line">            <span class="keyword">elif</span> min_sum &gt;= target:  <span class="comment"># 最小的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(min_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = min_sum      </span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                two_sum_target = target - nums[first]</span><br><span class="line">                s = nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s + nums[first] - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = s + nums[first]</span><br><span class="line">                <span class="keyword">if</span> s &gt; two_sum_target:  <span class="comment"># 当前数值太大 右指针左移</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third + <span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; two_sum_target:  <span class="comment"># 当前数值太小 左指针右移</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 刚好等于 直接返回target即可</span></span><br><span class="line">                    <span class="keyword">return</span> target </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;16-3Sum-Closest-medium&quot;&gt;&lt;a href=&quot;#16-3Sum-Closest-medium&quot; class=&quot;headerlink&quot; title=&quot;16. 3Sum Closest(medium)&quot;&gt;&lt;/a&gt;16. 3Sum Closest(m</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="sort" scheme="http://example.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>744. Find Smallest Letter Greater Than Target (Easy)</title>
    <link href="http://example.com/2022/06/16/744/"/>
    <id>http://example.com/2022/06/16/744/</id>
    <published>2022-06-16T16:42:31.000Z</published>
    <updated>2022-06-21T01:40:29.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="744-Find-Smallest-Letter-Greater-Than-Target-Easy"><a href="#744-Find-Smallest-Letter-Greater-Than-Target-Easy" class="headerlink" title="744. Find Smallest Letter Greater Than Target (Easy)"></a>744. Find Smallest Letter Greater Than Target (Easy)</h1><h2 id="Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target"><a href="#Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target" class="headerlink" title="Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target."></a>Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;d&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;k&quot;</span><br><span class="line">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure><p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution/xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7/">官方题解</a></h2><h2 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h2><p>由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。</p><p>如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>((letter <span class="keyword">for</span> letter <span class="keyword">in</span> letters <span class="keyword">if</span> letter &gt; target), letters[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。</p><p>初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> letters[bisect_right(letters, target)] <span class="keyword">if</span> target &lt; letters[-<span class="number">1</span>] <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h3 id="自己写的完全版"><a href="#自己写的完全版" class="headerlink" title="自己写的完全版"></a>自己写的完全版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        first,last=<span class="number">0</span>,<span class="built_in">len</span>(letters)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意如果目标值大于或等于有序列表的最后一项，返回值为首元素</span></span><br><span class="line">        <span class="comment">#letters[-1]是列表最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> target&gt;=letters[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+ (last-first)//<span class="number">2</span> <span class="comment">#1//2=0,向下取整</span></span><br><span class="line">            <span class="keyword">if</span> letters[mid]&lt;=target:</span><br><span class="line">                first=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = mid</span><br><span class="line">        <span class="keyword">return</span> letters[first]                </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;744-Find-Smallest-Letter-Greater-Than-Target-Easy&quot;&gt;&lt;a href=&quot;#744-Find-Smallest-Letter-Greater-Than-Target-Easy&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>69. Sqrt(x) (Easy)</title>
    <link href="http://example.com/2022/06/16/69/"/>
    <id>http://example.com/2022/06/16/69/</id>
    <published>2022-06-16T14:18:13.000Z</published>
    <updated>2022-06-16T16:42:00.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h1><h2 id="Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x"><a href="#Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x" class="headerlink" title="Given a non-negative integer x, compute and return the square root of x."></a>Given a non-negative integer x, compute and return the square root of x.</h2><h2 id="Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned"><a href="#Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned" class="headerlink" title="Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned."></a>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</h2><h2 id="Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5"><a href="#Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5" class="headerlink" title="Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5"></a>Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5</h2><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: </span><br><span class="line">            first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(left-right)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="comment">#mid = (left + right) // 2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="方法二：牛顿迭代"><a href="#方法二：牛顿迭代" class="headerlink" title="方法二：牛顿迭代"></a>方法二：牛顿迭代</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;69-Sqrt-x-Easy&quot;&gt;&lt;a href=&quot;#69-Sqrt-x-Easy&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x) (Easy)&quot;&gt;&lt;/a&gt;69. Sqrt(x) (Easy)&lt;/h1&gt;&lt;h2 id=&quot;Given-a-n</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode05</title>
    <link href="http://example.com/2022/06/16/LeetCode05/"/>
    <id>http://example.com/2022/06/16/LeetCode05/</id>
    <published>2022-06-16T14:12:48.000Z</published>
    <updated>2022-06-16T15:58:17.017Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-二分查找"><a href="#Leetcode-题解-二分查找" class="headerlink" title="Leetcode 题解 - 二分查找"></a>Leetcode 题解 - 二分查找</h1><h2 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h2><h2 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h2><h2 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h2><h2 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h2><h2 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h2><h2 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h2><p>二分查找 binary search algorithm</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="m-计算"><a href="#m-计算" class="headerlink" title="m 计算"></a>m 计算</h2><p>有两种计算中值 m 的方式：</p><p>m = (l + h) / 2<br>m = l + (h - l) / 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p><h2 id="未成功查找的返回值"><a href="#未成功查找的返回值" class="headerlink" title="未成功查找的返回值"></a>未成功查找的返回值</h2><p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p><p>-1：以一个错误码表示没有查找到 key<br>l：将 key 插入到 nums 中的正确位置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>763. Partition Labels (Medium)</title>
    <link href="http://example.com/2022/06/13/763/"/>
    <id>http://example.com/2022/06/13/763/</id>
    <published>2022-06-14T03:40:49.000Z</published>
    <updated>2022-06-14T03:51:29.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="763-Partition-Labels-Medium"><a href="#763-Partition-Labels-Medium" class="headerlink" title="763. Partition Labels (Medium)"></a>763. Partition Labels (Medium)</h1><h2 id="You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part"><a href="#You-are-given-a-string-s-We-want-to-partition-the-string-into-as-many-parts-as-possible-so-that-each-letter-appears-in-at-most-one-part" class="headerlink" title="You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part."></a>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</h2><h2 id="Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s"><a href="#Note-that-the-partition-is-done-so-that-after-concatenating-all-the-parts-in-order-the-resultant-string-should-be-s" class="headerlink" title="Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s."></a>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</h2><h2 id="Return-a-list-of-integers-representing-the-size-of-these-parts"><a href="#Return-a-list-of-integers-representing-the-size-of-these-parts" class="headerlink" title="Return a list of integers representing the size of these parts."></a>Return a list of integers representing the size of these parts.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-labels/solution/python-jiu-zhe-quan-guo-zui-cai-you-hua-dai-ma-by-/">思路</a>:<br>其实思路很简单，<br>1， 首先看第一个字母，找到它在串里最后的一个位置，记作last或一段的最后位置。<br>2， 在从0~last这个范围里，挨个查其他字母，看他们的最后位置是不是比刚才的last或一段的最后位置大。<br>如果没有刚才的last或一段的最后位置大，无视它继续往后找。<br>如果比刚才的大，说明这一段的分隔位置必须往后移动，所以我们把last或一段的最后位置更新为当前的字母的最后位置。<br>3，肯定到有一个时间，这个last就更新不了了，那么这个时候这个位置就是我们的分隔位置。<br>注意题目要分隔后的长度，我们就用last - startindex + 1。<br>4，找到一个分割位，更新一下起始位置，同理搜索就行了。</p><p>用字典的好处就是不用每次都搜索位置了。直接用字典存所有字符的最后位置就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;<span class="built_in">list</span>[<span class="built_in">int</span>]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end) <span class="comment">#如果最后位置比刚才的大，就更新最后位置</span></span><br><span class="line">            <span class="keyword">if</span> i == end: <span class="comment">#这里就是找到这一段的结束了，就说明当前位置的index和这个字母在字典里的最后位置应该是相同的。</span></span><br><span class="line">                ans.append(end - start + <span class="number">1</span>) <span class="comment"># 加入result</span></span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;763-Partition-Labels-Medium&quot;&gt;&lt;a href=&quot;#763-Partition-Labels-Medium&quot; class=&quot;headerlink&quot; title=&quot;763. Partition Labels (Medium)&quot;&gt;&lt;/a&gt;76</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>53. Maximum Subarray (Easy)</title>
    <link href="http://example.com/2022/06/13/53/"/>
    <id>http://example.com/2022/06/13/53/</id>
    <published>2022-06-14T03:09:56.000Z</published>
    <updated>2022-06-14T03:52:46.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a>53. Maximum Subarray (Easy)</h1><h2 id="Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum"><a href="#Given-an-integer-array-nums-find-the-contiguous-subarray-containing-at-least-one-number-which-has-the-largest-sum-and-return-its-sum" class="headerlink" title="Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum."></a>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</h2><h1 id="A-subarray-is-a-contiguous-part-of-an-array"><a href="#A-subarray-is-a-contiguous-part-of-an-array" class="headerlink" title="A subarray is a contiguous part of an array."></a>A subarray is a contiguous part of an array.</h1><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>这题第一眼非常像买股票第一弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="comment">#float(&#x27;inf&#x27;)表示正无穷大</span></span><br><span class="line">        maxprofit = <span class="number">0</span> <span class="comment">#保存当前最大的利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices: <span class="comment">#一次遍历</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(price - minprice, maxprofit)<span class="comment">#当前利润与最大的利润相比</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice) <span class="comment">#保存当前最小的价格</span></span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure><h2 id="本质上是动态规划问题："><a href="#本质上是动态规划问题：" class="headerlink" title="本质上是动态规划问题："></a>本质上是动态规划问题：</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">leetcode题解</a></p><p>方法一：动态规划<br>「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。</p><p>本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。</p><h2 id="关键-1：理解题意"><a href="#关键-1：理解题意" class="headerlink" title="关键 1：理解题意"></a>关键 1：理解题意</h2><p>题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。</p><p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。</p><h2 id="关键-2：如何定义子问题（如何定义状态）"><a href="#关键-2：如何定义子问题（如何定义状态）" class="headerlink" title="关键 2：如何定义子问题（如何定义状态）"></a>关键 2：如何定义子问题（如何定义状态）</h2><p>设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。</p><p>友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，</p><p>我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。</p><p>例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：</p><p>子问题 1：经过 -2 的连续子数组的最大和是多少；<br>子问题 2：经过 1 的连续子数组的最大和是多少；<br>子问题 3：经过 -3 的连续子数组的最大和是多少；<br>子问题 4：经过 4 的连续子数组的最大和是多少；<br>子问题 5：经过 -1 的连续子数组的最大和是多少；<br>子问题 6：经过 2 的连续子数组的最大和是多少；<br>子问题 7：经过 1 的连续子数组的最大和是多少；<br>子问题 8：经过 -5 的连续子数组的最大和是多少；<br>子问题 9：经过 4 的连续子数组的最大和是多少。<br>一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。</p><p>例如「子问题 3」：经过 -3 的连续子数组的最大和是多少。</p><p>「经过 -3 的连续子数组」我们任意举出几个：</p><p>[-2,1,-3,4] ，-3 是这个连续子数组的第 3 个元素；<br>[1,-3,4,-1] ，-3 是这个连续子数组的第 2 个元素；<br>……<br>我们不确定的是：-3 是连续子数组的第几个元素。那么我们就把 -3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>子问题 3：以 -3 结尾的连续子数组的最大和是多少；<br>子问题 4：以 4 结尾的连续子数组的最大和是多少；<br>子问题 5：以 -1 结尾的连续子数组的最大和是多少；<br>子问题 6：以 2 结尾的连续子数组的最大和是多少；<br>子问题 7：以 1 结尾的连续子数组的最大和是多少；<br>子问题 8：以 -5 结尾的连续子数组的最大和是多少；<br>子问题 9：以 4 结尾的连续子数组的最大和是多少。<br>我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：</p><p>子问题 1：以 -2 结尾的连续子数组的最大和是多少；<br>以 -2 结尾的连续子数组是 [-2]，因此最大和就是 -2。</p><p>子问题 2：以 1 结尾的连续子数组的最大和是多少；<br>以 1 结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 &lt; 1−2+1=−1&lt;1 ，因此「子问题 2」 的答案是 1。</p><p>大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：</p><p>一个数 a 加上负数的结果比 a 更小；<br>一个数 a 加上 0 的结果不会比 a 更大；<br>而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 nums[i] 结尾的那个数。<br>因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。</p><p>接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。</p><h2 id="定义状态（定义子问题）"><a href="#定义状态（定义子问题）" class="headerlink" title="定义状态（定义子问题）"></a>定义状态（定义子问题）</h2><p>dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。</p><p>说明：「结尾」和「连续」是关键字。</p><h2 id="状态转移方程（描述子问题之间的联系）"><a href="#状态转移方程（描述子问题之间的联系）" class="headerlink" title="状态转移方程（描述子问题之间的联系）"></a>状态转移方程（描述子问题之间的联系）</h2><p>根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。</p><p>假设数组 nums 的值全都严格大于 0，那么一定有 dp[i] = dp[i - 1] + nums[i]。</p><p>可是 dp[i - 1] 有可能是负数，于是分类讨论：</p><p>如果 dp[i - 1] &gt; 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；<br>如果 dp[i - 1] &lt;= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。</p><h2 id="思考初始值"><a href="#思考初始值" class="headerlink" title="思考初始值"></a>思考初始值</h2><p>dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。</p><h2 id="思考输出"><a href="#思考输出" class="headerlink" title="思考输出"></a>思考输出</h2><p>注意：</p><h3 id="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"><a href="#这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；" class="headerlink" title="这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；"></a>这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-Maximum-Subarray-Easy&quot;&gt;&lt;a href=&quot;#53-Maximum-Subarray-Easy&quot; class=&quot;headerlink&quot; title=&quot;53. Maximum Subarray (Easy)&quot;&gt;&lt;/a&gt;53. Maximum</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>665. Non-decreasing Array(medium)</title>
    <link href="http://example.com/2022/06/13/665/"/>
    <id>http://example.com/2022/06/13/665/</id>
    <published>2022-06-14T02:13:19.000Z</published>
    <updated>2022-06-14T03:51:01.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="665-Non-decreasing-Array-medium"><a href="#665-Non-decreasing-Array-medium" class="headerlink" title="665. Non-decreasing Array(medium)"></a>665. Non-decreasing Array(medium)</h1><h2 id="Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element"><a href="#Given-an-array-nums-with-n-integers-your-task-is-to-check-if-it-could-become-non-decreasing-by-modifying-at-most-one-element" class="headerlink" title="Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element."></a>Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.</h2><h2 id="We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2"><a href="#We-define-an-array-is-non-decreasing-if-nums-i-lt-nums-i-1-holds-for-every-i-0-based-such-that-0-lt-i-lt-n-2" class="headerlink" title="We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2)."></a>We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2).</h2><p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure><p>这道题的关键在于修改哪个数，本题在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><p>思路:<br>nums[i] &lt; nums[i - 1]:<br>    nums[i - 1] = nums[i]<br>nums[i] &lt; nums[i - 2]:<br>    nums[i] = nums[i - 1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">2</span>] <span class="keyword">and</span> i-<span class="number">2</span>&gt;=<span class="number">0</span> :</span><br><span class="line">                nums[i]=nums[i-<span class="number">1</span>]</span><br><span class="line">                cnt+=<span class="number">1</span>              </span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[i-<span class="number">1</span>]= nums[i]</span><br><span class="line">                cnt+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;665-Non-decreasing-Array-medium&quot;&gt;&lt;a href=&quot;#665-Non-decreasing-Array-medium&quot; class=&quot;headerlink&quot; title=&quot;665. Non-decreasing Array(medi</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>392. Is Subsequence (Medium)</title>
    <link href="http://example.com/2022/06/13/392/"/>
    <id>http://example.com/2022/06/13/392/</id>
    <published>2022-06-14T01:58:20.000Z</published>
    <updated>2022-06-14T03:50:49.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="392-Is-Subsequence-Medium"><a href="#392-Is-Subsequence-Medium" class="headerlink" title="392. Is Subsequence (Medium)"></a>392. Is Subsequence (Medium)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-s-is-a-subsequence-of-t-or-false-otherwise" class="headerlink" title="Given two strings s and t, return true if s is a subsequence of t, or false otherwise."></a>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</h2><h2 id="A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not"><a href="#A-subsequence-of-a-string-is-a-new-string-that-is-formed-from-the-original-string-by-deleting-some-can-be-none-of-the-characters-without-disturbing-the-relative-positions-of-the-remaining-characters-i-e-“ace”-is-a-subsequence-of-“abcde”-while-“aec”-is-not" class="headerlink" title="A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not)."></a>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</h2><p>本题询问的是，s 是否是 t 的子序列，因此只要能找到任意一种 s 在 t 中出现的方式，即可认为 s 是 t 的子序列。</p><p>而当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。</p><p>这样，我们初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。</p><p>最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p><p>Example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i]==t[j]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;392-Is-Subsequence-Medium&quot;&gt;&lt;a href=&quot;#392-Is-Subsequence-Medium&quot; class=&quot;headerlink&quot; title=&quot;392. Is Subsequence (Medium)&quot;&gt;&lt;/a&gt;392. Is </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="greedy algorithm" scheme="http://example.com/tags/greedy-algorithm/"/>
    
    <category term="Dynamic Programming" scheme="http://example.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
