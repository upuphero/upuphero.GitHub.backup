<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  <subtitle>Engineering House</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-22T02:19:24.398Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>290. Word Pattern(easy)</title>
    <link href="http://example.com/2022/08/21/290/"/>
    <id>http://example.com/2022/08/21/290/</id>
    <published>2022-08-22T02:07:56.000Z</published>
    <updated>2022-08-22T02:19:24.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="290-Word-Pattern-easy"><a href="#290-Word-Pattern-easy" class="headerlink" title="290. Word Pattern(easy)"></a>290. Word Pattern(easy)</h1><h2 id="Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern"><a href="#Given-a-pattern-and-a-string-s-find-if-s-follows-the-same-pattern" class="headerlink" title="Given a pattern and a string s, find if s follows the same pattern."></a>Given a pattern and a string s, find if s follows the same pattern.</h2><h2 id="Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s"><a href="#Here-follow-means-a-full-match-such-that-there-is-a-bijection-between-a-letter-in-pattern-and-a-non-empty-word-in-s" class="headerlink" title="Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s."></a>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>这道题与<a href="https://leetcode-cn.com/problems/isomorphic-strings/">205.同构字符串</a>几乎一样，区别在于：<br>1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况</p><p>2.本题需要将s分隔成单个单词</p><p>常规做法是，根据pattern和s的对应关系建立一个hashmap，然后再遍历s与hashmap的映射做比较，有不一样就返回false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s=s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern))!=<span class="built_in">len</span>(<span class="built_in">set</span>(s)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> pattern[i] <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[pattern[i]]=s[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pattern)):</span><br><span class="line">            <span class="keyword">if</span> hashmap[pattern[i]]!=s[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优雅的python解法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        s = s.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pattern) != <span class="built_in">len</span>(s): </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(pattern)) == <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(pattern,s)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;290-Word-Pattern-easy&quot;&gt;&lt;a href=&quot;#290-Word-Pattern-easy&quot; class=&quot;headerlink&quot; title=&quot;290. Word Pattern(easy)&quot;&gt;&lt;/a&gt;290. Word Pattern(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>350. Intersection of Two Arrays II</title>
    <link href="http://example.com/2022/08/21/350/"/>
    <id>http://example.com/2022/08/21/350/</id>
    <published>2022-08-21T21:13:28.000Z</published>
    <updated>2022-08-22T02:08:09.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-appear-as-many-times-as-it-shows-in-both-arrays-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</h2><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii">https://leetcode.cn/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/">官方题解</a><br>用的是heap 加hashmap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.intersect(nums2, nums1)</span><br><span class="line">        </span><br><span class="line">        m = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            m[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        intersection = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> (count := m.get(num, <span class="number">0</span>)) &gt; <span class="number">0</span>:</span><br><span class="line">                intersection.append(num)</span><br><span class="line">                m[num] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m[num] == <span class="number">0</span>:</span><br><span class="line">                    m.pop(num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intersection</span><br></pre></td></tr></table></figure><p>这个方法用的是python一些独特的函数 Counter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        num1 = collections.Counter(nums1)</span><br><span class="line">        num2 = collections.Counter(nums2)</span><br><span class="line">        num = num1 &amp; num2</span><br><span class="line">        <span class="keyword">return</span> num.elements()</span><br></pre></td></tr></table></figure><p>链接：<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;350-Intersection-of-Two-Arrays-II&quot;&gt;&lt;a href=&quot;#350-Intersection-of-Two-Arrays-II&quot; class=&quot;headerlink&quot; title=&quot;350. Intersection of Two A</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>349. Intersection of Two Arrays</title>
    <link href="http://example.com/2022/08/21/349/"/>
    <id>http://example.com/2022/08/21/349/</id>
    <published>2022-08-21T20:57:39.000Z</published>
    <updated>2022-08-21T21:07:10.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a>349. Intersection of Two Arrays</h1><h2 id="Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order"><a href="#Given-two-integer-arrays-nums1-and-nums2-return-an-array-of-their-intersection-Each-element-in-the-result-must-be-unique-and-you-may-return-the-result-in-any-order" class="headerlink" title="Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order."></a>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p>这题相对比较简单，就是找到nums1 和nums2相同的数字，并且输出hashset（不能输出重复数字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[i]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[i]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hashmap:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;349-Intersection-of-Two-Arrays&quot;&gt;&lt;a href=&quot;#349-Intersection-of-Two-Arrays&quot; class=&quot;headerlink&quot; title=&quot;349. Intersection of Two Arrays&quot;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>299. Bulls and Cows</title>
    <link href="http://example.com/2022/08/21/299/"/>
    <id>http://example.com/2022/08/21/299/</id>
    <published>2022-08-21T20:19:24.000Z</published>
    <updated>2022-08-21T20:21:32.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a>299. Bulls and Cows</h1><h2 id="You-are-playing-the-Bulls-and-Cows-game-with-your-friend"><a href="#You-are-playing-the-Bulls-and-Cows-game-with-your-friend" class="headerlink" title="You are playing the Bulls and Cows game with your friend."></a>You are playing the Bulls and Cows game with your friend.</h2><h2 id="You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info"><a href="#You-write-down-a-secret-number-and-ask-your-friend-to-guess-what-the-number-is-When-your-friend-makes-a-guess-you-provide-a-hint-with-the-following-info" class="headerlink" title="You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:"></a>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</h2><h2 id="The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position"><a href="#The-number-of-“bulls”-which-are-digits-in-the-guess-that-are-in-the-correct-position" class="headerlink" title="The number of “bulls”, which are digits in the guess that are in the correct position."></a>The number of “bulls”, which are digits in the guess that are in the correct position.</h2><h2 id="The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls"><a href="#The-number-of-“cows”-which-are-digits-in-the-guess-that-are-in-your-secret-number-but-are-located-in-the-wrong-position-Specifically-the-non-bull-digits-in-the-guess-that-could-be-rearranged-such-that-they-become-bulls" class="headerlink" title="The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls."></a>The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</h2><h2 id="Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess"><a href="#Given-the-secret-number-secret-and-your-friend’s-guess-guess-return-the-hint-for-your-friend’s-guess" class="headerlink" title="Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess."></a>Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess.</h2><h2 id="The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits"><a href="#The-hint-should-be-formatted-as-“xAyB”-where-x-is-the-number-of-bulls-and-y-is-the-number-of-cows-Note-that-both-secret-and-guess-may-contain-duplicate-digits" class="headerlink" title="The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits."></a>The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.</h2><p>原理：<br>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），<br>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;299-Bulls-and-Cows&quot;&gt;&lt;a href=&quot;#299-Bulls-and-Cows&quot; class=&quot;headerlink&quot; title=&quot;299. Bulls and Cows&quot;&gt;&lt;/a&gt;299. Bulls and Cows&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>264. Ugly Number II(medium)</title>
    <link href="http://example.com/2022/08/20/264/"/>
    <id>http://example.com/2022/08/20/264/</id>
    <published>2022-08-21T02:47:26.000Z</published>
    <updated>2022-08-21T20:05:34.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="264-Ugly-Number-II-medium"><a href="#264-Ugly-Number-II-medium" class="headerlink" title="264. Ugly Number II(medium)"></a>264. Ugly Number II(medium)</h1><h2 id="An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5"><a href="#An-ugly-number-is-a-positive-integer-whose-prime-factors-are-limited-to-2-3-and-5" class="headerlink" title="An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5."></a>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</h2><h1 id="Given-an-integer-n-return-the-nth-ugly-number"><a href="#Given-an-integer-n-return-the-nth-ugly-number" class="headerlink" title="Given an integer n, return the nth ugly number."></a>Given an integer n, return the nth ugly number.</h1><p>“prime factor”是质因子，质因子是所有因子中是质数的</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode-solution-uoqd/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125;</span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            curr = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := curr * factor) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nxt)</span><br><span class="line">                    heapq.heappush(heap, nxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution">https://leetcode.com/problems/ugly-number-ii/discuss/2427817/Python-solution</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ugly = [<span class="number">1</span>]</span><br><span class="line">        p2, p3, p5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment"># pointers that point to the last element 2, 3 or 5 was multiplied to</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ugly) &lt; n:</span><br><span class="line">            u2 = <span class="number">2</span> * ugly[p2]</span><br><span class="line">            u3 = <span class="number">3</span> * ugly[p3]</span><br><span class="line">            u5 = <span class="number">5</span> * ugly[p5]</span><br><span class="line">            </span><br><span class="line">            u = <span class="built_in">min</span>(u2, u3, u5) </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u2: <span class="comment"># if the minimum result was result of multiplying the element(ugly[p2]) by 2</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> u == u3: <span class="comment"># if minimum was result of multiplying the element(ugly[p3]) by 3</span></span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> u == u5: <span class="comment"># if minimus was result of multiplying the element(ugly[p5]) by 5</span></span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">ugly.append(u)</span><br><span class="line"><span class="keyword">return</span> ugly[-<span class="number">1</span>] <span class="comment"># return the last element of ugly list</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;264-Ugly-Number-II-medium&quot;&gt;&lt;a href=&quot;#264-Ugly-Number-II-medium&quot; class=&quot;headerlink&quot; title=&quot;264. Ugly Number II(medium)&quot;&gt;&lt;/a&gt;264. Ugly</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>268. Missing Number</title>
    <link href="http://example.com/2022/08/20/268/"/>
    <id>http://example.com/2022/08/20/268/</id>
    <published>2022-08-21T02:29:40.000Z</published>
    <updated>2022-08-21T04:54:20.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><h2 id="Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array"><a href="#Given-an-array-nums-containing-n-distinct-numbers-in-the-range-0-n-return-the-only-number-in-the-range-that-is-missing-from-the-array" class="headerlink" title="Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array."></a>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</h2><p>题目是说给了n个数，找到0-n之间缺的那个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p>思路：<br>本质上与242. Valid AnagramZ(easy) 没有什么区别，相当于是两个hashmap的比较，这里有个隐性的比较，分别是nums建成的hashmap，还有一个是完整的0-n这样的list建成的hashmap，所以第一步是建造一个包含0-n数字的list，然后以nums建成的hasmap为基础，拿完整版进行比较，这样可以得到缺失的数字</p><pre><code class="python">class Solution:    def missingNumber(self, nums: List[int]) -&gt; int:        hashmap=&#123;&#125;        n=len(nums)        list = []        for i in nums:            if i not in hashmap:                hashmap[i]=1            else:                hashmap[i]+=1                for i in range(n+1):            list.append(i)        for i in list:            if i not in hashmap:                a = i        return a</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;268-Missing-Number&quot;&gt;&lt;a href=&quot;#268-Missing-Number&quot; class=&quot;headerlink&quot; title=&quot;268. Missing Number&quot;&gt;&lt;/a&gt;268. Missing Number&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>242. Valid Anagram(easy)</title>
    <link href="http://example.com/2022/08/20/242/"/>
    <id>http://example.com/2022/08/20/242/</id>
    <published>2022-08-21T01:37:24.000Z</published>
    <updated>2022-08-21T04:53:47.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="242-Valid-AnagramZ-easy"><a href="#242-Valid-AnagramZ-easy" class="headerlink" title="242. Valid AnagramZ(easy)"></a>242. Valid AnagramZ(easy)</h1><h2 id="Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise"><a href="#Given-two-strings-s-and-t-return-true-if-t-is-an-anagram-of-s-and-false-otherwise" class="headerlink" title="Given two strings s and t, return true if t is an anagram of s, and false otherwise."></a>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</h2><h2 id="An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once"><a href="#An-Anagram-is-a-word-or-phrase-formed-by-rearranging-the-leters-of-a-different-word-or-phrase-typically-using-all-the-original-leters-exactly-once" class="headerlink" title="An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once."></a>An Anagram is a word or phrase formed by rearranging the leters of a different word or phrase, typically using all the original leters exactly once.</h2><p>这道题和 205. Isomorphic Strings 有点像，但这道题更简单。这道题最容易想到的方法就是直接对字符串排序比较得到结果，首先字符串长度不同肯定输出false，接下来再对字符串排序，如果排序后相同就输出true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(s)==<span class="built_in">sorted</span>(t)</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line"><span class="comment">### [但是！](htps://leetcode.cn/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/)</span></span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(nlogn)，其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlogn+n)=O(nlogn)。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(logn)。排序需要 O(logn) 的空间复杂度。注意，在某些语言（比如 Java &amp; JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：</span><br><span class="line"></span><br><span class="line">这依赖于语言的细节；</span><br><span class="line">这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以，有第二种方法，也就是hashmap：</span><br><span class="line">从另一个角度考虑，t 是 s 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <span class="number">26</span> 个小写字母，因此我们可以维护一个长度为 <span class="number">26</span> 的频次数组 table，先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现 table[i]&lt;<span class="number">0</span>，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。</span><br><span class="line"></span><br><span class="line">其实简单点想，就是建两个hashmap，最后比较是否相同就完事了。</span><br><span class="line">比较的函数</span><br><span class="line">```python</span><br><span class="line">operator.eq(hashmap1,hashmap2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)!=<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>        </span><br><span class="line">        hashmap1=&#123;&#125;</span><br><span class="line">        hashmap2=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1 <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c1 <span class="keyword">not</span> <span class="keyword">in</span> hashmap1:</span><br><span class="line">                hashmap1[c1]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap1[c1]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c2 <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> c2 <span class="keyword">not</span> <span class="keyword">in</span> hashmap2:</span><br><span class="line">                hashmap2[c2]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap2[c2]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> operator.eq(hashmap1,hashmap2)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br>对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 Unicode 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和 UTF−16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。</p><p>回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clas Solution:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment">#Using Hashmaps: (O(s+t) time and space)</span></span><br><span class="line">        s_map = &#123;&#125;</span><br><span class="line">        t_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> s:</span><br><span class="line">            s_map[leter] = s_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> leter <span class="keyword">in</span> t:</span><br><span class="line">            t_map[leter] = t_map.setdefault(leter, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s_map == t_map</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;242-Valid-AnagramZ-easy&quot;&gt;&lt;a href=&quot;#242-Valid-AnagramZ-easy&quot; class=&quot;headerlink&quot; title=&quot;242. Valid AnagramZ(easy)&quot;&gt;&lt;/a&gt;242. Valid Anag</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>229. Majority Element II(easy)</title>
    <link href="http://example.com/2022/08/20/229/"/>
    <id>http://example.com/2022/08/20/229/</id>
    <published>2022-08-20T21:50:59.000Z</published>
    <updated>2022-08-21T02:01:14.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="229-Majority-Element-II-easy"><a href="#229-Majority-Element-II-easy" class="headerlink" title="229. Majority Element II(easy)"></a>229. Majority Element II(easy)</h1><h2 id="Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times"><a href="#Given-an-integer-array-of-size-n-find-all-elements-that-appear-more-than-⌊-n-3-⌋-times" class="headerlink" title="Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times."></a>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</h2><p>这道题有点像TOP K问题，看到all elements里的遍历想到hashmap</p><p>把top K 的代码和Majority Element I的放在一起就可以解决这个问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> ans <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">not</span> <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[ans]=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[ans]+=<span class="number">1</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hashmap.keys():</span><br><span class="line">            <span class="keyword">if</span> hashmap[i]&gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">```        </span><br><span class="line">这里需要注意的是，在输出所有有可能的数组时，TOP K 问题用的是extend，而这里用的是append</span><br><span class="line">append可以追加一个<span class="built_in">list</span>，一个对象；</span><br><span class="line">extend则是把两个<span class="built_in">list</span>连接起来，类似matlab的cat函数        </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">NumList1.append(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2append到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, [‘a’, ‘b’, ‘c’]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第四个元素为&#x27;</span>,NumList1[<span class="number">3</span>]) <span class="comment">#[‘a’, ‘b’, ‘c’]</span></span><br><span class="line">NumList1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">NumList1.extend(NumList2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;列表2extend到列表1：&quot;</span>,NumList1)<span class="comment">#[1, 2, 3, ‘a’, ‘b’, ‘c’]</span></span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">列表2append到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [‘a’, ‘b’, ‘c’]]</span><br><span class="line">第四个元素为 [‘a’, ‘b’, ‘c’]</span><br><span class="line">列表2extend到列表<span class="number">1</span>： [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ‘a’, ‘b’, ‘c’]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;229-Majority-Element-II-easy&quot;&gt;&lt;a href=&quot;#229-Majority-Element-II-easy&quot; class=&quot;headerlink&quot; title=&quot;229. Majority Element II(easy)&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>219. Contains Duplicate II(easy)</title>
    <link href="http://example.com/2022/08/20/219/"/>
    <id>http://example.com/2022/08/20/219/</id>
    <published>2022-08-20T21:06:38.000Z</published>
    <updated>2022-08-20T21:49:45.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="219-Contains-Duplicate-II-easy"><a href="#219-Contains-Duplicate-II-easy" class="headerlink" title="219. Contains Duplicate II(easy)"></a>219. Contains Duplicate II(easy)</h1><h2 id="Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k"><a href="#Given-an-integer-array-nums-and-an-integer-k-return-true-if-there-are-two-distinct-indices-i-and-j-in-the-array-such-that-nums-i-nums-j-and-abs-i-j-lt-k" class="headerlink" title="Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k."></a>Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/solution/cun-zai-zhong-fu-yuan-su-ii-by-leetcode-kluvk/">官方题解</a></h3><p>可以使用哈希表记录每个元素的最大下标。从左到右遍历数组 nums，当遍历到下标 i 时，进行如下操作：</p><p>如果哈希表中已经存在和 nums[i] 相等的元素且该元素在哈希表中记录的下标 j 满足 i−j≤k，返回 true；</p><p>将 nums[i] 和下标 i 存入哈希表，此时 i 是 nums[i] 的最大下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> pos <span class="keyword">and</span> i - pos[num] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pos[num] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;219-Contains-Duplicate-II-easy&quot;&gt;&lt;a href=&quot;#219-Contains-Duplicate-II-easy&quot; class=&quot;headerlink&quot; title=&quot;219. Contains Duplicate II(easy)</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>205. Isomorphic Strings(easy)</title>
    <link href="http://example.com/2022/08/20/205/"/>
    <id>http://example.com/2022/08/20/205/</id>
    <published>2022-08-20T04:07:47.000Z</published>
    <updated>2022-08-21T01:45:06.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="205-Isomorphic-Strings-easy"><a href="#205-Isomorphic-Strings-easy" class="headerlink" title="205. Isomorphic Strings(easy)"></a>205. Isomorphic Strings(easy)</h1><h2 id="Given-two-strings-s-and-t-determine-if-they-are-isomorphic"><a href="#Given-two-strings-s-and-t-determine-if-they-are-isomorphic" class="headerlink" title="Given two strings s and t, determine if they are isomorphic."></a>Given two strings s and t, determine if they are isomorphic.</h2><h2 id="Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t"><a href="#Two-strings-s-and-t-are-isomorphic-if-the-characters-in-s-can-be-replaced-to-get-t" class="headerlink" title="Two strings s and t are isomorphic if the characters in s can be replaced to get t."></a>Two strings s and t are isomorphic if the characters in s can be replaced to get t.</h2><h2 id="All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself"><a href="#All-occurrences-of-a-character-must-be-replaced-with-another-character-while-preserving-the-order-of-characters-No-two-characters-may-map-to-the-same-character-but-a-character-may-map-to-itself" class="headerlink" title="All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself."></a>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/">官方题解</a></h3><p>此题是「290. 单词规律」的简化版，需要我们判断 s 和 t 每个位置上的字符是否都一一对应，即 s 的任意一个字符被 t 中唯一的字符对应，同时 t 的任意一个字符被 s 中唯一的字符对应。这也被称为「双射」的关系。</p><p>总结一下就是得一一对应，并且是互相对应。<br>所以第一种方法可以用两个hashmap互相存储对应关系，再往后进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        hashmap1 = &#123;&#125;</span><br><span class="line">        hashmap2 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">            <span class="comment">#The zip() function takes iterables (can be zero or more), aggregates them in a tuple, and returns it.</span></span><br><span class="line">            <span class="keyword">if</span> hashmap1.get(c1, c2) != c2 <span class="keyword">or</span> hashmap2.get(c2, c1) != c1:   </span><br><span class="line">                <span class="comment">#The get() method returns the value for the specified key if the key is in the dictionary.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            hashmap1[c1] = c2</span><br><span class="line">            hashmap2[c2] = c1</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法也是评论里的很有意思的方法，利用set的无重复特性来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(s)) == <span class="built_in">len</span>(<span class="built_in">set</span>(t)) == <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">zip</span>(s, t)))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;205-Isomorphic-Strings-easy&quot;&gt;&lt;a href=&quot;#205-Isomorphic-Strings-easy&quot; class=&quot;headerlink&quot; title=&quot;205. Isomorphic Strings(easy)&quot;&gt;&lt;/a&gt;205</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
  <entry>
    <title>202. Happy Number(easy)</title>
    <link href="http://example.com/2022/08/19/202/"/>
    <id>http://example.com/2022/08/19/202/</id>
    <published>2022-08-19T21:05:01.000Z</published>
    <updated>2022-08-20T04:08:55.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202-Happy-Number-easy"><a href="#202-Happy-Number-easy" class="headerlink" title="202. Happy Number(easy)"></a>202. Happy Number(easy)</h1><h2 id="Write-an-algorithm-to-determine-if-a-number-n-is-happy"><a href="#Write-an-algorithm-to-determine-if-a-number-n-is-happy" class="headerlink" title="Write an algorithm to determine if a number n is happy."></a>Write an algorithm to determine if a number n is happy.</h2><h2 id="A-happy-number-is-a-number-defined-by-the-following-process"><a href="#A-happy-number-is-a-number-defined-by-the-following-process" class="headerlink" title="A happy number is a number defined by the following process:"></a>A happy number is a number defined by the following process:</h2><h2 id="Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits"><a href="#Starting-with-any-positive-integer-replace-the-number-by-the-sum-of-the-squares-of-its-digits" class="headerlink" title="Starting with any positive integer, replace the number by the sum of the squares of its digits."></a>Starting with any positive integer, replace the number by the sum of the squares of its digits.</h2><h2 id="Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1"><a href="#Repeat-the-process-until-the-number-equals-1-where-it-will-stay-or-it-loops-endlessly-in-a-cycle-which-does-not-include-1" class="headerlink" title="Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1."></a>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</h2><h2 id="Those-numbers-for-which-this-process-ends-in-1-are-happy"><a href="#Those-numbers-for-which-this-process-ends-in-1-are-happy" class="headerlink" title="Those numbers for which this process ends in 1 are happy."></a>Those numbers for which this process ends in 1 are happy.</h2><h2 id="Return-true-if-n-is-a-happy-number-and-false-if-not"><a href="#Return-true-if-n-is-a-happy-number-and-false-if-not" class="headerlink" title="Return true if n is a happy number, and false if not."></a>Return true if n is a happy number, and false if not.</h2><p>又是一个奇怪的数，叫做happy number</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">官方题解</a></h3><p>总结一下，数字每一位的平方和后的结果有两种可能性</p><ol><li>变成1</li><li>变成循环</li></ol><p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除无限增大的选择。</p><p>算法</p><p>算法分为两部分，我们需要设计和编写代码。</p><p>给一个数字 nn，它的下一个数字是什么？<br>按照一系列的数字来判断我们是否进入了一个循环。</p><ol><li><p>我们按照题目的要求做数位分离，求平方和。</p></li><li><p>可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p></li></ol><p>如果它不在哈希集合中，我们应该添加它。<br>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</p><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1) 的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p>Hashmap解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n_history=&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                n_history[n]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                n_history[n]=<span class="number">0</span></span><br><span class="line">                digit_li=[<span class="built_in">str</span>(n)[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(n)))]</span><br><span class="line">                n=<span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:(<span class="built_in">int</span>(x))**<span class="number">2</span>,digit_li)))</span><br><span class="line">                <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">```                </span><br><span class="line">相当于把数字n转换成字符串，再进行平方和运算                </span><br><span class="line">```python                </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        </span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            seen.add(n)</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">str</span>(n)</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> num:</span><br><span class="line">                temp += <span class="built_in">int</span>(ch)**<span class="number">2</span></span><br><span class="line">            n = temp            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hashset解法</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">n</span>):</span></span><br><span class="line">            total_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, digit = <span class="built_in">divmod</span>(n, <span class="number">10</span>)   <span class="comment">#divmod求余数</span></span><br><span class="line">                total_sum += digit ** <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> total_sum</span><br><span class="line"></span><br><span class="line">        seen = <span class="built_in">set</span>() <span class="comment"># python里hashset的本质就是set</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            seen.add(n)</span><br><span class="line">            n = get_next(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;202-Happy-Number-easy&quot;&gt;&lt;a href=&quot;#202-Happy-Number-easy&quot; class=&quot;headerlink&quot; title=&quot;202. Happy Number(easy)&quot;&gt;&lt;/a&gt;202. Happy Number(eas</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="hashset" scheme="http://example.com/tags/hashset/"/>
    
  </entry>
  
  <entry>
    <title>169. Majority Element(easy)</title>
    <link href="http://example.com/2022/08/19/169/"/>
    <id>http://example.com/2022/08/19/169/</id>
    <published>2022-08-19T20:38:31.000Z</published>
    <updated>2022-08-20T04:10:11.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="169-Majority-Element-easy"><a href="#169-Majority-Element-easy" class="headerlink" title="169. Majority Element(easy)"></a>169. Majority Element(easy)</h1><h2 id="Given-an-array-nums-of-size-n-return-the-majority-element"><a href="#Given-an-array-nums-of-size-n-return-the-majority-element" class="headerlink" title="Given an array nums of size n, return the majority element."></a>Given an array nums of size n, return the majority element.</h2><h2 id="The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array"><a href="#The-majority-element-is-the-element-that-appears-more-than-⌊n-2⌋-times-You-may-assume-that-the-majority-element-always-exists-in-the-array" class="headerlink" title="The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array."></a>The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h4 id="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"><a href="#堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。" class="headerlink" title="堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。"></a>堪称hashamp最基础题目，纯粹是考hashmap的性质，前面是把数字都录入hashmap，后面再进行一个简单的判断。</h4><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        hashmap = &#123;&#125;        n=len(nums)        for ans in nums:            if ans not in hashmap:                hashmap[ans]=1            else:                hashmap[ans]+=1        for ans in hashmap:            if hashmap[ans]&gt;n//2:                return ans</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;169-Majority-Element-easy&quot;&gt;&lt;a href=&quot;#169-Majority-Element-easy&quot; class=&quot;headerlink&quot; title=&quot;169. Majority Element(easy)&quot;&gt;&lt;/a&gt;169. Majo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree (Easy)</title>
    <link href="http://example.com/2022/08/17/101/"/>
    <id>http://example.com/2022/08/17/101/</id>
    <published>2022-08-18T03:42:45.000Z</published>
    <updated>2022-08-18T21:36:30.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a>101. Symmetric Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center"><a href="#Given-the-root-of-a-binary-tree-check-whether-it-is-a-mirror-of-itself-i-e-symmetric-around-its-center" class="headerlink" title="Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center)."></a>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type root: TreeNode</span></span><br><span class="line"><span class="string">:rtype: bool</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left,right</span>):</span></span><br><span class="line"><span class="comment"># 递归的终止条件是两个节点都为空</span></span><br><span class="line"><span class="comment"># 或者两个节点中有一个为空</span></span><br><span class="line"><span class="comment"># 或者两个节点的值不相等</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> left.val!=right.val:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> dfs(left.left,right.right) <span class="keyword">and</span> dfs(left.right,right.left)</span><br><span class="line"><span class="comment"># 用递归函数，比较左节点，右节点</span></span><br><span class="line"><span class="keyword">return</span> dfs(root.left,root.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-Symmetric-Tree-Easy&quot;&gt;&lt;a href=&quot;#101-Symmetric-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;101. Symmetric Tree (Easy)&quot;&gt;&lt;/a&gt;101. Symmetric</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>572. Subtree of Another Tree (Easy)</title>
    <link href="http://example.com/2022/08/17/572/"/>
    <id>http://example.com/2022/08/17/572/</id>
    <published>2022-08-18T03:39:46.000Z</published>
    <updated>2022-08-21T01:38:20.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="572-Subtree-of-Another-Tree-Easy"><a href="#572-Subtree-of-Another-Tree-Easy" class="headerlink" title="572. Subtree of Another Tree (Easy)"></a>572. Subtree of Another Tree (Easy)</h1><h2 id="Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise"><a href="#Given-the-roots-of-two-binary-trees-root-and-subRoot-return-true-if-there-is-a-subtree-of-root-with-the-same-structure-and-node-values-of-subRoot-and-false-otherwise" class="headerlink" title="Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise."></a>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</h2><h2 id="A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself"><a href="#A-subtree-of-a-binary-tree-tree-is-a-tree-that-consists-of-a-node-in-tree-and-all-of-this-node’s-descendants-The-tree-tree-could-also-be-considered-as-a-subtree-of-itself" class="headerlink" title="A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself."></a>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, root, subRoot</span>) :</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            curr = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> curr.val == subRoot.val :</span><br><span class="line">                <span class="keyword">if</span> self.compare(curr,subRoot):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> curr.right:</span><br><span class="line">                queue.append(curr.right)</span><br><span class="line">            <span class="keyword">if</span> curr.left:</span><br><span class="line">                queue.append(curr.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self,curr,subRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> subRoot <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> curr.val == subRoot.val :</span><br><span class="line">            r_flag = self.compare(curr.right,subRoot.right)</span><br><span class="line">            l_flag = self.compare(curr.left,subRoot.left)</span><br><span class="line">            <span class="keyword">if</span> r_flag <span class="keyword">and</span> l_flag:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;572-Subtree-of-Another-Tree-Easy&quot;&gt;&lt;a href=&quot;#572-Subtree-of-Another-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;572. Subtree of Another Tree</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>437. Path Sum III (Easy)</title>
    <link href="http://example.com/2022/08/17/437/"/>
    <id>http://example.com/2022/08/17/437/</id>
    <published>2022-08-18T03:34:41.000Z</published>
    <updated>2022-08-18T21:35:06.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="437-Path-Sum-III-Easy"><a href="#437-Path-Sum-III-Easy" class="headerlink" title="437. Path Sum III (Easy)"></a>437. Path Sum III (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-the-number-of-paths-where-the-sum-of-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</h2><h2 id="The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes"><a href="#The-path-does-not-need-to-start-or-end-at-the-root-or-a-leaf-but-it-must-go-downwards-i-e-traveling-only-from-parent-nodes-to-child-nodes" class="headerlink" title="The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes)."></a>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><h3 id="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。"><a href="#我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点-root-到当前节点-pp-的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和-currcurr-减去-targetSum。" class="headerlink" title="我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。"></a>我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 root 到当前节点 pp 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 currcurr 减去 targetSum。</h3><h3 id="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。"><a href="#对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为-00。" class="headerlink" title="对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。"></a>对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 00。</h3><h3 id="假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p"><a href="#假设根节点为-root，我们当前刚好访问节点-node，则此时从根节点-root-到节点-node-的路径（无重复节点）刚好为-rightarrow-p-1-rightarrow-p-2-rightarrow-ldots-rightarrow-p-k-rightarrow-root→p" class="headerlink" title="假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p"></a>假设根节点为 root，我们当前刚好访问节点 node，则此时从根节点 root 到节点 node 的路径（无重复节点）刚好为  \rightarrow p_1 \rightarrow p_2 \rightarrow \ldots \rightarrow p_k \rightarrow root→p</h3><p>1<br>​<br> →p<br>2<br>​<br> →…→p<br>k<br>​<br> →node，此时我们可以已经保存了节点 p_1, p_2, p_3, \ldots, p_kp<br>1<br>​<br> ,p<br>2<br>​<br> ,p<br>3<br>​<br> ,…,p<br>k<br>​<br>  的前缀和，并且计算出了节点 node 的前缀和。</p><p>假设当前从根节点 root 到节点 node 的前缀和为 \textit{curr}curr，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 \textit{curr} - curr−targetSum。假设从根节点 root 到节点 node 的路径中存在节点 p_ip<br>i<br>​<br>  到根节点 root 的前缀和为 \textit{curr} - curr−targetSum，则节点 p_{i+1}p<br>i+1<br>​<br>  到 node 的路径上所有节点的和一定为 targetSum。</p><p>我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode.cn/problems/path-sum-iii/solution/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;437-Path-Sum-III-Easy&quot;&gt;&lt;a href=&quot;#437-Path-Sum-III-Easy&quot; class=&quot;headerlink&quot; title=&quot;437. Path Sum III (Easy)&quot;&gt;&lt;/a&gt;437. Path Sum III (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>112. Path Sum (Easy)</title>
    <link href="http://example.com/2022/08/16/112/"/>
    <id>http://example.com/2022/08/16/112/</id>
    <published>2022-08-17T03:37:14.000Z</published>
    <updated>2022-08-17T03:55:30.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a>112. Path Sum (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</h2><h2 id="A-leaf-is-a-node-with-no-children"><a href="#A-leaf-is-a-node-with-no-children" class="headerlink" title="A leaf is a node with no children."></a>A leaf is a node with no children.</h2><p><a href="https://leetcode.cn/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">官方题解</a></p><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p><p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p><p>复杂度分析</p><p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;112-Path-Sum-Easy&quot;&gt;&lt;a href=&quot;#112-Path-Sum-Easy&quot; class=&quot;headerlink&quot; title=&quot;112. Path Sum (Easy)&quot;&gt;&lt;/a&gt;112. Path Sum (Easy)&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>617. Merge Two Binary Trees (Easy)</title>
    <link href="http://example.com/2022/08/15/617/"/>
    <id>http://example.com/2022/08/15/617/</id>
    <published>2022-08-16T03:26:38.000Z</published>
    <updated>2022-08-17T03:55:09.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-Merge-Two-Binary-Trees-Easy"><a href="#617-Merge-Two-Binary-Trees-Easy" class="headerlink" title="617. Merge Two Binary Trees (Easy)"></a>617. Merge Two Binary Trees (Easy)</h1><h2 id="You-are-given-two-binary-trees-root1-and-root2"><a href="#You-are-given-two-binary-trees-root1-and-root2" class="headerlink" title="You are given two binary trees root1 and root2."></a>You are given two binary trees root1 and root2.</h2><h2 id="Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree"><a href="#Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree" class="headerlink" title="Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree."></a>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</h2><h2 id="Return-the-merged-tree"><a href="#Return-the-merged-tree" class="headerlink" title="Return the merged tree."></a>Return the merged tree.</h2><h2 id="Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees"><a href="#Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees" class="headerlink" title="Note: The merging process must start from the root nodes of both trees."></a>Note: The merging process must start from the root nodes of both trees.</h2><h3 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/">参考解析</a></h3><p>对于二叉树来说，如果我们像遍历数组那样，挨个遍历两颗二叉树中的每个节点，再把他们相加，那问题就比较容易解决了。</p><p>遍历二叉树很简单，用 前序 遍历就可以了，再依次把访问到的节点值相加，因为题目没有说不能改变树的值和结构，我们不用再创建新的节点了，直接将树2合并到树1上再返回就可以了。<br>需要注意：这两颗树并不是长得完全一样，有的树可能有左节点，但有的树没有。</p><p>总结下递归的条件：</p><p>终止条件：树 1 的节点为 null，或者树 2 的节点为 null<br>递归函数内：将两个树的节点相加后，再赋给树 1 的节点。再递归的执行两个树的左节点，递归执行两个树的右节点</p><p>总结一下就是把root2的值复制到root1上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root1,root2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root1 <span class="keyword">and</span> root2):</span><br><span class="line">                <span class="keyword">return</span> root1 <span class="keyword">if</span> root1 <span class="keyword">else</span> root2</span><br><span class="line">            root1.val += root2.val</span><br><span class="line">            root1.left = dfs(root1.left,root2.left)</span><br><span class="line">            root1.right = dfs(root1.right,root2.right)</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">return</span> dfs(root1,root2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;617-Merge-Two-Binary-Trees-Easy&quot;&gt;&lt;a href=&quot;#617-Merge-Two-Binary-Trees-Easy&quot; class=&quot;headerlink&quot; title=&quot;617. Merge Two Binary Trees (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>226. Invert Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/15/226/"/>
    <id>http://example.com/2022/08/15/226/</id>
    <published>2022-08-16T03:08:56.000Z</published>
    <updated>2022-08-17T03:54:54.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a>226. Invert Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root"><a href="#Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root" class="headerlink" title="Given the root of a binary tree, invert the tree, and return its root."></a>Given the root of a binary tree, invert the tree, and return its root.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode-solution/">官方题解</a></h3><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if not root:            return root        left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left = right        root.right = left        return root</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;226-Invert-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree (Easy)&quot;&gt;&lt;/a&gt;22</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>543. Diameter of Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/543/"/>
    <id>http://example.com/2022/08/14/543/</id>
    <published>2022-08-15T02:24:25.000Z</published>
    <updated>2022-08-16T03:26:12.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a>543. Diameter of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree"><a href="#Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree" class="headerlink" title="Given the root of a binary tree, return the length of the diameter of the tree."></a>Given the root of a binary tree, return the length of the diameter of the tree.</h2><h2 id="The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root"><a href="#The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root" class="headerlink" title="The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root."></a>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</h2><h2 id="The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them"><a href="#The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them" class="headerlink" title="The length of a path between two nodes is represented by the number of edges between them."></a>The length of a path between two nodes is represented by the number of edges between them.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/">官方题解</a></h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>其实我看到这道题感觉和<a href="https://upuphero.github.io/2022/08/14/110/">110. Balanced Binary Tree (Easy)</a>很像，可以在求高度的基础上稍微改一下<br>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p><p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p><p>我们记节点node 为起点的路径经过节点数的最大值为 d<sub>node</sub>，那么二叉树的直径就是所有节点 d<sub>node</sub>的最大值减一。</p><p>最后的算法流程为：我们定义一个递归函数 depth(node) 计算 d<sub>node</sub>，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为max(L,R)+1</p><p>该节点的 d<sub>node</sub> 值为L+R+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="comment"># 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 左儿子为根的子树的深度</span></span><br><span class="line">            L = depth(root.left)</span><br><span class="line">            <span class="comment"># 右儿子为根的子树的深度</span></span><br><span class="line">            R = depth(root.right)</span><br><span class="line">            <span class="comment"># 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, L + R + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 返回该节点为根的子树的深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        depth(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;543-Diameter-of-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#543-Diameter-of-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;543. Diameter of Binary Tree</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>110. Balanced Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/110/"/>
    <id>http://example.com/2022/08/14/110/</id>
    <published>2022-08-14T21:49:16.000Z</published>
    <updated>2022-08-16T02:54:48.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a>110. Balanced Binary Tree (Easy)</h1><h2 id="Given-a-binary-tree-determine-if-it-is-height-balanced"><a href="#Given-a-binary-tree-determine-if-it-is-height-balanced" class="headerlink" title="Given a binary tree, determine if it is height-balanced."></a>Given a binary tree, determine if it is height-balanced.</h2><h2 id="For-this-problem-a-height-balanced-binary-tree-is-defined-as"><a href="#For-this-problem-a-height-balanced-binary-tree-is-defined-as" class="headerlink" title="For this problem, a height-balanced binary tree is defined as:"></a>For this problem, a height-balanced binary tree is defined as:</h2><h2 id="a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1"><a href="#a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1" class="headerlink" title="a binary tree in which the left and right subtrees of every node differ in height by no more than 1."></a>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">两种办法</a></p><h3 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h3><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：<br>height(p)=max(height(p.left),height(p.right))+1 P是非空节点</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(height(root.left), height(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><h3 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h3><p>方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftHeight = height(root.left)</span><br><span class="line">            rightHeight = height(root.right)</span><br><span class="line">            <span class="keyword">if</span> leftHeight == -<span class="number">1</span> <span class="keyword">or</span> rightHeight == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;110-Balanced-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#110-Balanced-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;110. Balanced Binary Tree (Easy)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
    <category term="Tree" scheme="http://example.com/tags/Tree/"/>
    
  </entry>
  
</feed>
