<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-02T03:40:39.533Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>13. Roman to Integer(easy)</title>
    <link href="http://example.com/2022/07/01/13/"/>
    <id>http://example.com/2022/07/01/13/</id>
    <published>2022-07-02T03:22:05.000Z</published>
    <updated>2022-07-02T03:40:39.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer-easy"><a href="#13-Roman-to-Integer-easy" class="headerlink" title="13. Roman to Integer(easy)"></a>13. Roman to Integer(easy)</h1><h2 id="Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M"><a href="#Roman-numerals-are-represented-by-seven-different-symbols-I-V-X-L-C-D-and-M" class="headerlink" title="Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M."></a>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</h2><h2 id="For-example-2-is-written-as-II-in-Roman-numeral-just-two-ones-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II"><a href="#For-example-2-is-written-as-II-in-Roman-numeral-just-two-ones-added-together-12-is-written-as-XII-which-is-simply-X-II-The-number-27-is-written-as-XXVII-which-is-XX-V-II" class="headerlink" title="For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II."></a>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</h2><h2 id="Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used"><a href="#Roman-numerals-are-usually-written-largest-to-smallest-from-left-to-right-However-the-numeral-for-four-is-not-IIII-Instead-the-number-four-is-written-as-IV-Because-the-one-is-before-the-five-we-subtract-it-making-four-The-same-principle-applies-to-the-number-nine-which-is-written-as-IX-There-are-six-instances-where-subtraction-is-used" class="headerlink" title="Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:"></a>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</h2><h2 id="I-can-be-placed-before-V-5-and-X-10-to-make-4-and-9"><a href="#I-can-be-placed-before-V-5-and-X-10-to-make-4-and-9" class="headerlink" title="I can be placed before V (5) and X (10) to make 4 and 9."></a>I can be placed before V (5) and X (10) to make 4 and 9.</h2><h2 id="X-can-be-placed-before-L-50-and-C-100-to-make-40-and-90"><a href="#X-can-be-placed-before-L-50-and-C-100-to-make-40-and-90" class="headerlink" title="X can be placed before L (50) and C (100) to make 40 and 90."></a>X can be placed before L (50) and C (100) to make 40 and 90.</h2><h2 id="C-can-be-placed-before-D-500-and-M-1000-to-make-400-and-900"><a href="#C-can-be-placed-before-D-500-and-M-1000-to-make-400-and-900" class="headerlink" title="C can be placed before D (500) and M (1000) to make 400 and 900."></a>C can be placed before D (500) and M (1000) to make 400 and 900.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/">官方题解</a></p><p>这题的特点<br>通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。</p><p>例如 XXVII 可视作 X+X+V+I+I=10+10+5+1+1=27。</p><p>若存在小的数字在大的数字的左边的情况，根据规则需要减去小的数字。对于这种情况，我们也可以将每个字符视作一个单独的值，若一个数字右侧的数字比它大，则将该数字的符号取反。</p><p>例如 XIV 可视作 X−I+V=10−1+5=14。</p><h3 id="但是评论里有超神思路："><a href="#但是评论里有超神思路：" class="headerlink" title="但是评论里有超神思路："></a>但是评论里有超神思路：</h3><p><a href="https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/1060752">从右到左遍历，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减，更好理解吧</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        highestLevel = <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s[::-<span class="number">1</span>]:</span><br><span class="line">            level = mapping[ch]</span><br><span class="line">            <span class="keyword">if</span> level &gt;= highestLevel:</span><br><span class="line">                result += level</span><br><span class="line">                highestLevel = level</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result -= level</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;13-Roman-to-Integer-easy&quot;&gt;&lt;a href=&quot;#13-Roman-to-Integer-easy&quot; class=&quot;headerlink&quot; title=&quot;13. Roman to Integer(easy)&quot;&gt;&lt;/a&gt;13. Roman to</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="mapping" scheme="http://example.com/tags/mapping/"/>
    
  </entry>
  
  <entry>
    <title>9. Palindrome Number(easy)</title>
    <link href="http://example.com/2022/07/01/9/"/>
    <id>http://example.com/2022/07/01/9/</id>
    <published>2022-07-02T03:16:17.000Z</published>
    <updated>2022-07-02T03:40:11.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number-easy"><a href="#9-Palindrome-Number-easy" class="headerlink" title="9. Palindrome Number(easy)"></a>9. Palindrome Number(easy)</h1><h2 id="Given-an-integer-x-return-true-if-x-is-palindrome-integer"><a href="#Given-an-integer-x-return-true-if-x-is-palindrome-integer" class="headerlink" title="Given an integer x, return true if x is palindrome integer."></a>Given an integer x, return true if x is palindrome integer.</h2><h2 id="An-integer-is-a-palindrome-when-it-reads-the-same-backward-as-forward"><a href="#An-integer-is-a-palindrome-when-it-reads-the-same-backward-as-forward" class="headerlink" title="An integer is a palindrome when it reads the same backward as forward."></a>An integer is a palindrome when it reads the same backward as forward.</h2><h2 id="For-example-121-is-a-palindrome-while-123-is-not"><a href="#For-example-121-is-a-palindrome-while-123-is-not" class="headerlink" title="For example, 121 is a palindrome while 123 is not."></a>For example, 121 is a palindrome while 123 is not.</h2><p>找到回文数</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/">官方题解</a></h2><p>反转一半数字<br>思路</p><p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。</p><p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p><p>根据官方题解改的python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        revertedNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; revertedNumber:</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber <span class="keyword">or</span> x == revertedNumber // <span class="number">10</span>        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9-Palindrome-Number-easy&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number-easy&quot; class=&quot;headerlink&quot; title=&quot;9. Palindrome Number(easy)&quot;&gt;&lt;/a&gt;9. Palindrom</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Palindrome Number" scheme="http://example.com/tags/Palindrome-Number/"/>
    
  </entry>
  
  <entry>
    <title>15. 3Sum(medium)</title>
    <link href="http://example.com/2022/07/01/15/"/>
    <id>http://example.com/2022/07/01/15/</id>
    <published>2022-07-02T03:01:07.000Z</published>
    <updated>2022-07-02T03:40:02.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="15-3Sum-medium"><a href="#15-3Sum-medium" class="headerlink" title="15. 3Sum(medium)"></a>15. 3Sum(medium)</h1><h2 id="Given-an-integer-array-nums-return-all-the-triplets-nums-i-nums-j-nums-k-such-that-i-j-i-k-and-j-k-and-nums-i-nums-j-nums-k-0"><a href="#Given-an-integer-array-nums-return-all-the-triplets-nums-i-nums-j-nums-k-such-that-i-j-i-k-and-j-k-and-nums-i-nums-j-nums-k-0" class="headerlink" title="Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0."></a>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</h2><h2 id="Notice-that-the-solution-set-must-not-contain-duplicate-triplets"><a href="#Notice-that-the-solution-set-must-not-contain-duplicate-triplets" class="headerlink" title="Notice that the solution set must not contain duplicate triplets."></a>Notice that the solution set must not contain duplicate triplets.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>): <span class="comment"># renamed this to left because this will always be the leftmost pointer in the triplet</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]: <span class="comment"># this step makes sure that we do not have any duplicates in our result output</span></span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">        mid = left + <span class="number">1</span> <span class="comment"># renamed this to mid because this is the pointer that is between the left and right pointers</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> mid &lt; right:</span><br><span class="line">            curr_sum = nums[left] + nums[mid] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> curr_sum &lt; <span class="number">0</span>:</span><br><span class="line">                mid += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">elif</span> curr_sum &gt; <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append([nums[left], nums[mid], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> mid &lt; right <span class="keyword">and</span> nums[mid] == nums[mid + <span class="number">1</span>]: <span class="comment"># Another conditional for not calculating duplicates</span></span><br><span class="line">                    mid += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> mid &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]: <span class="comment"># Avoiding duplicates check</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                mid += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;15-3Sum-medium&quot;&gt;&lt;a href=&quot;#15-3Sum-medium&quot; class=&quot;headerlink&quot; title=&quot;15. 3Sum(medium)&quot;&gt;&lt;/a&gt;15. 3Sum(medium)&lt;/h1&gt;&lt;h2 id=&quot;Given-an-inte</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>11. Container With Most Water(medium)</title>
    <link href="http://example.com/2022/07/01/11/"/>
    <id>http://example.com/2022/07/01/11/</id>
    <published>2022-07-01T16:01:52.000Z</published>
    <updated>2022-07-02T03:39:46.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water-medium"><a href="#11-Container-With-Most-Water-medium" class="headerlink" title="11. Container With Most Water(medium)"></a>11. Container With Most Water(medium)</h1><h2 id="You-are-given-an-integer-array-height-of-length-n-There-are-n-vertical-lines-drawn-such-that-the-two-endpoints-of-the-ith-line-are-i-0-and-i-height-i"><a href="#You-are-given-an-integer-array-height-of-length-n-There-are-n-vertical-lines-drawn-such-that-the-two-endpoints-of-the-ith-line-are-i-0-and-i-height-i" class="headerlink" title="You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i])."></a>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</h2><h2 id="Find-two-lines-that-together-with-the-x-axis-form-a-container-such-that-the-container-contains-the-most-water"><a href="#Find-two-lines-that-together-with-the-x-axis-form-a-container-such-that-the-container-contains-the-most-water" class="headerlink" title="Find two lines that together with the x-axis form a container, such that the container contains the most water."></a>Find two lines that together with the x-axis form a container, such that the container contains the most water.</h2><h2 id="Return-the-maximum-amount-of-water-a-container-can-store"><a href="#Return-the-maximum-amount-of-water-a-container-can-store" class="headerlink" title="Return the maximum amount of water a container can store."></a>Return the maximum amount of water a container can store.</h2><h2 id="Notice-that-you-may-not-slant-the-container"><a href="#Notice-that-you-may-not-slant-the-container" class="headerlink" title="Notice that you may not slant the container."></a>Notice that you may not slant the container.</h2><p>看了题解，双指针，从两头开始内卷，先卷矮的那头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            area = <span class="built_in">min</span>(height[l],height[r])*(r-l)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,area)</span><br><span class="line">            l=</span><br><span class="line">            <span class="keyword">if</span> height[l]&lt;height[r]:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height</span>):</span></span><br><span class="line">        L, R, width, res = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(width, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment">#range(start, stop, step)</span></span><br><span class="line">            <span class="keyword">if</span> height[L] &lt; height[R]:</span><br><span class="line">                res, L = <span class="built_in">max</span>(res, height[L] * w), L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res, R = <span class="built_in">max</span>(res, height[R] * w), R - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11-Container-With-Most-Water-medium&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water-medium&quot; class=&quot;headerlink&quot; title=&quot;11. Container With Mos</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>3. Longest Substring Without Repeating Characters(medium)</title>
    <link href="http://example.com/2022/07/01/3/"/>
    <id>http://example.com/2022/07/01/3/</id>
    <published>2022-07-01T15:31:22.000Z</published>
    <updated>2022-07-01T23:16:01.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters-medium"><a href="#3-Longest-Substring-Without-Repeating-Characters-medium" class="headerlink" title="3. Longest Substring Without Repeating Characters(medium)"></a>3. Longest Substring Without Repeating Characters(medium)</h1><h2 id="Given-a-string-s-find-the-length-of-the-longest-substring-without-repeating-characters"><a href="#Given-a-string-s-find-the-length-of-the-longest-substring-without-repeating-characters" class="headerlink" title="Given a string s, find the length of the longest substring without repeating characters."></a>Given a string s, find the length of the longest substring without repeating characters.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>这道题第一反应是双指针，通过滑动窗口来解决，但有个需要解决的问题是如果判断substring的字母有重复的。</p><p>利用hashmap查找重复字母<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/376956">leetcode评论</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        k, res, c_dict = -<span class="number">1</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> c_dict <span class="keyword">and</span> c_dict[c] &gt; k:  <span class="comment"># 字符c在字典中 且 上次出现的下标大于当前长度的起始下标</span></span><br><span class="line">                k = c_dict[c]</span><br><span class="line">                c_dict[c] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c_dict[c] = i</span><br><span class="line">                res = <span class="built_in">max</span>(res, i-k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用队列查找字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        lst = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> lst:</span><br><span class="line">                <span class="keyword">del</span> lst[<span class="number">0</span>]  <span class="comment"># 队首元素出队</span></span><br><span class="line">            lst.append(s[i]) <span class="comment"># 排除重复元素后 新元素入队</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(lst))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-Longest-Substring-Without-Repeating-Characters-medium&quot;&gt;&lt;a href=&quot;#3-Longest-Substring-Without-Repeating-Characters-medium&quot; class=&quot;h</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode09-hashmap</title>
    <link href="http://example.com/2022/06/28/LeetCode09/"/>
    <id>http://example.com/2022/06/28/LeetCode09/</id>
    <published>2022-06-29T03:37:33.000Z</published>
    <updated>2022-07-02T02:55:17.231Z</updated>
    
    <content type="html"><![CDATA[<p>专门列出的一期：hashmap</p><p>官方是有专门的hashmap的<a href="https://leetcode.com/tag/hash-table/">tag</a></p><h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md">Leetcode 题解 - 目录.md</a></h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;专门列出的一期：hashmap&lt;/p&gt;
&lt;p&gt;官方是有专门的hashmap的&lt;a href=&quot;https://leetcode.com/tag/hash-table/&quot;&gt;tag&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode08-动态规划</title>
    <link href="http://example.com/2022/06/28/LeetCode08/"/>
    <id>http://example.com/2022/06/28/LeetCode08/</id>
    <published>2022-06-29T03:14:48.000Z</published>
    <updated>2022-07-02T02:55:14.753Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-动态规划"><a href="#Leetcode-题解-动态规划" class="headerlink" title="Leetcode 题解 - 动态规划"></a>Leetcode 题解 - 动态规划</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>914</title>
    <link href="http://example.com/2022/06/27/914/"/>
    <id>http://example.com/2022/06/27/914/</id>
    <published>2022-06-27T23:53:57.000Z</published>
    <updated>2022-07-01T23:15:07.368Z</updated>
    
    <content type="html"><![CDATA[<ol start="914"><li>卡牌分组</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;914&quot;&gt;
&lt;li&gt;卡牌分组&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Greatest common divisor " scheme="http://example.com/tags/Greatest-common-divisor/"/>
    
  </entry>
  
  <entry>
    <title>204. Count Primes (Easy)</title>
    <link href="http://example.com/2022/06/27/204/"/>
    <id>http://example.com/2022/06/27/204/</id>
    <published>2022-06-27T21:28:56.000Z</published>
    <updated>2022-07-01T23:14:59.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="204-Count-Primes-Easy"><a href="#204-Count-Primes-Easy" class="headerlink" title="204. Count Primes (Easy)"></a>204. Count Primes (Easy)</h1><h2 id="Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n"><a href="#Given-an-integer-n-return-the-number-of-prime-numbers-that-are-strictly-less-than-n" class="headerlink" title="Given an integer n, return the number of prime numbers that are strictly less than n."></a>Given an integer n, return the number of prime numbers that are strictly less than n.</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/">官方题解</a></h2><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><h3 id="方法二：埃氏筛"><a href="#方法二：埃氏筛" class="headerlink" title="方法二：埃氏筛"></a>方法二：埃氏筛</h3><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 yy 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 xx 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><h4 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.com/problems/count-primes/discuss/153528/Python3-99-112-ms-Explained%3A-The-Sieve-of-Eratosthenes-with-optimizations">leetcode题解</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Sieve of Eratosthenes埃氏筛</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># We are only interested in numbers LESS than the input number</span></span><br><span class="line">        <span class="comment"># exit early for numbers LESS than 2; (two is prime)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create strike list for the input range, initializing all indices to</span></span><br><span class="line">        <span class="comment"># prime (1).</span></span><br><span class="line">        strikes = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we know that 0 and 2 are not prime</span></span><br><span class="line">        strikes[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        strikes[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Now set multiples of remaining numbers that are marked as prime to</span></span><br><span class="line">        <span class="comment"># not prime.  It is safe ignore numbers alreay marked as not prime</span></span><br><span class="line">        <span class="comment"># because there are factor(s) that divide evenly into this number and</span></span><br><span class="line">        <span class="comment"># all its multiples.  Use upper limit of (n**0.5)+1, because:</span></span><br><span class="line">        <span class="comment">#  (a) the smallest factor of a non-prime number will not be &gt; sqrt(n).</span></span><br><span class="line">        <span class="comment">#      Ex. non-prime = 100, </span></span><br><span class="line">        <span class="comment">#           5*20</span></span><br><span class="line">        <span class="comment">#           10*10, </span></span><br><span class="line">        <span class="comment">#           20*5   # !! we have seen 5 before.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>  strikes[i] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># slow:</span></span><br><span class="line">                <span class="comment">#for j in range(i*i, n, i):</span></span><br><span class="line">                <span class="comment">#    strikes[j] = 0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 3x faster:</span></span><br><span class="line">                <span class="comment"># strikes[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)</span></span><br><span class="line">                <span class="comment"># n = 11</span></span><br><span class="line">                <span class="comment"># i = 2</span></span><br><span class="line">                <span class="comment"># (n-1-i*i)//i + 1</span></span><br><span class="line">                <span class="comment"># (n-1)               # get total # of indicies for n (non-inclusive)</span></span><br><span class="line">                <span class="comment">#     -i*i            # shift to get # of slots in range of interest</span></span><br><span class="line">                <span class="comment">#          //i        # get number of groups</span></span><br><span class="line">                <span class="comment">#              + 1    # get number of slots</span></span><br><span class="line">                <span class="comment"># strikes[2*2:11:2]  = [0] * ((11-1-2*2)//2 + 1</span></span><br><span class="line">                <span class="comment"># strikes[4:11:2]    = [0] * 4</span></span><br><span class="line">                <span class="comment"># s[4], s[6], s[8], s10] = 0, 0, 0, 0</span></span><br><span class="line">                strikes[i*i:n:i] = [<span class="number">0</span>] * ((n-<span class="number">1</span>-i*i)//i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(strikes)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]=primes[<span class="number">1</span>]=<span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 用数组primes[i]表示数字i是否是素数，如果值为True则为素数，</span></span><br><span class="line"><span class="string">        如果值为False则为合数 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>]= primes[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            <span class="comment"># 如果当前值是素数，就将它倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                _power = i * i</span><br><span class="line">                <span class="keyword">if</span> _power &lt; n :</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(_power, n, i):</span><br><span class="line">                        primes[j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;204-Count-Primes-Easy&quot;&gt;&lt;a href=&quot;#204-Count-Primes-Easy&quot; class=&quot;headerlink&quot; title=&quot;204. Count Primes (Easy)&quot;&gt;&lt;/a&gt;204. Count Primes (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="prime number" scheme="http://example.com/tags/prime-number/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode07-数学</title>
    <link href="http://example.com/2022/06/26/LeetCode07/"/>
    <id>http://example.com/2022/06/26/LeetCode07/</id>
    <published>2022-06-27T02:22:25.000Z</published>
    <updated>2022-07-02T02:55:28.413Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-数学"><a href="#Leetcode-题解-数学" class="headerlink" title="Leetcode 题解 - 数学"></a>Leetcode 题解 - 数学</h1><h2 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h2><p>每一个数都可以分解成素数的乘积</p><h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><p>令 x = 2m0 * 3m1 * 5m2 * 7m3 * 11m4 * …</p><p>令 y = 2n0 * 3n1 * 5n2 * 7n3 * 11n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h2 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h2><p>x 和 y 的最大公约数为：gcd(x,y) = 2min(m0,n0) * 3min(m1,n1) * 5min(m2,n2) * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) = 2max(m0,n0) * 3max(m1,n1) * 5max(m2,n2) * …</p><h3 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h3><h3 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h3><h3 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h3><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h3><h3 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h3><h3 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h3><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h3><h2 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h2><h3 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h3><h3 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h3><h2 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h2><h3 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h3><h2 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h2><h3 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h3><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h3><h3 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h3><h3 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h3><h3 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode06-搜索</title>
    <link href="http://example.com/2022/06/23/LeetCode06/"/>
    <id>http://example.com/2022/06/23/LeetCode06/</id>
    <published>2022-06-24T02:59:51.000Z</published>
    <updated>2022-07-02T02:55:23.234Z</updated>
    
    <content type="html"><![CDATA[<h6 id="具体学习链接-Leetcode-题解-目录-md"><a href="#具体学习链接-Leetcode-题解-目录-md" class="headerlink" title="具体学习链接:Leetcode 题解 - 目录.md"></a>具体学习链接:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md">Leetcode 题解 - 目录.md</a></h6><h1 id="Leetcode-题解-搜索"><a href="#Leetcode-题解-搜索" class="headerlink" title="Leetcode 题解 - 搜索"></a>Leetcode 题解 - 搜索</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="1-计算在网格中从原点到特定点的最短路径长度"><a href="#1-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="1. 计算在网格中从原点到特定点的最短路径长度"></a>1. 计算在网格中从原点到特定点的最短路径长度</h3><h3 id="2-组成整数的最小平方数数量"><a href="#2-组成整数的最小平方数数量" class="headerlink" title="2. 组成整数的最小平方数数量"></a>2. 组成整数的最小平方数数量</h3><h3 id="3-最短单词路径"><a href="#3-最短单词路径" class="headerlink" title="3. 最短单词路径"></a>3. 最短单词路径</h3><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="1-查找最大的连通面积"><a href="#1-查找最大的连通面积" class="headerlink" title="1. 查找最大的连通面积"></a>1. 查找最大的连通面积</h3><h3 id="2-矩阵中的连通分量数目"><a href="#2-矩阵中的连通分量数目" class="headerlink" title="2. 矩阵中的连通分量数目"></a>2. 矩阵中的连通分量数目</h3><h3 id="3-好友关系的连通分量数目"><a href="#3-好友关系的连通分量数目" class="headerlink" title="3. 好友关系的连通分量数目"></a>3. 好友关系的连通分量数目</h3><h3 id="4-填充封闭区域"><a href="#4-填充封闭区域" class="headerlink" title="4. 填充封闭区域"></a>4. 填充封闭区域</h3><h3 id="5-能到达的太平洋和大西洋的区域"><a href="#5-能到达的太平洋和大西洋的区域" class="headerlink" title="5. 能到达的太平洋和大西洋的区域"></a>5. 能到达的太平洋和大西洋的区域</h3><h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h3 id="1-数字键盘组合"><a href="#1-数字键盘组合" class="headerlink" title="1. 数字键盘组合"></a>1. 数字键盘组合</h3><h3 id="2-IP-地址划分"><a href="#2-IP-地址划分" class="headerlink" title="2. IP 地址划分"></a>2. IP 地址划分</h3><h3 id="3-在矩阵中寻找字符串"><a href="#3-在矩阵中寻找字符串" class="headerlink" title="3. 在矩阵中寻找字符串"></a>3. 在矩阵中寻找字符串</h3><h3 id="4-输出二叉树中所有从根到叶子的路径"><a href="#4-输出二叉树中所有从根到叶子的路径" class="headerlink" title="4. 输出二叉树中所有从根到叶子的路径"></a>4. 输出二叉树中所有从根到叶子的路径</h3><h3 id="5-排列"><a href="#5-排列" class="headerlink" title="5. 排列"></a>5. 排列</h3><h3 id="6-含有相同元素求排列"><a href="#6-含有相同元素求排列" class="headerlink" title="6. 含有相同元素求排列"></a>6. 含有相同元素求排列</h3><h3 id="7-组合"><a href="#7-组合" class="headerlink" title="7. 组合"></a>7. 组合</h3><h3 id="8-组合求和"><a href="#8-组合求和" class="headerlink" title="8. 组合求和"></a>8. 组合求和</h3><h3 id="9-含有相同元素的组合求和"><a href="#9-含有相同元素的组合求和" class="headerlink" title="9. 含有相同元素的组合求和"></a>9. 含有相同元素的组合求和</h3><h3 id="10-1-9-数字的组合求和"><a href="#10-1-9-数字的组合求和" class="headerlink" title="10. 1-9 数字的组合求和"></a>10. 1-9 数字的组合求和</h3><h3 id="11-子集"><a href="#11-子集" class="headerlink" title="11. 子集"></a>11. 子集</h3><h3 id="12-含有相同元素求子集"><a href="#12-含有相同元素求子集" class="headerlink" title="12. 含有相同元素求子集"></a>12. 含有相同元素求子集</h3><h3 id="13-分割字符串使得每个部分都是回文数"><a href="#13-分割字符串使得每个部分都是回文数" class="headerlink" title="13. 分割字符串使得每个部分都是回文数"></a>13. 分割字符串使得每个部分都是回文数</h3><h3 id="14-数独"><a href="#14-数独" class="headerlink" title="14. 数独"></a>14. 数独</h3><h3 id="15-N-皇后"><a href="#15-N-皇后" class="headerlink" title="15. N 皇后"></a>15. N 皇后</h3><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>bfs是按一层一层来访问的，所以适合有目标求最短路的步数，你想想层层搜索每次层就代表了一步。bfs优先访问的是兄弟节点，只有这一层全部访问完才能访问下一层，也就是说bfs第几层就代表当前可以走到的位置(结点).而dfs是按递归来实现的，它优先搜索深度，再回溯，优先访问的是没有访问过的子节点<br>DFS多用于连通性问题因为其运行思想与人脑的思维很相似，故解决连通性问题更自然。BFS多用于解决最短路问题，其运行过程中需要储存每一层的信息，所以其运行时需要储存的信息量较大，如果人脑也可储存大量信息的话，理论上人脑也可运行BFS。<br>总的来说多数情况下运行BFS所需的内存会大于DFS需要的内存(DFS一次访问一条路，BFS一次访问多条路)，DFS容易爆栈(栈不易”控制”)，BFS通过控制队列可以很好解决”爆队列”风险。<br>它们两者间各自的优势需要通过实际的问题来具体分析，根据它们各自的特点来应用于不同的问题中才能获得最优的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;具体学习链接-Leetcode-题解-目录-md&quot;&gt;&lt;a href=&quot;#具体学习链接-Leetcode-题解-目录-md&quot; class=&quot;headerlink&quot; title=&quot;具体学习链接:Leetcode 题解 - 目录.md&quot;&gt;&lt;/a&gt;具体学习链接:&lt;a hr</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>95. Unique Binary Search Trees II (Medium)</title>
    <link href="http://example.com/2022/06/21/95/"/>
    <id>http://example.com/2022/06/21/95/</id>
    <published>2022-06-22T02:47:55.000Z</published>
    <updated>2022-06-23T15:35:37.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a>95. Unique Binary Search Trees II (Medium)</h1><h2 id="Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order"><a href="#Given-an-integer-n-return-all-the-structurally-unique-BST’s-binary-search-trees-which-has-exactly-n-nodes-of-unique-values-from-1-to-n-Return-the-answer-in-any-order" class="headerlink" title="Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order."></a>Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><h2 id="官方leetcode-题解"><a href="#官方leetcode-题解" class="headerlink" title="官方leetcode 题解"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/">官方leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>,]</span><br><span class="line">            </span><br><span class="line">            allTrees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):  <span class="comment"># 枚举可行根节点</span></span><br><span class="line">                <span class="comment"># 获得所有可行的左子树集合</span></span><br><span class="line">                leftTrees = generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 获得所有可行的右子树集合</span></span><br><span class="line">                rightTrees = generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        currTree = TreeNode(i)</span><br><span class="line">                        currTree.left = l</span><br><span class="line">                        currTree.right = r</span><br><span class="line">                        allTrees.append(currTree)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> allTrees</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;95-Unique-Binary-Search-Trees-II-Medium&quot;&gt;&lt;a href=&quot;#95-Unique-Binary-Search-Trees-II-Medium&quot; class=&quot;headerlink&quot; title=&quot;95. Unique Bin</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="divide and conquer" scheme="http://example.com/tags/divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>241. Different Ways to Add Parentheses (Medium)</title>
    <link href="http://example.com/2022/06/21/241/"/>
    <id>http://example.com/2022/06/21/241/</id>
    <published>2022-06-22T02:47:33.000Z</published>
    <updated>2022-06-23T15:36:10.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses-Medium"><a href="#241-Different-Ways-to-Add-Parentheses-Medium" class="headerlink" title="241. Different Ways to Add Parentheses (Medium)"></a>241. Different Ways to Add Parentheses (Medium)</h1><h2 id="Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order"><a href="#Given-a-string-expression-of-numbers-and-operators-return-all-possible-results-from-computing-all-the-different-possible-ways-to-group-numbers-and-operators-You-may-return-the-answer-in-any-order" class="headerlink" title="Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order."></a>Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.</h2><h2 id="The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4"><a href="#The-test-cases-are-generated-such-that-the-output-values-fit-in-a-32-bit-integer-and-the-number-of-different-results-does-not-exceed-10-4" class="headerlink" title="The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4."></a>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: expression = &quot;2-1-1&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">Explanation:</span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure><h2 id="分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"><a href="#分治算法-divide-and-conquer-的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。" class="headerlink" title="分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。"></a>分治算法(divide and conquer)的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</h2><h2 id="分治法解题的一般步骤（如图1）："><a href="#分治法解题的一般步骤（如图1）：" class="headerlink" title="分治法解题的一般步骤（如图1）："></a>分治法解题的一般步骤（如图1）：</h2><h3 id="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"><a href="#（1）分解，将要解决的问题划分成若干规模较小的同类问题；" class="headerlink" title="（1）分解，将要解决的问题划分成若干规模较小的同类问题；"></a>（1）分解，将要解决的问题划分成若干规模较小的同类问题；</h3><h3 id="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"><a href="#（2）求解，当子问题划分得足够小时，用较简单的方法解决；" class="headerlink" title="（2）求解，当子问题划分得足够小时，用较简单的方法解决；"></a>（2）求解，当子问题划分得足够小时，用较简单的方法解决；</h3><h3 id="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"><a href="#（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。" class="headerlink" title="（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。"></a>（3）合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</h3><h2 id="leetcode-题解"><a href="#leetcode-题解" class="headerlink" title="leetcode 题解"></a><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/pythongolang-fen-zhi-suan-fa-by-jalan/">leetcode 题解</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;241-Different-Ways-to-Add-Parentheses-Medium&quot;&gt;&lt;a href=&quot;#241-Different-Ways-to-Add-Parentheses-Medium&quot; class=&quot;headerlink&quot; title=&quot;241.</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="divide and conquer" scheme="http://example.com/tags/divide-and-conquer/"/>
    
  </entry>
  
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <link href="http://example.com/2022/06/20/34/"/>
    <id>http://example.com/2022/06/20/34/</id>
    <published>2022-06-21T02:40:29.000Z</published>
    <updated>2022-06-21T03:51:34.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a>34. Find First and Last Position of Element in Sorted Array (Medium)</h1><h2 id="Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value"><a href="#Given-an-array-of-integers-nums-sorted-in-non-decreasing-order-find-the-starting-and-ending-position-of-a-given-target-value" class="headerlink" title="Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value."></a>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</h2><h2 id="If-target-is-not-found-in-the-array-return-1-1"><a href="#If-target-is-not-found-in-the-array-return-1-1" class="headerlink" title="If target is not found in the array, return [-1, -1]."></a>If target is not found in the array, return [-1, -1].</h2><h2 id="You-must-write-an-algorithm-with-O-log-n-runtime-complexity"><a href="#You-must-write-an-algorithm-with-O-log-n-runtime-complexity" class="headerlink" title="You must write an algorithm with O(log n) runtime complexity."></a>You must write an algorithm with O(log n) runtime complexity.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/837944">Solution</a>:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = (left + right)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        start = binarysearchleft(nums, target)</span><br><span class="line">        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start, end]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#34-Find-First-and-Last-Position-of-Element-in-Sorted-Ar</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array (Medium)</title>
    <link href="http://example.com/2022/06/20/153/"/>
    <id>http://example.com/2022/06/20/153/</id>
    <published>2022-06-21T02:40:20.000Z</published>
    <updated>2022-06-23T15:36:16.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a>153. Find Minimum in Rotated Sorted Array (Medium)</h1><h2 id="Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become"><a href="#Suppose-an-array-of-length-n-sorted-in-ascending-order-is-rotated-between-1-and-n-times-For-example-the-array-nums-0-1-2-4-5-6-7-might-become" class="headerlink" title="Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:"></a>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:</h2><h2 id="4-5-6-7-0-1-2-if-it-was-rotated-4-times"><a href="#4-5-6-7-0-1-2-if-it-was-rotated-4-times" class="headerlink" title="[4,5,6,7,0,1,2] if it was rotated 4 times."></a>[4,5,6,7,0,1,2] if it was rotated 4 times.</h2><h2 id="0-1-2-4-5-6-7-if-it-was-rotated-7-times"><a href="#0-1-2-4-5-6-7-if-it-was-rotated-7-times" class="headerlink" title="[0,1,2,4,5,6,7] if it was rotated 7 times."></a>[0,1,2,4,5,6,7] if it was rotated 7 times.</h2><h2 id="Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2"><a href="#Notice-that-rotating-an-array-a-0-a-1-a-2-…-a-n-1-1-time-results-in-the-array-a-n-1-a-0-a-1-a-2-…-a-n-2" class="headerlink" title="Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]."></a>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].</h2><h2 id="Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array"><a href="#Given-the-sorted-rotated-array-nums-of-unique-elements-return-the-minimum-element-of-this-array" class="headerlink" title="Given the sorted rotated array nums of unique elements, return the minimum element of this array."></a>Given the sorted rotated array nums of unique elements, return the minimum element of this array.</h2><h2 id="You-must-write-an-algorithm-that-runs-in-O-log-n-time"><a href="#You-must-write-an-algorithm-that-runs-in-O-log-n-time" class="headerlink" title="You must write an algorithm that runs in O(log n) time."></a>You must write an algorithm that runs in O(log n) time.</h2><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last = <span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;nums[last] :                </span><br><span class="line">                last = mid         </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[first]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;153-Find-Minimum-in-Rotated-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#153-Find-Minimum-in-Rotated-Sorted-Array-Medium&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>278. First Bad Version (Easy)</title>
    <link href="http://example.com/2022/06/20/278/"/>
    <id>http://example.com/2022/06/20/278/</id>
    <published>2022-06-21T02:27:02.000Z</published>
    <updated>2022-06-21T03:51:02.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a>278. First Bad Version (Easy)</h1><h2 id="You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad"><a href="#You-are-a-product-manager-and-currently-leading-a-team-to-develop-a-new-product-Unfortunately-the-latest-version-of-your-product-fails-the-quality-check-Since-each-version-is-developed-based-on-the-previous-version-all-the-versions-after-a-bad-version-are-also-bad" class="headerlink" title="You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad."></a>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</h2><h2 id="Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad"><a href="#Suppose-you-have-n-versions-1-2-…-n-and-you-want-to-find-out-the-first-bad-one-which-causes-all-the-following-ones-to-be-bad" class="headerlink" title="Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad."></a>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</h2><h2 id="You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API"><a href="#You-are-given-an-API-bool-isBadVersion-version-which-returns-whether-version-is-bad-Implement-a-function-to-find-the-first-bad-version-You-should-minimize-the-number-of-calls-to-the-API" class="headerlink" title="You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."></a>You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, bad = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line">Then 4 is the first bad version.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/">官方题解</a></h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p><p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p><p>具体地，将左右边界分别初始化为 1 和 n，其中 n 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p><p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 O(logn) 次。</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><p>solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        first,last=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+(last-first)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):                </span><br><span class="line">                last= mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> first</span><br><span class="line">               </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;278-First-Bad-Version-Easy&quot;&gt;&lt;a href=&quot;#278-First-Bad-Version-Easy&quot; class=&quot;headerlink&quot; title=&quot;278. First Bad Version (Easy)&quot;&gt;&lt;/a&gt;278. </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>540. Single Element in a Sorted Array (Medium)</title>
    <link href="http://example.com/2022/06/20/540/"/>
    <id>http://example.com/2022/06/20/540/</id>
    <published>2022-06-21T01:39:30.000Z</published>
    <updated>2022-06-21T03:50:48.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="540-Single-Element-in-a-Sorted-Array-Medium"><a href="#540-Single-Element-in-a-Sorted-Array-Medium" class="headerlink" title="540. Single Element in a Sorted Array (Medium)"></a>540. Single Element in a Sorted Array (Medium)</h1><h2 id="You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once"><a href="#You-are-given-a-sorted-array-consisting-of-only-integers-where-every-element-appears-exactly-twice-except-for-one-element-which-appears-exactly-once" class="headerlink" title="You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once."></a>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</h2><h2 id="Return-the-single-element-that-appears-only-once"><a href="#Return-the-single-element-that-appears-only-once" class="headerlink" title="Return the single element that appears only once."></a>Return the single element that appears only once.</h2><h2 id="Your-solution-must-run-in-O-log-n-time-and-O-1-space"><a href="#Your-solution-must-run-in-O-log-n-time-and-O-1-space" class="headerlink" title="Your solution must run in O(log n) time and O(1) space."></a>Your solution must run in O(log n) time and O(1) space.</h2><p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。<br>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-y8gh/">官方题解</a></h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>这道题的特点在于比较的不是数字本身的大小，而是下标的奇偶性。因为只有一个数只出现一次，所以这个数字的下标就只能是偶数。</p><p>由于数组是有序的，因此数组中相同的元素一定相邻。对于下标 x 左边的下标 y，如果 nums[y]=nums[y+1]，则 y 一定是偶数；对于下标 x 右边的下标 z，如果 nums[z]=nums[z+1]，则 z 一定是奇数。由于下标 x 是相同元素的开始下标的奇偶性的分界，因此可以使用二分查找的方法寻找下标 x。</p><p>初始时，二分查找的左边界是 0，右边界是数组的最大下标。每次取左右边界的平均值 mid 作为待判断的下标，根据 mid 的奇偶性决定和左边或右边的相邻元素比较：</p><p>如果 mid 是偶数，则比较 nums[mid] 和 nums[mid+1] 是否相等；</p><p>如果 mid 是奇数，则比较 nums[mid−1] 和 nums[mid] 是否相等。</p><p>如果上述比较相邻元素的结果是相等，则 mid&lt;x, 调整左边界。否则 mid≥x，调整右边界。调整边界之后继续二分查找，直到确定下标 x 的值。</p><p>得到下标 x 的值之后，nums[x] 即为只出现一次的元素。</p><p>⊕ 是按位异或运算符</p><p>当 mid 是偶数时， mid+1=mid⊕1；</p><p>当 mid 是奇数时， mid−1=mid⊕1。</p><h2 id="注：按位异或-按位或-按位与-amp"><a href="#注：按位异或-按位或-按位与-amp" class="headerlink" title="注：按位异或 ^ ,按位或 | ,按位与 &amp;"></a>注：按位异或 ^ ,按位或 | ,按位与 &amp;</h2><p>也就是说判断奇偶性是靠异或运算</p><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid ^ <span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;540-Single-Element-in-a-Sorted-Array-Medium&quot;&gt;&lt;a href=&quot;#540-Single-Element-in-a-Sorted-Array-Medium&quot; class=&quot;headerlink&quot; title=&quot;540. S</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>16. 3Sum Closest(medium)</title>
    <link href="http://example.com/2022/06/16/16/"/>
    <id>http://example.com/2022/06/16/16/</id>
    <published>2022-06-16T19:24:32.000Z</published>
    <updated>2022-06-16T19:32:58.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="16-3Sum-Closest-medium"><a href="#16-3Sum-Closest-medium" class="headerlink" title="16. 3Sum Closest(medium)"></a>16. 3Sum Closest(medium)</h1><h2 id="Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target"><a href="#Given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers-in-nums-such-that-the-sum-is-closest-to-target" class="headerlink" title="Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target."></a>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</h2><h2 id="Return-the-sum-of-the-three-integers"><a href="#Return-the-sum-of-the-three-integers" class="headerlink" title="Return the sum of the three integers."></a>Return the sum of the three integers.</h2><h2 id="You-may-assume-that-each-input-would-have-exactly-one-solution"><a href="#You-may-assume-that-each-input-would-have-exactly-one-solution" class="headerlink" title="You may assume that each input would have exactly one solution."></a>You may assume that each input would have exactly one solution.</h2><p><a href="https://leetcode.cn/problems/3sum-closest/solution/pythonshuang-zhi-zhen-you-hua-ji-bai-999-by-hardca/">排序 + 双指针</a><br>这题和三数之和接近，就是排序然后再使用双指针。寻找最接近的数，刚好原来的三数之和就是使用慢慢接近的方法寻找target的，所以就可以在寻找target的过程中每一次都判断是否是最接近的。</p><p>优化的细节是在双指针前加入当前这一轮，也就是first固定下来后，的最大值和最小值与target的关系。如果最大的数都小于等于target，那直接下一轮，first往右也许能更大；如果最小的数都大于等于target，那压根别找了，因为不可能再有更小的数了，直接Break掉返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()         <span class="comment"># 排序</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):        <span class="comment"># 枚举第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> first &gt; <span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first-<span class="number">1</span>]: <span class="keyword">continue</span>     <span class="comment"># 保证first不会有重复</span></span><br><span class="line"></span><br><span class="line">            second, third = first + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            max_sum = nums[first] + nums[-<span class="number">2</span>] + nums[-<span class="number">1</span>]</span><br><span class="line">            min_sum = nums[first] + nums[first + <span class="number">1</span>] + nums[first + <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> max_sum &lt;= target:    <span class="comment"># 最大的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(max_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = max_sum</span><br><span class="line">                <span class="keyword">continue</span>              </span><br><span class="line">            <span class="keyword">elif</span> min_sum &gt;= target:  <span class="comment"># 最小的数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(min_sum - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = min_sum      </span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                two_sum_target = target - nums[first]</span><br><span class="line">                s = nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s + nums[first] - target) &lt; <span class="built_in">abs</span>(ans - target):</span><br><span class="line">                    ans = s + nums[first]</span><br><span class="line">                <span class="keyword">if</span> s &gt; two_sum_target:  <span class="comment"># 当前数值太大 右指针左移</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third + <span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; two_sum_target:  <span class="comment"># 当前数值太小 左指针右移</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[second] == nums[second - <span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:                   <span class="comment"># 刚好等于 直接返回target即可</span></span><br><span class="line">                    <span class="keyword">return</span> target </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;16-3Sum-Closest-medium&quot;&gt;&lt;a href=&quot;#16-3Sum-Closest-medium&quot; class=&quot;headerlink&quot; title=&quot;16. 3Sum Closest(medium)&quot;&gt;&lt;/a&gt;16. 3Sum Closest(m</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="sort" scheme="http://example.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>744. Find Smallest Letter Greater Than Target (Easy)</title>
    <link href="http://example.com/2022/06/16/744/"/>
    <id>http://example.com/2022/06/16/744/</id>
    <published>2022-06-16T16:42:31.000Z</published>
    <updated>2022-06-21T01:40:29.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="744-Find-Smallest-Letter-Greater-Than-Target-Easy"><a href="#744-Find-Smallest-Letter-Greater-Than-Target-Easy" class="headerlink" title="744. Find Smallest Letter Greater Than Target (Easy)"></a>744. Find Smallest Letter Greater Than Target (Easy)</h1><h2 id="Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target"><a href="#Given-a-characters-array-letters-that-is-sorted-in-non-decreasing-order-and-a-character-target-return-the-smallest-character-in-the-array-that-is-larger-than-target" class="headerlink" title="Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target."></a>Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;d&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target = &quot;k&quot;</span><br><span class="line">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure><p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution/xun-zhao-bi-mu-biao-zi-mu-da-de-zui-xiao-lhm7/">官方题解</a></h2><h2 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1.线性查找"></a>1.线性查找</h2><p>由于给定的列表已经按照递增顺序排序，因此可以从左到右遍历列表，找到第一个比目标字母大的字母，即为比目标字母大的最小字母。</p><p>如果目标字母小于列表中的最后一个字母，则一定可以在列表中找到比目标字母大的最小字母。如果目标字母大于或等于列表中的最后一个字母，则列表中不存在比目标字母大的字母，根据循环出现的顺序，列表的首个字母是比目标字母大的最小字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>((letter <span class="keyword">for</span> letter <span class="keyword">in</span> letters <span class="keyword">if</span> letter &gt; target), letters[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h2><p>利用列表有序的特点，可以使用二分查找降低时间复杂度。</p><p>首先比较目标字母和列表中的最后一个字母，当目标字母大于或等于列表中的最后一个字母时，答案是列表的首个字母。当目标字母小于列表中的最后一个字母时，列表中一定存在比目标字母大的字母，可以使用二分查找得到比目标字母大的最小字母。</p><p>初始时，二分查找的范围是整个列表的下标范围。每次比较当前下标处的字母和目标字母，如果当前下标处的字母大于目标字母，则在当前下标以及当前下标的左侧继续查找，否则在当前下标的右侧继续查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> letters[bisect_right(letters, target)] <span class="keyword">if</span> target &lt; letters[-<span class="number">1</span>] <span class="keyword">else</span> letters[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="这个是二分查找的模板"><a href="#这个是二分查找的模板" class="headerlink" title="这个是二分查找的模板"></a>这个是二分查找的模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br></pre></td></tr></table></figure><h3 id="自己写的完全版"><a href="#自己写的完全版" class="headerlink" title="自己写的完全版"></a>自己写的完全版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        first,last=<span class="number">0</span>,<span class="built_in">len</span>(letters)-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意如果目标值大于或等于有序列表的最后一项，返回值为首元素</span></span><br><span class="line">        <span class="comment">#letters[-1]是列表最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> target&gt;=letters[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> first&lt;last:</span><br><span class="line">            mid = first+ (last-first)//<span class="number">2</span> <span class="comment">#1//2=0,向下取整</span></span><br><span class="line">            <span class="keyword">if</span> letters[mid]&lt;=target:</span><br><span class="line">                first=mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = mid</span><br><span class="line">        <span class="keyword">return</span> letters[first]                </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;744-Find-Smallest-Letter-Greater-Than-Target-Easy&quot;&gt;&lt;a href=&quot;#744-Find-Smallest-Letter-Greater-Than-Target-Easy&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>69. Sqrt(x) (Easy)</title>
    <link href="http://example.com/2022/06/16/69/"/>
    <id>http://example.com/2022/06/16/69/</id>
    <published>2022-06-16T14:18:13.000Z</published>
    <updated>2022-06-16T16:42:00.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a>69. Sqrt(x) (Easy)</h1><h2 id="Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x"><a href="#Given-a-non-negative-integer-x-compute-and-return-the-square-root-of-x" class="headerlink" title="Given a non-negative integer x, compute and return the square root of x."></a>Given a non-negative integer x, compute and return the square root of x.</h2><h2 id="Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned"><a href="#Since-the-return-type-is-an-integer-the-decimal-digits-are-truncated-and-only-the-integer-part-of-the-result-is-returned" class="headerlink" title="Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned."></a>Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.</h2><h2 id="Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5"><a href="#Note-You-are-not-allowed-to-use-any-built-in-exponent-function-or-operator-such-as-pow-x-0-5-or-x-0-5" class="headerlink" title="Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5"></a>Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5</h2><h2 id="方法一：二分查找"><a href="#方法一：二分查找" class="headerlink" title="方法一：二分查找"></a>方法一：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span>(<span class="params">array, first, last, value</span>):</span>  <span class="comment"># 求非降序范围[first, last)内第一个不小于value的值的位置</span></span><br><span class="line">    <span class="keyword">while</span> first &lt; last: <span class="comment"># 搜索区间[first, last)不为空</span></span><br><span class="line">        mid = first + (last - first) // <span class="number">2</span>  <span class="comment"># 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> array[mid] &lt; value: </span><br><span class="line">            first = mid + <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            last = mid</span><br><span class="line">    <span class="keyword">return</span> first  <span class="comment"># last也行，因为[first, last)为空的时候它们重合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(left-right)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left+(right-left)//<span class="number">2</span> <span class="comment"># 防溢出</span></span><br><span class="line">            <span class="comment">#mid = (left + right) // 2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="方法二：牛顿迭代"><a href="#方法二：牛顿迭代" class="headerlink" title="方法二：牛顿迭代"></a>方法二：牛顿迭代</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;69-Sqrt-x-Easy&quot;&gt;&lt;a href=&quot;#69-Sqrt-x-Easy&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x) (Easy)&quot;&gt;&lt;/a&gt;69. Sqrt(x) (Easy)&lt;/h1&gt;&lt;h2 id=&quot;Given-a-n</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="binary search algorithm" scheme="http://example.com/tags/binary-search-algorithm/"/>
    
  </entry>
  
</feed>
