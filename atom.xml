<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>八角书屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-17T03:49:43.684Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>leaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>112. Path Sum (Easy)</title>
    <link href="http://example.com/2022/08/16/112/"/>
    <id>http://example.com/2022/08/16/112/</id>
    <published>2022-08-17T03:37:14.000Z</published>
    <updated>2022-08-17T03:49:43.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a>112. Path Sum (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum"><a href="#Given-the-root-of-a-binary-tree-and-an-integer-targetSum-return-true-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-targetSum" class="headerlink" title="Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum."></a>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</h2><h2 id="A-leaf-is-a-node-with-no-children"><a href="#A-leaf-is-a-node-with-no-children" class="headerlink" title="A leaf is a node with no children."></a>A leaf is a node with no children.</h2><p><a href="https://leetcode.cn/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">官方题解</a></p><p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p><p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p><p>复杂度分析</p><p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left,targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,targetSum-root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;112-Path-Sum-Easy&quot;&gt;&lt;a href=&quot;#112-Path-Sum-Easy&quot; class=&quot;headerlink&quot; title=&quot;112. Path Sum (Easy)&quot;&gt;&lt;/a&gt;112. Path Sum (Easy)&lt;/h1&gt;&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>617. Merge Two Binary Trees (Easy)</title>
    <link href="http://example.com/2022/08/15/617/"/>
    <id>http://example.com/2022/08/15/617/</id>
    <published>2022-08-16T03:26:38.000Z</published>
    <updated>2022-08-17T03:29:51.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="617-Merge-Two-Binary-Trees-Easy"><a href="#617-Merge-Two-Binary-Trees-Easy" class="headerlink" title="617. Merge Two Binary Trees (Easy)"></a>617. Merge Two Binary Trees (Easy)</h1><h2 id="You-are-given-two-binary-trees-root1-and-root2"><a href="#You-are-given-two-binary-trees-root1-and-root2" class="headerlink" title="You are given two binary trees root1 and root2."></a>You are given two binary trees root1 and root2.</h2><h2 id="Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree"><a href="#Imagine-that-when-you-put-one-of-them-to-cover-the-other-some-nodes-of-the-two-trees-are-overlapped-while-the-others-are-not-You-need-to-merge-the-two-trees-into-a-new-binary-tree-The-merge-rule-is-that-if-two-nodes-overlap-then-sum-node-values-up-as-the-new-value-of-the-merged-node-Otherwise-the-NOT-null-node-will-be-used-as-the-node-of-the-new-tree" class="headerlink" title="Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree."></a>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</h2><h2 id="Return-the-merged-tree"><a href="#Return-the-merged-tree" class="headerlink" title="Return the merged tree."></a>Return the merged tree.</h2><h2 id="Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees"><a href="#Note-The-merging-process-must-start-from-the-root-nodes-of-both-trees" class="headerlink" title="Note: The merging process must start from the root nodes of both trees."></a>Note: The merging process must start from the root nodes of both trees.</h2><h3 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/">参考解析</a></h3><p>对于二叉树来说，如果我们像遍历数组那样，挨个遍历两颗二叉树中的每个节点，再把他们相加，那问题就比较容易解决了。</p><p>遍历二叉树很简单，用 前序 遍历就可以了，再依次把访问到的节点值相加，因为题目没有说不能改变树的值和结构，我们不用再创建新的节点了，直接将树2合并到树1上再返回就可以了。<br>需要注意：这两颗树并不是长得完全一样，有的树可能有左节点，但有的树没有。</p><p>总结下递归的条件：</p><p>终止条件：树 1 的节点为 null，或者树 2 的节点为 null<br>递归函数内：将两个树的节点相加后，再赋给树 1 的节点。再递归的执行两个树的左节点，递归执行两个树的右节点</p><p>总结一下就是把root2的值复制到root1上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root1,root2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (root1 <span class="keyword">and</span> root2):</span><br><span class="line">                <span class="keyword">return</span> root1 <span class="keyword">if</span> root1 <span class="keyword">else</span> root2</span><br><span class="line">            root1.val += root2.val</span><br><span class="line">            root1.left = dfs(root1.left,root2.left)</span><br><span class="line">            root1.right = dfs(root1.right,root2.right)</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">return</span> dfs(root1,root2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;617-Merge-Two-Binary-Trees-Easy&quot;&gt;&lt;a href=&quot;#617-Merge-Two-Binary-Trees-Easy&quot; class=&quot;headerlink&quot; title=&quot;617. Merge Two Binary Trees (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>226. Invert Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/15/226/"/>
    <id>http://example.com/2022/08/15/226/</id>
    <published>2022-08-16T03:08:56.000Z</published>
    <updated>2022-08-16T03:27:12.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a>226. Invert Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root"><a href="#Given-the-root-of-a-binary-tree-invert-the-tree-and-return-its-root" class="headerlink" title="Given the root of a binary tree, invert the tree, and return its root."></a>Given the root of a binary tree, invert the tree, and return its root.</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-leetcode-solution/">官方题解</a></h3><p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:        if not root:            return root        left = self.invertTree(root.left)        right = self.invertTree(root.right)        root.left = right        root.right = left        return root</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;226-Invert-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree (Easy)&quot;&gt;&lt;/a&gt;22</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>543. Diameter of Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/543/"/>
    <id>http://example.com/2022/08/14/543/</id>
    <published>2022-08-15T02:24:25.000Z</published>
    <updated>2022-08-16T03:26:12.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a>543. Diameter of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree"><a href="#Given-the-root-of-a-binary-tree-return-the-length-of-the-diameter-of-the-tree" class="headerlink" title="Given the root of a binary tree, return the length of the diameter of the tree."></a>Given the root of a binary tree, return the length of the diameter of the tree.</h2><h2 id="The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root"><a href="#The-diameter-of-a-binary-tree-is-the-length-of-the-longest-path-between-any-two-nodes-in-a-tree-This-path-may-or-may-not-pass-through-the-root" class="headerlink" title="The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root."></a>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</h2><h2 id="The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them"><a href="#The-length-of-a-path-between-two-nodes-is-represented-by-the-number-of-edges-between-them" class="headerlink" title="The length of a path between two nodes is represented by the number of edges between them."></a>The length of a path between two nodes is represented by the number of edges between them.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/">官方题解</a></h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>其实我看到这道题感觉和<a href="https://upuphero.github.io/2022/08/14/110/">110. Balanced Binary Tree (Easy)</a>很像，可以在求高度的基础上稍微改一下<br>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p><p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p><p>我们记节点node 为起点的路径经过节点数的最大值为 d<sub>node</sub>，那么二叉树的直径就是所有节点 d<sub>node</sub>的最大值减一。</p><p>最后的算法流程为：我们定义一个递归函数 depth(node) 计算 d<sub>node</sub>，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为max(L,R)+1</p><p>该节点的 d<sub>node</sub> 值为L+R+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="comment"># 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 左儿子为根的子树的深度</span></span><br><span class="line">            L = depth(root.left)</span><br><span class="line">            <span class="comment"># 右儿子为根的子树的深度</span></span><br><span class="line">            R = depth(root.right)</span><br><span class="line">            <span class="comment"># 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, L + R + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 返回该节点为根的子树的深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        depth(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;543-Diameter-of-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#543-Diameter-of-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;543. Diameter of Binary Tree</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>110. Balanced Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/110/"/>
    <id>http://example.com/2022/08/14/110/</id>
    <published>2022-08-14T21:49:16.000Z</published>
    <updated>2022-08-16T02:54:48.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a>110. Balanced Binary Tree (Easy)</h1><h2 id="Given-a-binary-tree-determine-if-it-is-height-balanced"><a href="#Given-a-binary-tree-determine-if-it-is-height-balanced" class="headerlink" title="Given a binary tree, determine if it is height-balanced."></a>Given a binary tree, determine if it is height-balanced.</h2><h2 id="For-this-problem-a-height-balanced-binary-tree-is-defined-as"><a href="#For-this-problem-a-height-balanced-binary-tree-is-defined-as" class="headerlink" title="For this problem, a height-balanced binary tree is defined as:"></a>For this problem, a height-balanced binary tree is defined as:</h2><h2 id="a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1"><a href="#a-binary-tree-in-which-the-left-and-right-subtrees-of-every-node-differ-in-height-by-no-more-than-1" class="headerlink" title="a binary tree in which the left and right subtrees of every node differ in height by no more than 1."></a>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/">两种办法</a></p><h3 id="方法一：自顶向下的递归"><a href="#方法一：自顶向下的递归" class="headerlink" title="方法一：自顶向下的递归"></a>方法一：自顶向下的递归</h3><p>定义函数 height，用于计算二叉树中的任意一个节点 p 的高度：<br>height(p)=max(height(p.left),height(p.right))+1 P是非空节点</p><p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(height(root.left), height(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><h3 id="方法二：自底向上的递归"><a href="#方法二：自底向上的递归" class="headerlink" title="方法二：自底向上的递归"></a>方法二：自底向上的递归</h3><p>方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。</p><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftHeight = height(root.left)</span><br><span class="line">            rightHeight = height(root.right)</span><br><span class="line">            <span class="keyword">if</span> leftHeight == -<span class="number">1</span> <span class="keyword">or</span> rightHeight == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;110-Balanced-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#110-Balanced-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;110. Balanced Binary Tree (Easy)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
    <category term="Tree" scheme="http://example.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>104. Maximum Depth of Binary Tree (Easy)</title>
    <link href="http://example.com/2022/08/14/104/"/>
    <id>http://example.com/2022/08/14/104/</id>
    <published>2022-08-14T19:58:34.000Z</published>
    <updated>2022-08-16T02:54:57.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a>104. Maximum Depth of Binary Tree (Easy)</h1><h2 id="Given-the-root-of-a-binary-tree-return-its-maximum-depth"><a href="#Given-the-root-of-a-binary-tree-return-its-maximum-depth" class="headerlink" title="Given the root of a binary tree, return its maximum depth."></a>Given the root of a binary tree, return its maximum depth.</h2><h2 id="A-binary-tree’s-maximum-depth-is-the-number-of-nodes-along-the-longest-path-from-the-root-node-down-to-the-farthest-leaf-node"><a href="#A-binary-tree’s-maximum-depth-is-the-number-of-nodes-along-the-longest-path-from-the-root-node-down-to-the-farthest-leaf-node" class="headerlink" title="A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node."></a>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</h2><p>经典重现<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p><p>这道题是求二叉树的深度，可以用深度优先搜索。<br>算法思想： 一个节点的高度=max(左孩子的高度,右孩子的高度)+1。 进行先序遍历搜索，每次递归返回的时候统计其左右孩子中最大的深度。</p><pre><code class="python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        if root is None:            return 0        else:            left_height = self.maxDepth(root.left)            right_height = self.maxDepth(root.right)            return max(left_height,right_height)+1</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;104-Maximum-Depth-of-Binary-Tree-Easy&quot;&gt;&lt;a href=&quot;#104-Maximum-Depth-of-Binary-Tree-Easy&quot; class=&quot;headerlink&quot; title=&quot;104. Maximum Depth</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
    <category term="Tree" scheme="http://example.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>328. Odd Even Linked List (Medium)</title>
    <link href="http://example.com/2022/08/06/328/"/>
    <id>http://example.com/2022/08/06/328/</id>
    <published>2022-08-07T03:14:11.000Z</published>
    <updated>2022-08-07T03:22:50.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="328-Odd-Even-Linked-List-Medium"><a href="#328-Odd-Even-Linked-List-Medium" class="headerlink" title="328. Odd Even Linked List (Medium)"></a>328. Odd Even Linked List (Medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-group-all-the-nodes-with-odd-indices-together-followed-by-the-nodes-with-even-indices-and-return-the-reordered-list"><a href="#Given-the-head-of-a-singly-linked-list-group-all-the-nodes-with-odd-indices-together-followed-by-the-nodes-with-even-indices-and-return-the-reordered-list" class="headerlink" title="Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list."></a>Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.</h2><h2 id="The-first-node-is-considered-odd-and-the-second-node-is-even-and-so-on"><a href="#The-first-node-is-considered-odd-and-the-second-node-is-even-and-so-on" class="headerlink" title="The first node is considered odd, and the second node is even, and so on."></a>The first node is considered odd, and the second node is even, and so on.</h2><h2 id="Note-that-the-relative-order-inside-both-the-even-and-odd-groups-should-remain-as-it-was-in-the-input"><a href="#Note-that-the-relative-order-inside-both-the-even-and-odd-groups-should-remain-as-it-was-in-the-input" class="headerlink" title="Note that the relative order inside both the even and odd groups should remain as it was in the input."></a>Note that the relative order inside both the even and odd groups should remain as it was in the input.</h2><h2 id="You-must-solve-the-problem-in-O-1-extra-space-complexity-and-O-n-time-complexity"><a href="#You-must-solve-the-problem-in-O-1-extra-space-complexity-and-O-n-time-complexity" class="headerlink" title="You must solve the problem in O(1) extra space complexity and O(n) time complexity."></a>You must solve the problem in O(1) extra space complexity and O(n) time complexity.</h2><p>总结是把奇数节点串一块儿，再把偶数节点串一起，然后把两个连成一条链表</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/odd-even-linked-list/solution/qi-ou-lian-biao-by-leetcode-solution/">官方题解</a></h3><p><img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="图片"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        evenHead = head.<span class="built_in">next</span> <span class="comment">#新建一个链表头</span></span><br><span class="line">        odd, even = head, evenHead</span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">            odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">            odd = odd.<span class="built_in">next</span></span><br><span class="line">            even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">            even = even.<span class="built_in">next</span></span><br><span class="line">        odd.<span class="built_in">next</span> = evenHead</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;328-Odd-Even-Linked-List-Medium&quot;&gt;&lt;a href=&quot;#328-Odd-Even-Linked-List-Medium&quot; class=&quot;headerlink&quot; title=&quot;328. Odd Even Linked List (Med</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>725. Split Linked List in Parts(Medium)</title>
    <link href="http://example.com/2022/08/06/725/"/>
    <id>http://example.com/2022/08/06/725/</id>
    <published>2022-08-06T21:29:09.000Z</published>
    <updated>2022-08-07T03:16:30.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="725-Split-Linked-List-in-Parts-Medium"><a href="#725-Split-Linked-List-in-Parts-Medium" class="headerlink" title="725. Split Linked List in Parts(Medium)"></a>725. Split Linked List in Parts(Medium)</h1><h2 id="Given-the-head-of-a-singly-linked-list-and-an-integer-k-split-the-linked-list-into-k-consecutive-linked-list-parts"><a href="#Given-the-head-of-a-singly-linked-list-and-an-integer-k-split-the-linked-list-into-k-consecutive-linked-list-parts" class="headerlink" title="Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts."></a>Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.</h2><h2 id="The-length-of-each-part-should-be-as-equal-as-possible-no-two-parts-should-have-a-size-differing-by-more-than-one-This-may-lead-to-some-parts-being-null"><a href="#The-length-of-each-part-should-be-as-equal-as-possible-no-two-parts-should-have-a-size-differing-by-more-than-one-This-may-lead-to-some-parts-being-null" class="headerlink" title="The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null."></a>The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.</h2><h2 id="The-parts-should-be-in-the-order-of-occurrence-in-the-input-list-and-parts-occurring-earlier-should-always-have-a-size-greater-than-or-equal-to-parts-occurring-later"><a href="#The-parts-should-be-in-the-order-of-occurrence-in-the-input-list-and-parts-occurring-earlier-should-always-have-a-size-greater-than-or-equal-to-parts-occurring-later" class="headerlink" title="The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later."></a>The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.</h2><h2 id="Return-an-array-of-the-k-parts"><a href="#Return-an-array-of-the-k-parts" class="headerlink" title="Return an array of the k parts."></a>Return an array of the k parts.</h2><h3 id="题目描述：把链表分隔成-k-部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。"><a href="#题目描述：把链表分隔成-k-部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。" class="headerlink" title="题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。"></a>题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</h3><p>其实就是n个数分成m组，前面一些组多一个，n/m+1，后面的组数量是n/m</p><p><a href="https://leetcode.cn/problems/split-linked-list-in-parts/solution/fen-ge-lian-biao-by-leetcode-solution-wevt/">代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[ListNode]:</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node: <span class="comment">#一次遍历得到长度</span></span><br><span class="line">            L += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        quotient, remainder = L // k, L % k</span><br><span class="line"></span><br><span class="line">        parts = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]  <span class="comment">#create lists of size n and initialize with None</span></span><br><span class="line">        i, curr = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> i &lt; k <span class="keyword">and</span> curr:</span><br><span class="line">            parts[i] = curr</span><br><span class="line">            <span class="keyword">if</span> i&lt;remainder:</span><br><span class="line">                part_size = quotient + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                part_size = quotient</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(part_size - <span class="number">1</span>):</span><br><span class="line">                <span class="comment">#for _ in range:When you are not interested in some values returned by a function we use underscore in place of variable name . Basically it means you are not interested in how many times the loop is run till now just that it should run some specific number of times overall.</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            curr = <span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> parts</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;725-Split-Linked-List-in-Parts-Medium&quot;&gt;&lt;a href=&quot;#725-Split-Linked-List-in-Parts-Medium&quot; class=&quot;headerlink&quot; title=&quot;725. Split Linked </summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List (Easy)</title>
    <link href="http://example.com/2022/08/04/234/"/>
    <id>http://example.com/2022/08/04/234/</id>
    <published>2022-08-05T03:41:28.000Z</published>
    <updated>2022-08-07T03:14:40.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a>234. Palindrome Linked List (Easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-return-true-if-it-is-a-palindrome"><a href="#Given-the-head-of-a-singly-linked-list-return-true-if-it-is-a-palindrome" class="headerlink" title="Given the head of a singly linked list, return true if it is a palindrome."></a>Given the head of a singly linked list, return true if it is a palindrome.</h2><p>这道题的关键在于如何控制空间复杂度。</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/">官方题解</a></h3><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n):"></a>O(n):</h3><p>简单来说就是把链表的数值全都存到数组里，然后再进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        vals = []</span><br><span class="line">        current_node = head</span><br><span class="line">        <span class="keyword">while</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            vals.append(current_node.val)</span><br><span class="line">            current_node = current_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1):"></a>O(1):</h3><p>避免使用 O(n)额外空间的方法就是改变输入。</p><p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p><p>该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p><p>算法</p><p>整个流程可以分为以下五个步骤：</p><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        first_half_end = self.end_of_first_half(head)</span><br><span class="line">        second_half_start = self.reverse_list(first_half_end.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否回文</span></span><br><span class="line">        result = <span class="literal">True</span></span><br><span class="line">        first_position = head</span><br><span class="line">        second_position = second_half_start</span><br><span class="line">        <span class="keyword">while</span> result <span class="keyword">and</span> second_position <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> first_position.val != second_position.val:</span><br><span class="line">                result = <span class="literal">False</span></span><br><span class="line">            first_position = first_position.<span class="built_in">next</span></span><br><span class="line">            second_position = second_position.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 还原链表并返回结果</span></span><br><span class="line">        first_half_end.<span class="built_in">next</span> = self.reverse_list(second_half_start)</span><br><span class="line">        <span class="keyword">return</span> result    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_of_first_half</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_node = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = next_node</span><br><span class="line">        <span class="keyword">return</span> previous</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;234-Palindrome-Linked-List-Easy&quot;&gt;&lt;a href=&quot;#234-Palindrome-Linked-List-Easy&quot; class=&quot;headerlink&quot; title=&quot;234. Palindrome Linked List (E</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>445. Add Two Numbers II (Medium)</title>
    <link href="http://example.com/2022/08/04/445/"/>
    <id>http://example.com/2022/08/04/445/</id>
    <published>2022-08-05T03:38:49.000Z</published>
    <updated>2022-08-06T21:28:48.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="445-Add-Two-Numbers-II-Medium"><a href="#445-Add-Two-Numbers-II-Medium" class="headerlink" title="445. Add Two Numbers II (Medium)"></a>445. Add Two Numbers II (Medium)</h1><h2 id="You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-most-significant-digit-comes-first-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list"><a href="#You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-most-significant-digit-comes-first-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list" class="headerlink" title="You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list."></a>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</h2><h2 id="You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself"><a href="#You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself" class="headerlink" title="You may assume the two numbers do not contain any leading zero, except the number 0 itself."></a>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</h2><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class="line">Output: [7,8,0,7]</span><br></pre></td></tr></table></figure><p>这个例子想讲的其实就是7243+564=7807</p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/">官方题解</a></h2><p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p><h3 id="对于逆序处理应该首先想到栈"><a href="#对于逆序处理应该首先想到栈" class="headerlink" title="对于逆序处理应该首先想到栈"></a>对于逆序处理应该首先想到栈</h3><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/solution/zhang-by-kind-i3lackburnmaf-aamu/">代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">or</span> s2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            a = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s1 <span class="keyword">else</span> s1.pop()</span><br><span class="line">            b = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> s2 <span class="keyword">else</span> s2.pop()</span><br><span class="line">            cur = a + b + carry</span><br><span class="line">            carry = cur // <span class="number">10</span></span><br><span class="line">            cur %= <span class="number">10</span></span><br><span class="line">            curnode = ListNode(cur)</span><br><span class="line">            curnode.<span class="built_in">next</span> = ans</span><br><span class="line">            ans = curnode</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;445-Add-Two-Numbers-II-Medium&quot;&gt;&lt;a href=&quot;#445-Add-Two-Numbers-II-Medium&quot; class=&quot;headerlink&quot; title=&quot;445. Add Two Numbers II (Medium)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>24. Swap Nodes in Pairs (Medium)</title>
    <link href="http://example.com/2022/08/04/24/"/>
    <id>http://example.com/2022/08/04/24/</id>
    <published>2022-08-05T03:28:03.000Z</published>
    <updated>2022-08-05T03:50:21.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a>24. Swap Nodes in Pairs (Medium)</h1><h2 id="Given-a-linked-list-swap-every-two-adjacent-nodes-and-return-its-head-You-must-solve-the-problem-without-modifying-the-values-in-the-list’s-nodes-i-e-only-nodes-themselves-may-be-changed"><a href="#Given-a-linked-list-swap-every-two-adjacent-nodes-and-return-its-head-You-must-solve-the-problem-without-modifying-the-values-in-the-list’s-nodes-i-e-only-nodes-themselves-may-be-changed" class="headerlink" title="Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)"></a>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</h2><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/">官方题解</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(newHead.<span class="built_in">next</span>)</span><br><span class="line">        newHead.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;24-Swap-Nodes-in-Pairs-Medium&quot;&gt;&lt;a href=&quot;#24-Swap-Nodes-in-Pairs-Medium&quot; class=&quot;headerlink&quot; title=&quot;24. Swap Nodes in Pairs (Medium)&quot;&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>19. Remove Nth Node From End of List (medium)</title>
    <link href="http://example.com/2022/08/01/19/"/>
    <id>http://example.com/2022/08/01/19/</id>
    <published>2022-08-02T02:17:04.000Z</published>
    <updated>2022-08-05T03:27:38.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-Remove-Nth-Node-From-End-of-List-medium"><a href="#19-Remove-Nth-Node-From-End-of-List-medium" class="headerlink" title="19. Remove Nth Node From End of List (medium)"></a>19. Remove Nth Node From End of List (medium)</h1><h2 id="Given-the-head-of-a-linked-list-remove-the-nth-node-from-the-end-of-the-list-and-return-its-head"><a href="#Given-the-head-of-a-linked-list-remove-the-nth-node-from-the-end-of-the-list-and-return-its-head" class="headerlink" title="Given the head of a linked list, remove the nth node from the end of the list and return its head."></a>Given the head of a linked list, remove the nth node from the end of the list and return its head.</h2><p>移除倒序的第n个节点</p><p>第一反应是两次遍历，第一次遍历先判断链表长度L，然后再遍历第二次算出应该删除的L−n+1节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">head: ListNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 添加哑结点dummy</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        length = getLength(head)</span><br><span class="line">        current = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - n + <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>方法二</p><h3 id="双指针解决问题思路："><a href="#双指针解决问题思路：" class="headerlink" title="双指针解决问题思路："></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/dong-hua-tu-jie-leetcode-di-19-hao-wen-ti-shan-chu/">双指针解决问题思路</a>：</h3><p>我们可以设想假设设定了双指针 p 和 q 的话，当 q 指向末尾的 NULL，p 与 q 之间相隔的元素个数为 n 时，那么删除掉 p 的下一个指针就完成了要求。</p><ol><li>设置虚拟节点 dummyHead 指向 head</li><li>设定双指针 p 和 q，初始都指向虚拟节点 dummyHead</li><li>移动 q，直到 p 与 q 之间相隔的元素个数为 n</li><li>同时移动 p 与 q，直到 q 指向的为 NULL</li><li>将 p 的下一个节点指向下下个节点</li></ol><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/">代码</a>：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        first = head</span><br><span class="line">        second = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> first:</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">            second = second.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加哑节点："><a href="#添加哑节点：" class="headerlink" title="添加哑节点："></a>添加哑节点：</h3><p>添加一个哑节点（dummy node），让它的next 指针指向链表的头节点。这样一来，头节点的前驱节点就是哑节点本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(0,head)  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;19-Remove-Nth-Node-From-End-of-List-medium&quot;&gt;&lt;a href=&quot;#19-Remove-Nth-Node-From-End-of-List-medium&quot; class=&quot;headerlink&quot; title=&quot;19. Remo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>83. Remove Duplicates from Sorted List (Easy)</title>
    <link href="http://example.com/2022/08/01/83/"/>
    <id>http://example.com/2022/08/01/83/</id>
    <published>2022-08-01T22:44:28.000Z</published>
    <updated>2022-08-01T22:46:08.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List (Easy)"></a>83. Remove Duplicates from Sorted List (Easy)</h1><h2 id="Given-the-head-of-a-sorted-linked-list-delete-all-duplicates-such-that-each-element-appears-only-once-Return-the-linked-list-sorted-as-well"><a href="#Given-the-head-of-a-sorted-linked-list-delete-all-duplicates-such-that-each-element-appears-only-once-Return-the-linked-list-sorted-as-well" class="headerlink" title="Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well."></a>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</h2><p>删除重复节点<br>因为是有序节点，经过一遍遍历，把重复的删除就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current.<span class="built_in">next</span>:            </span><br><span class="line">            <span class="keyword">if</span> current.val== current.<span class="built_in">next</span>.val:</span><br><span class="line">                current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head     </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;83-Remove-Duplicates-from-Sorted-List-Easy&quot;&gt;&lt;a href=&quot;#83-Remove-Duplicates-from-Sorted-List-Easy&quot; class=&quot;headerlink&quot; title=&quot;83. Remo</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
    <category term="recursion" scheme="http://example.com/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List(easy)</title>
    <link href="http://example.com/2022/07/20/206/"/>
    <id>http://example.com/2022/07/20/206/</id>
    <published>2022-07-20T22:21:02.000Z</published>
    <updated>2022-07-21T03:24:20.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-Reverse-Linked-List-easy"><a href="#206-Reverse-Linked-List-easy" class="headerlink" title="206. Reverse Linked List(easy)"></a>206. Reverse Linked List(easy)</h1><h2 id="Given-the-head-of-a-singly-linked-list-reverse-the-list-and-return-the-reversed-list"><a href="#Given-the-head-of-a-singly-linked-list-reverse-the-list-and-return-the-reversed-list" class="headerlink" title="Given the head of a singly linked list, reverse the list, and return the reversed list."></a>Given the head of a singly linked list, reverse the list, and return the reversed list.</h2><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p><p>反转数组，还是用双指针，另外设置了一个临时变量tmp记录current的下一个值<br>图例可以看这个<a href="https://leetcode.cn/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">回答</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current !=<span class="literal">None</span>:</span><br><span class="line">            tmp = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = current</span><br><span class="line">            current = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-Reverse-Linked-List-easy&quot;&gt;&lt;a href=&quot;#206-Reverse-Linked-List-easy&quot; class=&quot;headerlink&quot; title=&quot;206. Reverse Linked List(easy)&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>160. Intersection of Two Linked Lists (Easy)</title>
    <link href="http://example.com/2022/07/20/160/"/>
    <id>http://example.com/2022/07/20/160/</id>
    <published>2022-07-20T21:41:56.000Z</published>
    <updated>2022-07-21T03:24:39.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a>160. Intersection of Two Linked Lists (Easy)</h1><h2 id="Given-the-heads-of-two-singly-linked-lists-headA-and-headB-return-the-node-at-which-the-two-lists-intersect-If-the-two-linked-lists-have-no-intersection-at-all-return-null"><a href="#Given-the-heads-of-two-singly-linked-lists-headA-and-headB-return-the-node-at-which-the-two-lists-intersect-If-the-two-linked-lists-have-no-intersection-at-all-return-null" class="headerlink" title="Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null."></a>Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.</h2><h2 id="For-example-the-following-two-linked-lists-begin-to-intersect-at-node-c1"><a href="#For-example-the-following-two-linked-lists-begin-to-intersect-at-node-c1" class="headerlink" title="For example, the following two linked lists begin to intersect at node c1:"></a>For example, the following two linked lists begin to intersect at node c1:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></p><h2 id="The-test-cases-are-generated-such-that-there-are-no-cycles-anywhere-in-the-entire-linked-structure"><a href="#The-test-cases-are-generated-such-that-there-are-no-cycles-anywhere-in-the-entire-linked-structure" class="headerlink" title="The test cases are generated such that there are no cycles anywhere in the entire linked structure."></a>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</h2><h2 id="Note-that-the-linked-lists-must-retain-their-original-structure-after-the-function-returns"><a href="#Note-that-the-linked-lists-must-retain-their-original-structure-after-the-function-returns" class="headerlink" title="Note that the linked lists must retain their original structure after the function returns."></a>Note that the linked lists must retain their original structure after the function returns.</h2><h2 id="Custom-Judge"><a href="#Custom-Judge" class="headerlink" title="Custom Judge:"></a>Custom Judge:</h2><h2 id="The-inputs-to-the-judge-are-given-as-follows-your-program-is-not-given-these-inputs"><a href="#The-inputs-to-the-judge-are-given-as-follows-your-program-is-not-given-these-inputs" class="headerlink" title="The inputs to the judge are given as follows (your program is not given these inputs):"></a>The inputs to the judge are given as follows (your program is not given these inputs):</h2><h4 id="intersectVal-The-value-of-the-node-where-the-intersection-occurs-This-is-0-if-there-is-no-intersected-node"><a href="#intersectVal-The-value-of-the-node-where-the-intersection-occurs-This-is-0-if-there-is-no-intersected-node" class="headerlink" title="intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node."></a>intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.</h4><h4 id="listA-The-first-linked-list"><a href="#listA-The-first-linked-list" class="headerlink" title="listA - The first linked list."></a>listA - The first linked list.</h4><h4 id="listB-The-second-linked-list"><a href="#listB-The-second-linked-list" class="headerlink" title="listB - The second linked list."></a>listB - The second linked list.</h4><h4 id="skipA-The-number-of-nodes-to-skip-ahead-in-listA-starting-from-the-head-to-get-to-the-intersected-node"><a href="#skipA-The-number-of-nodes-to-skip-ahead-in-listA-starting-from-the-head-to-get-to-the-intersected-node" class="headerlink" title="skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node."></a>skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.</h4><h4 id="skipB-The-number-of-nodes-to-skip-ahead-in-listB-starting-from-the-head-to-get-to-the-intersected-node"><a href="#skipB-The-number-of-nodes-to-skip-ahead-in-listB-starting-from-the-head-to-get-to-the-intersected-node" class="headerlink" title="skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node."></a>skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.</h4><h3 id="The-judge-will-then-create-the-linked-structure-based-on-these-inputs-and-pass-the-two-heads-headA-and-headB-to-your-program-If-you-correctly-return-the-intersected-node-then-your-solution-will-be-accepted"><a href="#The-judge-will-then-create-the-linked-structure-based-on-these-inputs-and-pass-the-two-heads-headA-and-headB-to-your-program-If-you-correctly-return-the-intersected-node-then-your-solution-will-be-accepted" class="headerlink" title="The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted."></a>The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.</h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><p>这道题可以通过双指针的方法解决，一开始想的是通过两个链表的公共部分从后往前，但是该题题解里有个思路很好：<br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/">160. 相交链表（双指针，清晰图解）</a></p><p>ListA 头节点 headA 到 公共node 前，共有 a - c 个节点；<br>ListB 头节点 headB 到 公共node 前，共有 b - c 个节点；</p><p>考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：</p><p>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 公共node 时，共走步数为：<br>a + (b - c) = a + b - c</p><p>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 公共node 时，共走步数为：<br>b + (a - c) = a + b - c</p><p>所以这就有可以操作的地方了</p><p>如下式所示，此时指针 A , B 重合，并有两种情况：</p><p>a + (b - c) = b + (a - c)</p><p>若两链表 有 公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node 。<br>若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。</p><p>其实就是两边互相换家走一遍，相当于从一开始的头结点开始，指针A,B都走一遍list A和list B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A != B:</span><br><span class="line">            A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.<span class="built_in">next</span> <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br></pre></td></tr></table></figure><p>其实没看懂实现逻辑（基础不牢固），后来搜了一下是python的一个条件表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">It&#x27;s a conditional expression:</span><br><span class="line"></span><br><span class="line">A if PREDICATE else B</span><br><span class="line">A is yielded if PREDICATE is true, otherwise B is yielded.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#x27;A&#x27; if 1 &lt; 2 else &#x27;B&#x27;</span><br><span class="line">&#x27;A&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;A&#x27; if 1 &gt; 2 else &#x27;B&#x27;</span><br><span class="line">&#x27;B&#x27;</span><br></pre></td></tr></table></figure><p>换成完整版就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 1 &lt; 2:</span><br><span class="line">    &#x27;A&#x27;</span><br><span class="line">else: &#x27;B&#x27;</span><br></pre></td></tr></table></figure><p>所以题解里的写法其实可以写成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span></span><br><span class="line">        a,b= headA,headB</span><br><span class="line">        <span class="keyword">while</span> a!=b:</span><br><span class="line">            <span class="keyword">if</span> a:</span><br><span class="line">                a =a.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: a= headB</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> b:</span><br><span class="line">                b =b.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: b = headA</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;160-Intersection-of-Two-Linked-Lists-Easy&quot;&gt;&lt;a href=&quot;#160-Intersection-of-Two-Linked-Lists-Easy&quot; class=&quot;headerlink&quot; title=&quot;160. Inter</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="two-pointers" scheme="http://example.com/tags/two-pointers/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode12-Tree</title>
    <link href="http://example.com/2022/07/20/LeetCode12-Tree/"/>
    <id>http://example.com/2022/07/20/LeetCode12-Tree/</id>
    <published>2022-07-20T21:37:08.000Z</published>
    <updated>2022-08-16T03:27:01.011Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><h2 id="Leetcode-题解-链表"><a href="#Leetcode-题解-链表" class="headerlink" title="Leetcode 题解 - 链表"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md">Leetcode 题解 - 链表</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/linked-list/">leetcode tag</a></h2><p>如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。</p><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。<br><img src="https://s2.51cto.com/oss/202108/05/76b5d27335a0239eacf8b76a391ed229.jpg" alt="binary tree"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-题解-链表&quot;&gt;&lt;a href=&quot;#Leetcode-题解-链表&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 题解 - 链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CyC</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>2. Add Two Numbers(medium)</title>
    <link href="http://example.com/2022/07/15/2/"/>
    <id>http://example.com/2022/07/15/2/</id>
    <published>2022-07-15T20:30:53.000Z</published>
    <updated>2022-07-21T03:23:24.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers-medium"><a href="#2-Add-Two-Numbers-medium" class="headerlink" title="2. Add Two Numbers(medium)"></a>2. Add Two Numbers(medium)</h1><h2 id="You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list"><a href="#You-are-given-two-non-empty-linked-lists-representing-two-non-negative-integers-The-digits-are-stored-in-reverse-order-and-each-of-their-nodes-contains-a-single-digit-Add-the-two-numbers-and-return-the-sum-as-a-linked-list" class="headerlink" title="You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list."></a>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</h2><h2 id="You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself"><a href="#You-may-assume-the-two-numbers-do-not-contain-any-leading-zero-except-the-number-0-itself" class="headerlink" title="You may assume the two numbers do not contain any leading zero, except the number 0 itself."></a>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</h2><p>参考：</p><h2 id="Leetcode-题解-链表"><a href="#Leetcode-题解-链表" class="headerlink" title="Leetcode 题解 - 链表"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md">Leetcode 题解 - 链表</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/linked-list/">leetcode tag</a></h2><p>如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-Add-Two-Numbers-medium&quot;&gt;&lt;a href=&quot;#2-Add-Two-Numbers-medium&quot; class=&quot;headerlink&quot; title=&quot;2. Add Two Numbers(medium)&quot;&gt;&lt;/a&gt;2. Add Two N</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode11-Linked list</title>
    <link href="http://example.com/2022/07/15/LeetCode11-Linked%20list/"/>
    <id>http://example.com/2022/07/15/LeetCode11-Linked%20list/</id>
    <published>2022-07-15T19:54:06.000Z</published>
    <updated>2022-07-21T03:22:52.536Z</updated>
    
    <content type="html"><![CDATA[<p>链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。</p><p>参考：</p><h2 id="Leetcode-题解-链表"><a href="#Leetcode-题解-链表" class="headerlink" title="Leetcode 题解 - 链表"></a><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md">Leetcode 题解 - 链表</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/linked-list/">leetcode tag</a></h2><p>如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;Leetcode-题解-链表&quot;&gt;&lt;a href=&quot;#Leetcode-题解-链表&quot; class=&quot;headerlink&quot; title=&quot;L</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Linked list" scheme="http://example.com/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode10-Backtracking</title>
    <link href="http://example.com/2022/07/14/LeetCode10-Backtracking/"/>
    <id>http://example.com/2022/07/14/LeetCode10-Backtracking/</id>
    <published>2022-07-15T02:56:54.000Z</published>
    <updated>2022-07-15T03:14:35.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯题目总结："><a href="#回溯题目总结：" class="headerlink" title="回溯题目总结："></a>回溯题目总结：</h1><h2 id="Backtracking-Python-problems-solutions-interview-prep"><a href="#Backtracking-Python-problems-solutions-interview-prep" class="headerlink" title="Backtracking Python problems+ solutions- interview prep"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/780232/Backtracking-Python-problems%2B-solutions-interview-prep">Backtracking Python problems+ solutions- interview prep</a></h2><h2 id="leetcode-tag"><a href="#leetcode-tag" class="headerlink" title="leetcode tag"></a><a href="https://leetcode.com/tag/backtracking/">leetcode tag</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯题目总结：&quot;&gt;&lt;a href=&quot;#回溯题目总结：&quot; class=&quot;headerlink&quot; title=&quot;回溯题目总结：&quot;&gt;&lt;/a&gt;回溯题目总结：&lt;/h1&gt;&lt;h2 id=&quot;Backtracking-Python-problems-solutions-interv</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="Backtracking" scheme="http://example.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>17. Letter Combinations of a Phone Number(medium)</title>
    <link href="http://example.com/2022/07/14/17/"/>
    <id>http://example.com/2022/07/14/17/</id>
    <published>2022-07-15T01:55:06.000Z</published>
    <updated>2022-07-15T03:15:36.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-Letter-Combinations-of-a-Phone-Number-medium"><a href="#17-Letter-Combinations-of-a-Phone-Number-medium" class="headerlink" title="17. Letter Combinations of a Phone Number(medium)"></a>17. Letter Combinations of a Phone Number(medium)</h1><h2 id="Given-a-string-containing-digits-from-2-9-inclusive-return-all-possible-letter-combinations-that-the-number-could-represent-Return-the-answer-in-any-order"><a href="#Given-a-string-containing-digits-from-2-9-inclusive-return-all-possible-letter-combinations-that-the-number-could-represent-Return-the-answer-in-any-order" class="headerlink" title="Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order."></a>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</h2><h2 id="A-mapping-of-digits-to-letters-just-like-on-the-telephone-buttons-is-given-below-Note-that-1-does-not-map-to-any-letters"><a href="#A-mapping-of-digits-to-letters-just-like-on-the-telephone-buttons-is-given-below-Note-that-1-does-not-map-to-any-letters" class="headerlink" title="A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters."></a>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phone = &#123;&#x27;2&#x27;:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">                 &#x27;3&#x27;:[&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;],</span><br><span class="line">                 &#x27;4&#x27;:[&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;],</span><br><span class="line">                 &#x27;5&#x27;:[&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;],</span><br><span class="line">                 &#x27;6&#x27;:[&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;],</span><br><span class="line">                 &#x27;7&#x27;:[&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;],</span><br><span class="line">                 &#x27;8&#x27;:[&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;],</span><br><span class="line">                 &#x27;9&#x27;:[&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;]&#125;</span><br><span class="line">                </span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>这题属于是hashmap记录数字和字母的对应关系，然后再用回溯的方法解决</p><h2 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/">leetcode题解</a></h2><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: </span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        phone = &#123;<span class="string">&#x27;2&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;3&#x27;</span>:[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;4&#x27;</span>:[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;5&#x27;</span>:[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;6&#x27;</span>:[<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;7&#x27;</span>:[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;8&#x27;</span>:[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;9&#x27;</span>:[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]&#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">conbination,nextdigit</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nextdigit) == <span class="number">0</span>:</span><br><span class="line">                res.append(conbination)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phone[nextdigit[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(conbination + letter,nextdigit[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="string">&#x27;&#x27;</span>,digits)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;17-Letter-Combinations-of-a-Phone-Number-medium&quot;&gt;&lt;a href=&quot;#17-Letter-Combinations-of-a-Phone-Number-medium&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="study" scheme="http://example.com/categories/study/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="hashmap" scheme="http://example.com/tags/hashmap/"/>
    
    <category term="mapping" scheme="http://example.com/tags/mapping/"/>
    
    <category term="Backtracking" scheme="http://example.com/tags/Backtracking/"/>
    
  </entry>
  
</feed>
